var tipuesearch = {"pages":[{"title":" fortran-astrodynamics-toolkit ","text":"fortran-astrodynamics-toolkit Overview The goal of the Fortran Astrodynamics Toolkit is to produce a comprehensive library, written in modern Fortran (Fortran 2008+), of all the standard orbital mechanics algorithms.  This is a work in progress.  Currently-implemented and proposed capabilities include: Lambert solvers [x] Gooding [x] Izzo [x] Arora Kepler propagators [x] Gooding [x] Shepperd [x] Goodyear ODE solvers (with event-finding) [x] Runge-Kutta [ ] Nystrom [ ] Adams Force models [ ] point mass gravity field [x] geopotential gravity [x] solar radiation pressure [ ] atmospheric drag [ ] relativistic effects Reference frames [x] IAU_EARTH [x] IAU_MOON Celestial Body Ephemerides [x] JPLEPH [x] SPICE [x] Analytical Moon w.r.t Earth [x] Analytical solar system primary bodies Alternate equations of motion [x] Circular restricted three-body problem [x] Clohessy-Wiltshire [x] Modified equinoctial elements Misc [x] orbital element conversions [x] halo orbits [x] solar eclipsing [ ] targeting and optimization [ ] spacecraft engine models Examples Building The Fortran Astrodynamics Toolkit and the test programs will build with any modern Fortran compiler. A Fortran Package Manager manifest file ( fpm.toml ) is included, so that the library and tests cases can be compiled with FPM. For example: fpm build --profile release\nfpm test --profile release To use Fortran-Astrodynamics-Toolkit within your fpm project, add the following to your fpm.toml file: [dependencies] fortran-astrodynamics-toolkit = { git = \"https://github.com/jacobwilliams/Fortran-Astrodynamics-Toolkit.git\" } or, to use a specific version: [dependencies] fortran-astrodynamics-toolkit = { git = \"https://github.com/jacobwilliams/Fortran-Astrodynamics-Toolkit.git\" , tag = \"0.3\" } To generate the documentation using ford , run: ford ford.md Third-Party Requirements A script get_third_party.sh is included to download and build the third-party dependencies on unix-like operating systems. Pyplot-Fortran The plots generated by the examples are done using the pyplot-fortran module. When compiling with FPM, this will automatically be downloaded and compiled. Ephemeris files To use the ephemeris_module, a copy of one of the JPL binary ephemeris files must be present in the eph directory.  This can be built from the instructions at: ftp://ssd.jpl.nasa.gov/pub/eph/planets/fortran/userguide.txt.  For example (on Linux): wget ftp://ssd.jpl.nasa.gov/pub/eph/planets/fortran/*\nwget ftp://ssd.jpl.nasa.gov/pub/eph/planets/ascii/de405/* #edit asc2eph.f file to set NRECL = 4: sed -i '_original' '/&#94;C.*PARAMETER ( NRECL = 4 )/s/&#94;C//' asc2eph.f\ngfortran asc2eph.f -o asc2eph\ncat header.405 ascp*.405 | ./asc2eph\nmkdir Fortran-Astrodynamics-Toolkit/eph\nmv JPLEPH Fortran-Astrodynamics-Toolkit/eph/JPLEPH.405 Geopotential files To use the geopotential_module, you need a geopotential model file (for example GGM03C.GEO from ftp://ftp.csr.utexas.edu/pub/grace/GGM03/GGM03_Archive.zip). This should be placed in the grav directory.  For example: wget http://download.csr.utexas.edu/pub/grace/GGM03/GGM03_Archive.zip\nunzip GGM03_Archive.zip\nmkdir Fortran-Astrodynamics-Toolkit/grav\ncp GGM03_Archive/GGM03C.GEO Fortran-Astrodynamics-Toolkit/grav Documentation The documentation for the latest code in master can be found here . See also SPICE NOVAS SOFA astro-fortran LLEA poliastro Developer Info Jacob Williams","tags":"home","url":"index.html"},{"title":"standish_ephemeris – fortran-astrodynamics-toolkit ","text":"type, public, extends( ephemeris_class ) :: standish_ephemeris Standish ephemeris class for computing the\napproximate positions of the major planets. Inherits type~~standish_ephemeris~~InheritsGraph type~standish_ephemeris standish_ephemeris type~ephemeris_class ephemeris_class type~standish_ephemeris->type~ephemeris_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure, public :: get_rv => standish_rv_func private  subroutine standish_rv_func (me, et, targ, obs, rv, status_ok) Author Jacob Williams Date 3/4/2018 Return the state of the targ body relative to\nthe obs body, in the inertial frame [ICRF]. Read more… Arguments Type Intent Optional Attributes Name class( standish_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(6) :: rv state of targ w.r.t. obs [km, km/s] logical, intent(out) :: status_ok true if there were no problems procedure, public :: get_r => standish_r_func private  subroutine standish_r_func (me, et, targ, obs, r, status_ok) Return the position of the targ body relative to\n the obs body, in the inertial frame [ICRF]. Read more… Arguments Type Intent Optional Attributes Name class( standish_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(3) :: r position of targ w.r.t. obs [km] logical, intent(out) :: status_ok true if there were no problems Source Code type , extends ( ephemeris_class ), public :: standish_ephemeris !! Standish ephemeris class for computing the !! approximate positions of the major planets. contains procedure , public :: get_rv => standish_rv_func procedure , public :: get_r => standish_r_func end type standish_ephemeris","tags":"","url":"type/standish_ephemeris.html"},{"title":"ephem – fortran-astrodynamics-toolkit ","text":"type, private, extends( base_class ) :: ephem an ephemeris defined using a date range\nand a set of elements from the reference. There are two that can be used. Inherits type~~ephem~~InheritsGraph type~ephem ephem type~base_class base_class type~ephem->type~base_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: id = 0 a unique ID code that distinguishes a\nvariable from other variables of the same type. character(len=name_len), public :: name = '' the variable name real(kind=wp), public, dimension(2) :: jd_range = zero valid julian date range real(kind=wp), public, dimension (16, 9) :: o = zero keplerian elements terms Type-Bound Procedures generic, public :: operator(==) => base_class_equal public pure elemental function base_class_equal (b1, b2) result(is_equal) == operator for base_class variables.\nTo be equal, they must be the same type and have the same ID . Arguments Type Intent Optional Attributes Name class( base_class ), intent(in) :: b1 class( base_class ), intent(in) :: b2 Return Value logical generic, public :: operator(/=) => base_class_not_equal public pure elemental function base_class_not_equal (b1, b2) result(not_equal) /= operator for base_class variables.\nTo be equal, they must be the same type and have the same ID . Arguments Type Intent Optional Attributes Name class( base_class ), intent(in) :: b1 class( base_class ), intent(in) :: b2 Return Value logical Source Code type , extends ( base_class ) :: ephem !! an ephemeris defined using a date range !! and a set of elements from the reference. !! !! There are two that can be used. !! !!@note This should probably be merged into [[standish_ephemeris]] real ( wp ), dimension ( 2 ) :: jd_range = zero !! valid julian date range real ( wp ), dimension ( 16 , 9 ) :: o = zero !! keplerian elements terms end type ephem","tags":"","url":"type/ephem.html"},{"title":"spice_ephemeris – fortran-astrodynamics-toolkit ","text":"type, public, extends( ephemeris_class ) :: spice_ephemeris Main class for accessing the SPICE ephemeris system. Note: SPICE is not object-oriented or threadsafe. So,\nwhile this class provides an object-oriented like interface\nto SPICE, it should really be treated as a singleton. Inherits type~~spice_ephemeris~~InheritsGraph type~spice_ephemeris spice_ephemeris type~ephemeris_class ephemeris_class type~spice_ephemeris->type~ephemeris_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, dimension(:), allocatable :: kernels the list of kernels Type-Bound Procedures procedure, public :: get_rv => get_rv_from_spice_ephemeris private  subroutine get_rv_from_spice_ephemeris (me, et, targ, obs, rv, status_ok) Interface for the ephemeris_module . Read more… Arguments Type Intent Optional Attributes Name class( spice_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(6) :: rv state of targ w.r.t. obs [km,km/s] in ICRF frame logical, intent(out) :: status_ok true if there were no problems procedure, public :: get_r => get_r_from_spice_ephemeris private  subroutine get_r_from_spice_ephemeris (me, et, targ, obs, r, status_ok) Interface for the ephemeris_module . Read more… Arguments Type Intent Optional Attributes Name class( spice_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(3) :: r position of targ w.r.t. obs [km] in ICRF frame logical, intent(out) :: status_ok true if there were no problems procedure, public :: initialize => initialize_spice_ephemeris private  subroutine initialize_spice_ephemeris (me, kernels) Initialize a SPICE ephemeris by loading the specified kernels. Arguments Type Intent Optional Attributes Name class( spice_ephemeris ), intent(inout) :: me character(len=*), intent(in), dimension(:) :: kernels list of kernels to load procedure, public :: close => close_spice_ephemeris private  subroutine close_spice_ephemeris (me) Close the SPICE ephemeris and unload all the kernels. Arguments Type Intent Optional Attributes Name class( spice_ephemeris ), intent(inout) :: me Source Code type , extends ( ephemeris_class ), public :: spice_ephemeris !! Main class for accessing the SPICE ephemeris system. !! !! Note: SPICE is not object-oriented or threadsafe. So, !! while this class provides an object-oriented like interface !! to SPICE, it should really be treated as a singleton. character ( len = :), dimension (:), allocatable :: kernels !! the list of kernels contains procedure , public :: get_rv => get_rv_from_spice_ephemeris procedure , public :: get_r => get_r_from_spice_ephemeris procedure , public :: initialize => initialize_spice_ephemeris procedure , public :: close => close_spice_ephemeris end type spice_ephemeris","tags":"","url":"type/spice_ephemeris.html"},{"title":"geopotential_model – fortran-astrodynamics-toolkit ","text":"type, public, abstract :: geopotential_model The base abstract class for the various geopotential models Inherited by type~~geopotential_model~~InheritedByGraph type~geopotential_model geopotential_model type~geopotential_model_matrix_coeff geopotential_model_matrix_coeff type~geopotential_model_matrix_coeff->type~geopotential_model type~geopotential_model_vector_coeff geopotential_model_vector_coeff type~geopotential_model_vector_coeff->type~geopotential_model type~geopotential_model_kuga_carrara geopotential_model_kuga_carrara type~geopotential_model_kuga_carrara->type~geopotential_model_matrix_coeff type~geopotential_model_lear geopotential_model_lear type~geopotential_model_lear->type~geopotential_model_matrix_coeff type~geopotential_model_mueller geopotential_model_mueller type~geopotential_model_mueller->type~geopotential_model_vector_coeff type~geopotential_model_normalized_pines geopotential_model_normalized_pines type~geopotential_model_normalized_pines->type~geopotential_model_matrix_coeff type~geopotential_model_pines geopotential_model_pines type~geopotential_model_pines->type~geopotential_model_matrix_coeff Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] Type-Bound Procedures procedure, public :: initialize => read_geopotential_file private  subroutine read_geopotential_file (me, filename, nmax, mmax, status_ok) Author Jacob Williams Date 9/20/2014 Read the gravity coefficient file.\nExample file: ftp://ftp.csr.utexas.edu/pub/grav/EGM96.GEO.Z Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me character(len=*), intent(in) :: filename integer, intent(in) :: nmax integer, intent(in) :: mmax logical, intent(out) :: status_ok procedure, public :: destroy => destroy_geopotential_model private  subroutine destroy_geopotential_model (me) Destroy a gravity model. Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me procedure( acc_function ), public, deferred :: get_acc subroutine acc_function(me, r, n, m, a) Prototype Interface to the acceleration function for the different methods Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Source Code type , abstract , public :: geopotential_model !! The base abstract class for the various geopotential models character ( len = :), allocatable :: name !! model name character ( len = :), allocatable :: filename !! model file name integer :: nmax = 0 !! degree of the model integer :: mmax = 0 !! order of the model real ( wp ) :: re = zero !! body radius [km] real ( wp ) :: mu = zero !! body grav. parameter [km3/s2] contains procedure , public :: initialize => read_geopotential_file procedure , public :: destroy => destroy_geopotential_model procedure ( acc_function ), deferred , public :: get_acc end type geopotential_model","tags":"","url":"type/geopotential_model.html"},{"title":"geopotential_model_vector_coeff – fortran-astrodynamics-toolkit ","text":"type, public, abstract, extends( geopotential_model ) :: geopotential_model_vector_coeff The models where the C,S coefficients are stored in vectors Inherits type~~geopotential_model_vector_coeff~~InheritsGraph type~geopotential_model_vector_coeff geopotential_model_vector_coeff type~geopotential_model geopotential_model type~geopotential_model_vector_coeff->type~geopotential_model Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~geopotential_model_vector_coeff~~InheritedByGraph type~geopotential_model_vector_coeff geopotential_model_vector_coeff type~geopotential_model_mueller geopotential_model_mueller type~geopotential_model_mueller->type~geopotential_model_vector_coeff Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] real(kind=wp), public, dimension(:), allocatable :: c real(kind=wp), public, dimension(:), allocatable :: s Type-Bound Procedures procedure, public :: initialize => read_geopotential_file private  subroutine read_geopotential_file (me, filename, nmax, mmax, status_ok) Author Jacob Williams Date 9/20/2014 Read the gravity coefficient file.\nExample file: ftp://ftp.csr.utexas.edu/pub/grav/EGM96.GEO.Z Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me character(len=*), intent(in) :: filename integer, intent(in) :: nmax integer, intent(in) :: mmax logical, intent(out) :: status_ok procedure, public :: destroy => destroy_geopotential_model private  subroutine destroy_geopotential_model (me) Destroy a gravity model. Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me procedure( acc_function ), public, deferred :: get_acc subroutine acc_function(me, r, n, m, a) Prototype Interface to the acceleration function for the different methods Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Source Code type , extends ( geopotential_model ), abstract , public :: geopotential_model_vector_coeff !! The models where the C,S coefficients are stored in vectors real ( wp ), dimension (:), allocatable :: c real ( wp ), dimension (:), allocatable :: s end type geopotential_model_vector_coeff","tags":"","url":"type/geopotential_model_vector_coeff.html"},{"title":"geopotential_model_matrix_coeff – fortran-astrodynamics-toolkit ","text":"type, public, abstract, extends( geopotential_model ) :: geopotential_model_matrix_coeff The models where the C,S coefficients are stored in matrices Inherits type~~geopotential_model_matrix_coeff~~InheritsGraph type~geopotential_model_matrix_coeff geopotential_model_matrix_coeff type~geopotential_model geopotential_model type~geopotential_model_matrix_coeff->type~geopotential_model Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~geopotential_model_matrix_coeff~~InheritedByGraph type~geopotential_model_matrix_coeff geopotential_model_matrix_coeff type~geopotential_model_kuga_carrara geopotential_model_kuga_carrara type~geopotential_model_kuga_carrara->type~geopotential_model_matrix_coeff type~geopotential_model_lear geopotential_model_lear type~geopotential_model_lear->type~geopotential_model_matrix_coeff type~geopotential_model_normalized_pines geopotential_model_normalized_pines type~geopotential_model_normalized_pines->type~geopotential_model_matrix_coeff type~geopotential_model_pines geopotential_model_pines type~geopotential_model_pines->type~geopotential_model_matrix_coeff Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] real(kind=wp), public, dimension(:,:), allocatable :: cnm real(kind=wp), public, dimension(:,:), allocatable :: snm Type-Bound Procedures procedure, public :: initialize => read_geopotential_file private  subroutine read_geopotential_file (me, filename, nmax, mmax, status_ok) Author Jacob Williams Date 9/20/2014 Read the gravity coefficient file.\nExample file: ftp://ftp.csr.utexas.edu/pub/grav/EGM96.GEO.Z Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me character(len=*), intent(in) :: filename integer, intent(in) :: nmax integer, intent(in) :: mmax logical, intent(out) :: status_ok procedure, public :: destroy => destroy_geopotential_model private  subroutine destroy_geopotential_model (me) Destroy a gravity model. Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me procedure( acc_function ), public, deferred :: get_acc subroutine acc_function(me, r, n, m, a) Prototype Interface to the acceleration function for the different methods Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Source Code type , extends ( geopotential_model ), abstract , public :: geopotential_model_matrix_coeff !! The models where the C,S coefficients are stored in matrices real ( wp ), dimension (:,:), allocatable :: cnm real ( wp ), dimension (:,:), allocatable :: snm end type geopotential_model_matrix_coeff","tags":"","url":"type/geopotential_model_matrix_coeff.html"},{"title":"geopotential_model_mueller – fortran-astrodynamics-toolkit ","text":"type, public, extends( geopotential_model_vector_coeff ) :: geopotential_model_mueller Mueller method Inherits type~~geopotential_model_mueller~~InheritsGraph type~geopotential_model_mueller geopotential_model_mueller type~geopotential_model_vector_coeff geopotential_model_vector_coeff type~geopotential_model_mueller->type~geopotential_model_vector_coeff type~geopotential_model geopotential_model type~geopotential_model_vector_coeff->type~geopotential_model Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] real(kind=wp), public, dimension(:), allocatable :: c real(kind=wp), public, dimension(:), allocatable :: s Type-Bound Procedures procedure, public :: initialize => read_geopotential_file private  subroutine read_geopotential_file (me, filename, nmax, mmax, status_ok) Author Jacob Williams Date 9/20/2014 Read the gravity coefficient file.\nExample file: ftp://ftp.csr.utexas.edu/pub/grav/EGM96.GEO.Z Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me character(len=*), intent(in) :: filename integer, intent(in) :: nmax integer, intent(in) :: mmax logical, intent(out) :: status_ok procedure, public :: destroy => destroy_geopotential_model private  subroutine destroy_geopotential_model (me) Destroy a gravity model. Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me procedure, public :: get_acc => compute_gravity_acceleration_mueller private  subroutine compute_gravity_acceleration_mueller (me, r, n, m, a) Wrapper for Mueller method. Arguments Type Intent Optional Attributes Name class( geopotential_model_mueller ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Source Code type , extends ( geopotential_model_vector_coeff ), public :: geopotential_model_mueller !! Mueller method contains procedure , public :: get_acc => compute_gravity_acceleration_mueller end type geopotential_model_mueller","tags":"","url":"type/geopotential_model_mueller.html"},{"title":"geopotential_model_lear – fortran-astrodynamics-toolkit ","text":"type, public, extends( geopotential_model_matrix_coeff ) :: geopotential_model_lear Lear method Inherits type~~geopotential_model_lear~~InheritsGraph type~geopotential_model_lear geopotential_model_lear type~geopotential_model_matrix_coeff geopotential_model_matrix_coeff type~geopotential_model_lear->type~geopotential_model_matrix_coeff type~geopotential_model geopotential_model type~geopotential_model_matrix_coeff->type~geopotential_model Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] real(kind=wp), public, dimension(:,:), allocatable :: cnm real(kind=wp), public, dimension(:,:), allocatable :: snm Type-Bound Procedures procedure, public :: initialize => read_geopotential_file private  subroutine read_geopotential_file (me, filename, nmax, mmax, status_ok) Author Jacob Williams Date 9/20/2014 Read the gravity coefficient file.\nExample file: ftp://ftp.csr.utexas.edu/pub/grav/EGM96.GEO.Z Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me character(len=*), intent(in) :: filename integer, intent(in) :: nmax integer, intent(in) :: mmax logical, intent(out) :: status_ok procedure, public :: destroy => destroy_geopotential_model private  subroutine destroy_geopotential_model (me) Destroy a gravity model. Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me procedure, public :: get_acc => compute_gravity_acceleration_lear private  subroutine compute_gravity_acceleration_lear (me, r, n, m, a) Wrapper for Lear method. Arguments Type Intent Optional Attributes Name class( geopotential_model_lear ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Source Code type , extends ( geopotential_model_matrix_coeff ), public :: geopotential_model_lear !! Lear method contains procedure , public :: get_acc => compute_gravity_acceleration_lear end type geopotential_model_lear","tags":"","url":"type/geopotential_model_lear.html"},{"title":"geopotential_model_pines – fortran-astrodynamics-toolkit ","text":"type, public, extends( geopotential_model_matrix_coeff ) :: geopotential_model_pines Pines method Inherits type~~geopotential_model_pines~~InheritsGraph type~geopotential_model_pines geopotential_model_pines type~geopotential_model_matrix_coeff geopotential_model_matrix_coeff type~geopotential_model_pines->type~geopotential_model_matrix_coeff type~geopotential_model geopotential_model type~geopotential_model_matrix_coeff->type~geopotential_model Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] real(kind=wp), public, dimension(:,:), allocatable :: cnm real(kind=wp), public, dimension(:,:), allocatable :: snm Type-Bound Procedures procedure, public :: initialize => read_geopotential_file private  subroutine read_geopotential_file (me, filename, nmax, mmax, status_ok) Author Jacob Williams Date 9/20/2014 Read the gravity coefficient file.\nExample file: ftp://ftp.csr.utexas.edu/pub/grav/EGM96.GEO.Z Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me character(len=*), intent(in) :: filename integer, intent(in) :: nmax integer, intent(in) :: mmax logical, intent(out) :: status_ok procedure, public :: destroy => destroy_geopotential_model private  subroutine destroy_geopotential_model (me) Destroy a gravity model. Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me procedure, public :: get_acc => compute_gravity_acceleration_pines private  subroutine compute_gravity_acceleration_pines (me, r, n, m, a) Wrapper for Pines method. Arguments Type Intent Optional Attributes Name class( geopotential_model_pines ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Source Code type , extends ( geopotential_model_matrix_coeff ), public :: geopotential_model_pines !! Pines method contains procedure , public :: get_acc => compute_gravity_acceleration_pines end type geopotential_model_pines","tags":"","url":"type/geopotential_model_pines.html"},{"title":"geopotential_model_normalized_pines – fortran-astrodynamics-toolkit ","text":"type, public, extends( geopotential_model_matrix_coeff ) :: geopotential_model_normalized_pines Pines (normalized) method Inherits type~~geopotential_model_normalized_pines~~InheritsGraph type~geopotential_model_normalized_pines geopotential_model_normalized_pines type~geopotential_model_matrix_coeff geopotential_model_matrix_coeff type~geopotential_model_normalized_pines->type~geopotential_model_matrix_coeff type~geopotential_model geopotential_model type~geopotential_model_matrix_coeff->type~geopotential_model Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] real(kind=wp), public, dimension(:,:), allocatable :: cnm real(kind=wp), public, dimension(:,:), allocatable :: snm Type-Bound Procedures procedure, public :: initialize => read_geopotential_file private  subroutine read_geopotential_file (me, filename, nmax, mmax, status_ok) Author Jacob Williams Date 9/20/2014 Read the gravity coefficient file.\nExample file: ftp://ftp.csr.utexas.edu/pub/grav/EGM96.GEO.Z Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me character(len=*), intent(in) :: filename integer, intent(in) :: nmax integer, intent(in) :: mmax logical, intent(out) :: status_ok procedure, public :: destroy => destroy_geopotential_model private  subroutine destroy_geopotential_model (me) Destroy a gravity model. Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me procedure, public :: get_acc => compute_gravity_acceleration_normalized_pines private  subroutine compute_gravity_acceleration_normalized_pines (me, r, n, m, a) Wrapper for normalized Pines method. Arguments Type Intent Optional Attributes Name class( geopotential_model_normalized_pines ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Source Code type , extends ( geopotential_model_matrix_coeff ), public :: geopotential_model_normalized_pines !! Pines (normalized) method contains procedure , public :: get_acc => compute_gravity_acceleration_normalized_pines end type geopotential_model_normalized_pines","tags":"","url":"type/geopotential_model_normalized_pines.html"},{"title":"geopotential_model_kuga_carrara – fortran-astrodynamics-toolkit ","text":"type, public, extends( geopotential_model_matrix_coeff ) :: geopotential_model_kuga_carrara Kuga/Carrara method Inherits type~~geopotential_model_kuga_carrara~~InheritsGraph type~geopotential_model_kuga_carrara geopotential_model_kuga_carrara type~geopotential_model_matrix_coeff geopotential_model_matrix_coeff type~geopotential_model_kuga_carrara->type~geopotential_model_matrix_coeff type~geopotential_model geopotential_model type~geopotential_model_matrix_coeff->type~geopotential_model Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] real(kind=wp), public, dimension(:,:), allocatable :: cnm real(kind=wp), public, dimension(:,:), allocatable :: snm Type-Bound Procedures procedure, public :: initialize => read_geopotential_file private  subroutine read_geopotential_file (me, filename, nmax, mmax, status_ok) Author Jacob Williams Date 9/20/2014 Read the gravity coefficient file.\nExample file: ftp://ftp.csr.utexas.edu/pub/grav/EGM96.GEO.Z Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me character(len=*), intent(in) :: filename integer, intent(in) :: nmax integer, intent(in) :: mmax logical, intent(out) :: status_ok procedure, public :: destroy => destroy_geopotential_model private  subroutine destroy_geopotential_model (me) Destroy a gravity model. Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me procedure, public :: get_acc => compute_gravity_acceleration_kuga_carrara private  subroutine compute_gravity_acceleration_kuga_carrara (me, r, n, m, a) Wrapper for Kuga/Carrara method. Arguments Type Intent Optional Attributes Name class( geopotential_model_kuga_carrara ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Source Code type , extends ( geopotential_model_matrix_coeff ), public :: geopotential_model_kuga_carrara !! Kuga/Carrara method contains procedure , public :: get_acc => compute_gravity_acceleration_kuga_carrara end type geopotential_model_kuga_carrara","tags":"","url":"type/geopotential_model_kuga_carrara.html"},{"title":"container – fortran-astrodynamics-toolkit ","text":"type, private :: container a container for data that is\nto be passed to C. We include\nit here so that we can use c_loc() Components Type Visibility Attributes Name Initial class(*), private, pointer :: data Source Code type :: container !! a container for data that is !! to be passed to C. We include !! it here so that we can use `c_loc()` private class ( * ), pointer :: data end type container","tags":"","url":"type/container.html"},{"title":"rk_class – fortran-astrodynamics-toolkit ","text":"type, public, abstract :: rk_class main integration class: Inherited by type~~rk_class~~InheritedByGraph type~rk_class rk_class type~rk4_class rk4_class type~rk4_class->type~rk_class type~rk8_10_class rk8_10_class type~rk8_10_class->type~rk_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: n = 0 user specified number of variables procedure( deriv_func ), public, pointer :: f => null() user-specified derivative function procedure( report_func ), public, pointer :: report => null() user-specified report function procedure( event_func ), public, pointer :: g => null() event function (stop when this is zero) Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) private  subroutine initialize (me, n, f, report, g) Initialize the rk_class . Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me integer, intent(in) :: n number of variables procedure( deriv_func ) :: f derivative function procedure( report_func ), optional :: report for reporting the steps procedure( event_func ), optional :: g for stopping at an event procedure, public, non_overridable :: integrate main integration routine private  subroutine integrate (me, t0, x0, h, tf, xf) Main integration routine for the rk_class . Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tf final time real(kind=wp), intent(out), dimension(me%n) :: xf final state procedure, public, non_overridable :: integrate_to_event integration with event finding private  subroutine integrate_to_event (me, t0, x0, h, tmax, tol, tf, xf, gf) Event-finding integration routine for the rk_class .\nIntegrates until g(t,x)=0, or until t=tf (whichever happens first). Read more… Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tmax max final time if event not located real(kind=wp), intent(in) :: tol function tolerance for root finding real(kind=wp), intent(out) :: tf actual final time reached real(kind=wp), intent(out), dimension(me%n) :: xf final state (at tf) real(kind=wp), intent(out) :: gf g value at tf procedure( step_func ), public, deferred :: step the step routine for the rk method subroutine step_func(me, t, x, h, xf) Prototype rk step function Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state vector real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf final state vector procedure, public :: destroy destructor private  subroutine destroy (me) Destructor for rk_class . Arguments Type Intent Optional Attributes Name class( rk_class ), intent(out) :: me Source Code type , abstract , public :: rk_class !! main integration class: integer :: n = 0 !! user specified number of variables procedure ( deriv_func ), pointer :: f => null () !! user-specified derivative function procedure ( report_func ), pointer :: report => null () !! user-specified report function procedure ( event_func ), pointer :: g => null () !! event function (stop when this is zero) contains procedure :: initialize !! initialize the class (set n,f, and report) procedure , non_overridable , public :: integrate !! main integration routine procedure , non_overridable , public :: integrate_to_event !! integration with event finding procedure ( step_func ), deferred :: step !! the step routine for the rk method procedure , public :: destroy !! destructor end type rk_class","tags":"","url":"type/rk_class.html"},{"title":"rk4_class – fortran-astrodynamics-toolkit ","text":"type, public, extends( rk_class ) :: rk4_class 4th order Runge-Kutta method. Inherits type~~rk4_class~~InheritsGraph type~rk4_class rk4_class type~rk_class rk_class type~rk4_class->type~rk_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: n = 0 user specified number of variables procedure( deriv_func ), public, pointer :: f => null() user-specified derivative function procedure( report_func ), public, pointer :: report => null() user-specified report function procedure( event_func ), public, pointer :: g => null() event function (stop when this is zero) Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) private  subroutine initialize (me, n, f, report, g) Initialize the rk_class . Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me integer, intent(in) :: n number of variables procedure( deriv_func ) :: f derivative function procedure( report_func ), optional :: report for reporting the steps procedure( event_func ), optional :: g for stopping at an event procedure, public, non_overridable :: integrate main integration routine private  subroutine integrate (me, t0, x0, h, tf, xf) Main integration routine for the rk_class . Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tf final time real(kind=wp), intent(out), dimension(me%n) :: xf final state procedure, public, non_overridable :: integrate_to_event integration with event finding private  subroutine integrate_to_event (me, t0, x0, h, tmax, tol, tf, xf, gf) Event-finding integration routine for the rk_class .\nIntegrates until g(t,x)=0, or until t=tf (whichever happens first). Read more… Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tmax max final time if event not located real(kind=wp), intent(in) :: tol function tolerance for root finding real(kind=wp), intent(out) :: tf actual final time reached real(kind=wp), intent(out), dimension(me%n) :: xf final state (at tf) real(kind=wp), intent(out) :: gf g value at tf procedure, public :: destroy destructor private  subroutine destroy (me) Destructor for rk_class . Arguments Type Intent Optional Attributes Name class( rk_class ), intent(out) :: me procedure, public :: step => rk4 private  subroutine rk4 (me, t, x, h, xf) Take one Runge Kutta 4 integration step: t -> t+h (x -> xf) Arguments Type Intent Optional Attributes Name class( rk4_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h Source Code type , extends ( rk_class ), public :: rk4_class !! 4th order Runge-Kutta method. contains procedure :: step => rk4 end type rk4_class","tags":"","url":"type/rk4_class.html"},{"title":"rk8_10_class – fortran-astrodynamics-toolkit ","text":"type, public, extends( rk_class ) :: rk8_10_class 8th order Runge-Kutta method. Inherits type~~rk8_10_class~~InheritsGraph type~rk8_10_class rk8_10_class type~rk_class rk_class type~rk8_10_class->type~rk_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: n = 0 user specified number of variables procedure( deriv_func ), public, pointer :: f => null() user-specified derivative function procedure( report_func ), public, pointer :: report => null() user-specified report function procedure( event_func ), public, pointer :: g => null() event function (stop when this is zero) Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) private  subroutine initialize (me, n, f, report, g) Initialize the rk_class . Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me integer, intent(in) :: n number of variables procedure( deriv_func ) :: f derivative function procedure( report_func ), optional :: report for reporting the steps procedure( event_func ), optional :: g for stopping at an event procedure, public, non_overridable :: integrate main integration routine private  subroutine integrate (me, t0, x0, h, tf, xf) Main integration routine for the rk_class . Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tf final time real(kind=wp), intent(out), dimension(me%n) :: xf final state procedure, public, non_overridable :: integrate_to_event integration with event finding private  subroutine integrate_to_event (me, t0, x0, h, tmax, tol, tf, xf, gf) Event-finding integration routine for the rk_class .\nIntegrates until g(t,x)=0, or until t=tf (whichever happens first). Read more… Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tmax max final time if event not located real(kind=wp), intent(in) :: tol function tolerance for root finding real(kind=wp), intent(out) :: tf actual final time reached real(kind=wp), intent(out), dimension(me%n) :: xf final state (at tf) real(kind=wp), intent(out) :: gf g value at tf procedure, public :: destroy destructor private  subroutine destroy (me) Destructor for rk_class . Arguments Type Intent Optional Attributes Name class( rk_class ), intent(out) :: me procedure, public :: step => rk8_10 private  subroutine rk8_10 (me, t, x, h, xf) Take one Runge Kutta 8 integration step: t -> t+h (x -> xf) This is Formula (8-10) from Reference [1]. Read more… Arguments Type Intent Optional Attributes Name class( rk8_10_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h Source Code type , extends ( rk_class ), public :: rk8_10_class !! 8th order Runge-Kutta method. contains procedure :: step => rk8_10 end type rk8_10_class","tags":"","url":"type/rk8_10_class.html"},{"title":"reference_frame – fortran-astrodynamics-toolkit ","text":"type, public, abstract :: reference_frame a reference frame defines an orientation at\na specified frame center at a specified epoch.\nUsually, the center is the primary_body of the\nframe, but can be otherwise for a two_body_rotating_frame . Inherits type~~reference_frame~~InheritsGraph type~reference_frame reference_frame type~celestial_body celestial_body type~reference_frame->type~celestial_body primary_body type~base_class base_class type~celestial_body->type~base_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~reference_frame~~InheritedByGraph type~reference_frame reference_frame type~inertial_frame_class inertial_frame_class type~inertial_frame_class->type~reference_frame type~rotating_frame_class rotating_frame_class type~rotating_frame_class->type~reference_frame type~ecliptic_frame ecliptic_frame type~ecliptic_frame->type~inertial_frame_class type~iau_rotating_frame_class iau_rotating_frame_class type~iau_rotating_frame_class->type~rotating_frame_class type~icrf_frame icrf_frame type~icrf_frame->type~inertial_frame_class type~two_body_rotating_frame two_body_rotating_frame type~two_body_rotating_frame->type~rotating_frame_class type~iau_earth_rotating_frame iau_earth_rotating_frame type~iau_earth_rotating_frame->type~iau_rotating_frame_class type~iau_moon_rotating_frame iau_moon_rotating_frame type~iau_moon_rotating_frame->type~iau_rotating_frame_class type~two_body_rotating_pulsating_frame two_body_rotating_pulsating_frame type~two_body_rotating_pulsating_frame->type~two_body_rotating_frame Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( celestial_body ), private :: primary_body = body_earth the primary body of the frame real(kind=wp), private :: et = zero epoch at which the frame is defined [sec] Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine private  subroutine transform (from, rv, to, et, eph, rv_out, status_ok) Transform a Cartesian state from one reference frame to another at\na specified epoch. The from and to reference_frame s may each\nbe defined at a different epoch. The et ephemeris time is the time\nthe transformation is to be done, and accounts for the motion of the two\nframe centers from from%et and to%et to et . Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: from real(kind=wp), intent(in), dimension(6) :: rv class( reference_frame ), intent(inout) :: to real(kind=wp), intent(in) :: et the time of the transformation [sec] class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(out), dimension(6) :: rv_out logical, intent(out) :: status_ok procedure( c_cdot_func ), private, deferred :: get_c_cdot to get the rotating matrix for the frame orientation subroutine c_cdot_func(me, eph, to_icrf, c, cdot, status_ok) Prototype Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations\n(assumed to have already\nbeen initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok Source Code type , abstract , public :: reference_frame !! a reference frame defines an orientation at !! a specified frame center at a specified epoch. !! Usually, the center is the `primary_body` of the !! frame, but can be otherwise for a !! [[two_body_rotating_frame]]. private type ( celestial_body ) :: primary_body = body_earth !! the primary body of the frame real ( wp ) :: et = zero !! epoch at which the frame is defined [sec] contains private procedure , pass ( from ), public :: transform !! coordinate transformation routine procedure ( c_cdot_func ), deferred :: get_c_cdot !! to get the rotating matrix for the frame orientation end type reference_frame","tags":"","url":"type/reference_frame.html"},{"title":"inertial_frame_class – fortran-astrodynamics-toolkit ","text":"type, public, abstract, extends( reference_frame ) :: inertial_frame_class a non-rotating frame (a frame where the orientation axes are time invariant) Inherits type~~inertial_frame_class~~InheritsGraph type~inertial_frame_class inertial_frame_class type~reference_frame reference_frame type~inertial_frame_class->type~reference_frame type~celestial_body celestial_body type~reference_frame->type~celestial_body primary_body type~base_class base_class type~celestial_body->type~base_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~inertial_frame_class~~InheritedByGraph type~inertial_frame_class inertial_frame_class type~ecliptic_frame ecliptic_frame type~ecliptic_frame->type~inertial_frame_class type~icrf_frame icrf_frame type~icrf_frame->type~inertial_frame_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine private  subroutine transform (from, rv, to, et, eph, rv_out, status_ok) Transform a Cartesian state from one reference frame to another at\na specified epoch. The from and to reference_frame s may each\nbe defined at a different epoch. The et ephemeris time is the time\nthe transformation is to be done, and accounts for the motion of the two\nframe centers from from%et and to%et to et . Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: from real(kind=wp), intent(in), dimension(6) :: rv class( reference_frame ), intent(inout) :: to real(kind=wp), intent(in) :: et the time of the transformation [sec] class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(out), dimension(6) :: rv_out logical, intent(out) :: status_ok Source Code type , abstract , extends ( reference_frame ), public :: inertial_frame_class !! a non-rotating frame (a frame where the orientation axes are time invariant) end type inertial_frame_class","tags":"","url":"type/inertial_frame_class.html"},{"title":"rotating_frame_class – fortran-astrodynamics-toolkit ","text":"type, public, abstract, extends( reference_frame ) :: rotating_frame_class a rotating frame (a frame where the orientation axes vary with time) Inherits type~~rotating_frame_class~~InheritsGraph type~rotating_frame_class rotating_frame_class type~reference_frame reference_frame type~rotating_frame_class->type~reference_frame type~celestial_body celestial_body type~reference_frame->type~celestial_body primary_body type~base_class base_class type~celestial_body->type~base_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~rotating_frame_class~~InheritedByGraph type~rotating_frame_class rotating_frame_class type~iau_rotating_frame_class iau_rotating_frame_class type~iau_rotating_frame_class->type~rotating_frame_class type~two_body_rotating_frame two_body_rotating_frame type~two_body_rotating_frame->type~rotating_frame_class type~iau_earth_rotating_frame iau_earth_rotating_frame type~iau_earth_rotating_frame->type~iau_rotating_frame_class type~iau_moon_rotating_frame iau_moon_rotating_frame type~iau_moon_rotating_frame->type~iau_rotating_frame_class type~two_body_rotating_pulsating_frame two_body_rotating_pulsating_frame type~two_body_rotating_pulsating_frame->type~two_body_rotating_frame Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine private  subroutine transform (from, rv, to, et, eph, rv_out, status_ok) Transform a Cartesian state from one reference frame to another at\na specified epoch. The from and to reference_frame s may each\nbe defined at a different epoch. The et ephemeris time is the time\nthe transformation is to be done, and accounts for the motion of the two\nframe centers from from%et and to%et to et . Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: from real(kind=wp), intent(in), dimension(6) :: rv class( reference_frame ), intent(inout) :: to real(kind=wp), intent(in) :: et the time of the transformation [sec] class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(out), dimension(6) :: rv_out logical, intent(out) :: status_ok Source Code type , abstract , extends ( reference_frame ), public :: rotating_frame_class !! a rotating frame (a frame where the orientation axes vary with time) end type rotating_frame_class","tags":"","url":"type/rotating_frame_class.html"},{"title":"iau_rotating_frame_class – fortran-astrodynamics-toolkit ","text":"type, public, abstract, extends( rotating_frame_class ) :: iau_rotating_frame_class frame defined by the orientation of a celestial body using the IAU models. Inherits type~~iau_rotating_frame_class~~InheritsGraph type~iau_rotating_frame_class iau_rotating_frame_class type~rotating_frame_class rotating_frame_class type~iau_rotating_frame_class->type~rotating_frame_class type~reference_frame reference_frame type~rotating_frame_class->type~reference_frame type~celestial_body celestial_body type~reference_frame->type~celestial_body primary_body type~base_class base_class type~celestial_body->type~base_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~iau_rotating_frame_class~~InheritedByGraph type~iau_rotating_frame_class iau_rotating_frame_class type~iau_earth_rotating_frame iau_earth_rotating_frame type~iau_earth_rotating_frame->type~iau_rotating_frame_class type~iau_moon_rotating_frame iau_moon_rotating_frame type~iau_moon_rotating_frame->type~iau_rotating_frame_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine private  subroutine transform (from, rv, to, et, eph, rv_out, status_ok) Transform a Cartesian state from one reference frame to another at\na specified epoch. The from and to reference_frame s may each\nbe defined at a different epoch. The et ephemeris time is the time\nthe transformation is to be done, and accounts for the motion of the two\nframe centers from from%et and to%et to et . Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: from real(kind=wp), intent(in), dimension(6) :: rv class( reference_frame ), intent(inout) :: to real(kind=wp), intent(in) :: et the time of the transformation [sec] class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(out), dimension(6) :: rv_out logical, intent(out) :: status_ok Source Code type , abstract , extends ( rotating_frame_class ), public :: iau_rotating_frame_class !! frame defined by the orientation of a celestial body using the IAU models. end type iau_rotating_frame_class","tags":"","url":"type/iau_rotating_frame_class.html"},{"title":"two_body_rotating_frame – fortran-astrodynamics-toolkit ","text":"type, public, extends( rotating_frame_class ) :: two_body_rotating_frame The two-body rotating frame is constructed from the states\nof two celestial bodies. Inherits type~~two_body_rotating_frame~~InheritsGraph type~two_body_rotating_frame two_body_rotating_frame type~celestial_body celestial_body type~two_body_rotating_frame->type~celestial_body secondary_body type~rotating_frame_class rotating_frame_class type~two_body_rotating_frame->type~rotating_frame_class type~base_class base_class type~celestial_body->type~base_class type~reference_frame reference_frame type~rotating_frame_class->type~reference_frame type~reference_frame->type~celestial_body primary_body Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~two_body_rotating_frame~~InheritedByGraph type~two_body_rotating_frame two_body_rotating_frame type~two_body_rotating_pulsating_frame two_body_rotating_pulsating_frame type~two_body_rotating_pulsating_frame->type~two_body_rotating_frame Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( celestial_body ), public :: secondary_body = body_moon the secondary body used to construct the frame integer, public :: center = center_at_barycenter the frame center (can be primary_body,secondary_body, or barycenter) real(kind=wp), public, dimension(6) :: rv12 = zero [r,v] of secondary body w.r.t. primary body logical, public :: inertial = .false. to make it a quasi-inertial frame (cdot is zero) Constructor public        interface two_body_rotating_frame private pure function two_body_rotating_frame_constructor (primary_body, secondary_body, center, et, inertial) result(f) Constructor for a two_body_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: primary_body the primary body of\nthe frame type( celestial_body ), intent(in) :: secondary_body the secondary body used\nto construct the frame integer, intent(in) :: center the frame center (can\nbe primary_body , secondary_body , or barycenter ) real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] logical, intent(in), optional :: inertial if true, it's a quasi-inertial frame\n[default is false] Return Value type( two_body_rotating_frame ) Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine private  subroutine transform (from, rv, to, et, eph, rv_out, status_ok) Transform a Cartesian state from one reference frame to another at\na specified epoch. The from and to reference_frame s may each\nbe defined at a different epoch. The et ephemeris time is the time\nthe transformation is to be done, and accounts for the motion of the two\nframe centers from from%et and to%et to et . Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: from real(kind=wp), intent(in), dimension(6) :: rv class( reference_frame ), intent(inout) :: to real(kind=wp), intent(in) :: et the time of the transformation [sec] class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(out), dimension(6) :: rv_out logical, intent(out) :: status_ok procedure, public :: from_primary_to_center private  subroutine from_primary_to_center (me, eph, et, rc, status_ok) returns the state of the frame center w.r.t. the frame primary body. Arguments Type Intent Optional Attributes Name class( two_body_rotating_frame ), intent(in) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(in) :: et ephemeris time [sec] real(kind=wp), intent(out), dimension(6) :: rc state of frame center w.r.t. primary body [inertial] logical, intent(out) :: status_ok true if no errors. procedure, public :: get_c_cdot => get_c_cdot_two_body_rotating private  subroutine get_c_cdot_two_body_rotating (me, eph, to_icrf, c, cdot, status_ok) rotation matrix for ROTATING <-> ICRF Arguments Type Intent Optional Attributes Name class( two_body_rotating_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok Source Code type , extends ( rotating_frame_class ), public :: two_body_rotating_frame !! The two-body rotating frame is constructed from the states !! of two celestial bodies. type ( celestial_body ) :: secondary_body = body_moon !! the secondary body used to construct the frame integer :: center = center_at_barycenter !! the frame center (can be primary_body,secondary_body, or barycenter) real ( wp ), dimension ( 6 ) :: rv12 = zero !! [r,v] of secondary body w.r.t. primary body logical :: inertial = . false . !! to make it a quasi-inertial frame (cdot is zero) contains procedure :: from_primary_to_center procedure :: get_c_cdot => get_c_cdot_two_body_rotating end type two_body_rotating_frame","tags":"","url":"type/two_body_rotating_frame.html"},{"title":"two_body_rotating_pulsating_frame – fortran-astrodynamics-toolkit ","text":"type, public, extends( two_body_rotating_frame ) :: two_body_rotating_pulsating_frame This frame is an extension of the two-body rotating frame, where\na scale factor is used to scale the position and velocity of the state\nbased on the distance between the primary and secondary bodies. Inherits type~~two_body_rotating_pulsating_frame~~InheritsGraph type~two_body_rotating_pulsating_frame two_body_rotating_pulsating_frame type~two_body_rotating_frame two_body_rotating_frame type~two_body_rotating_pulsating_frame->type~two_body_rotating_frame type~celestial_body celestial_body type~two_body_rotating_frame->type~celestial_body secondary_body type~rotating_frame_class rotating_frame_class type~two_body_rotating_frame->type~rotating_frame_class type~base_class base_class type~celestial_body->type~base_class type~reference_frame reference_frame type~rotating_frame_class->type~reference_frame type~reference_frame->type~celestial_body primary_body Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial type( celestial_body ), public :: secondary_body = body_moon the secondary body used to construct the frame integer, public :: center = center_at_barycenter the frame center (can be primary_body,secondary_body, or barycenter) real(kind=wp), public, dimension(6) :: rv12 = zero [r,v] of secondary body w.r.t. primary body logical, public :: inertial = .false. to make it a quasi-inertial frame (cdot is zero) real(kind=wp), public :: scale = zero scale factor Constructor public        interface two_body_rotating_pulsating_frame private pure function two_body_rotating_pulsating_frame_constructor (primary_body, secondary_body, center, scale, et) result(f) Constructor for a two_body_rotating_pulsating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: primary_body the primary body of\nthe frame type( celestial_body ), intent(in) :: secondary_body the secondary body used\nto construct the frame integer, intent(in) :: center the frame center (can\nbe primary_body , secondary_body , or barycenter ) real(kind=wp), intent(in) :: scale scale factor real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( two_body_rotating_pulsating_frame ) Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine private  subroutine transform (from, rv, to, et, eph, rv_out, status_ok) Transform a Cartesian state from one reference frame to another at\na specified epoch. The from and to reference_frame s may each\nbe defined at a different epoch. The et ephemeris time is the time\nthe transformation is to be done, and accounts for the motion of the two\nframe centers from from%et and to%et to et . Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: from real(kind=wp), intent(in), dimension(6) :: rv class( reference_frame ), intent(inout) :: to real(kind=wp), intent(in) :: et the time of the transformation [sec] class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(out), dimension(6) :: rv_out logical, intent(out) :: status_ok procedure, public :: from_primary_to_center private  subroutine from_primary_to_center (me, eph, et, rc, status_ok) returns the state of the frame center w.r.t. the frame primary body. Arguments Type Intent Optional Attributes Name class( two_body_rotating_frame ), intent(in) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(in) :: et ephemeris time [sec] real(kind=wp), intent(out), dimension(6) :: rc state of frame center w.r.t. primary body [inertial] logical, intent(out) :: status_ok true if no errors. procedure, public :: get_c_cdot => get_c_cdot_two_body_rotating_pulsating private  subroutine get_c_cdot_two_body_rotating_pulsating (me, eph, to_icrf, c, cdot, status_ok) rotation matrix for ROTATING_PULSATING <-> ICRF Arguments Type Intent Optional Attributes Name class( two_body_rotating_pulsating_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok Source Code type , extends ( two_body_rotating_frame ), public :: two_body_rotating_pulsating_frame !! This frame is an extension of the two-body rotating frame, where !! a scale factor is used to scale the position and velocity of the state !! based on the distance between the primary and secondary bodies. real ( wp ) :: scale = zero !! scale factor contains procedure :: get_c_cdot => get_c_cdot_two_body_rotating_pulsating end type two_body_rotating_pulsating_frame","tags":"","url":"type/two_body_rotating_pulsating_frame.html"},{"title":"iau_earth_rotating_frame – fortran-astrodynamics-toolkit ","text":"type, public, extends( iau_rotating_frame_class ) :: iau_earth_rotating_frame IAU Earth frame Inherits type~~iau_earth_rotating_frame~~InheritsGraph type~iau_earth_rotating_frame iau_earth_rotating_frame type~iau_rotating_frame_class iau_rotating_frame_class type~iau_earth_rotating_frame->type~iau_rotating_frame_class type~rotating_frame_class rotating_frame_class type~iau_rotating_frame_class->type~rotating_frame_class type~reference_frame reference_frame type~rotating_frame_class->type~reference_frame type~celestial_body celestial_body type~reference_frame->type~celestial_body primary_body type~base_class base_class type~celestial_body->type~base_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Constructor public        interface iau_earth_rotating_frame private pure function iau_earth_rotating_frame_constructor (b, et) result(f) Constructor for a iau_earth_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( iau_earth_rotating_frame ) Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine private  subroutine transform (from, rv, to, et, eph, rv_out, status_ok) Transform a Cartesian state from one reference frame to another at\na specified epoch. The from and to reference_frame s may each\nbe defined at a different epoch. The et ephemeris time is the time\nthe transformation is to be done, and accounts for the motion of the two\nframe centers from from%et and to%et to et . Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: from real(kind=wp), intent(in), dimension(6) :: rv class( reference_frame ), intent(inout) :: to real(kind=wp), intent(in) :: et the time of the transformation [sec] class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(out), dimension(6) :: rv_out logical, intent(out) :: status_ok procedure, public :: get_c_cdot => get_c_cdot_iau_earth private  subroutine get_c_cdot_iau_earth (me, eph, to_icrf, c, cdot, status_ok) rotation matrix for IAU_EARTH <-> ICRF Arguments Type Intent Optional Attributes Name class( iau_earth_rotating_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok Source Code type , extends ( iau_rotating_frame_class ), public :: iau_earth_rotating_frame !! IAU Earth frame contains procedure :: get_c_cdot => get_c_cdot_iau_earth end type iau_earth_rotating_frame","tags":"","url":"type/iau_earth_rotating_frame.html"},{"title":"iau_moon_rotating_frame – fortran-astrodynamics-toolkit ","text":"type, public, extends( iau_rotating_frame_class ) :: iau_moon_rotating_frame IAU Moon frame Inherits type~~iau_moon_rotating_frame~~InheritsGraph type~iau_moon_rotating_frame iau_moon_rotating_frame type~iau_rotating_frame_class iau_rotating_frame_class type~iau_moon_rotating_frame->type~iau_rotating_frame_class type~rotating_frame_class rotating_frame_class type~iau_rotating_frame_class->type~rotating_frame_class type~reference_frame reference_frame type~rotating_frame_class->type~reference_frame type~celestial_body celestial_body type~reference_frame->type~celestial_body primary_body type~base_class base_class type~celestial_body->type~base_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Constructor public        interface iau_moon_rotating_frame private pure function iau_moon_rotating_frame_constructor (b, et) result(f) Constructor for a iau_moon_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( iau_earth_rotating_frame ) Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine private  subroutine transform (from, rv, to, et, eph, rv_out, status_ok) Transform a Cartesian state from one reference frame to another at\na specified epoch. The from and to reference_frame s may each\nbe defined at a different epoch. The et ephemeris time is the time\nthe transformation is to be done, and accounts for the motion of the two\nframe centers from from%et and to%et to et . Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: from real(kind=wp), intent(in), dimension(6) :: rv class( reference_frame ), intent(inout) :: to real(kind=wp), intent(in) :: et the time of the transformation [sec] class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(out), dimension(6) :: rv_out logical, intent(out) :: status_ok procedure, public :: get_c_cdot => get_c_cdot_iau_moon private  subroutine get_c_cdot_iau_moon (me, eph, to_icrf, c, cdot, status_ok) rotation matrix for IAU_MOON <-> ICRF Arguments Type Intent Optional Attributes Name class( iau_moon_rotating_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok Source Code type , extends ( iau_rotating_frame_class ), public :: iau_moon_rotating_frame !! IAU Moon frame contains procedure :: get_c_cdot => get_c_cdot_iau_moon end type iau_moon_rotating_frame","tags":"","url":"type/iau_moon_rotating_frame.html"},{"title":"icrf_frame – fortran-astrodynamics-toolkit ","text":"type, public, extends( inertial_frame_class ) :: icrf_frame the fundamental inertial frame\nfor the ephemeris (i.e., J2000). Inherits type~~icrf_frame~~InheritsGraph type~icrf_frame icrf_frame type~inertial_frame_class inertial_frame_class type~icrf_frame->type~inertial_frame_class type~reference_frame reference_frame type~inertial_frame_class->type~reference_frame type~celestial_body celestial_body type~reference_frame->type~celestial_body primary_body type~base_class base_class type~celestial_body->type~base_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Constructor public        interface icrf_frame private pure function icrf_frame_constructor (b) result(f) Constructor for a icrf_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body Return Value type( icrf_frame ) Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine private  subroutine transform (from, rv, to, et, eph, rv_out, status_ok) Transform a Cartesian state from one reference frame to another at\na specified epoch. The from and to reference_frame s may each\nbe defined at a different epoch. The et ephemeris time is the time\nthe transformation is to be done, and accounts for the motion of the two\nframe centers from from%et and to%et to et . Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: from real(kind=wp), intent(in), dimension(6) :: rv class( reference_frame ), intent(inout) :: to real(kind=wp), intent(in) :: et the time of the transformation [sec] class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(out), dimension(6) :: rv_out logical, intent(out) :: status_ok procedure, public :: get_c_cdot => get_c_cdot_icrf private  subroutine get_c_cdot_icrf (me, eph, to_icrf, c, cdot, status_ok) rotation matrix for ICRF <-> ICRF Arguments Type Intent Optional Attributes Name class( icrf_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok Source Code type , extends ( inertial_frame_class ), public :: icrf_frame !! the fundamental inertial frame !! for the ephemeris (i.e., J2000). contains procedure :: get_c_cdot => get_c_cdot_icrf end type icrf_frame","tags":"","url":"type/icrf_frame.html"},{"title":"ecliptic_frame – fortran-astrodynamics-toolkit ","text":"type, public, extends( inertial_frame_class ) :: ecliptic_frame Mean ecliptic frame. Inherits type~~ecliptic_frame~~InheritsGraph type~ecliptic_frame ecliptic_frame type~inertial_frame_class inertial_frame_class type~ecliptic_frame->type~inertial_frame_class type~reference_frame reference_frame type~inertial_frame_class->type~reference_frame type~celestial_body celestial_body type~reference_frame->type~celestial_body primary_body type~base_class base_class type~celestial_body->type~base_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Constructor public        interface ecliptic_frame private pure function ecliptic_frame_constructor (b) result(f) Constructor for a ecliptic_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body Return Value type( ecliptic_frame ) Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine private  subroutine transform (from, rv, to, et, eph, rv_out, status_ok) Transform a Cartesian state from one reference frame to another at\na specified epoch. The from and to reference_frame s may each\nbe defined at a different epoch. The et ephemeris time is the time\nthe transformation is to be done, and accounts for the motion of the two\nframe centers from from%et and to%et to et . Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: from real(kind=wp), intent(in), dimension(6) :: rv class( reference_frame ), intent(inout) :: to real(kind=wp), intent(in) :: et the time of the transformation [sec] class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(out), dimension(6) :: rv_out logical, intent(out) :: status_ok procedure, public :: get_c_cdot => get_c_cdot_ecliptic private  subroutine get_c_cdot_ecliptic (me, eph, to_icrf, c, cdot, status_ok) rotation matrix for ICRF <-> Mean Ecliptic Arguments Type Intent Optional Attributes Name class( ecliptic_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok Source Code type , extends ( inertial_frame_class ), public :: ecliptic_frame !! Mean ecliptic frame. contains procedure :: get_c_cdot => get_c_cdot_ecliptic end type ecliptic_frame","tags":"","url":"type/ecliptic_frame.html"},{"title":"jpl_ephemeris – fortran-astrodynamics-toolkit ","text":"type, public, extends( ephemeris_class ) :: jpl_ephemeris Main class for accessing a JPL ephemeris file. Inherits type~~jpl_ephemeris~~InheritsGraph type~jpl_ephemeris jpl_ephemeris type~ephemeris_class ephemeris_class type~jpl_ephemeris->type~ephemeris_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: namfil name of the binary ephemeris file integer, public :: ksize = 2036 ksize must be set by the user according to the ephemeris to be read:\n  for de200 , set ksize=1652 ,\n  for de405 , set ksize=2036 ,\n  for de406 , set ksize=1456 ,\n  for de414 , set ksize=2036 ,\n  for de418 , set ksize=2036 ,\n  for de421 , set ksize=2036 ,\n  for de422 , set ksize=2036 ,\n  for de423 , set ksize=2036 ,\n  for de424 , set ksize=2036 ,\n  for de430 , set ksize=2036 . integer, public, dimension(3,13) :: ipt = 0 ipt(39) real(kind=wp), public, dimension(nmax) :: cval = 0.0_wp real(kind=wp), public, dimension(3) :: ss = 0.0_wp real(kind=wp), public :: au = 0.0_wp real(kind=wp), public :: emrat = 0.0_wp integer, public :: ncon = 0 integer, public :: numde = 0 real(kind=wp), public, dimension(6) :: pvsun = 0.0_wp dp 6-word array containing the barycentric position and\nvelocity of the sun. logical, public :: km = .true. logical flag defining physical units of the output states.\n  km = .true.  : km and km/sec\n  km = .false. : au and au/day\nfor nutations and librations.  angle unit is always radians. logical, public :: bary = .false. logical flag defining output center.\nonly the 9 planets are affected.\n  bary = .true.  : center is solar-system barycenter\n  bary = .false. : center is sun character(len=6), public, dimension(14,3) :: ttl = '' character(len=6), public, dimension(nmax) :: cnam = '' logical, public :: initialized = .false. is the ephemeris initialized? integer, public :: nrfile = 0 file unit for the ephemeris file integer, public :: nrl = -1 this was formerly in state integer, public :: ncoeffs = 0 real(kind=wp), public, dimension(1500) :: buf = 0.0_wp real(kind=wp), public, dimension(18) :: pc = 0.0_wp real(kind=wp), public, dimension(18) :: vc = 0.0_wp integer, public :: np = 2 integer, public :: nv = 3 real(kind=wp), public :: twot = 0.0_wp Type-Bound Procedures procedure, public :: get_rv => get_rv_from_jpl_ephemeris private  subroutine get_rv_from_jpl_ephemeris (me, et, targ, obs, rv, status_ok) Interface for the ephemeris_module . Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=fat_wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=fat_wp), intent(out), dimension(6) :: rv state of targ w.r.t. obs [km,km/s] in ICRF frame logical, intent(out) :: status_ok true if there were no problems procedure, public :: get_r => get_r_from_jpl_ephemeris private  subroutine get_r_from_jpl_ephemeris (me, et, targ, obs, r, status_ok) Interface for the ephemeris_module . Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=fat_wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=fat_wp), intent(out), dimension(3) :: r position of targ w.r.t. obs [km] in ICRF frame logical, intent(out) :: status_ok true if there were no problems procedure, public :: initialize => initialize_ephemeris private  subroutine initialize_ephemeris (me, filename, ksize, km, bary, status_ok) Initialize the ephemeris.\n  This routine may be called to load a different ephemeris file.\n  Otherwise, it is called on the first call to get_state, and loads\n  the file specified in the module header. Read more… Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me character(len=*), intent(in) :: filename ephemeris file name integer, intent(in), optional :: ksize corresponding ksize logical, intent(in), optional :: km defining physical units of the output states. km = .true. : km and km/sec [default], km = .false. : au and au/day. logical, intent(in), optional :: bary logical flag defining output center.\nonly the 9 planets are affected. bary = .true. : center is solar-system barycenter, bary = .false. : center is sun [default]. logical, intent(out) :: status_ok true if there were not problems. procedure, public :: get_state private  subroutine get_state (me, jd, ntarg, ncent, rrd, status_ok, pos_only) This subroutine reads the JPL planetary ephemeris\n  and gives the position and velocity of the point ntarg with respect to ncent . Read more… Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: jd d.p. Julian ephemeris date at which interpolation is wanted. integer, intent(in) :: ntarg integer number of 'target' point. integer, intent(in) :: ncent integer number of 'center' point. real(kind=wp), intent(out), dimension(6) :: rrd output 6-word d.p. array containing position and velocity\nof point ntarg relative to ncent .\nthe units are AU and AU/day (or km and km/sec if me%km=.true. ).\nFor librations the units are radians and radians\nper day. In the case of nutations the first four words of rrd will be set to nutations and rates, having units of\nradians and radians/day. logical, intent(out) :: status_ok true if there were no problems logical, intent(in), optional :: pos_only if .true. only the position components are returned, not the velocity. [doesn't work yet] procedure, public :: get_constants private  subroutine get_constants (me, nam, val, sss, n) Obtain the constants from the ephemeris file. Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me character(len=6), intent(out), dimension(:) :: nam array of constant names real(kind=wp), intent(out), dimension(:) :: val array of values of constants real(kind=wp), intent(out), dimension(3) :: sss jd start, jd stop, step of ephemeris integer, intent(out) :: n number of entries in nam and val arrays procedure, public :: close => close_ephemeris private  subroutine close_ephemeris (me) Close the ephemeris. Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me procedure, public :: interp private  subroutine interp (me, buf, t, ncf, ncm, na, ifl, pv) this subroutine differentiates and interpolates a\nset of chebyshev coefficients to give position and velocity. Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=wp), dimension(ncf,ncm,*) :: buf 1st location of array of d.p. chebyshev coefficients of position real(kind=wp), intent(in), dimension(2) :: t integer, intent(in) :: ncf Read more… integer, intent(in) :: ncm Read more… integer, intent(in) :: na (i.e., # of sub-intervals in full interval) Read more… integer, intent(in) :: ifl integer flag\n= 1 for positions only\n= 2 for pos and vel real(kind=wp), dimension(ncm,*) :: pv interpolated quantities requested.  dimension\nexpected is pv(ncm,ifl), dp. procedure, public :: state private  subroutine state (me, et2, list, pv, pnut, status_ok) This subroutine reads and interpolates the JPL planetary ephemeris file. Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=wp), intent(in), dimension(2) :: et2 2-word Julian ephemeris epoch at which interpolation\nis wanted.  any combination of et2(1)+et2(2) which falls\nwithin the time span on the file is a permissible epoch. Read more… integer, intent(in), dimension(12) :: list 12-word integer array specifying what interpolation\nis wanted for each of the bodies on the file. list(i) = 0 : no interpolation for body i, list(i) = 1 : position only, list(i) = 2 : position and velocity. Read more… real(kind=wp), intent(out), dimension(6,11) :: pv dp 6 x 11 array that will contain requested interpolated\nquantities (other than nutation, stored in pnut ).\nthe body specified by list(i) will have its\nstate in the array starting at pv(1,i) .\n(on any given call, only those words in pv which are\naffected by the first 10 list entries, and by list(12) if librations are on the file, are set.\nthe rest of the pv array is untouched.)\nthe order of components starting in pv(1,i) is: x , y , z , dx , dy , dz . Read more… real(kind=wp), intent(out), dimension(4) :: pnut dp 4-word array that will contain nutations and rates,\ndepending on the setting of list(11) .  the order of\nquantities in pnut is: Read more… logical, intent(out) :: status_ok true if there were no problems Source Code type , extends ( ephemeris_class ), public :: jpl_ephemeris !! Main class for accessing a JPL ephemeris file. character ( len = :), allocatable :: namfil !! name of the binary ephemeris file integer :: ksize = 2036 !! ksize must be set by the user according to the ephemeris to be read: !!   for ***de200***, set `ksize=1652`, !!   for ***de405***, set `ksize=2036`, !!   for ***de406***, set `ksize=1456`, !!   for ***de414***, set `ksize=2036`, !!   for ***de418***, set `ksize=2036`, !!   for ***de421***, set `ksize=2036`, !!   for ***de422***, set `ksize=2036`, !!   for ***de423***, set `ksize=2036`, !!   for ***de424***, set `ksize=2036`, !!   for ***de430***, set `ksize=2036`. !ephhdr integer , dimension ( 3 , 13 ) :: ipt = 0 !! ipt(39) real ( wp ), dimension ( nmax ) :: cval = 0.0_wp real ( wp ), dimension ( 3 ) :: ss = 0.0_wp real ( wp ) :: au = 0.0_wp real ( wp ) :: emrat = 0.0_wp integer :: ncon = 0 integer :: numde = 0 !stcomx real ( wp ), dimension ( 6 ) :: pvsun = 0.0_wp !! dp 6-word array containing the barycentric position and !! velocity of the sun. logical :: km = . true . !! logical flag defining physical units of the output states. !!   km = .true.  : km and km/sec !!   km = .false. : au and au/day !! for nutations and librations.  angle unit is always radians. logical :: bary = . false . !! logical flag defining output center. !! only the 9 planets are affected. !!   bary = .true.  : center is solar-system barycenter !!   bary = .false. : center is sun !chrhdr character ( len = 6 ), dimension ( 14 , 3 ) :: ttl = '' character ( len = 6 ), dimension ( nmax ) :: cnam = '' logical :: initialized = . false . !! is the ephemeris initialized? integer :: nrfile = 0 !! file unit for the ephemeris file integer :: nrl = - 1 !! this was formerly in state integer :: ncoeffs = 0 ! formerly in state: real ( wp ), dimension ( 1500 ) :: buf = 0.0_wp ! formerly in interp: real ( wp ), dimension ( 18 ) :: pc = 0.0_wp real ( wp ), dimension ( 18 ) :: vc = 0.0_wp integer :: np = 2 integer :: nv = 3 real ( wp ) :: twot = 0.0_wp contains procedure , public :: get_rv => get_rv_from_jpl_ephemeris procedure , public :: get_r => get_r_from_jpl_ephemeris procedure , public :: initialize => initialize_ephemeris procedure , public :: get_state procedure , public :: get_constants procedure , public :: close => close_ephemeris procedure :: interp procedure :: state end type jpl_ephemeris","tags":"","url":"type/jpl_ephemeris.html"},{"title":"brent_class – fortran-astrodynamics-toolkit ","text":"type, public :: brent_class the main class Components Type Visibility Attributes Name Initial procedure( func ), public, pointer :: f => null() function to be minimized Type-Bound Procedures procedure, public :: set_function private  subroutine set_function (me, f) Author Jacob Williams Date 7/19/2014 Set the function to be minimized. Arguments Type Intent Optional Attributes Name class( brent_class ), intent(inout) :: me procedure( func ) :: f procedure, public :: minimize => fmin private  function fmin (me, ax, bx, tol) result(xmin) An approximation x to the point where f attains a minimum on\n  the interval (ax,bx) is determined. Read more… Arguments Type Intent Optional Attributes Name class( brent_class ), intent(inout) :: me real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp), intent(in) :: tol desired length of the interval of\nuncertainty of the final result (>=0) Return Value real(kind=wp) abcissa approximating the point where\nf attains a minimum procedure, public :: find_zero => zeroin private  subroutine zeroin (me, ax, bx, tol, xzero, fzero, iflag, fax, fbx) Find a zero of the function in the given interval to within a tolerance ,\n  where is the relative machine precision defined as\n  the smallest representable number such that . Read more… Arguments Type Intent Optional Attributes Name class( brent_class ), intent(inout) :: me real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp), intent(in) :: tol desired length of the interval of uncertainty of the final result (>=0) real(kind=wp), intent(out) :: xzero abscissa approximating a zero of f in the interval ax , bx real(kind=wp), intent(out) :: fzero value of f at the root ( f(xzero) ) integer, intent(out) :: iflag status flag ( -1 =error, 0 =root found) real(kind=wp), intent(in), optional :: fax if f(ax) is already known, it can be input here real(kind=wp), intent(in), optional :: fbx if f(ax) is already known, it can be input here Source Code type , public :: brent_class !! the main class procedure ( func ), pointer :: f => null () !! function to be minimized contains procedure :: set_function procedure :: minimize => fmin procedure :: find_zero => zeroin end type brent_class","tags":"","url":"type/brent_class.html"},{"title":"celestial_body – fortran-astrodynamics-toolkit ","text":"type, public, extends( base_class ) :: celestial_body A celestial body (Planet, moon, etc.)\nThe ID from the base_class is the NAIF SPICE ID code for the body Inherits type~~celestial_body~~InheritsGraph type~celestial_body celestial_body type~base_class base_class type~celestial_body->type~base_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~celestial_body~~InheritedByGraph type~celestial_body celestial_body type~reference_frame reference_frame type~reference_frame->type~celestial_body primary_body type~two_body_rotating_frame two_body_rotating_frame type~two_body_rotating_frame->type~celestial_body secondary_body type~rotating_frame_class rotating_frame_class type~two_body_rotating_frame->type~rotating_frame_class type~inertial_frame_class inertial_frame_class type~inertial_frame_class->type~reference_frame type~rotating_frame_class->type~reference_frame type~two_body_rotating_pulsating_frame two_body_rotating_pulsating_frame type~two_body_rotating_pulsating_frame->type~two_body_rotating_frame type~ecliptic_frame ecliptic_frame type~ecliptic_frame->type~inertial_frame_class type~iau_rotating_frame_class iau_rotating_frame_class type~iau_rotating_frame_class->type~rotating_frame_class type~icrf_frame icrf_frame type~icrf_frame->type~inertial_frame_class type~iau_earth_rotating_frame iau_earth_rotating_frame type~iau_earth_rotating_frame->type~iau_rotating_frame_class type~iau_moon_rotating_frame iau_moon_rotating_frame type~iau_moon_rotating_frame->type~iau_rotating_frame_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: id = 0 a unique ID code that distinguishes a\nvariable from other variables of the same type. character(len=name_len), public :: name = '' the variable name real(kind=wp), public :: mu = zero gravitational parameter [ ] Type-Bound Procedures generic, public :: operator(==) => base_class_equal public pure elemental function base_class_equal (b1, b2) result(is_equal) == operator for base_class variables.\nTo be equal, they must be the same type and have the same ID . Arguments Type Intent Optional Attributes Name class( base_class ), intent(in) :: b1 class( base_class ), intent(in) :: b2 Return Value logical generic, public :: operator(/=) => base_class_not_equal public pure elemental function base_class_not_equal (b1, b2) result(not_equal) /= operator for base_class variables.\nTo be equal, they must be the same type and have the same ID . Arguments Type Intent Optional Attributes Name class( base_class ), intent(in) :: b1 class( base_class ), intent(in) :: b2 Return Value logical Source Code type , extends ( base_class ), public :: celestial_body !! A celestial body (Planet, moon, etc.) !! The `ID` from the [[base_class]] is the NAIF SPICE ID code for the body real ( wp ) :: mu = zero !! gravitational parameter  \\mu  [km&#94;3/s&#94;2] !note: also should add radius, etc. end type celestial_body","tags":"","url":"type/celestial_body.html"},{"title":"base_class – fortran-astrodynamics-toolkit ","text":"type, public, abstract :: base_class A base class for defining other classes. Inherited by type~~base_class~~InheritedByGraph type~base_class base_class type~celestial_body celestial_body type~celestial_body->type~base_class type~ephem ephem type~ephem->type~base_class type~reference_frame reference_frame type~reference_frame->type~celestial_body primary_body type~two_body_rotating_frame two_body_rotating_frame type~two_body_rotating_frame->type~celestial_body secondary_body type~rotating_frame_class rotating_frame_class type~two_body_rotating_frame->type~rotating_frame_class type~inertial_frame_class inertial_frame_class type~inertial_frame_class->type~reference_frame type~rotating_frame_class->type~reference_frame type~two_body_rotating_pulsating_frame two_body_rotating_pulsating_frame type~two_body_rotating_pulsating_frame->type~two_body_rotating_frame type~ecliptic_frame ecliptic_frame type~ecliptic_frame->type~inertial_frame_class type~iau_rotating_frame_class iau_rotating_frame_class type~iau_rotating_frame_class->type~rotating_frame_class type~icrf_frame icrf_frame type~icrf_frame->type~inertial_frame_class type~iau_earth_rotating_frame iau_earth_rotating_frame type~iau_earth_rotating_frame->type~iau_rotating_frame_class type~iau_moon_rotating_frame iau_moon_rotating_frame type~iau_moon_rotating_frame->type~iau_rotating_frame_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, public :: id = 0 a unique ID code that distinguishes a\nvariable from other variables of the same type. character(len=name_len), public :: name = '' the variable name Type-Bound Procedures generic, public :: operator(==) => base_class_equal public pure elemental function base_class_equal (b1, b2) result(is_equal) == operator for base_class variables.\nTo be equal, they must be the same type and have the same ID . Arguments Type Intent Optional Attributes Name class( base_class ), intent(in) :: b1 class( base_class ), intent(in) :: b2 Return Value logical generic, public :: operator(/=) => base_class_not_equal public pure elemental function base_class_not_equal (b1, b2) result(not_equal) /= operator for base_class variables.\nTo be equal, they must be the same type and have the same ID . Arguments Type Intent Optional Attributes Name class( base_class ), intent(in) :: b1 class( base_class ), intent(in) :: b2 Return Value logical procedure, private :: base_class_equal public pure elemental function base_class_equal (b1, b2) result(is_equal) == operator for base_class variables.\nTo be equal, they must be the same type and have the same ID . Arguments Type Intent Optional Attributes Name class( base_class ), intent(in) :: b1 class( base_class ), intent(in) :: b2 Return Value logical procedure, private :: base_class_not_equal public pure elemental function base_class_not_equal (b1, b2) result(not_equal) /= operator for base_class variables.\nTo be equal, they must be the same type and have the same ID . Arguments Type Intent Optional Attributes Name class( base_class ), intent(in) :: b1 class( base_class ), intent(in) :: b2 Return Value logical Source Code type , abstract , public :: base_class !! A base class for defining other classes. integer :: id = 0 !! a unique ID code that distinguishes a !! variable from other variables of the same type. character ( len = name_len ) :: name = '' !! the variable name contains generic , public :: operator ( == ) => base_class_equal generic , public :: operator ( /= ) => base_class_not_equal procedure , private :: base_class_equal procedure , private :: base_class_not_equal end type base_class","tags":"","url":"type/base_class.html"},{"title":"stepsize_class – fortran-astrodynamics-toolkit ","text":"type, public :: stepsize_class Algorithms for adjusting the step size for variable-step\nRunge-Kutta integrators. Inherited by type~~stepsize_class~~InheritedByGraph type~stepsize_class stepsize_class type~rk_variable_step_class rk_variable_step_class type~rk_variable_step_class->type~stepsize_class stepsize_method type~rkf108_class rkf108_class type~rkf108_class->type~rk_variable_step_class type~rkf1210_class rkf1210_class type~rkf1210_class->type~rk_variable_step_class type~rkf1412_class rkf1412_class type~rkf1412_class->type~rk_variable_step_class type~rkf78_class rkf78_class type~rkf78_class->type~rk_variable_step_class type~rkf89_class rkf89_class type~rkf89_class->type~rk_variable_step_class type~rkv89_class rkv89_class type~rkv89_class->type~rk_variable_step_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial real(kind=wp), private :: hmax = huge(one) maximum allowed step size real(kind=wp), private :: hmin = two*epsilon(one) minimum allowed step size real(kind=wp), private :: hfactor_reject = 1.0e-3_wp minimum allowed factor for decreasing step size after rejected step real(kind=wp), private :: hfactor_accept = 100.0_wp maximum allowed factor for increasing step size after accepted step integer, private :: accept_mode = 1 method to determine if step is accepted [1,2] integer, private :: max_attempts = 100 maximum number of attempts to decrease step size before giving up logical, private :: relative_err = .false. to use tol*h in the hfactor equation real(kind=wp), private :: safety_factor = 0.9_wp for hfactor equation (>0) integer, private :: p_exponent_offset = 0 p + this value in the exponent (0 or 1) procedure( norm_func ), private, nopass, pointer :: norm => maxval_func routine for computing the norm of the state Type-Bound Procedures procedure, public :: initialize => stepsize_class_constructor private pure subroutine stepsize_class_constructor (me, hmin, hmax, hfactor_reject, hfactor_accept, norm, accept_mode, relative_err, safety_factor, p_exponent_offset, max_attempts) Constructor for a stepsize_class . Read more… Arguments Type Intent Optional Attributes Name class( stepsize_class ), intent(inout) :: me real(kind=wp), intent(in), optional :: hmin minimum allowed step size (>0) real(kind=wp), intent(in), optional :: hmax maximum allowed step size (>0) real(kind=wp), intent(in), optional :: hfactor_reject minimum allowed factor for\ndecreasing step size after\nrejected step (>0) real(kind=wp), intent(in), optional :: hfactor_accept maximum allowed factor for\ndecreasing step size after\naccepted step (>0) procedure( norm_func ), optional :: norm the user-specified function integer, intent(in), optional :: accept_mode method to determine if step\nis accepted [1,2] logical, intent(in), optional :: relative_err to use tol*h in the hfactor equation real(kind=wp), intent(in), optional :: safety_factor for hfactor equation (>0) integer, intent(in), optional :: p_exponent_offset p + this value in the exponent (0 or 1) integer, intent(in), optional :: max_attempts max step size change attempts\nafter rejected step procedure, public :: compute_stepsize private pure subroutine compute_stepsize (me, h, tol, err, p, hnew, accept) Compute the new step size using the specific method. Arguments Type Intent Optional Attributes Name class( stepsize_class ), intent(in) :: me real(kind=wp), intent(in) :: h current step size (<>0) real(kind=wp), intent(in) :: tol abs error tolerance (>0) real(kind=wp), intent(in) :: err truncation error estimate (>0) integer, intent(in) :: p order of the method real(kind=wp), intent(out) :: hnew new step size (<>0) logical, intent(out) :: accept if the step is accepted procedure, public :: destroy => destroy_stepsize_class private  subroutine destroy_stepsize_class (me) Destructor for stepsize_class . Arguments Type Intent Optional Attributes Name class( stepsize_class ), intent(out) :: me Source Code type , public :: stepsize_class !! Algorithms for adjusting the step size for variable-step !! Runge-Kutta integrators. private real ( wp ) :: hmax = huge ( one ) !! maximum allowed step size real ( wp ) :: hmin = two * epsilon ( one ) !! minimum allowed step size real ( wp ) :: hfactor_reject = 1.0e-3_wp !! minimum allowed factor for decreasing step size after rejected step real ( wp ) :: hfactor_accept = 10 0.0_wp !! maximum allowed factor for increasing step size after accepted step integer :: accept_mode = 1 !! method to determine if step is accepted [1,2] integer :: max_attempts = 100 !! maximum number of attempts to decrease step size before giving up ! the `hfactor` equation is: ! ! if (relative_err) then !     hfactor = safety_factor * abs(tol*h/err)**(one/real(p+p_exponent_offset,wp)) ! else !     hfactor = safety_factor * abs(tol/err)**(one/real(p+p_exponent_offset,wp)) ! end if logical :: relative_err = . false . !! to use `tol*h` in the `hfactor` equation real ( wp ) :: safety_factor = 0.9_wp !! for `hfactor` equation (>0) integer :: p_exponent_offset = 0 !! p + this value in the exponent (0 or 1) procedure ( norm_func ), nopass , pointer :: norm => maxval_func !! routine for computing the norm of the state contains private procedure , public :: initialize => stepsize_class_constructor procedure , public :: compute_stepsize procedure , public :: destroy => destroy_stepsize_class end type stepsize_class","tags":"","url":"type/stepsize_class.html"},{"title":"rk_variable_step_class – fortran-astrodynamics-toolkit ","text":"type, public, abstract :: rk_variable_step_class Main integration class for variable step size Runge-Kutta methods Inherits type~~rk_variable_step_class~~InheritsGraph type~rk_variable_step_class rk_variable_step_class type~stepsize_class stepsize_class type~rk_variable_step_class->type~stepsize_class stepsize_method Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Inherited by type~~rk_variable_step_class~~InheritedByGraph type~rk_variable_step_class rk_variable_step_class type~rkf108_class rkf108_class type~rkf108_class->type~rk_variable_step_class type~rkf1210_class rkf1210_class type~rkf1210_class->type~rk_variable_step_class type~rkf1412_class rkf1412_class type~rkf1412_class->type~rk_variable_step_class type~rkf78_class rkf78_class type~rkf78_class->type~rk_variable_step_class type~rkf89_class rkf89_class type~rkf89_class->type~rk_variable_step_class type~rkv89_class rkv89_class type~rkv89_class->type~rk_variable_step_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Components Type Visibility Attributes Name Initial integer, private :: n = 0 user specified number of variables procedure( deriv_func ), private, pointer :: f => null() user-specified derivative function procedure( report_func ), private, pointer :: report => null() user-specified report function procedure( event_func ), private, pointer :: g => null() event function (stop when this is zero) class( stepsize_class ), private, allocatable :: stepsize_method the method for varying the step size real(kind=wp), private, dimension(:), allocatable :: rtol relative tolerance ( size(n) ) real(kind=wp), private, dimension(:), allocatable :: atol absolute tolerance ( size(n) ) integer, private :: p = 0 order of the method integer, private :: hinit_method = 1 if automatically computing the inital step size, which\nmethod to use. 1 = hstart , 2 = hinit . integer, private :: num_rejected_steps = 0 number of rejected steps Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) private  subroutine initialize (me, n, f, rtol, atol, stepsize_method, hinit_method, report, g) Initialize the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me integer, intent(in) :: n number of equations procedure( deriv_func ) :: f derivative function real(kind=wp), intent(in), dimension(:) :: rtol relative tolerance (if size=1,\nthen same tol used for all\nequations) real(kind=wp), intent(in), dimension(:) :: atol absolute tolerance (if size=1,\nthen same tol used for all\nequations) class( stepsize_class ), intent(in) :: stepsize_method method for varying the step size integer, intent(in), optional :: hinit_method which method to use for\nautomatic initial step size\ncomputation.\n1 = use hstart , 2 = use hinit . procedure( report_func ), optional :: report for reporting the steps procedure( event_func ), optional :: g for stopping at an event procedure, public :: destroy destructor private  subroutine destroy (me) Destructor for rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(out) :: me procedure, public, non_overridable :: integrate main integration routine private  subroutine integrate (me, t0, x0, h, tf, xf, ierr) Main integration routine for the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(:) :: x0 initial state real(kind=wp), intent(in) :: h initial abs(time step) real(kind=wp), intent(in) :: tf final time real(kind=wp), intent(out), dimension(:) :: xf final state integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. procedure, public, non_overridable :: integrate_to_event integration with event finding private  subroutine integrate_to_event (me, t0, x0, h, tmax, tol, tf, xf, gf, ierr) Event-finding integration routine for the rk_variable_step_class .\nIntegrates until g(t,x)=0, or until t=tf (whichever happens first). Read more… Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tmax max final time if event not located real(kind=wp), intent(in) :: tol function tolerance for root finding real(kind=wp), intent(out) :: tf actual final time reached real(kind=wp), intent(out), dimension(me%n) :: xf final state (at tf) real(kind=wp), intent(out) :: gf g value at tf integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. procedure( step_func ), private, deferred :: step the step routine for the rk method subroutine step_func(me, t, x, h, xf, terr) Prototype rk step function Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state vector real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf final state vector real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate procedure( order_func ), private, deferred :: order returns p , the order of the method pure function order_func(me) result(p) Prototype Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(in) :: me Return Value integer order of the method procedure, private :: hstart for automatically computing the initial step size [this is from DDEABM] private  subroutine hstart (me, a, b, y, yprime, etol, h) Computes a starting step size to be used in solving initial\n  value problems in ordinary differential equations. Read more… Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: a the initial point of integration. real(kind=wp), intent(in) :: b a value of the independent variable used to define\nthe direction of integration. a reasonable choice is to\nset b to the first point at which a solution is desired.\nyou can also use b , if necessary, to restrict the length\nof the first integration step because the algorithm will\nnot compute a starting step length which is bigger than abs(b-a) , unless b has been chosen too close to a .\n(it is presumed that hstart has been called with b different from a on the machine being used. also see the\ndiscussion about the parameter small .) real(kind=wp), intent(in), dimension(me%n) :: y the vector of initial values of the neq solution\ncomponents at the initial point a . real(kind=wp), intent(in), dimension(me%n) :: yprime the vector of derivatives of the neq solution components at the initial point a .\n(defined by the differential equations in subroutine me%f ) real(kind=wp), intent(in), dimension(me%n) :: etol the vector of error tolerances corresponding to\nthe neq solution components. it is assumed that all\nelements are positive. following the first integration\nstep, the tolerances are expected to be used by the\nintegrator in an error test which roughly requires that abs(local error) <= etol for each vector component. real(kind=wp), intent(out) :: h appropriate starting step size to be attempted by the\ndifferential equation method. procedure, private :: hinit for automatically computing the initial step size [this is from DOP853] private  function hinit (me, x, y, posneg, f0, hmax, atol, rtol) computation of an initial step size guess Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in), dimension(:) :: y dimension(n) real(kind=wp), intent(in) :: posneg posneg = sign(1.0_wp,xend-x) real(kind=wp), intent(in), dimension(:) :: f0 dimension(n) real(kind=wp), intent(in) :: hmax real(kind=wp), intent(in), dimension(:) :: atol real(kind=wp), intent(in), dimension(:) :: rtol Return Value real(kind=wp) Source Code type , abstract , public :: rk_variable_step_class !! Main integration class for variable step size Runge-Kutta methods private integer :: n = 0 !! user specified number of variables procedure ( deriv_func ), pointer :: f => null () !! user-specified derivative function procedure ( report_func ), pointer :: report => null () !! user-specified report function procedure ( event_func ), pointer :: g => null () !! event function (stop when this is zero) class ( stepsize_class ), allocatable :: stepsize_method !! the method for varying the step size real ( wp ), dimension (:), allocatable :: rtol !! relative tolerance (`size(n)`) real ( wp ), dimension (:), allocatable :: atol !! absolute tolerance (`size(n)`) integer :: p = 0 !! order of the method integer :: hinit_method = 1 !! if automatically computing the inital step size, which !! method to use. 1 = `hstart`, 2 = `hinit`. integer :: num_rejected_steps = 0 !! number of rejected steps contains private procedure , public :: initialize !! initialize the class (set n,f, and report) procedure , public :: destroy !! destructor procedure , non_overridable , public :: integrate !! main integration routine procedure , non_overridable , public :: integrate_to_event !! integration with event finding procedure ( step_func ), deferred :: step !! the step routine for the rk method procedure ( order_func ), deferred :: order !! returns `p`, the order of the method procedure :: hstart !! for automatically computing the initial step size [this is from DDEABM] procedure :: hinit !! for automatically computing the initial step size [this is from DOP853] end type rk_variable_step_class","tags":"","url":"type/rk_variable_step_class.html"},{"title":"rkf78_class – fortran-astrodynamics-toolkit ","text":"type, public, extends( rk_variable_step_class ) :: rkf78_class Runga-Kutta Fehlberg 7(8) method. Inherits type~~rkf78_class~~InheritsGraph type~rkf78_class rkf78_class type~rk_variable_step_class rk_variable_step_class type~rkf78_class->type~rk_variable_step_class type~stepsize_class stepsize_class type~rk_variable_step_class->type~stepsize_class stepsize_method Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) private  subroutine initialize (me, n, f, rtol, atol, stepsize_method, hinit_method, report, g) Initialize the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me integer, intent(in) :: n number of equations procedure( deriv_func ) :: f derivative function real(kind=wp), intent(in), dimension(:) :: rtol relative tolerance (if size=1,\nthen same tol used for all\nequations) real(kind=wp), intent(in), dimension(:) :: atol absolute tolerance (if size=1,\nthen same tol used for all\nequations) class( stepsize_class ), intent(in) :: stepsize_method method for varying the step size integer, intent(in), optional :: hinit_method which method to use for\nautomatic initial step size\ncomputation.\n1 = use hstart , 2 = use hinit . procedure( report_func ), optional :: report for reporting the steps procedure( event_func ), optional :: g for stopping at an event procedure, public :: destroy destructor private  subroutine destroy (me) Destructor for rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(out) :: me procedure, public, non_overridable :: integrate main integration routine private  subroutine integrate (me, t0, x0, h, tf, xf, ierr) Main integration routine for the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(:) :: x0 initial state real(kind=wp), intent(in) :: h initial abs(time step) real(kind=wp), intent(in) :: tf final time real(kind=wp), intent(out), dimension(:) :: xf final state integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. procedure, public, non_overridable :: integrate_to_event integration with event finding private  subroutine integrate_to_event (me, t0, x0, h, tmax, tol, tf, xf, gf, ierr) Event-finding integration routine for the rk_variable_step_class .\nIntegrates until g(t,x)=0, or until t=tf (whichever happens first). Read more… Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tmax max final time if event not located real(kind=wp), intent(in) :: tol function tolerance for root finding real(kind=wp), intent(out) :: tf actual final time reached real(kind=wp), intent(out), dimension(me%n) :: xf final state (at tf) real(kind=wp), intent(out) :: gf g value at tf integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. procedure, public :: step => rkf78 private  subroutine rkf78 (me, t, x, h, xf, terr) Fehlberg's 7(8) algorithm. Read more… Arguments Type Intent Optional Attributes Name class( rkf78_class ), intent(inout) :: me real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(me%n) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out), dimension(me%n) :: xf real(kind=wp), intent(out), dimension(me%n) :: terr procedure, public :: order => rkf78_order private pure function rkf78_order (me) result(p) Returns the order of the rkf78 method. Arguments Type Intent Optional Attributes Name class( rkf78_class ), intent(in) :: me Return Value integer order of the method Source Code type , extends ( rk_variable_step_class ), public :: rkf78_class !! Runga-Kutta Fehlberg 7(8) method. contains procedure :: step => rkf78 procedure :: order => rkf78_order end type rkf78_class","tags":"","url":"type/rkf78_class.html"},{"title":"rkf89_class – fortran-astrodynamics-toolkit ","text":"type, public, extends( rk_variable_step_class ) :: rkf89_class Runga-Kutta Fehlberg 8(9) method. Inherits type~~rkf89_class~~InheritsGraph type~rkf89_class rkf89_class type~rk_variable_step_class rk_variable_step_class type~rkf89_class->type~rk_variable_step_class type~stepsize_class stepsize_class type~rk_variable_step_class->type~stepsize_class stepsize_method Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) private  subroutine initialize (me, n, f, rtol, atol, stepsize_method, hinit_method, report, g) Initialize the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me integer, intent(in) :: n number of equations procedure( deriv_func ) :: f derivative function real(kind=wp), intent(in), dimension(:) :: rtol relative tolerance (if size=1,\nthen same tol used for all\nequations) real(kind=wp), intent(in), dimension(:) :: atol absolute tolerance (if size=1,\nthen same tol used for all\nequations) class( stepsize_class ), intent(in) :: stepsize_method method for varying the step size integer, intent(in), optional :: hinit_method which method to use for\nautomatic initial step size\ncomputation.\n1 = use hstart , 2 = use hinit . procedure( report_func ), optional :: report for reporting the steps procedure( event_func ), optional :: g for stopping at an event procedure, public :: destroy destructor private  subroutine destroy (me) Destructor for rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(out) :: me procedure, public, non_overridable :: integrate main integration routine private  subroutine integrate (me, t0, x0, h, tf, xf, ierr) Main integration routine for the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(:) :: x0 initial state real(kind=wp), intent(in) :: h initial abs(time step) real(kind=wp), intent(in) :: tf final time real(kind=wp), intent(out), dimension(:) :: xf final state integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. procedure, public, non_overridable :: integrate_to_event integration with event finding private  subroutine integrate_to_event (me, t0, x0, h, tmax, tol, tf, xf, gf, ierr) Event-finding integration routine for the rk_variable_step_class .\nIntegrates until g(t,x)=0, or until t=tf (whichever happens first). Read more… Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tmax max final time if event not located real(kind=wp), intent(in) :: tol function tolerance for root finding real(kind=wp), intent(out) :: tf actual final time reached real(kind=wp), intent(out), dimension(me%n) :: xf final state (at tf) real(kind=wp), intent(out) :: gf g value at tf integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. procedure, public :: step => rkf89 private  subroutine rkf89 (me, t, x, h, xf, terr) Fehlberg 8(9) method. Read more… Arguments Type Intent Optional Attributes Name class( rkf89_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate procedure, public :: order => rkf89_order private pure function rkf89_order (me) result(p) Returns the order of the rkf89 method. Arguments Type Intent Optional Attributes Name class( rkf89_class ), intent(in) :: me Return Value integer order of the method Source Code type , extends ( rk_variable_step_class ), public :: rkf89_class !! Runga-Kutta Fehlberg 8(9) method. contains procedure :: step => rkf89 procedure :: order => rkf89_order end type rkf89_class","tags":"","url":"type/rkf89_class.html"},{"title":"rkv89_class – fortran-astrodynamics-toolkit ","text":"type, public, extends( rk_variable_step_class ) :: rkv89_class Runga-Kutta Verner 8(9) method. Inherits type~~rkv89_class~~InheritsGraph type~rkv89_class rkv89_class type~rk_variable_step_class rk_variable_step_class type~rkv89_class->type~rk_variable_step_class type~stepsize_class stepsize_class type~rk_variable_step_class->type~stepsize_class stepsize_method Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) private  subroutine initialize (me, n, f, rtol, atol, stepsize_method, hinit_method, report, g) Initialize the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me integer, intent(in) :: n number of equations procedure( deriv_func ) :: f derivative function real(kind=wp), intent(in), dimension(:) :: rtol relative tolerance (if size=1,\nthen same tol used for all\nequations) real(kind=wp), intent(in), dimension(:) :: atol absolute tolerance (if size=1,\nthen same tol used for all\nequations) class( stepsize_class ), intent(in) :: stepsize_method method for varying the step size integer, intent(in), optional :: hinit_method which method to use for\nautomatic initial step size\ncomputation.\n1 = use hstart , 2 = use hinit . procedure( report_func ), optional :: report for reporting the steps procedure( event_func ), optional :: g for stopping at an event procedure, public :: destroy destructor private  subroutine destroy (me) Destructor for rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(out) :: me procedure, public, non_overridable :: integrate main integration routine private  subroutine integrate (me, t0, x0, h, tf, xf, ierr) Main integration routine for the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(:) :: x0 initial state real(kind=wp), intent(in) :: h initial abs(time step) real(kind=wp), intent(in) :: tf final time real(kind=wp), intent(out), dimension(:) :: xf final state integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. procedure, public, non_overridable :: integrate_to_event integration with event finding private  subroutine integrate_to_event (me, t0, x0, h, tmax, tol, tf, xf, gf, ierr) Event-finding integration routine for the rk_variable_step_class .\nIntegrates until g(t,x)=0, or until t=tf (whichever happens first). Read more… Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tmax max final time if event not located real(kind=wp), intent(in) :: tol function tolerance for root finding real(kind=wp), intent(out) :: tf actual final time reached real(kind=wp), intent(out), dimension(me%n) :: xf final state (at tf) real(kind=wp), intent(out) :: gf g value at tf integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. procedure, public :: step => rkv89 private  subroutine rkv89 (me, t, x, h, xf, terr) Runge Kutta Verner 8(9) Read more… Arguments Type Intent Optional Attributes Name class( rkv89_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate procedure, public :: order => rkv89_order private pure function rkv89_order (me) result(p) Returns the order of the rkv89 method. Arguments Type Intent Optional Attributes Name class( rkv89_class ), intent(in) :: me Return Value integer order of the method Source Code type , extends ( rk_variable_step_class ), public :: rkv89_class !! Runga-Kutta Verner 8(9) method. contains procedure :: step => rkv89 procedure :: order => rkv89_order end type rkv89_class","tags":"","url":"type/rkv89_class.html"},{"title":"rkf108_class – fortran-astrodynamics-toolkit ","text":"type, public, extends( rk_variable_step_class ) :: rkf108_class Runga-Kutta Feagin 8(10) method. Inherits type~~rkf108_class~~InheritsGraph type~rkf108_class rkf108_class type~rk_variable_step_class rk_variable_step_class type~rkf108_class->type~rk_variable_step_class type~stepsize_class stepsize_class type~rk_variable_step_class->type~stepsize_class stepsize_method Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) private  subroutine initialize (me, n, f, rtol, atol, stepsize_method, hinit_method, report, g) Initialize the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me integer, intent(in) :: n number of equations procedure( deriv_func ) :: f derivative function real(kind=wp), intent(in), dimension(:) :: rtol relative tolerance (if size=1,\nthen same tol used for all\nequations) real(kind=wp), intent(in), dimension(:) :: atol absolute tolerance (if size=1,\nthen same tol used for all\nequations) class( stepsize_class ), intent(in) :: stepsize_method method for varying the step size integer, intent(in), optional :: hinit_method which method to use for\nautomatic initial step size\ncomputation.\n1 = use hstart , 2 = use hinit . procedure( report_func ), optional :: report for reporting the steps procedure( event_func ), optional :: g for stopping at an event procedure, public :: destroy destructor private  subroutine destroy (me) Destructor for rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(out) :: me procedure, public, non_overridable :: integrate main integration routine private  subroutine integrate (me, t0, x0, h, tf, xf, ierr) Main integration routine for the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(:) :: x0 initial state real(kind=wp), intent(in) :: h initial abs(time step) real(kind=wp), intent(in) :: tf final time real(kind=wp), intent(out), dimension(:) :: xf final state integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. procedure, public, non_overridable :: integrate_to_event integration with event finding private  subroutine integrate_to_event (me, t0, x0, h, tmax, tol, tf, xf, gf, ierr) Event-finding integration routine for the rk_variable_step_class .\nIntegrates until g(t,x)=0, or until t=tf (whichever happens first). Read more… Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tmax max final time if event not located real(kind=wp), intent(in) :: tol function tolerance for root finding real(kind=wp), intent(out) :: tf actual final time reached real(kind=wp), intent(out), dimension(me%n) :: xf final state (at tf) real(kind=wp), intent(out) :: gf g value at tf integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. procedure, public :: step => rkf108 private  subroutine rkf108 (me, t, x, h, xf, terr) Feagin's RK8(10) method -- a 10th-order method with an embedded 8th-order method. Read more… Arguments Type Intent Optional Attributes Name class( rkf108_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate procedure, public :: order => rkf108_order private pure function rkf108_order (me) result(p) Returns the order of the rkf108 method. Arguments Type Intent Optional Attributes Name class( rkf108_class ), intent(in) :: me Return Value integer order of the method Source Code type , extends ( rk_variable_step_class ), public :: rkf108_class !! Runga-Kutta Feagin 8(10) method. contains procedure :: step => rkf108 procedure :: order => rkf108_order end type rkf108_class","tags":"","url":"type/rkf108_class.html"},{"title":"rkf1210_class – fortran-astrodynamics-toolkit ","text":"type, public, extends( rk_variable_step_class ) :: rkf1210_class Runga-Kutta Feagin 12(10) method. Inherits type~~rkf1210_class~~InheritsGraph type~rkf1210_class rkf1210_class type~rk_variable_step_class rk_variable_step_class type~rkf1210_class->type~rk_variable_step_class type~stepsize_class stepsize_class type~rk_variable_step_class->type~stepsize_class stepsize_method Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) private  subroutine initialize (me, n, f, rtol, atol, stepsize_method, hinit_method, report, g) Initialize the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me integer, intent(in) :: n number of equations procedure( deriv_func ) :: f derivative function real(kind=wp), intent(in), dimension(:) :: rtol relative tolerance (if size=1,\nthen same tol used for all\nequations) real(kind=wp), intent(in), dimension(:) :: atol absolute tolerance (if size=1,\nthen same tol used for all\nequations) class( stepsize_class ), intent(in) :: stepsize_method method for varying the step size integer, intent(in), optional :: hinit_method which method to use for\nautomatic initial step size\ncomputation.\n1 = use hstart , 2 = use hinit . procedure( report_func ), optional :: report for reporting the steps procedure( event_func ), optional :: g for stopping at an event procedure, public :: destroy destructor private  subroutine destroy (me) Destructor for rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(out) :: me procedure, public, non_overridable :: integrate main integration routine private  subroutine integrate (me, t0, x0, h, tf, xf, ierr) Main integration routine for the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(:) :: x0 initial state real(kind=wp), intent(in) :: h initial abs(time step) real(kind=wp), intent(in) :: tf final time real(kind=wp), intent(out), dimension(:) :: xf final state integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. procedure, public, non_overridable :: integrate_to_event integration with event finding private  subroutine integrate_to_event (me, t0, x0, h, tmax, tol, tf, xf, gf, ierr) Event-finding integration routine for the rk_variable_step_class .\nIntegrates until g(t,x)=0, or until t=tf (whichever happens first). Read more… Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tmax max final time if event not located real(kind=wp), intent(in) :: tol function tolerance for root finding real(kind=wp), intent(out) :: tf actual final time reached real(kind=wp), intent(out), dimension(me%n) :: xf final state (at tf) real(kind=wp), intent(out) :: gf g value at tf integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. procedure, public :: step => rkf1210 private  subroutine rkf1210 (me, t, x, h, xf, terr) Feagin's RK12(10) method -- a 12th-order method with an embedded 10th-order method. Read more… Arguments Type Intent Optional Attributes Name class( rkf1210_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate procedure, public :: order => rkf1210_order private pure function rkf1210_order (me) result(p) Returns the order of the rkf1210 method. Arguments Type Intent Optional Attributes Name class( rkf1210_class ), intent(in) :: me Return Value integer order of the method Source Code type , extends ( rk_variable_step_class ), public :: rkf1210_class !! Runga-Kutta Feagin 12(10) method. contains procedure :: step => rkf1210 procedure :: order => rkf1210_order end type rkf1210_class","tags":"","url":"type/rkf1210_class.html"},{"title":"rkf1412_class – fortran-astrodynamics-toolkit ","text":"type, public, extends( rk_variable_step_class ) :: rkf1412_class Runga-Kutta Feagin 14(12) method. Inherits type~~rkf1412_class~~InheritsGraph type~rkf1412_class rkf1412_class type~rk_variable_step_class rk_variable_step_class type~rkf1412_class->type~rk_variable_step_class type~stepsize_class stepsize_class type~rk_variable_step_class->type~stepsize_class stepsize_method Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) private  subroutine initialize (me, n, f, rtol, atol, stepsize_method, hinit_method, report, g) Initialize the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me integer, intent(in) :: n number of equations procedure( deriv_func ) :: f derivative function real(kind=wp), intent(in), dimension(:) :: rtol relative tolerance (if size=1,\nthen same tol used for all\nequations) real(kind=wp), intent(in), dimension(:) :: atol absolute tolerance (if size=1,\nthen same tol used for all\nequations) class( stepsize_class ), intent(in) :: stepsize_method method for varying the step size integer, intent(in), optional :: hinit_method which method to use for\nautomatic initial step size\ncomputation.\n1 = use hstart , 2 = use hinit . procedure( report_func ), optional :: report for reporting the steps procedure( event_func ), optional :: g for stopping at an event procedure, public :: destroy destructor private  subroutine destroy (me) Destructor for rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(out) :: me procedure, public, non_overridable :: integrate main integration routine private  subroutine integrate (me, t0, x0, h, tf, xf, ierr) Main integration routine for the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(:) :: x0 initial state real(kind=wp), intent(in) :: h initial abs(time step) real(kind=wp), intent(in) :: tf final time real(kind=wp), intent(out), dimension(:) :: xf final state integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. procedure, public, non_overridable :: integrate_to_event integration with event finding private  subroutine integrate_to_event (me, t0, x0, h, tmax, tol, tf, xf, gf, ierr) Event-finding integration routine for the rk_variable_step_class .\nIntegrates until g(t,x)=0, or until t=tf (whichever happens first). Read more… Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tmax max final time if event not located real(kind=wp), intent(in) :: tol function tolerance for root finding real(kind=wp), intent(out) :: tf actual final time reached real(kind=wp), intent(out), dimension(me%n) :: xf final state (at tf) real(kind=wp), intent(out) :: gf g value at tf integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. procedure, public :: step => rkf1412 private  subroutine rkf1412 (me, t, x, h, xf, terr) Feagin's RK14(12) - a 14th-order method with an embedded 12th-order method. Read more… Arguments Type Intent Optional Attributes Name class( rkf1412_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate procedure, public :: order => rkf1412_order private pure function rkf1412_order (me) result(p) Returns the order of the rkf1412 method. Arguments Type Intent Optional Attributes Name class( rkf1412_class ), intent(in) :: me Return Value integer order of the method Source Code type , extends ( rk_variable_step_class ), public :: rkf1412_class !! Runga-Kutta Feagin 14(12) method. contains procedure :: step => rkf1412 procedure :: order => rkf1412_order end type rkf1412_class","tags":"","url":"type/rkf1412_class.html"},{"title":"ephemeris_class – fortran-astrodynamics-toolkit ","text":"type, public, abstract :: ephemeris_class abstract class for interfacing with ephemeris systems. Inherited by type~~ephemeris_class~~InheritedByGraph type~ephemeris_class ephemeris_class type~jpl_ephemeris jpl_ephemeris type~jpl_ephemeris->type~ephemeris_class type~spice_ephemeris spice_ephemeris type~spice_ephemeris->type~ephemeris_class type~standish_ephemeris standish_ephemeris type~standish_ephemeris->type~ephemeris_class Help Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from a derived type to the parent type which it\nextends. Dashed arrows point from a derived type to the other\ntypes it contains as a components, with a label listing the name(s) of\nsaid component(s). Type-Bound Procedures procedure( rv_func ), public, deferred :: get_rv get the state of one body w.r.t. another body. subroutine rv_func(me, et, targ, obs, rv, status_ok) Prototype function to return the state of the targ body relative to\nthe obs body, in the inertial frame [ICRF]. Arguments Type Intent Optional Attributes Name class( ephemeris_class ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(6) :: rv state of targ w.r.t. obs logical, intent(out) :: status_ok true if there were no problems procedure( r_func ), public, deferred :: get_r get the position of one body w.r.t. another body. subroutine r_func(me, et, targ, obs, r, status_ok) Prototype function to return the position of the targ body relative to\nthe obs body, in the inertial frame [ICRF]. Arguments Type Intent Optional Attributes Name class( ephemeris_class ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(3) :: r position vector of targ w.r.t. obs logical, intent(out) :: status_ok true if there were no problems Source Code type , abstract , public :: ephemeris_class !! abstract class for interfacing with ephemeris systems. private contains private procedure ( rv_func ), deferred , public :: get_rv !! get the state of one body w.r.t. another body. procedure ( r_func ), deferred , public :: get_r !! get the position of one body w.r.t. another body. end type ephemeris_class","tags":"","url":"type/ephemeris_class.html"},{"title":"mean_obliquity_func – fortran-astrodynamics-toolkit","text":"interface private pure function mean_obliquity_func(et) result(e) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: et ephemeris time (sec) Return Value real(kind=wp) obliquity of ecliptic (deg) Description a function for computing the mean obliquity of the ecliptic.","tags":"","url":"interface/mean_obliquity_func.html"},{"title":"func – fortran-astrodynamics-toolkit","text":"interface private  subroutine func(x, f) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: f Description interface for the function and derivative","tags":"","url":"interface/func.html"},{"title":"fcn_hybrd – fortran-astrodynamics-toolkit","text":"interface public  subroutine fcn_hybrd(n, x, fvec, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(out), dimension(n) :: fvec integer, intent(inout) :: iflag the value of iflag should not be changed by fcn unless\nthe user wants to terminate execution of hybrd .\nin this case set iflag to a negative integer. Description function for hybrd .\ncalculate the functions at x and\nreturn this vector in fvec .","tags":"","url":"interface/fcn_hybrd.html"},{"title":"fcn_hybrj – fortran-astrodynamics-toolkit","text":"interface public  subroutine fcn_hybrj(n, x, fvec, fjac, ldfjac, iflag) Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(out), dimension(n) :: fvec real(kind=wp), intent(out), dimension(ldfjac,n) :: fjac integer, intent(in) :: ldfjac integer, intent(inout) :: iflag Description function for hybrj","tags":"","url":"interface/fcn_hybrj.html"},{"title":"func – fortran-astrodynamics-toolkit","text":"interface private  function func(t) result(f) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t Independant variable for the function. Return Value real(kind=wp) The function evaluated at t . Description interface to the zeroin input function","tags":"","url":"interface/func~3.html"},{"title":"acc_function – fortran-astrodynamics-toolkit","text":"interface private  subroutine acc_function(me, r, n, m, a) Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Description Interface to the acceleration function for the different methods","tags":"","url":"interface/acc_function.html"},{"title":"c_cdot_func – fortran-astrodynamics-toolkit","text":"interface private  subroutine c_cdot_func(me, eph, to_icrf, c, cdot, status_ok) Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations\n(assumed to have already\nbeen initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok","tags":"","url":"interface/c_cdot_func.html"},{"title":"report_func – fortran-astrodynamics-toolkit","text":"interface private  subroutine report_func(t, rv) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t time [sec] real(kind=wp), intent(in), dimension(6) :: rv state [km,km/s] Description for reporting the points in the cw_propagator .","tags":"","url":"interface/report_func~2.html"},{"title":"frame_transform_func – fortran-astrodynamics-toolkit","text":"interface private  subroutine frame_transform_func(mu, r, v, a, c, cdot) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] [not used by all algorithms] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix","tags":"","url":"interface/frame_transform_func.html"},{"title":"func – fortran-astrodynamics-toolkit","text":"interface private  function func(me, x) result(f) Arguments Type Intent Optional Attributes Name class( brent_class ), intent(inout) :: me real(kind=wp), intent(in) :: x Return Value real(kind=wp) Description Interface to the function to be minimized.\nIt should evaluate f(x) for any x in the interval (ax,bx)","tags":"","url":"interface/func~4.html"},{"title":"norm_func – fortran-astrodynamics-toolkit","text":"interface private pure function norm_func(x) result(xmag) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x a vector Return Value real(kind=wp) the magnitude of the vector Description Vector norm function. Must return a value .","tags":"","url":"interface/norm_func.html"},{"title":"order_func – fortran-astrodynamics-toolkit","text":"interface private pure function order_func(me) result(p) Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(in) :: me Return Value integer order of the method","tags":"","url":"interface/order_func.html"},{"title":"deriv_func – fortran-astrodynamics-toolkit","text":"interface private  subroutine deriv_func(me, t, x, xdot) Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t time real(kind=wp), intent(in), dimension(:) :: x state vector real(kind=wp), intent(out), dimension(:) :: xdot derivative of state vector Description derivative function","tags":"","url":"interface/deriv_func~2.html"},{"title":"event_func – fortran-astrodynamics-toolkit","text":"interface private  subroutine event_func(me, t, x, g) Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t time real(kind=wp), intent(in), dimension(:) :: x state vector real(kind=wp), intent(out) :: g g(t,x). The goal is to stop the integration when g=0. Description event function","tags":"","url":"interface/event_func~2.html"},{"title":"report_func – fortran-astrodynamics-toolkit","text":"interface private  subroutine report_func(me, t, x) Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t time real(kind=wp), intent(in), dimension(:) :: x state vector Description report function","tags":"","url":"interface/report_func~3.html"},{"title":"step_func – fortran-astrodynamics-toolkit","text":"interface private  subroutine step_func(me, t, x, h, xf, terr) Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state vector real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf final state vector real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate Description rk step function","tags":"","url":"interface/step_func~2.html"},{"title":"rv_func – fortran-astrodynamics-toolkit","text":"interface private  subroutine rv_func(me, et, targ, obs, rv, status_ok) Arguments Type Intent Optional Attributes Name class( ephemeris_class ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(6) :: rv state of targ w.r.t. obs logical, intent(out) :: status_ok true if there were no problems Description function to return the state of the targ body relative to\nthe obs body, in the inertial frame [ICRF].","tags":"","url":"interface/rv_func.html"},{"title":"r_func – fortran-astrodynamics-toolkit","text":"interface private  subroutine r_func(me, et, targ, obs, r, status_ok) Arguments Type Intent Optional Attributes Name class( ephemeris_class ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(3) :: r position vector of targ w.r.t. obs logical, intent(out) :: status_ok true if there were no problems Description function to return the position of the targ body relative to\nthe obs body, in the inertial frame [ICRF].","tags":"","url":"interface/r_func.html"},{"title":"get_random_number – fortran-astrodynamics-toolkit","text":"public  function get_random_number(a, b) result(x) Returns a uniform random number x , such that: a <= x < b . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b Return Value real(kind=wp) Called by proc~~get_random_number~~CalledByGraph proc~get_random_number get_random_number proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->proc~get_random_number proc~lambert_test lambert_test proc~lambert_test->proc~get_random_number Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function get_random_number ( a , b ) result ( x ) implicit none real ( wp ) :: x real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ) :: b call random_number ( x ) x = a + ( b - a ) * x end function get_random_number","tags":"","url":"proc/get_random_number.html"},{"title":"spice_id_to_standish_id – fortran-astrodynamics-toolkit","text":"private pure function spice_id_to_standish_id(spice_id) result(old_id) Convert the NAIF SPICE ID code to the one used by the standish ephemeris.\n  Returns 0 if the body was not found. See also spice_id_to_old_id Arguments Type Intent Optional Attributes Name integer, intent(in) :: spice_id the ID code used by SPICE Return Value integer the ID code used by this module Called by proc~~spice_id_to_standish_id~~CalledByGraph proc~spice_id_to_standish_id spice_id_to_standish_id proc~standish_rv_func standish_ephemeris%standish_rv_func proc~standish_rv_func->proc~spice_id_to_standish_id proc~standish_module_test standish_module_test proc~standish_module_test->proc~standish_rv_func proc~standish_r_func standish_ephemeris%standish_r_func proc~standish_r_func->proc~standish_rv_func Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function spice_id_to_standish_id ( spice_id ) result ( old_id ) implicit none integer , intent ( in ) :: spice_id !! the ID code used by SPICE integer :: old_id !! the ID code used by this module integer :: i !! counter !> !  The index of this array is the ID code. The value is the NAIF code. !  See: [NAIF Integer ID codes](http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/req/naif_ids.html) integer , parameter , dimension ( 9 ) :: new_ids = & [ 199 ,& ! mercury 299 ,& ! venus 3 , & ! earth-moon barycenter 499 ,& ! mars 599 ,& ! jupiter 699 ,& ! saturn 799 ,& ! uranus 899 ,& ! neptune 999 ] ! pluto !just a simple search of the list: ! [small enough that bisection search probably not worth it] do i = 1 , size ( new_ids ) if ( new_ids ( i ) == spice_id ) then old_id = i return end if end do !not found: old_id = 0 end function spice_id_to_standish_id","tags":"","url":"proc/spice_id_to_standish_id.html"},{"title":"kepler – fortran-astrodynamics-toolkit","text":"private pure function kepler(ma, ec) solve kepler's equation ma = ea + ec*sin(ea) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ma eccentricity real(kind=wp), intent(in) :: ec mean anomaly in rad Return Value real(kind=wp) Called by proc~~kepler~~CalledByGraph proc~kepler kepler proc~calcelements calcelements proc~calcelements->proc~kepler proc~helio helio proc~helio->proc~calcelements proc~standish_module_test standish_module_test proc~standish_module_test->proc~helio proc~standish_rv_func standish_ephemeris%standish_rv_func proc~standish_module_test->proc~standish_rv_func proc~standish_rv_func->proc~helio proc~standish_r_func standish_ephemeris%standish_r_func proc~standish_r_func->proc~standish_rv_func Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure real ( wp ) function kepler ( ma , ec ) implicit none real ( wp ), intent ( in ) :: ma !! eccentricity real ( wp ), intent ( in ) :: ec !! mean anomaly in rad real ( wp ) :: r , ea integer :: i ! acceptable accuracy for this calculation real ( wp ), parameter :: tol = 1.0e-08_wp !! max error in eccentric anomaly `ea` in rad integer , parameter :: maxit = 12 !! max iterations (1-4 typical for `ec<0.3`) ea = ma + ec * sin ( ma ) ! starting value do i = 1 , maxit ! newton(-raphson) iterations r = ( ma - ea + ec * sin ( ea )) / ( one - ec * cos ( ea )) ea = ea + r if ( abs ( r ) <= tol ) exit end do kepler = modulo ( ea , twopi ) ! eccentric anomaly adjusted 0-2pi end function kepler","tags":"","url":"proc/kepler.html"},{"title":"tbl – fortran-astrodynamics-toolkit","text":"private pure function tbl(jd) result(itbl) Determine which data set to use for highest accuracy for the given julian date. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: jd julian date (eg 2451545.0) Return Value integer Which data set to use: itbl=1 jd in range of table 1\n  (1800ad-2050ad) - highest accuracy itbl=2 jd outside range of table 1\n  but in range of table 2 (3000bc-3000ad) itbl=0 3000bc 3000ad  julian\n  date out of range for ephemeris. Called by proc~~tbl~~CalledByGraph proc~tbl tbl proc~helio helio proc~helio->proc~tbl proc~standish_module_test standish_module_test proc~standish_module_test->proc~helio proc~standish_rv_func standish_ephemeris%standish_rv_func proc~standish_module_test->proc~standish_rv_func proc~standish_rv_func->proc~helio proc~standish_r_func standish_ephemeris%standish_r_func proc~standish_r_func->proc~standish_rv_func Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function tbl ( jd ) result ( itbl ) implicit none real ( wp ), intent ( in ) :: jd !! julian date (eg 2451545.0) integer :: itbl !! Which data set to use: !! !! * itbl=1 jd in range of table 1 !!   (1800ad-2050ad) - highest accuracy !! * itbl=2 jd outside range of table 1 !!   but in range of table 2 (3000bc-3000ad) !! * itbl=0 3000bc<jd or jd>3000ad  julian !!   date out of range for ephemeris. if (( jd > eph_set ( 1 )% jd_range ( 1 )) . and . ( jd < eph_set ( 1 )% jd_range ( 2 ))) then itbl = 1 else if (( jd > eph_set ( 2 )% jd_range ( 1 )) . and . ( jd < eph_set ( 2 )% jd_range ( 2 ))) then itbl = 2 else itbl = 0 end if end if end function tbl","tags":"","url":"proc/tbl.html"},{"title":"standish_rv_func – fortran-astrodynamics-toolkit","text":"private  subroutine standish_rv_func(me, et, targ, obs, rv, status_ok) Return the state of the targ body relative to\nthe obs body, in the inertial frame [ICRF]. This is the function that can be used in the ephemeris_class . Type Bound standish_ephemeris Arguments Type Intent Optional Attributes Name class( standish_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(6) :: rv state of targ w.r.t. obs [km, km/s] logical, intent(out) :: status_ok true if there were no problems Calls proc~~standish_rv_func~~CallsGraph proc~standish_rv_func standish_ephemeris%standish_rv_func proc~ec2eq ec2eq proc~standish_rv_func->proc~ec2eq proc~et_to_jd et_to_jd proc~standish_rv_func->proc~et_to_jd proc~helio helio proc~standish_rv_func->proc~helio proc~spice_id_to_standish_id spice_id_to_standish_id proc~standish_rv_func->proc~spice_id_to_standish_id proc~calcelements calcelements proc~helio->proc~calcelements proc~el2op el2op proc~helio->proc~el2op proc~op2ec op2ec proc~helio->proc~op2ec proc~tbl tbl proc~helio->proc~tbl proc~kepler kepler proc~calcelements->proc~kepler Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~standish_rv_func~~CalledByGraph proc~standish_rv_func standish_ephemeris%standish_rv_func proc~standish_module_test standish_module_test proc~standish_module_test->proc~standish_rv_func proc~standish_r_func standish_ephemeris%standish_r_func proc~standish_r_func->proc~standish_rv_func Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine standish_rv_func ( me , et , targ , obs , rv , status_ok ) implicit none class ( standish_ephemeris ), intent ( inout ) :: me real ( wp ), intent ( in ) :: et !! ephemeris time [sec] type ( celestial_body ), intent ( in ) :: targ !! target body type ( celestial_body ), intent ( in ) :: obs !! observer body real ( wp ), dimension ( 6 ), intent ( out ) :: rv !! state of targ w.r.t. obs [km, km/s] logical , intent ( out ) :: status_ok !! true if there were no problems real ( wp ) :: jd integer :: itbl_targ , itbl_obs integer :: itarg integer :: iobs real ( wp ), dimension ( 6 ) :: targ_rv_au real ( wp ), dimension ( 6 ) :: obs_rv_au real ( wp ), dimension ( 6 ) :: rv_ecliptic integer , parameter :: naif_id_sun = 10 !! NAIF ID for the Sun if ( targ == obs ) then rv = zero return end if jd = et_to_jd ( et ) if ( targ % id == naif_id_sun ) then itarg = - 1 ! dummy else itarg = spice_id_to_standish_id ( targ % id ) end if if ( obs % id == naif_id_sun ) then iobs = - 1 ! dummy else iobs = spice_id_to_standish_id ( obs % id ) end if if ( itarg == 0 . or . iobs == 0 ) then ! if the bodies were not found in this ephemeris rv = zero status_ok = . false . else if ( targ % id /= naif_id_sun ) then ! targ w.r.t sun [j2000 ecliptic] call helio ( itarg , jd , targ_rv_au , itbl_targ ) else targ_rv_au = zero itbl_targ = 3 ! dummy value end if if ( obs % id /= naif_id_sun ) then ! obs w.r.t sun [j2000 ecliptic] call helio ( iobs , jd , obs_rv_au , itbl_obs ) else obs_rv_au = zero itbl_obs = 3 ! dummy value end if if ( itbl_targ > 0 . and . itbl_obs > 0 ) then ! vector from obs to targ [j2000 ecliptic] rv_ecliptic = targ_rv_au - obs_rv_au ! convert to ICRF: call ec2eq ( rv_ecliptic , rv ) ! Convert to km, km/s: rv = rv * au2m * m2km rv ( 4 : 6 ) = rv ( 4 : 6 ) / ( year2day * day2sec ) status_ok = . true . else ! out of range of the ephemeris: rv = zero status_ok = . false . end if end if end subroutine standish_rv_func","tags":"","url":"proc/standish_rv_func.html"},{"title":"standish_r_func – fortran-astrodynamics-toolkit","text":"private  subroutine standish_r_func(me, et, targ, obs, r, status_ok) Return the position of the targ body relative to\n the obs body, in the inertial frame [ICRF]. This is the function that can be used in the ephemeris_class . position of targ w.r.t. obs [km] Type Bound standish_ephemeris Arguments Type Intent Optional Attributes Name class( standish_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(3) :: r position of targ w.r.t. obs [km] logical, intent(out) :: status_ok true if there were no problems Calls proc~~standish_r_func~~CallsGraph proc~standish_r_func standish_ephemeris%standish_r_func proc~standish_rv_func standish_ephemeris%standish_rv_func proc~standish_r_func->proc~standish_rv_func proc~ec2eq ec2eq proc~standish_rv_func->proc~ec2eq proc~et_to_jd et_to_jd proc~standish_rv_func->proc~et_to_jd proc~helio helio proc~standish_rv_func->proc~helio proc~spice_id_to_standish_id spice_id_to_standish_id proc~standish_rv_func->proc~spice_id_to_standish_id proc~calcelements calcelements proc~helio->proc~calcelements proc~el2op el2op proc~helio->proc~el2op proc~op2ec op2ec proc~helio->proc~op2ec proc~tbl tbl proc~helio->proc~tbl proc~kepler kepler proc~calcelements->proc~kepler Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine standish_r_func ( me , et , targ , obs , r , status_ok ) implicit none class ( standish_ephemeris ), intent ( inout ) :: me real ( wp ), intent ( in ) :: et !! ephemeris time [sec] type ( celestial_body ), intent ( in ) :: targ !! target body type ( celestial_body ), intent ( in ) :: obs !! observer body real ( wp ), dimension ( 3 ), intent ( out ) :: r !! position of targ w.r.t. obs [km] logical , intent ( out ) :: status_ok !! true if there were no problems real ( wp ), dimension ( 6 ) :: rv !! full state vector [km, km/s] call me % get_rv ( et , targ , obs , rv , status_ok ) if ( status_ok ) then r = rv ( 1 : 3 ) !! position of targ w.r.t. obs [km] else r = zero end if end subroutine standish_r_func","tags":"","url":"proc/standish_r_func.html"},{"title":"helio – fortran-astrodynamics-toolkit","text":"private pure subroutine helio(np, jd, p, itbl) For planet np and julian date jd and using using table itbl ,\nreturn j2000 ecliptic position (au) and velocity (au/yr).\nin cartesian coordinates (p(1)-p(6)). Arguments Type Intent Optional Attributes Name integer, intent(in) :: np planet 1-9 real(kind=wp), intent(in) :: jd julian date real(kind=wp), intent(out), dimension(6) :: p position (au)/velocity (au/yr) integer, intent(out) :: itbl table used or error if zero Calls proc~~helio~~CallsGraph proc~helio helio proc~calcelements calcelements proc~helio->proc~calcelements proc~el2op el2op proc~helio->proc~el2op proc~op2ec op2ec proc~helio->proc~op2ec proc~tbl tbl proc~helio->proc~tbl proc~kepler kepler proc~calcelements->proc~kepler Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~helio~~CalledByGraph proc~helio helio proc~standish_module_test standish_module_test proc~standish_module_test->proc~helio proc~standish_rv_func standish_ephemeris%standish_rv_func proc~standish_module_test->proc~standish_rv_func proc~standish_rv_func->proc~helio proc~standish_r_func standish_ephemeris%standish_r_func proc~standish_r_func->proc~standish_rv_func Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine helio ( np , jd , p , itbl ) implicit none integer , intent ( in ) :: np !! planet 1-9 real ( wp ), intent ( in ) :: jd !! julian date real ( wp ), dimension ( 6 ), intent ( out ) :: p !! position (au)/velocity (au/yr) integer , intent ( out ) :: itbl !! table used or error if zero real ( wp ), dimension ( 8 ) :: z !! elements [a, e, i, l, w, o, ma, ea] real ( wp ), dimension ( 8 ) :: po z = zero po = zero itbl = tbl ( jd ) if ( itbl > 0 ) then call calcelements ( np , jd , itbl , z ) call el2op ( z , po ) call op2ec ( z , po , p ) end if end subroutine helio","tags":"","url":"proc/helio.html"},{"title":"calcelements – fortran-astrodynamics-toolkit","text":"private pure subroutine calcelements(np, jd, itbl, z) Calculate current elements z(jd) for planet j from jpl data Arguments Type Intent Optional Attributes Name integer, intent(in) :: np planet number (1-9) real(kind=wp), intent(in) :: jd julian date integer, intent(in) :: itbl which table to use (1-2) real(kind=wp), intent(out), dimension(8) :: z elements for jd a = semi major axis (au) e = eccentricity (rad) i = inclination (rad) l = mean longitude (rad) w = longitude of perihelion (rad) o = longitude of ascending mode (rad) ma = mean anomaly (rad) ea = eccentric anomaly (rad) Calls proc~~calcelements~~CallsGraph proc~calcelements calcelements proc~kepler kepler proc~calcelements->proc~kepler Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calcelements~~CalledByGraph proc~calcelements calcelements proc~helio helio proc~helio->proc~calcelements proc~standish_module_test standish_module_test proc~standish_module_test->proc~helio proc~standish_rv_func standish_ephemeris%standish_rv_func proc~standish_module_test->proc~standish_rv_func proc~standish_rv_func->proc~helio proc~standish_r_func standish_ephemeris%standish_r_func proc~standish_r_func->proc~standish_rv_func Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine calcelements ( np , jd , itbl , z ) implicit none integer , intent ( in ) :: np !! planet number (1-9) integer , intent ( in ) :: itbl !! which table to use (1-2) real ( wp ), intent ( in ) :: jd !! julian date real ( wp ), dimension ( 8 ), intent ( out ) :: z !! elements for `jd` !! !!  * a = semi major axis (au) !!  * e = eccentricity (rad) !!  * i = inclination (rad) !!  * l = mean longitude (rad) !!  * w = longitude of perihelion (rad) !!  * o = longitude of ascending mode (rad) !!  * ma = mean anomaly (rad) !!  * ea = eccentric anomaly (rad) integer :: i !! counter real ( wp ) :: t !! centuries since epoch real ( wp ) :: tz !! perturbation term t = ( jd - epoch ) * day2century do i = 1 , 6 ! a,e,i,l,w,o z ( i ) = eph_set ( itbl )% o ( i , np ) + eph_set ( itbl )% o ( i + 6 , np ) * t ! if (i>2) z(i) = modulo(z(i), twopi)  !optional scaling end do if ( itbl == 2 ) then ! perturbation term nonzero for planets 5-9 if table 2 used tz = eph_set ( itbl )% o ( 13 , np ) * t ** 2 + & eph_set ( itbl )% o ( 14 , np ) * cos ( eph_set ( itbl )% o ( 16 , np ) * t ) + & eph_set ( itbl )% o ( 15 , np ) * sin ( eph_set ( itbl )% o ( 16 , np ) * t ) else tz = zero end if z ( 7 ) = modulo (( z ( 4 ) - z ( 5 ) + tz ), twopi ) ! mean anomaly z ( 8 ) = kepler ( z ( 7 ), z ( 2 )) ! eccentric anomaly end subroutine calcelements","tags":"","url":"proc/calcelements.html"},{"title":"el2op – fortran-astrodynamics-toolkit","text":"private pure subroutine el2op(z, po) heliocentric coordinates for orbital plane from elements Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(8) :: z elements [a,e,i,l,w,o,ma,ea] real(kind=wp), intent(out), dimension(6) :: po coordinates and velocities Called by proc~~el2op~~CalledByGraph proc~el2op el2op proc~helio helio proc~helio->proc~el2op proc~standish_module_test standish_module_test proc~standish_module_test->proc~helio proc~standish_rv_func standish_ephemeris%standish_rv_func proc~standish_module_test->proc~standish_rv_func proc~standish_rv_func->proc~helio proc~standish_r_func standish_ephemeris%standish_r_func proc~standish_r_func->proc~standish_rv_func Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine el2op ( z , po ) implicit none real ( wp ), dimension ( 8 ), intent ( in ) :: z !! elements [a,e,i,l,w,o,ma,ea] real ( wp ), dimension ( 6 ), intent ( out ) :: po !! coordinates and velocities real ( wp ) :: v , s1 , c1 , s2 ! heliocentric orbital plane po = zero s1 = sin ( z ( 8 )) c1 = cos ( z ( 8 )) s2 = sqrt ( one - z ( 2 ) * z ( 2 )) v = twopi / ( sqrt ( z ( 1 )) * ( one - z ( 2 ) * c1 )) ! velocity au/yr po ( 1 ) = z ( 1 ) * ( c1 - z ( 2 )) ! xp (plane of orbit) po ( 2 ) = z ( 1 ) * s1 * s2 ! yp po ( 4 ) = - v * s1 ! vxp po ( 5 ) = v * c1 * s2 ! vyp end subroutine el2op","tags":"","url":"proc/el2op.html"},{"title":"op2ec – fortran-astrodynamics-toolkit","text":"private pure subroutine op2ec(z, po, pe) heliocentric coordinates j2000 ecliptic plane from orbital plane Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(8) :: z elements a,e,i,l,w,o,ma,ea real(kind=wp), intent(in), dimension(6) :: po orbital plane coordinates real(kind=wp), intent(out), dimension(6) :: pe j2000 ecliptic plane coordinates Called by proc~~op2ec~~CalledByGraph proc~op2ec op2ec proc~helio helio proc~helio->proc~op2ec proc~standish_module_test standish_module_test proc~standish_module_test->proc~helio proc~standish_rv_func standish_ephemeris%standish_rv_func proc~standish_module_test->proc~standish_rv_func proc~standish_rv_func->proc~helio proc~standish_r_func standish_ephemeris%standish_r_func proc~standish_r_func->proc~standish_rv_func Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine op2ec ( z , po , pe ) implicit none real ( wp ), dimension ( 8 ), intent ( in ) :: z !! elements a,e,i,l,w,o,ma,ea real ( wp ), dimension ( 6 ), intent ( in ) :: po !! orbital plane coordinates real ( wp ), dimension ( 6 ), intent ( out ) :: pe !! j2000 ecliptic plane coordinates real ( wp ) :: s1 , s2 , s3 , c1 , c2 , c3 ! heliocentric au, au/yr s1 = sin ( z ( 5 ) - z ( 6 )) s2 = sin ( z ( 3 )) s3 = sin ( z ( 6 )) c1 = cos ( z ( 5 ) - z ( 6 )) c2 = cos ( z ( 3 )) c3 = cos ( z ( 6 )) pe ( 1 ) = ( c1 * c3 - s1 * s3 * c2 ) * po ( 1 ) - ( s1 * c3 + c1 * s3 * c2 ) * po ( 2 ) ! xec pe ( 2 ) = ( c1 * s3 + s1 * c3 * c2 ) * po ( 1 ) - ( s1 * s3 - c1 * c3 * c2 ) * po ( 2 ) ! yec pe ( 3 ) = s1 * s2 * po ( 1 ) + c1 * s2 * po ( 2 ) ! zec pe ( 4 ) = ( c1 * c3 - s1 * s3 * c2 ) * po ( 4 ) - ( s1 * c3 + c1 * s3 * c2 ) * po ( 5 ) ! vxec pe ( 5 ) = ( c1 * s3 + s1 * c3 * c2 ) * po ( 4 ) - ( s1 * s3 - c1 * c3 * c2 ) * po ( 5 ) ! vyec pe ( 6 ) = s1 * s2 * po ( 4 ) + c1 * s2 * po ( 5 ) ! vzec end subroutine op2ec","tags":"","url":"proc/op2ec.html"},{"title":"ec2eq – fortran-astrodynamics-toolkit","text":"private pure subroutine ec2eq(pe, pq) converts cartesian heliocentric j2000 ecliptic to equatorial Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: pe ecliptic real(kind=wp), intent(out), dimension(6) :: pq equatorial Called by proc~~ec2eq~~CalledByGraph proc~ec2eq ec2eq proc~standish_rv_func standish_ephemeris%standish_rv_func proc~standish_rv_func->proc~ec2eq proc~standish_module_test standish_module_test proc~standish_module_test->proc~standish_rv_func proc~standish_r_func standish_ephemeris%standish_r_func proc~standish_r_func->proc~standish_rv_func Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine ec2eq ( pe , pq ) implicit none real ( wp ), dimension ( 6 ), intent ( in ) :: pe !! ecliptic real ( wp ), dimension ( 6 ), intent ( out ) :: pq !! equatorial pq ( 1 ) = pe ( 1 ) ! xeq same as xec pq ( 2 ) = s_cobl * pe ( 2 ) - s_sobl * pe ( 3 ) ! yeq pq ( 3 ) = s_sobl * pe ( 2 ) + s_cobl * pe ( 3 ) ! zeq pq ( 4 ) = pe ( 4 ) ! vxeq same as vxec pq ( 5 ) = s_cobl * pe ( 5 ) - s_sobl * pe ( 6 ) ! vyeq pq ( 6 ) = s_sobl * pe ( 5 ) + s_cobl * pe ( 6 ) ! vzeq end subroutine ec2eq","tags":"","url":"proc/ec2eq.html"},{"title":"eq2ec – fortran-astrodynamics-toolkit","text":"private pure subroutine eq2ec(pq, pe) converts cartesian heliocentric equatorial to ecliptic Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: pq equatorial real(kind=wp), intent(out), dimension(6) :: pe ecliptic Source Code pure subroutine eq2ec ( pq , pe ) implicit none real ( wp ), dimension ( 6 ), intent ( out ) :: pe !! ecliptic real ( wp ), dimension ( 6 ), intent ( in ) :: pq !! equatorial pe ( 1 ) = pq ( 1 ) ! xec same as xeq pe ( 2 ) = s_cobl * pq ( 2 ) + s_sobl * pq ( 3 ) ! yec pe ( 3 ) = - s_sobl * pq ( 2 ) + s_cobl * pq ( 3 ) ! zec pe ( 4 ) = pq ( 4 ) ! vxec same as vxeq pe ( 5 ) = s_cobl * pq ( 5 ) + s_sobl * pq ( 6 ) ! vyec pe ( 6 ) = - s_sobl * pq ( 5 ) + s_cobl * pq ( 6 ) ! vzec end subroutine eq2ec","tags":"","url":"proc/eq2ec.html"},{"title":"sphere – fortran-astrodynamics-toolkit","text":"private pure subroutine sphere(x, y, z, rho, theta, phi) cartesian to spherical coordinates (angles in radians) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x x = r cos(phi) cos (theta) real(kind=wp), intent(in) :: y y = r cos(phi) sin(theta) real(kind=wp), intent(in) :: z z = r sin(phi) real(kind=wp), intent(out) :: rho distance real(kind=wp), intent(out) :: theta longitude real(kind=wp), intent(out) :: phi latitude Source Code pure subroutine sphere ( x , y , z , rho , theta , phi ) implicit none real ( wp ), intent ( in ) :: x !! x = r cos(phi) cos (theta) real ( wp ), intent ( in ) :: y !! y = r cos(phi) sin(theta) real ( wp ), intent ( in ) :: z !! z = r sin(phi) real ( wp ), intent ( out ) :: rho !! distance real ( wp ), intent ( out ) :: theta !! longitude real ( wp ), intent ( out ) :: phi !! latitude real ( wp ) :: r theta = zero phi = zero rho = sqrt ( x * x + y * y + z * z ) r = sqrt ( x * x + y * y ) if ( r /= zero ) then theta = modulo ( atan2 ( y , x ), twopi ) phi = atan2 ( z , r ) end if end subroutine sphere","tags":"","url":"proc/sphere.html"},{"title":"standish_module_test – fortran-astrodynamics-toolkit","text":"public  subroutine standish_module_test() Test routine for the standish_module routines. Arguments None Calls proc~~standish_module_test~~CallsGraph proc~standish_module_test standish_module_test proc~et_to_jd et_to_jd proc~standish_module_test->proc~et_to_jd proc~helio helio proc~standish_module_test->proc~helio proc~standish_rv_func standish_ephemeris%standish_rv_func proc~standish_module_test->proc~standish_rv_func proc~calcelements calcelements proc~helio->proc~calcelements proc~el2op el2op proc~helio->proc~el2op proc~op2ec op2ec proc~helio->proc~op2ec proc~tbl tbl proc~helio->proc~tbl proc~standish_rv_func->proc~et_to_jd proc~standish_rv_func->proc~helio proc~ec2eq ec2eq proc~standish_rv_func->proc~ec2eq proc~spice_id_to_standish_id spice_id_to_standish_id proc~standish_rv_func->proc~spice_id_to_standish_id proc~kepler kepler proc~calcelements->proc~kepler Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine standish_module_test () implicit none type ( standish_ephemeris ) :: eph real ( wp ) :: et !! ephemeris time (sec) real ( wp ) :: jd !! julian date real ( wp ), dimension ( 6 ) :: rv !! state of targ w.r.t. obs logical :: status_ok !! true if there were no problems integer :: itbl !> !  State of Earth w.r.t. Sun from SPICE !  See: http://wgc.jpl.nasa.gov:8080/webgeocalc/#NewCalculation real ( wp ), dimension ( 6 ), parameter :: rv_from_spice = [ - 2650257 6.96907434_wp ,& 13275417 6.58943012_wp ,& 5755579 3.70952077_wp ,& - 2 9.78644078_wp ,& - 5.02614568_wp ,& - 2.17905509_wp ] write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' standish_module_test' write ( * , * ) '---------------' write ( * , * ) '' et = 0.0_wp ! J2000 ! get earth w.r.t. sun in J2000 frame: call eph % get_rv ( et , body_earth_moon_barycenter , body_sun , rv , status_ok ) if ( status_ok ) then write ( * , * ) '' write ( * , * ) 'State of Earth wrt Sun @ J2000' write ( * , '(A,1X,*(E26.16,1X))' ) 'standish:' , rv write ( * , '(A,1X,*(E26.16,1X))' ) 'SPICE:   ' , rv_from_spice write ( * , '(A,1X,*(E26.16,1X))' ) 'diff:    ' , rv - rv_from_spice write ( * , * ) '' else error stop 'error calling standish_ephemeris' end if ! low-level routine tests: write ( * , * ) 'helio:' jd = et_to_jd ( et ) call helio ( 3 , jd , rv , itbl ) write ( * , * ) '' write ( * , * ) 'State of Earth wrt Sun [ecliptic]' write ( * , '(*(E26.16,1X))' ) rv write ( * , * ) '' end subroutine standish_module_test","tags":"","url":"proc/standish_module_test.html"},{"title":"mean_ecliptic_to_equatorial_rotmat – fortran-astrodynamics-toolkit","text":"public pure function mean_ecliptic_to_equatorial_rotmat(obliquity_func) result(rot) Rotation matrix from Mean Ecliptic to J2000. Reference https://en.wikipedia.org/wiki/Ecliptic_coordinate_system Arguments Type Intent Optional Attributes Name procedure( mean_obliquity_func ), optional :: obliquity_func optional function to compute\nthe mean obliquity. If not\npresent, then mean_obliquity_of_ecliptic_iau1980 is used. Return Value real(kind=wp), dimension(3,3) rotation matrix Calls proc~~mean_ecliptic_to_equatorial_rotmat~~CallsGraph proc~mean_ecliptic_to_equatorial_rotmat mean_ecliptic_to_equatorial_rotmat proc~mean_obliquity_of_ecliptic_iau1980 mean_obliquity_of_ecliptic_iau1980 proc~mean_ecliptic_to_equatorial_rotmat->proc~mean_obliquity_of_ecliptic_iau1980 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~mean_ecliptic_to_equatorial_rotmat~~CalledByGraph proc~mean_ecliptic_to_equatorial_rotmat mean_ecliptic_to_equatorial_rotmat proc~equatorial_to_mean_ecliptic_rotmat equatorial_to_mean_ecliptic_rotmat proc~equatorial_to_mean_ecliptic_rotmat->proc~mean_ecliptic_to_equatorial_rotmat proc~get_c_cdot_ecliptic ecliptic_frame%get_c_cdot_ecliptic proc~get_c_cdot_ecliptic->proc~mean_ecliptic_to_equatorial_rotmat proc~get_c_cdot_ecliptic->proc~equatorial_to_mean_ecliptic_rotmat proc~transformation_module_test transformation_module_test proc~transformation_module_test->proc~get_c_cdot_ecliptic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function mean_ecliptic_to_equatorial_rotmat ( obliquity_func ) result ( rot ) implicit none real ( wp ), dimension ( 3 , 3 ) :: rot !! rotation matrix procedure ( mean_obliquity_func ), optional :: obliquity_func !! optional function to compute !! the mean obliquity. If not !! present, then !! [[mean_obliquity_of_ecliptic_iau1980]] !! is used. real ( wp ) :: e !! mean obliquity at J2000 (rad) real ( wp ) :: s , c if ( present ( obliquity_func )) then e = obliquity_func ( 0.0_wp ) else e = mean_obliquity_of_ecliptic_iau1980 ( 0.0_wp ) end if e = e * deg2rad s = sin ( e ) c = cos ( e ) rot (:, 1 ) = [ 1.0_wp , 0.0_wp , 0.0_wp ] rot (:, 2 ) = [ 0.0_wp , c , s ] rot (:, 3 ) = [ 0.0_wp , - s , c ] end function mean_ecliptic_to_equatorial_rotmat","tags":"","url":"proc/mean_ecliptic_to_equatorial_rotmat.html"},{"title":"equatorial_to_mean_ecliptic_rotmat – fortran-astrodynamics-toolkit","text":"public pure function equatorial_to_mean_ecliptic_rotmat(obliquity_func) result(rot) Rotation matrix from J2000 to Mean Ecliptic. Arguments Type Intent Optional Attributes Name procedure( mean_obliquity_func ), optional :: obliquity_func optional function to compute\nthe mean obliquity. If not\npresent, then mean_obliquity_of_ecliptic_iau1980 is used. Return Value real(kind=wp), dimension(3,3) rotation matrix Calls proc~~equatorial_to_mean_ecliptic_rotmat~~CallsGraph proc~equatorial_to_mean_ecliptic_rotmat equatorial_to_mean_ecliptic_rotmat proc~mean_ecliptic_to_equatorial_rotmat mean_ecliptic_to_equatorial_rotmat proc~equatorial_to_mean_ecliptic_rotmat->proc~mean_ecliptic_to_equatorial_rotmat proc~mean_obliquity_of_ecliptic_iau1980 mean_obliquity_of_ecliptic_iau1980 proc~mean_ecliptic_to_equatorial_rotmat->proc~mean_obliquity_of_ecliptic_iau1980 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~equatorial_to_mean_ecliptic_rotmat~~CalledByGraph proc~equatorial_to_mean_ecliptic_rotmat equatorial_to_mean_ecliptic_rotmat proc~get_c_cdot_ecliptic ecliptic_frame%get_c_cdot_ecliptic proc~get_c_cdot_ecliptic->proc~equatorial_to_mean_ecliptic_rotmat proc~transformation_module_test transformation_module_test proc~transformation_module_test->proc~get_c_cdot_ecliptic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function equatorial_to_mean_ecliptic_rotmat ( obliquity_func ) result ( rot ) implicit none real ( wp ), dimension ( 3 , 3 ) :: rot !! rotation matrix procedure ( mean_obliquity_func ), optional :: obliquity_func !! optional function to compute !! the mean obliquity. If not !! present, then !! [[mean_obliquity_of_ecliptic_iau1980]] !! is used. rot = transpose ( mean_ecliptic_to_equatorial_rotmat ( obliquity_func )) end function equatorial_to_mean_ecliptic_rotmat","tags":"","url":"proc/equatorial_to_mean_ecliptic_rotmat.html"},{"title":"mean_obliquity_of_ecliptic_iau2006 – fortran-astrodynamics-toolkit","text":"public pure function mean_obliquity_of_ecliptic_iau2006(et) result(e) Mean obliquity of the ecliptic, IAU 2006 formula. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: et ephemeris time (sec) Return Value real(kind=wp) obliquity of ecliptic (deg) Source Code pure function mean_obliquity_of_ecliptic_iau2006 ( et ) result ( e ) implicit none real ( wp ), intent ( in ) :: et !! ephemeris time (sec) real ( wp ) :: e !! obliquity of ecliptic (deg) real ( wp ) :: t !! time in centuries from the J2000 epoch real ( wp ), parameter , dimension ( 6 ) :: c = [ 8438 1.406_wp ,& - 4 6.836769_wp ,& - 0.0001831_wp ,& 0.00200340_wp ,& - 0.000000576_wp ,& - 0.0000000434_wp ] !! coefficients ! convert input time to centuries: t = et * sec2day * day2century ! use horner's rule: e = ( c ( 1 ) + t * ( c ( 2 ) + t * ( c ( 3 ) + t * ( c ( 4 ) + t * ( c ( 5 ) + t * c ( 6 )))))) * arcsec2deg end function mean_obliquity_of_ecliptic_iau2006","tags":"","url":"proc/mean_obliquity_of_ecliptic_iau2006.html"},{"title":"mean_obliquity_of_ecliptic_iau1980 – fortran-astrodynamics-toolkit","text":"public pure function mean_obliquity_of_ecliptic_iau1980(et) result(e) Mean obliquity of the ecliptic, IAU 1980 formula. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: et ephemeris time (sec) Return Value real(kind=wp) obliquity of ecliptic (deg) Called by proc~~mean_obliquity_of_ecliptic_iau1980~~CalledByGraph proc~mean_obliquity_of_ecliptic_iau1980 mean_obliquity_of_ecliptic_iau1980 proc~mean_ecliptic_to_equatorial_rotmat mean_ecliptic_to_equatorial_rotmat proc~mean_ecliptic_to_equatorial_rotmat->proc~mean_obliquity_of_ecliptic_iau1980 proc~equatorial_to_mean_ecliptic_rotmat equatorial_to_mean_ecliptic_rotmat proc~equatorial_to_mean_ecliptic_rotmat->proc~mean_ecliptic_to_equatorial_rotmat proc~get_c_cdot_ecliptic ecliptic_frame%get_c_cdot_ecliptic proc~get_c_cdot_ecliptic->proc~mean_ecliptic_to_equatorial_rotmat proc~get_c_cdot_ecliptic->proc~equatorial_to_mean_ecliptic_rotmat proc~transformation_module_test transformation_module_test proc~transformation_module_test->proc~get_c_cdot_ecliptic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function mean_obliquity_of_ecliptic_iau1980 ( et ) result ( e ) implicit none real ( wp ), intent ( in ) :: et !! ephemeris time (sec) real ( wp ) :: e !! obliquity of ecliptic (deg) real ( wp ) :: t !! time in centuries from the J2000 epoch real ( wp ), dimension ( 0 : 3 ), parameter :: c = [ 8438 1.448_wp ,& - 4 6.8150_wp ,& - 0.00059_wp ,& + 0.001813_wp ] !! coefficients ! convert input time to centuries: t = et * sec2day * day2century ! use horner's rule: e = ( c ( 0 ) + t * ( c ( 1 ) + t * ( c ( 2 ) + t * c ( 3 )))) * arcsec2deg end function mean_obliquity_of_ecliptic_iau1980","tags":"","url":"proc/mean_obliquity_of_ecliptic_iau1980.html"},{"title":"newton – fortran-astrodynamics-toolkit","text":"public  subroutine newton(x, f, dfdx, ftol, xtol, max_iter, xs, fx, iflag) Newton's method for root finding of scalar function f(x) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x initial point (initial guess) procedure( func ) :: f function f(x) procedure( func ) :: dfdx first derivative function f'(x) real(kind=wp), intent(in) :: ftol convergence tolerance for f(x) real(kind=wp), intent(in) :: xtol convergence tolerance for x integer, intent(in) :: max_iter the maximum number of iterations real(kind=wp), intent(out) :: xs the value where f(x) is zero real(kind=wp), intent(out) :: fx the value of f(x) at the root xs integer, intent(out) :: iflag status flag:\n 0 : absolute convergence in f\n 1 : relative convergence in x\n-1 : Error: derivative is zero\n-2 : Error: max iterations exceeded Called by proc~~newton~~CalledByGraph proc~newton newton proc~kepler_classical kepler_classical proc~kepler_classical->proc~newton Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine newton ( x , f , dfdx , ftol , xtol , max_iter , xs , fx , iflag ) implicit none real ( wp ), intent ( in ) :: x !! initial point (initial guess) procedure ( func ) :: f !! function f(x) procedure ( func ) :: dfdx !! first derivative function f'(x) real ( wp ), intent ( in ) :: ftol !! convergence tolerance for f(x) real ( wp ), intent ( in ) :: xtol !! convergence tolerance for x integer , intent ( in ) :: max_iter !! the maximum number of iterations real ( wp ), intent ( out ) :: xs !! the value where f(x) is zero real ( wp ), intent ( out ) :: fx !! the value of f(x) at the root xs integer , intent ( out ) :: iflag !! status flag: !!  0 : absolute convergence in f !!  1 : relative convergence in x !! -1 : Error: derivative is zero !! -2 : Error: max iterations exceeded real ( wp ) :: f1 , df1 , x1 , x1_prev integer :: iter real ( wp ), parameter :: alpha = one !! step factor x1 = x do iter = 1 , max_iter call f ( x1 , f1 ) if ( abs ( f1 ) <= ftol ) then iflag = 0 exit end if call dfdx ( x1 , df1 ) if ( df1 == zero ) then iflag = - 1 exit end if x1_prev = x1 x1 = x1 - alpha * ( f1 / df1 ) if ( abs ( x1_prev - x1 ) <= xtol ) then iflag = 1 exit end if end do ! max iterations exceeded if ( iter > max_iter ) iflag = - 2 !return results: xs = x1 fx = f1 end subroutine newton","tags":"","url":"proc/newton.html"},{"title":"complex_step_derivative – fortran-astrodynamics-toolkit","text":"public  subroutine complex_step_derivative(f, x, h, dfdx) Compute the first derivative using the complex-step method.\nThis is Equation 6 from Reference [1]. Arguments Type Intent Optional Attributes Name procedure( func ) :: f complex(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out) :: dfdx Called by proc~~complex_step_derivative~~CalledByGraph proc~complex_step_derivative complex_step_derivative proc~complex_step_test complex_step_test proc~complex_step_test->proc~complex_step_derivative Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine complex_step_derivative ( f , x , h , dfdx ) implicit none procedure ( func ) :: f complex ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: h real ( wp ), intent ( out ) :: dfdx dfdx = AIMAG ( f ( cmplx ( real ( x , wp ), AIMAG ( x ) + h , wp ))) / h end subroutine complex_step_derivative","tags":"","url":"proc/complex_step_derivative.html"},{"title":"forward_diff – fortran-astrodynamics-toolkit","text":"private  subroutine forward_diff(f, x, h, dfdx) Compute the first derivative using a forward difference.\nThis is Equation 1 from Reference [1]. Arguments Type Intent Optional Attributes Name procedure( func ) :: f complex(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out) :: dfdx Called by proc~~forward_diff~~CalledByGraph proc~forward_diff forward_diff proc~complex_step_test complex_step_test proc~complex_step_test->proc~forward_diff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine forward_diff ( f , x , h , dfdx ) implicit none procedure ( func ) :: f complex ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: h real ( wp ), intent ( out ) :: dfdx dfdx = ( f ( x + h ) - f ( x )) / h end subroutine forward_diff","tags":"","url":"proc/forward_diff.html"},{"title":"central_diff – fortran-astrodynamics-toolkit","text":"private  subroutine central_diff(f, x, h, dfdx) Compute the first derivative using a 2-point central difference [-h,h]. Arguments Type Intent Optional Attributes Name procedure( func ) :: f complex(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out) :: dfdx Called by proc~~central_diff~~CalledByGraph proc~central_diff central_diff proc~complex_step_test complex_step_test proc~complex_step_test->proc~central_diff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine central_diff ( f , x , h , dfdx ) implicit none procedure ( func ) :: f complex ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: h real ( wp ), intent ( out ) :: dfdx dfdx = ( f ( x + h ) - f ( x - h )) / ( 2.0_wp * h ) end subroutine central_diff","tags":"","url":"proc/central_diff.html"},{"title":"central_diff_4 – fortran-astrodynamics-toolkit","text":"private  subroutine central_diff_4(f, x, h, dfdx) Compute the first derivative using a 4-point central difference [-2h,-h,h,2h]. Arguments Type Intent Optional Attributes Name procedure( func ) :: f complex(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out) :: dfdx Called by proc~~central_diff_4~~CalledByGraph proc~central_diff_4 central_diff_4 proc~complex_step_test complex_step_test proc~complex_step_test->proc~central_diff_4 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine central_diff_4 ( f , x , h , dfdx ) implicit none procedure ( func ) :: f complex ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: h real ( wp ), intent ( out ) :: dfdx real ( wp ) :: h2 h2 = 2.0_wp * h dfdx = ( f ( x - h2 ) - 8.0_wp * f ( x - h ) + 8.0_wp * f ( x + h ) - f ( x + h2 )) / ( 1 2.0_wp * h ) end subroutine central_diff_4","tags":"","url":"proc/central_diff_4.html"},{"title":"complex_step_test – fortran-astrodynamics-toolkit","text":"public  subroutine complex_step_test() Unit test for the complex_step module. Arguments None Calls proc~~complex_step_test~~CallsGraph proc~complex_step_test complex_step_test proc~central_diff central_diff proc~complex_step_test->proc~central_diff proc~central_diff_4 central_diff_4 proc~complex_step_test->proc~central_diff_4 proc~complex_step_derivative complex_step_derivative proc~complex_step_test->proc~complex_step_derivative proc~forward_diff forward_diff proc~complex_step_test->proc~forward_diff Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine complex_step_test () implicit none integer :: i complex ( wp ) :: x real ( wp ) :: h , dfdx , dfdx2 , dfdx3 , dfdx4 , err , err2 , err3 , err4 write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' complex_step_test' write ( * , * ) '---------------' write ( * , * ) '' x = cmplx ( 2.0_wp , 0.0_wp , wp ) h = 1.0e-10_wp call complex_step_derivative ( test_func , x , h , dfdx ) !write(*,*) '' !write(*,*) 'x     :',x !write(*,*) 'dfdx  :',dfdx !write(*,*) 'error :',real(test_deriv(x),wp) - dfdx !write(*,*) '' write ( * , '(*(A30))' ) 'h' , 'forward diff err' , 'central diff err' , 'central diff 4 err' , 'complex step err' do i = 1 , 200 h = 1 0.0_wp ** ( - i / 1 0.0_wp ) call complex_step_derivative ( test_func , x , h , dfdx ) call forward_diff ( test_func , x , h , dfdx2 ) call central_diff ( test_func , x , h , dfdx3 ) call central_diff_4 ( test_func , x , h , dfdx4 ) err = real ( test_deriv ( x ), wp ) - dfdx err2 = real ( test_deriv ( x ), wp ) - dfdx2 err3 = real ( test_deriv ( x ), wp ) - dfdx3 err4 = real ( test_deriv ( x ), wp ) - dfdx4 write ( * , '(*(E30.16,1X))' ) h , err2 , err3 , err4 , err end do contains !***************************************************************************************** !**************************************** function test_func ( x ) result ( f ) implicit none complex ( wp ), intent ( in ) :: x complex ( wp ) :: f f = exp ( x ) + sin ( x ) end function test_func !**************************************** !**************************************** function test_deriv ( x ) result ( f ) implicit none complex ( wp ), intent ( in ) :: x complex ( wp ) :: f f = exp ( x ) + cos ( x ) end function test_deriv !**************************************** end subroutine complex_step_test","tags":"","url":"proc/complex_step_test.html"},{"title":"func – fortran-astrodynamics-toolkit","text":"interface private  function func(x) result(f) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x Return Value complex(kind=wp)","tags":"","url":"interface/func~2.html"},{"title":"third_body_gravity – fortran-astrodynamics-toolkit","text":"public  subroutine third_body_gravity(r, rb, mu, acc) Third-body (pointmass) gravitational acceleration. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r satellite position vector [km] real(kind=wp), intent(in), dimension(3) :: rb third-body position vector [km] real(kind=wp), intent(in) :: mu third-body gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(out), dimension(3) :: acc gravity acceleration vector [km/s&#94;2] Source Code subroutine third_body_gravity ( r , rb , mu , acc ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r !! satellite position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: rb !! third-body position vector [km] real ( wp ), intent ( in ) :: mu !! third-body gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( out ) :: acc !! gravity acceleration vector [km/s&#94;2] real ( wp ), dimension ( 3 ) :: r_sc_b !! vector from third-body to spacecraft [km] real ( wp ) :: rb_mag !! distance between origin and third-body [km] real ( wp ) :: r_sc_b_mag !! distance between spacecraft and third-body [km] r_sc_b = rb - r r_sc_b_mag = norm2 ( r_sc_b ) rb_mag = norm2 ( rb ) acc = ( mu / r_sc_b_mag ** 3 ) * r_sc_b - ( mu / rb_mag ** 3 ) * rb end subroutine third_body_gravity","tags":"","url":"proc/third_body_gravity.html"},{"title":"third_body_gravity_alt – fortran-astrodynamics-toolkit","text":"public  subroutine third_body_gravity_alt(r, rb, mu, acc) Third-body (pointmass) gravitational acceleration (alternate Battin formulation).\nSee Equation 8.61 in Battin. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r satellite position vector [km] real(kind=wp), intent(in), dimension(3) :: rb third-body position vector [km] real(kind=wp), intent(in) :: mu third-body gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(out), dimension(3) :: acc gravity acceleration vector [km/s&#94;2] Source Code subroutine third_body_gravity_alt ( r , rb , mu , acc ) real ( wp ), dimension ( 3 ), intent ( in ) :: r !! satellite position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: rb !! third-body position vector [km] real ( wp ), intent ( in ) :: mu !! third-body gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( out ) :: acc !! gravity acceleration vector [km/s&#94;2] real ( wp ) :: rb2 , q , f , tmp rb2 = dot_product ( rb , rb ) q = dot_product ( r , r - two * rb ) / rb2 tmp = ( one + q ) ** 1.5_wp f = q * ( three + three * q + q * q ) / ( one + tmp ) acc = - mu * ( r + f * rb ) / tmp / rb2 ** 1.5_wp end subroutine third_body_gravity_alt","tags":"","url":"proc/third_body_gravity_alt.html"},{"title":"gravity_j2_j3_j4 – fortran-astrodynamics-toolkit","text":"public  subroutine gravity_j2_j3_j4(r, mu, req, j2, j3, j4, acc) Gravitational acceleration due to simplified spherical harmonic\n  expansion (only the J2-J4 terms are used). Reference http://www.ni.com/pdf/manuals/370762a.pdf Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r satellite position vector [km] real(kind=wp), intent(in) :: mu central body gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: req body equatorial radius [km] real(kind=wp), intent(in) :: j2 j2 coefficient real(kind=wp), intent(in) :: j3 j3 coefficient real(kind=wp), intent(in) :: j4 j4 coefficient real(kind=wp), intent(out), dimension(3) :: acc gravity acceleration vector [km/s&#94;2] Source Code subroutine gravity_j2_j3_j4 ( r , mu , req , j2 , j3 , j4 , acc ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r !! satellite position vector [km] real ( wp ), intent ( in ) :: mu !! central body gravitational parameter [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: req !! body equatorial radius [km] real ( wp ), intent ( in ) :: j2 !! j2 coefficient real ( wp ), intent ( in ) :: j3 !! j3 coefficient real ( wp ), intent ( in ) :: j4 !! j4 coefficient real ( wp ), dimension ( 3 ), intent ( out ) :: acc !! gravity acceleration vector [km/s&#94;2] real ( wp ) :: mmor3 , reqor , reqor2 , reqor3 , reqor4 ,& rmag , rmag2 , rmag3 , rzor , rzor2 , rzor3 , rzor4 , c , d rmag2 = dot_product ( r , r ) rmag = sqrt ( rmag2 ) if ( rmag == zero ) then write ( output_unit , '(A)' ) 'Error in gravity_j2_j3_j4: spacecraft at center of body.' acc = zero else rmag3 = rmag * rmag2 mmor3 = - mu / rmag3 reqor = req / rmag reqor2 = reqor * reqor reqor3 = reqor2 * reqor reqor4 = reqor3 * reqor rzor = r ( 3 ) / rmag rzor2 = rzor * rzor rzor3 = rzor2 * rzor rzor4 = rzor3 * rzor c = mmor3 * ( 1.0_wp - 1.5_wp * J2 * reqor2 * ( 5.0_wp * rzor2 - 1.0_wp ) + & 2.5_wp * J3 * reqor3 * ( 3.0_wp * rzor - 7.0_wp * rzor3 ) - & 0.625_wp * J4 * reqor4 * ( 3.0_wp - 4 2.0_wp * rzor2 + 6 3.0_wp * rzor4 )) d = mmor3 * ( r ( 3 ) + 1.5_wp * J2 * reqor2 * ( 3.0_wp - 5.0_wp * rzor2 ) * r ( 3 ) + & 0.5_wp * J3 * reqor3 * ( 3 0.0_wp * rzor * r ( 3 ) - 3 5.0_wp * rzor3 * r ( 3 ) - 3.0_wp * rmag ) - & 0.625_wp * J4 * reqor4 * ( 1 5.0_wp - 7 0.0_wp * rzor2 + 6 3.0_wp * rzor4 ) * r ( 3 )) acc ( 1 ) = c * r ( 1 ) acc ( 2 ) = c * r ( 2 ) acc ( 3 ) = d end if end subroutine gravity_J2_J3_J4","tags":"","url":"proc/gravity_j2_j3_j4.html"},{"title":"cartesian_to_equinoctial – fortran-astrodynamics-toolkit","text":"public  subroutine cartesian_to_equinoctial(mu, rv, evec) Convert Cartesian coordinates to modified equinoctial elements (posigrade formulation). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu central body gravitational parameter ( ) real(kind=wp), intent(in), dimension(6) :: rv Cartesian state vector real(kind=wp), intent(out), dimension(6) :: evec Modified equinoctial element vector Calls proc~~cartesian_to_equinoctial~~CallsGraph proc~cartesian_to_equinoctial cartesian_to_equinoctial proc~cross cross proc~cartesian_to_equinoctial->proc~cross proc~unit unit proc~cartesian_to_equinoctial->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~cartesian_to_equinoctial~~CalledByGraph proc~cartesian_to_equinoctial cartesian_to_equinoctial proc~modified_equinoctial_test modified_equinoctial_test proc~modified_equinoctial_test->proc~cartesian_to_equinoctial Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine cartesian_to_equinoctial ( mu , rv , evec ) implicit none real ( wp ), intent ( in ) :: mu !! central body gravitational parameter (km&#94;3/s&#94;2) real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! Cartesian state vector real ( wp ), dimension ( 6 ), intent ( out ) :: evec !! Modified equinoctial element vector real ( wp ), dimension ( 3 ) :: r , v , hvec , hhat , ecc , fhat , ghat , rhat , vhat real ( wp ) :: hmag , rmag , p , f , g , h , k , L , kk , hh , s2 , tkh , rdv r = rv ( 1 : 3 ) v = rv ( 4 : 6 ) rdv = dot_product ( r , v ) rhat = unit ( r ) rmag = norm2 ( r ) hvec = cross ( r , v ) hmag = norm2 ( hvec ) hhat = unit ( hvec ) vhat = ( rmag * v - rdv * rhat ) / hmag p = hmag * hmag / mu k = hhat ( 1 ) / ( one + hhat ( 3 )) h = - hhat ( 2 ) / ( one + hhat ( 3 )) kk = k * k hh = h * h s2 = one + hh + kk tkh = two * k * h ecc = cross ( v , hvec ) / mu - rhat fhat ( 1 ) = one - kk + hh fhat ( 2 ) = tkh fhat ( 3 ) = - two * k ghat ( 1 ) = tkh ghat ( 2 ) = one + kk - hh ghat ( 3 ) = two * h fhat = fhat / s2 ghat = ghat / s2 f = dot_product ( ecc , fhat ) g = dot_product ( ecc , ghat ) L = atan2 ( rhat ( 2 ) - vhat ( 1 ), rhat ( 1 ) + vhat ( 2 )) evec = [ p , f , g , h , k , L ] end subroutine cartesian_to_equinoctial","tags":"","url":"proc/cartesian_to_equinoctial.html"},{"title":"equinoctial_to_cartesian – fortran-astrodynamics-toolkit","text":"public  subroutine equinoctial_to_cartesian(mu, evec, rv) Convert modified equinoctial elements (posigrade formulation) to Cartesian coordinates. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu central body gravitational parameter ( ) real(kind=wp), intent(in), dimension(6) :: evec Modified equinoctial element vector real(kind=wp), intent(out), dimension(6) :: rv Cartesian state vector Called by proc~~equinoctial_to_cartesian~~CalledByGraph proc~equinoctial_to_cartesian equinoctial_to_cartesian proc~modified_equinoctial_test modified_equinoctial_test proc~modified_equinoctial_test->proc~equinoctial_to_cartesian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine equinoctial_to_cartesian ( mu , evec , rv ) implicit none real ( wp ), intent ( in ) :: mu !! central body gravitational parameter (km&#94;3/s&#94;2) real ( wp ), dimension ( 6 ), intent ( in ) :: evec !! Modified equinoctial element vector real ( wp ), dimension ( 6 ), intent ( out ) :: rv !! Cartesian state vector real ( wp ) :: p , f , g , h , k , L , s2 , r , w , cL , sL , smp , hh , kk , tkh real ( wp ) :: x , y , xdot , ydot real ( wp ), dimension ( 3 ) :: fhat , ghat p = evec ( 1 ) f = evec ( 2 ) g = evec ( 3 ) h = evec ( 4 ) k = evec ( 5 ) L = evec ( 6 ) kk = k * k hh = h * h tkh = two * k * h s2 = one + hh + kk cL = cos ( L ) sL = sin ( L ) w = one + f * cL + g * sL r = p / w smp = sqrt ( mu / p ) fhat ( 1 ) = one - kk + hh fhat ( 2 ) = tkh fhat ( 3 ) = - two * k ghat ( 1 ) = tkh ghat ( 2 ) = one + kk - hh ghat ( 3 ) = two * h fhat = fhat / s2 ghat = ghat / s2 x = r * cL y = r * sL xdot = - smp * ( g + sL ) ydot = smp * ( f + cL ) rv ( 1 : 3 ) = x * fhat + y * ghat rv ( 4 : 6 ) = xdot * fhat + ydot * ghat end subroutine equinoctial_to_cartesian","tags":"","url":"proc/equinoctial_to_cartesian.html"},{"title":"modified_equinoctial_derivs – fortran-astrodynamics-toolkit","text":"public  subroutine modified_equinoctial_derivs(mu, evec, scn, evecd) Modified equinoctial elements (posigrade formulation) equations of motion. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu central body gravitational parameter ( ) real(kind=wp), intent(in), dimension(6) :: evec modified equinoctial element vector real(kind=wp), intent(in), dimension(3) :: scn Perturbation (in the RSW frame) real(kind=wp), intent(out), dimension(6) :: evecd derivative of evec Called by proc~~modified_equinoctial_derivs~~CalledByGraph proc~modified_equinoctial_derivs modified_equinoctial_derivs proc~modified_equinoctial_test modified_equinoctial_test proc~modified_equinoctial_test->proc~modified_equinoctial_derivs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine modified_equinoctial_derivs ( mu , evec , scn , evecd ) implicit none real ( wp ), intent ( in ) :: mu !! central body gravitational parameter (km&#94;3/s&#94;2) real ( wp ), dimension ( 6 ), intent ( in ) :: evec !! modified equinoctial element vector real ( wp ), dimension ( 3 ), intent ( in ) :: scn !! Perturbation (in the RSW frame) real ( wp ), dimension ( 6 ), intent ( out ) :: evecd !! derivative of `evec` real ( wp ) :: p , f , g , h , k , L , c , s , n , sqrtpm , sl , cl , s2no2w , s2 , w p = evec ( 1 ) f = evec ( 2 ) g = evec ( 3 ) h = evec ( 4 ) k = evec ( 5 ) L = evec ( 6 ) s = scn ( 1 ) c = scn ( 2 ) n = scn ( 3 ) sqrtpm = sqrt ( p / mu ) sl = sin ( L ) cl = cos ( L ) s2 = one + h * h + k * k w = one + f * cl + g * sl s2no2w = s2 * n / ( two * w ) evecd ( 1 ) = ( two * p * c / w ) * sqrtpm evecd ( 2 ) = sqrtpm * ( s * sl + (( w + one ) * cl + f ) * c / w - g * n * ( h * sl - k * cl ) / w ) evecd ( 3 ) = sqrtpm * ( - s * cl + (( w + one ) * sl + g ) * c / w + f * n * ( h * sl - k * cl ) / w ) evecd ( 4 ) = sqrtpm * s2no2w * cl evecd ( 5 ) = sqrtpm * s2no2w * sl evecd ( 6 ) = sqrt ( mu * p ) * ( w / p ) ** 2 + sqrtpm * (( h * sl - k * cl ) * n ) / w end subroutine modified_equinoctial_derivs","tags":"","url":"proc/modified_equinoctial_derivs.html"},{"title":"modified_equinoctial_test – fortran-astrodynamics-toolkit","text":"public  subroutine modified_equinoctial_test() Unit tests for the modified_equinoctial_module. Arguments None Calls proc~~modified_equinoctial_test~~CallsGraph proc~modified_equinoctial_test modified_equinoctial_test proc~cartesian_to_equinoctial cartesian_to_equinoctial proc~modified_equinoctial_test->proc~cartesian_to_equinoctial proc~equinoctial_to_cartesian equinoctial_to_cartesian proc~modified_equinoctial_test->proc~equinoctial_to_cartesian proc~modified_equinoctial_derivs modified_equinoctial_derivs proc~modified_equinoctial_test->proc~modified_equinoctial_derivs proc~cross cross proc~cartesian_to_equinoctial->proc~cross proc~unit unit proc~cartesian_to_equinoctial->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine modified_equinoctial_test () implicit none real ( wp ), parameter :: mu = 39860 0.436233_wp !! central body grav. parameter real ( wp ), dimension ( 6 ), parameter :: x0 = [ - 230 1.67224489839_wp , & - 537 1.07610250925_wp , & - 342 1.14671530212_wp , & 6.1338624555516_wp , & . 306265184163608_wp , & - 4.59713439017524_wp ] !! state vector real ( wp ), dimension ( 3 ), parameter :: scn = [ zero , zero , zero ] !! perturbation real ( wp ), dimension ( 6 ) :: e , ed , x2 write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' modified_equinoctial_test' write ( * , * ) '---------------' write ( * , * ) '' call cartesian_to_equinoctial ( mu , x0 , e ) call equinoctial_to_cartesian ( mu , e , x2 ) call modified_equinoctial_derivs ( mu , e , scn , ed ) write ( * , '(A,1X,*(F20.6,1X))' ) 'x:       ' , x0 write ( * , '(A,1X,*(F20.6,1X))' ) 'x2:      ' , x2 write ( * , '(A,1X,*(F20.6,1X))' ) 'x error: ' , x2 - x0 write ( * , '(A,1X,*(F20.6,1X))' ) 'e:       ' , e write ( * , '(A,1X,*(F20.6,1X))' ) 'ed:      ' , ed end subroutine modified_equinoctial_test","tags":"","url":"proc/modified_equinoctial_test.html"},{"title":"cross – fortran-astrodynamics-toolkit","text":"public pure function cross(r, v) result(rxv) Cross product of two 3x1 vectors Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r real(kind=wp), intent(in), dimension(3) :: v Return Value real(kind=wp), dimension(3) Called by proc~~cross~~CalledByGraph proc~cross cross proc~angle_between_vectors angle_between_vectors proc~angle_between_vectors->proc~cross proc~apparent_position apparent_position proc~apparent_position->proc~cross proc~axis_angle_rotation axis_angle_rotation proc~apparent_position->proc~axis_angle_rotation proc~axis_angle_rotation->proc~cross proc~box_product box_product proc~box_product->proc~cross proc~bplane bplane proc~bplane->proc~cross proc~ucross ucross proc~bplane->proc~ucross proc~calculate_bplane_data calculate_bplane_data proc~calculate_bplane_data->proc~cross proc~cartesian_to_equinoctial cartesian_to_equinoctial proc~cartesian_to_equinoctial->proc~cross proc~compute_vinf_vectors compute_vinf_vectors proc~compute_vinf_vectors->proc~cross proc~distance_from_point_to_line distance_from_point_to_line proc~distance_from_point_to_line->proc~cross proc~from_ijk_to_lvlh_mat from_ijk_to_lvlh_mat proc~from_ijk_to_lvlh_mat->proc~cross proc~from_ijk_to_rsw_mat from_ijk_to_rsw_mat proc~from_ijk_to_rsw_mat->proc~cross proc~from_ijk_to_vuw_mat from_ijk_to_vuw_mat proc~from_ijk_to_vuw_mat->proc~cross proc~get_c_cdot_two_body_rotating two_body_rotating_frame%get_c_cdot_two_body_rotating proc~get_c_cdot_two_body_rotating->proc~cross proc~rv_to_orbital_elements rv_to_orbital_elements proc~rv_to_orbital_elements->proc~cross proc~solve_lambert_gooding solve_lambert_gooding proc~solve_lambert_gooding->proc~cross proc~ucross->proc~cross interface~from_ijk_to_lvlh from_ijk_to_lvlh interface~from_ijk_to_lvlh->proc~from_ijk_to_lvlh_mat interface~from_ijk_to_rsw from_ijk_to_rsw interface~from_ijk_to_rsw->proc~from_ijk_to_rsw_mat interface~from_ijk_to_vuw from_ijk_to_vuw interface~from_ijk_to_vuw->proc~from_ijk_to_vuw_mat proc~bplane_test bplane_test proc~bplane_test->proc~bplane proc~bplane_test->proc~calculate_bplane_data proc~bplane_test->proc~compute_vinf_vectors proc~get_c_cdot_two_body_rotating_pulsating two_body_rotating_pulsating_frame%get_c_cdot_two_body_rotating_pulsating proc~get_c_cdot_two_body_rotating_pulsating->proc~get_c_cdot_two_body_rotating proc~get_sun_fraction get_sun_fraction proc~get_sun_fraction->proc~apparent_position proc~lambert_test lambert_test proc~lambert_test->proc~solve_lambert_gooding proc~solve_lambert_izzo solve_lambert_izzo proc~lambert_test->proc~solve_lambert_izzo proc~modified_equinoctial_test modified_equinoctial_test proc~modified_equinoctial_test->proc~cartesian_to_equinoctial proc~solve_lambert_izzo->proc~ucross proc~sphere_of_influence_earth_moon sphere_of_influence_earth_moon proc~sphere_of_influence_earth_moon->proc~angle_between_vectors proc~vector_test vector_test proc~vector_test->proc~axis_angle_rotation proc~from_lvlh_to_ijk_mat from_lvlh_to_ijk_mat proc~from_lvlh_to_ijk_mat->interface~from_ijk_to_lvlh proc~from_rsw_to_ijk_mat from_rsw_to_ijk_mat proc~from_rsw_to_ijk_mat->interface~from_ijk_to_rsw proc~from_vuw_to_ijk_mat from_vuw_to_ijk_mat proc~from_vuw_to_ijk_mat->interface~from_ijk_to_vuw proc~relative_motion_test relative_motion_test proc~relative_motion_test->interface~from_ijk_to_lvlh proc~relative_motion_test->interface~from_ijk_to_rsw interface~from_lvlh_to_ijk from_lvlh_to_ijk interface~from_lvlh_to_ijk->proc~from_lvlh_to_ijk_mat interface~from_rsw_to_ijk from_rsw_to_ijk interface~from_rsw_to_ijk->proc~from_rsw_to_ijk_mat interface~from_vuw_to_ijk from_vuw_to_ijk interface~from_vuw_to_ijk->proc~from_vuw_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function cross ( r , v ) result ( rxv ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r real ( wp ), dimension ( 3 ), intent ( in ) :: v real ( wp ), dimension ( 3 ) :: rxv rxv = [ r ( 2 ) * v ( 3 ) - v ( 2 ) * r ( 3 ), & r ( 3 ) * v ( 1 ) - v ( 3 ) * r ( 1 ), & r ( 1 ) * v ( 2 ) - v ( 1 ) * r ( 2 ) ] end function cross","tags":"","url":"proc/cross.html"},{"title":"unit – fortran-astrodynamics-toolkit","text":"public pure function unit(r) result(u) Unit vector Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: r Return Value real(kind=wp), dimension(size(r)) Called by proc~~unit~~CalledByGraph proc~unit unit proc~apparent_position apparent_position proc~apparent_position->proc~unit proc~axis_angle_rotation axis_angle_rotation proc~apparent_position->proc~axis_angle_rotation proc~axis_angle_rotation->proc~unit proc~axis_angle_rotation_to_rotation_matrix axis_angle_rotation_to_rotation_matrix proc~axis_angle_rotation_to_rotation_matrix->proc~unit proc~bplane bplane proc~bplane->proc~unit proc~ucross ucross proc~bplane->proc~ucross proc~calculate_bplane_data calculate_bplane_data proc~calculate_bplane_data->proc~unit proc~cartesian_to_equinoctial cartesian_to_equinoctial proc~cartesian_to_equinoctial->proc~unit proc~cubic_shadow_model cubic_shadow_model proc~cubic_shadow_model->proc~unit proc~from_ijk_to_lvlh_mat from_ijk_to_lvlh_mat proc~from_ijk_to_lvlh_mat->proc~unit proc~from_ijk_to_rsw_mat from_ijk_to_rsw_mat proc~from_ijk_to_rsw_mat->proc~unit proc~from_ijk_to_vuw_mat from_ijk_to_vuw_mat proc~from_ijk_to_vuw_mat->proc~unit proc~get_c_cdot_two_body_rotating two_body_rotating_frame%get_c_cdot_two_body_rotating proc~get_c_cdot_two_body_rotating->proc~unit proc~solar_fraction solar_fraction proc~solar_fraction->proc~unit proc~solar_fraction_alt solar_fraction_alt proc~solar_fraction_alt->proc~unit proc~solar_fraction_alt2 solar_fraction_alt2 proc~solar_fraction_alt2->proc~unit proc~solve_lambert_gooding solve_lambert_gooding proc~solve_lambert_gooding->proc~unit proc~solve_lambert_izzo solve_lambert_izzo proc~solve_lambert_izzo->proc~unit proc~solve_lambert_izzo->proc~ucross proc~ucross->proc~unit interface~from_ijk_to_lvlh from_ijk_to_lvlh interface~from_ijk_to_lvlh->proc~from_ijk_to_lvlh_mat interface~from_ijk_to_rsw from_ijk_to_rsw interface~from_ijk_to_rsw->proc~from_ijk_to_rsw_mat interface~from_ijk_to_vuw from_ijk_to_vuw interface~from_ijk_to_vuw->proc~from_ijk_to_vuw_mat proc~bplane_test bplane_test proc~bplane_test->proc~bplane proc~bplane_test->proc~calculate_bplane_data proc~get_c_cdot_two_body_rotating_pulsating two_body_rotating_pulsating_frame%get_c_cdot_two_body_rotating_pulsating proc~get_c_cdot_two_body_rotating_pulsating->proc~get_c_cdot_two_body_rotating proc~get_sun_fraction get_sun_fraction proc~get_sun_fraction->proc~apparent_position proc~get_sun_fraction->proc~cubic_shadow_model proc~get_sun_fraction->proc~solar_fraction proc~get_sun_fraction->proc~solar_fraction_alt proc~get_sun_fraction->proc~solar_fraction_alt2 proc~lambert_test lambert_test proc~lambert_test->proc~solve_lambert_gooding proc~lambert_test->proc~solve_lambert_izzo proc~lighting_module_test lighting_module_test proc~lighting_module_test->proc~solar_fraction proc~lighting_module_test->proc~solar_fraction_alt proc~lighting_module_test->proc~solar_fraction_alt2 proc~modified_equinoctial_test modified_equinoctial_test proc~modified_equinoctial_test->proc~cartesian_to_equinoctial proc~vector_test vector_test proc~vector_test->proc~axis_angle_rotation proc~vector_test->proc~axis_angle_rotation_to_rotation_matrix proc~from_lvlh_to_ijk_mat from_lvlh_to_ijk_mat proc~from_lvlh_to_ijk_mat->interface~from_ijk_to_lvlh proc~from_rsw_to_ijk_mat from_rsw_to_ijk_mat proc~from_rsw_to_ijk_mat->interface~from_ijk_to_rsw proc~from_vuw_to_ijk_mat from_vuw_to_ijk_mat proc~from_vuw_to_ijk_mat->interface~from_ijk_to_vuw proc~relative_motion_test relative_motion_test proc~relative_motion_test->interface~from_ijk_to_lvlh proc~relative_motion_test->interface~from_ijk_to_rsw interface~from_lvlh_to_ijk from_lvlh_to_ijk interface~from_lvlh_to_ijk->proc~from_lvlh_to_ijk_mat interface~from_rsw_to_ijk from_rsw_to_ijk interface~from_rsw_to_ijk->proc~from_rsw_to_ijk_mat interface~from_vuw_to_ijk from_vuw_to_ijk interface~from_vuw_to_ijk->proc~from_vuw_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function unit ( r ) result ( u ) implicit none real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension ( size ( r )) :: u real ( wp ) :: rmag rmag = norm2 ( r ) if ( rmag == zero ) then u = zero else u = r / rmag end if end function unit","tags":"","url":"proc/unit.html"},{"title":"uhat_dot – fortran-astrodynamics-toolkit","text":"public pure function uhat_dot(u, udot) result(uhatd) Time derivative of a unit vector. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: u vector [ u ] real(kind=wp), intent(in), dimension(3) :: udot derivative of vector [ du/dt ] Return Value real(kind=wp), dimension(3) derivative of unit vector [ d(uhat)/dt ] Called by proc~~uhat_dot~~CalledByGraph proc~uhat_dot uhat_dot proc~from_ijk_to_lvlh_mat from_ijk_to_lvlh_mat proc~from_ijk_to_lvlh_mat->proc~uhat_dot proc~from_ijk_to_rsw_mat from_ijk_to_rsw_mat proc~from_ijk_to_rsw_mat->proc~uhat_dot proc~from_ijk_to_vuw_mat from_ijk_to_vuw_mat proc~from_ijk_to_vuw_mat->proc~uhat_dot interface~from_ijk_to_lvlh from_ijk_to_lvlh interface~from_ijk_to_lvlh->proc~from_ijk_to_lvlh_mat interface~from_ijk_to_rsw from_ijk_to_rsw interface~from_ijk_to_rsw->proc~from_ijk_to_rsw_mat interface~from_ijk_to_vuw from_ijk_to_vuw interface~from_ijk_to_vuw->proc~from_ijk_to_vuw_mat proc~from_lvlh_to_ijk_mat from_lvlh_to_ijk_mat proc~from_lvlh_to_ijk_mat->interface~from_ijk_to_lvlh proc~from_rsw_to_ijk_mat from_rsw_to_ijk_mat proc~from_rsw_to_ijk_mat->interface~from_ijk_to_rsw proc~from_vuw_to_ijk_mat from_vuw_to_ijk_mat proc~from_vuw_to_ijk_mat->interface~from_ijk_to_vuw proc~relative_motion_test relative_motion_test proc~relative_motion_test->interface~from_ijk_to_lvlh proc~relative_motion_test->interface~from_ijk_to_rsw interface~from_lvlh_to_ijk from_lvlh_to_ijk interface~from_lvlh_to_ijk->proc~from_lvlh_to_ijk_mat interface~from_rsw_to_ijk from_rsw_to_ijk interface~from_rsw_to_ijk->proc~from_rsw_to_ijk_mat interface~from_vuw_to_ijk from_vuw_to_ijk interface~from_vuw_to_ijk->proc~from_vuw_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function uhat_dot ( u , udot ) result ( uhatd ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: u !! vector [`u`] real ( wp ), dimension ( 3 ), intent ( in ) :: udot !! derivative of vector [`du/dt`] real ( wp ), dimension ( 3 ) :: uhatd !! derivative of unit vector [`d(uhat)/dt`] real ( wp ) :: umag !! vector magnitude real ( wp ), dimension ( 3 ) :: uhat !! unit vector umag = norm2 ( u ) if ( umag == zero ) then !singularity uhatd = zero else uhat = u / umag uhatd = ( udot - dot_product ( uhat , udot ) * uhat ) / umag end if end function uhat_dot","tags":"","url":"proc/uhat_dot.html"},{"title":"ucross – fortran-astrodynamics-toolkit","text":"public pure function ucross(v1, v2) result(u) Unit vector of the cross product of two 3x1 vectors Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: v1 real(kind=wp), intent(in), dimension(3) :: v2 Return Value real(kind=wp), dimension(3) Calls proc~~ucross~~CallsGraph proc~ucross ucross proc~cross cross proc~ucross->proc~cross proc~unit unit proc~ucross->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ucross~~CalledByGraph proc~ucross ucross proc~bplane bplane proc~bplane->proc~ucross proc~solve_lambert_izzo solve_lambert_izzo proc~solve_lambert_izzo->proc~ucross proc~bplane_test bplane_test proc~bplane_test->proc~bplane proc~lambert_test lambert_test proc~lambert_test->proc~solve_lambert_izzo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function ucross ( v1 , v2 ) result ( u ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: v1 real ( wp ), dimension ( 3 ), intent ( in ) :: v2 real ( wp ), dimension ( 3 ) :: u u = unit ( cross ( v1 , v2 )) end function ucross","tags":"","url":"proc/ucross.html"},{"title":"cross_matrix – fortran-astrodynamics-toolkit","text":"public pure function cross_matrix(r) result(rcross) Computes the cross product matrix, where: cross(a,b) == matmul(cross_matrix(a),b) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r Return Value real(kind=wp), dimension(3,3) Called by proc~~cross_matrix~~CalledByGraph proc~cross_matrix cross_matrix proc~axis_angle_rotation_to_rotation_matrix axis_angle_rotation_to_rotation_matrix proc~axis_angle_rotation_to_rotation_matrix->proc~cross_matrix proc~get_c_cdot_two_body_rotating two_body_rotating_frame%get_c_cdot_two_body_rotating proc~get_c_cdot_two_body_rotating->proc~cross_matrix proc~get_c_cdot_two_body_rotating_pulsating two_body_rotating_pulsating_frame%get_c_cdot_two_body_rotating_pulsating proc~get_c_cdot_two_body_rotating_pulsating->proc~get_c_cdot_two_body_rotating proc~vector_test vector_test proc~vector_test->proc~axis_angle_rotation_to_rotation_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function cross_matrix ( r ) result ( rcross ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r real ( wp ), dimension ( 3 , 3 ) :: rcross rcross (:, 1 ) = [ zero , r ( 3 ), - r ( 2 )] rcross (:, 2 ) = [ - r ( 3 ), zero , r ( 1 )] rcross (:, 3 ) = [ r ( 2 ), - r ( 1 ), zero ] end function cross_matrix","tags":"","url":"proc/cross_matrix.html"},{"title":"outer_product – fortran-astrodynamics-toolkit","text":"public pure function outer_product(a, b) result(c) Computes the outer product of the two vectors. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: a real(kind=wp), intent(in), dimension(:) :: b Return Value real(kind=wp), dimension(size(a),size(b)) Source Code pure function outer_product ( a , b ) result ( c ) implicit none real ( wp ), dimension (:), intent ( in ) :: a real ( wp ), dimension (:), intent ( in ) :: b real ( wp ), dimension ( size ( a ), size ( b )) :: c integer :: i do i = 1 , size ( b ) c (:, i ) = a * b ( i ) end do end function outer_product","tags":"","url":"proc/outer_product.html"},{"title":"box_product – fortran-astrodynamics-toolkit","text":"public pure function box_product(a, b, c) result(d) Computes the box product (scalar triple product) of the three vectors. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: a real(kind=wp), intent(in), dimension(:) :: b real(kind=wp), intent(in), dimension(:) :: c Return Value real(kind=wp) Calls proc~~box_product~~CallsGraph proc~box_product box_product proc~cross cross proc~box_product->proc~cross Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function box_product ( a , b , c ) result ( d ) implicit none real ( wp ), dimension (:), intent ( in ) :: a real ( wp ), dimension (:), intent ( in ) :: b real ( wp ), dimension (:), intent ( in ) :: c real ( wp ) :: d d = dot_product ( a , cross ( b , c )) end function box_product","tags":"","url":"proc/box_product.html"},{"title":"vector_projection – fortran-astrodynamics-toolkit","text":"public pure function vector_projection(a, b) result(c) The projection of one vector onto another vector. Reference Wikipedia Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: a the original vector real(kind=wp), intent(in), dimension(size(a)) :: b the vector to project on to Return Value real(kind=wp), dimension(size(a)) the projection of a onto b Called by proc~~vector_projection~~CalledByGraph proc~vector_projection vector_projection proc~vector_projection_on_plane vector_projection_on_plane proc~vector_projection_on_plane->proc~vector_projection Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function vector_projection ( a , b ) result ( c ) implicit none real ( wp ), dimension (:), intent ( in ) :: a !! the original vector real ( wp ), dimension ( size ( a )), intent ( in ) :: b !! the vector to project on to real ( wp ), dimension ( size ( a )) :: c !! the projection of a onto b real ( wp ) :: bmag2 bmag2 = dot_product ( b , b ) if ( bmag2 == zero ) then c = zero else c = b * dot_product ( a , b ) / bmag2 end if end function vector_projection","tags":"","url":"proc/vector_projection.html"},{"title":"spherical_to_cartesian – fortran-astrodynamics-toolkit","text":"public pure function spherical_to_cartesian(r, alpha, beta) result(rvec) Convert spherical (r,alpha,beta) to Cartesian (x,y,z). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r magnitude real(kind=wp), intent(in) :: alpha right ascension [rad] real(kind=wp), intent(in) :: beta declination [rad] Return Value real(kind=wp), dimension(3) [x,y,z] vector Called by proc~~spherical_to_cartesian~~CalledByGraph proc~spherical_to_cartesian spherical_to_cartesian proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->proc~spherical_to_cartesian Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function spherical_to_cartesian ( r , alpha , beta ) result ( rvec ) implicit none real ( wp ), intent ( in ) :: r !! magnitude real ( wp ), intent ( in ) :: alpha !! right ascension [rad] real ( wp ), intent ( in ) :: beta !! declination [rad] real ( wp ), dimension ( 3 ) :: rvec !! [x,y,z] vector rvec ( 1 ) = r * cos ( alpha ) * cos ( beta ) rvec ( 2 ) = r * sin ( alpha ) * cos ( beta ) rvec ( 3 ) = r * sin ( beta ) end function spherical_to_cartesian","tags":"","url":"proc/spherical_to_cartesian.html"},{"title":"rotation_matrix – fortran-astrodynamics-toolkit","text":"public pure function rotation_matrix(axis, angle) result(rotmat) The 3x3 rotation matrix for a rotation about the x, y, or z-axis. EXAMPLE real ( wp ), dimension ( 3 , 3 ) :: rotmat real ( wp ), dimension ( 3 ) :: vec , vec2 real ( wp ) :: ang ang = pi / 4.0_wp vec = [ 1.414_wp , 0.0_wp , 0.0_wp ] rotmat = rotation_matrix ( z_axis , ang ) vec2 = matmul ( rotmat , vec ) Arguments Type Intent Optional Attributes Name integer, intent(in) :: axis x_axis, y_axis, or z_axis real(kind=wp), intent(in) :: angle angle in radians Return Value real(kind=wp), dimension(3,3) the rotation matrix Called by proc~~rotation_matrix~~CalledByGraph proc~rotation_matrix rotation_matrix proc~iau_rotation_matrix iau_rotation_matrix proc~iau_rotation_matrix->proc~rotation_matrix proc~vector_test vector_test proc~vector_test->proc~rotation_matrix proc~icrf_to_iau_earth icrf_to_iau_earth proc~icrf_to_iau_earth->proc~iau_rotation_matrix proc~icrf_to_iau_moon icrf_to_iau_moon proc~icrf_to_iau_moon->proc~iau_rotation_matrix proc~get_c_cdot_iau_earth iau_earth_rotating_frame%get_c_cdot_iau_earth proc~get_c_cdot_iau_earth->proc~icrf_to_iau_earth proc~get_c_cdot_iau_moon iau_moon_rotating_frame%get_c_cdot_iau_moon proc~get_c_cdot_iau_moon->proc~icrf_to_iau_moon proc~iau_test iau_test proc~iau_test->proc~icrf_to_iau_earth proc~iau_test->proc~icrf_to_iau_moon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function rotation_matrix ( axis , angle ) result ( rotmat ) implicit none real ( wp ), dimension ( 3 , 3 ) :: rotmat !! the rotation matrix integer , intent ( in ) :: axis !! x_axis, y_axis, or z_axis real ( wp ), intent ( in ) :: angle !! angle in radians real ( wp ) :: c , s !precompute these: c = cos ( angle ) s = sin ( angle ) select case ( axis ) case ( x_axis ); rotmat = reshape ([ one , zero , zero , zero , c , - s , zero , s , c ],[ 3 , 3 ]) case ( y_axis ); rotmat = reshape ([ c , zero , s , zero , one , zero , - s , zero , c ],[ 3 , 3 ]) case ( z_axis ); rotmat = reshape ([ c , - s , zero , s , c , zero , zero , zero , one ],[ 3 , 3 ]) case default ; rotmat = zero end select end function rotation_matrix","tags":"","url":"proc/rotation_matrix.html"},{"title":"rotation_matrix_dot – fortran-astrodynamics-toolkit","text":"public pure function rotation_matrix_dot(axis, angle, angledot) result(rotmatdot) Time derivative of the 3x3 rotation matrix\nfor a rotation about the x, y, or z-axis. Arguments Type Intent Optional Attributes Name integer, intent(in) :: axis x_axis, y_axis, or z_axis real(kind=wp), intent(in) :: angle angle in radians real(kind=wp), intent(in) :: angledot time derivative of angle in radians/sec Return Value real(kind=wp), dimension(3,3) the rotation matrix derivative Source Code pure function rotation_matrix_dot ( axis , angle , angledot ) result ( rotmatdot ) implicit none real ( wp ), dimension ( 3 , 3 ) :: rotmatdot !! the rotation matrix derivative  d \\mathbf{C} / d t  integer , intent ( in ) :: axis !! x_axis, y_axis, or z_axis real ( wp ), intent ( in ) :: angle !! angle in radians real ( wp ), intent ( in ) :: angledot !! time derivative of angle in radians/sec real ( wp ) :: c , s !precompute these: c = cos ( angle ) s = sin ( angle ) !first compute d[C]/da (time derivate w.r.t. the angle): select case ( axis ) case ( x_axis ); rotmatdot = reshape ([ zero , zero , zero , zero , - s , - c , zero , c , - s ],[ 3 , 3 ]) case ( y_axis ); rotmatdot = reshape ([ - s , zero , c , zero , zero , zero , - c , zero , - s ],[ 3 , 3 ]) case ( z_axis ); rotmatdot = reshape ([ - s , - c , zero , c , - s , zero , zero , zero , zero ],[ 3 , 3 ]) case default rotmatdot = zero return end select rotmatdot = rotmatdot * angledot ! d[C]/dt = d[C]/da * da/dt end function rotation_matrix_dot","tags":"","url":"proc/rotation_matrix_dot.html"},{"title":"angle_between_vectors – fortran-astrodynamics-toolkit","text":"public pure function angle_between_vectors(v1, v2) result(ang) The angle between two vectors (in radians). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: v1 real(kind=wp), intent(in), dimension(3) :: v2 Return Value real(kind=wp) [rad] Calls proc~~angle_between_vectors~~CallsGraph proc~angle_between_vectors angle_between_vectors proc~cross cross proc~angle_between_vectors->proc~cross Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~angle_between_vectors~~CalledByGraph proc~angle_between_vectors angle_between_vectors proc~sphere_of_influence_earth_moon sphere_of_influence_earth_moon proc~sphere_of_influence_earth_moon->proc~angle_between_vectors Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function angle_between_vectors ( v1 , v2 ) result ( ang ) implicit none real ( wp ) :: ang !! [rad] real ( wp ), dimension ( 3 ), intent ( in ) :: v1 real ( wp ), dimension ( 3 ), intent ( in ) :: v2 real ( wp ) :: d , c d = dot_product ( v1 , v2 ) c = norm2 ( cross ( v1 , v2 )) ang = atan2 ( c , d ) end function angle_between_vectors","tags":"","url":"proc/angle_between_vectors.html"},{"title":"axis_angle_rotation – fortran-astrodynamics-toolkit","text":"public pure subroutine axis_angle_rotation(v, k, theta, vrot) Rotate a 3x1 vector in space, given an axis and angle of rotation. Reference Wikipedia Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: v vector to rotate real(kind=wp), intent(in), dimension(3) :: k rotation axis real(kind=wp), intent(in) :: theta rotation angle [rad] real(kind=wp), intent(out), dimension(3) :: vrot result Calls proc~~axis_angle_rotation~~CallsGraph proc~axis_angle_rotation axis_angle_rotation proc~cross cross proc~axis_angle_rotation->proc~cross proc~unit unit proc~axis_angle_rotation->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~axis_angle_rotation~~CalledByGraph proc~axis_angle_rotation axis_angle_rotation proc~apparent_position apparent_position proc~apparent_position->proc~axis_angle_rotation proc~vector_test vector_test proc~vector_test->proc~axis_angle_rotation proc~get_sun_fraction get_sun_fraction proc~get_sun_fraction->proc~apparent_position Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine axis_angle_rotation ( v , k , theta , vrot ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: v !! vector to rotate real ( wp ), dimension ( 3 ), intent ( in ) :: k !! rotation axis real ( wp ), intent ( in ) :: theta !! rotation angle [rad] real ( wp ), dimension ( 3 ), intent ( out ) :: vrot !! result real ( wp ), dimension ( 3 ) :: khat real ( wp ) :: ct , st ct = cos ( theta ) st = sin ( theta ) khat = unit ( k ) !rotation axis unit vector vrot = v * ct + cross ( khat , v ) * st + khat * dot_product ( khat , v ) * ( one - ct ) end subroutine axis_angle_rotation","tags":"","url":"proc/axis_angle_rotation.html"},{"title":"vector_projection_on_plane – fortran-astrodynamics-toolkit","text":"public pure subroutine vector_projection_on_plane(a, b, c) Project a vector onto a plane. Reference Projection of a Vector onto a Plane Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: a the original vector real(kind=wp), intent(in), dimension(3) :: b the plane to project on to (a normal vector) real(kind=wp), intent(out), dimension(3) :: c the projection of a onto the b plane Calls proc~~vector_projection_on_plane~~CallsGraph proc~vector_projection_on_plane vector_projection_on_plane proc~vector_projection vector_projection proc~vector_projection_on_plane->proc~vector_projection Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine vector_projection_on_plane ( a , b , c ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: a !! the original vector real ( wp ), dimension ( 3 ), intent ( in ) :: b !! the plane to project on to (a normal vector) real ( wp ), dimension ( 3 ), intent ( out ) :: c !! the projection of a onto the b plane c = a - vector_projection ( a , b ) end subroutine vector_projection_on_plane","tags":"","url":"proc/vector_projection_on_plane.html"},{"title":"axis_angle_rotation_to_rotation_matrix – fortran-astrodynamics-toolkit","text":"public pure subroutine axis_angle_rotation_to_rotation_matrix(k, theta, rotmat) Computes the rotation matrix that corresponds to a\nrotation about the axis k by an angle theta . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: k rotation axis real(kind=wp), intent(in) :: theta rotation angle [rad] real(kind=wp), intent(out), dimension(3,3) :: rotmat rotation matrix Calls proc~~axis_angle_rotation_to_rotation_matrix~~CallsGraph proc~axis_angle_rotation_to_rotation_matrix axis_angle_rotation_to_rotation_matrix proc~cross_matrix cross_matrix proc~axis_angle_rotation_to_rotation_matrix->proc~cross_matrix proc~unit unit proc~axis_angle_rotation_to_rotation_matrix->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~axis_angle_rotation_to_rotation_matrix~~CalledByGraph proc~axis_angle_rotation_to_rotation_matrix axis_angle_rotation_to_rotation_matrix proc~vector_test vector_test proc~vector_test->proc~axis_angle_rotation_to_rotation_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine axis_angle_rotation_to_rotation_matrix ( k , theta , rotmat ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: k !! rotation axis real ( wp ), intent ( in ) :: theta !! rotation angle [rad] real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: rotmat !! rotation matrix real ( wp ), dimension ( 3 , 3 ), parameter :: I = & reshape ([ one , zero , zero , zero , one , zero , zero , zero , one ],[ 3 , 3 ]) !! 3x3 identity matrix real ( wp ), dimension ( 3 , 3 ) :: w real ( wp ), dimension ( 3 ) :: khat real ( wp ) :: ct , st ct = cos ( theta ) st = sin ( theta ) khat = unit ( k ) w = cross_matrix ( khat ) rotmat = I + w * st + matmul ( w , w ) * ( one - ct ) end subroutine axis_angle_rotation_to_rotation_matrix","tags":"","url":"proc/axis_angle_rotation_to_rotation_matrix.html"},{"title":"cartesian_to_spherical – fortran-astrodynamics-toolkit","text":"public pure subroutine cartesian_to_spherical(rvec, r, alpha, beta) Convert Cartesian (x,y,z) to spherical (r,alpha,beta). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: rvec [x,y,z] vector real(kind=wp), intent(out) :: r magnitude real(kind=wp), intent(out) :: alpha right ascension [rad] real(kind=wp), intent(out) :: beta declination [rad] Source Code pure subroutine cartesian_to_spherical ( rvec , r , alpha , beta ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: rvec !! [x,y,z] vector real ( wp ), intent ( out ) :: r !! magnitude real ( wp ), intent ( out ) :: alpha !! right ascension [rad] real ( wp ), intent ( out ) :: beta !! declination [rad] real ( wp ) :: r1 r1 = rvec ( 1 ) * rvec ( 1 ) + rvec ( 2 ) * rvec ( 2 ) r = sqrt ( r1 + rvec ( 3 ) * rvec ( 3 )) if ( r /= zero ) then beta = atan2 ( rvec ( 3 ), sqrt ( r1 )) if ( r1 /= zero ) then alpha = atan2 ( rvec ( 2 ), rvec ( 1 )) else alpha = zero end if else alpha = zero beta = zero end if end subroutine cartesian_to_spherical","tags":"","url":"proc/cartesian_to_spherical.html"},{"title":"fill_vector_with_vector – fortran-astrodynamics-toolkit","text":"private  subroutine fill_vector_with_vector(x, vals, i) Put the vector in the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: vals integer, intent(inout) :: i should be initialized to 0 before the first call Calls proc~~fill_vector_with_vector~~CallsGraph proc~fill_vector_with_vector fill_vector_with_vector interface~fill_vector fill_vector proc~fill_vector_with_vector->interface~fill_vector interface~fill_vector->proc~fill_vector_with_vector proc~fill_char_vector_with_scalar fill_char_vector_with_scalar interface~fill_vector->proc~fill_char_vector_with_scalar proc~fill_char_vector_with_vector fill_char_vector_with_vector interface~fill_vector->proc~fill_char_vector_with_vector proc~fill_vector_with_scalar fill_vector_with_scalar interface~fill_vector->proc~fill_vector_with_scalar proc~fill_char_vector_with_vector->interface~fill_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~fill_vector_with_vector~~CalledByGraph proc~fill_vector_with_vector fill_vector_with_vector interface~fill_vector fill_vector proc~fill_vector_with_vector->interface~fill_vector interface~fill_vector->proc~fill_vector_with_vector proc~fill_char_vector_with_vector fill_char_vector_with_vector interface~fill_vector->proc~fill_char_vector_with_vector proc~fill_char_vector_with_vector->interface~fill_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fill_vector_with_vector ( x , vals , i ) implicit none real ( wp ), dimension (:), intent ( inout ) :: x real ( wp ), dimension (:), intent ( in ) :: vals integer , intent ( inout ) :: i !! should be initialized to 0 before the first call integer :: j !! counter do j = 1 , size ( vals ) call fill_vector ( x , vals ( j ), i ) end do end subroutine fill_vector_with_vector","tags":"","url":"proc/fill_vector_with_vector.html"},{"title":"fill_vector_with_scalar – fortran-astrodynamics-toolkit","text":"private  subroutine fill_vector_with_scalar(x, val, i) Put the value in the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: x real(kind=wp), intent(in) :: val integer, intent(inout) :: i should be initialized to 0 before the first call Called by proc~~fill_vector_with_scalar~~CalledByGraph proc~fill_vector_with_scalar fill_vector_with_scalar interface~fill_vector fill_vector interface~fill_vector->proc~fill_vector_with_scalar proc~fill_char_vector_with_vector fill_char_vector_with_vector interface~fill_vector->proc~fill_char_vector_with_vector proc~fill_vector_with_vector fill_vector_with_vector interface~fill_vector->proc~fill_vector_with_vector proc~fill_char_vector_with_vector->interface~fill_vector proc~fill_vector_with_vector->interface~fill_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fill_vector_with_scalar ( x , val , i ) implicit none real ( wp ), dimension (:), intent ( inout ) :: x real ( wp ), intent ( in ) :: val integer , intent ( inout ) :: i !! should be initialized to 0 before the first call i = i + 1 if ( i > size ( x )) error stop 'error in fill_vector: x is not large enough.' x ( i ) = val end subroutine fill_vector_with_scalar","tags":"","url":"proc/fill_vector_with_scalar.html"},{"title":"fill_char_vector_with_vector – fortran-astrodynamics-toolkit","text":"private  subroutine fill_char_vector_with_vector(x, vals, i) Put the vector in the vector and update the index (character version) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout), dimension(:) :: x character(len=*), intent(in), dimension(:) :: vals integer, intent(inout) :: i should be initialized to 0 before the first call Calls proc~~fill_char_vector_with_vector~~CallsGraph proc~fill_char_vector_with_vector fill_char_vector_with_vector interface~fill_vector fill_vector proc~fill_char_vector_with_vector->interface~fill_vector interface~fill_vector->proc~fill_char_vector_with_vector proc~fill_char_vector_with_scalar fill_char_vector_with_scalar interface~fill_vector->proc~fill_char_vector_with_scalar proc~fill_vector_with_scalar fill_vector_with_scalar interface~fill_vector->proc~fill_vector_with_scalar proc~fill_vector_with_vector fill_vector_with_vector interface~fill_vector->proc~fill_vector_with_vector proc~fill_vector_with_vector->interface~fill_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~fill_char_vector_with_vector~~CalledByGraph proc~fill_char_vector_with_vector fill_char_vector_with_vector interface~fill_vector fill_vector proc~fill_char_vector_with_vector->interface~fill_vector interface~fill_vector->proc~fill_char_vector_with_vector proc~fill_vector_with_vector fill_vector_with_vector interface~fill_vector->proc~fill_vector_with_vector proc~fill_vector_with_vector->interface~fill_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fill_char_vector_with_vector ( x , vals , i ) implicit none character ( len =* ), dimension (:), intent ( inout ) :: x character ( len =* ), dimension (:), intent ( in ) :: vals integer , intent ( inout ) :: i !! should be initialized to 0 before the first call integer :: j !! counter do j = 1 , size ( vals ) call fill_vector ( x , vals ( j ), i ) end do end subroutine fill_char_vector_with_vector","tags":"","url":"proc/fill_char_vector_with_vector.html"},{"title":"fill_char_vector_with_scalar – fortran-astrodynamics-toolkit","text":"private  subroutine fill_char_vector_with_scalar(x, val, i) Put the value in the vector and update the index (character version) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout), dimension(:) :: x character(len=*), intent(in) :: val integer, intent(inout) :: i should be initialized to 0 before the first call Called by proc~~fill_char_vector_with_scalar~~CalledByGraph proc~fill_char_vector_with_scalar fill_char_vector_with_scalar interface~fill_vector fill_vector interface~fill_vector->proc~fill_char_vector_with_scalar proc~fill_char_vector_with_vector fill_char_vector_with_vector interface~fill_vector->proc~fill_char_vector_with_vector proc~fill_vector_with_vector fill_vector_with_vector interface~fill_vector->proc~fill_vector_with_vector proc~fill_char_vector_with_vector->interface~fill_vector proc~fill_vector_with_vector->interface~fill_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fill_char_vector_with_scalar ( x , val , i ) implicit none character ( len =* ), dimension (:), intent ( inout ) :: x character ( len =* ), intent ( in ) :: val integer , intent ( inout ) :: i !! should be initialized to 0 before the first call i = i + 1 if ( i > size ( x )) error stop 'error in fill_vector: x is not large enough.' x ( i ) = val end subroutine fill_char_vector_with_scalar","tags":"","url":"proc/fill_char_vector_with_scalar.html"},{"title":"extract_vector_from_vector – fortran-astrodynamics-toolkit","text":"private  subroutine extract_vector_from_vector(vals, x, i) Extract a vector from the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:) :: vals real(kind=wp), intent(in), dimension(:) :: x integer, intent(inout) :: i should be initialized to 0 before the first call Calls proc~~extract_vector_from_vector~~CallsGraph proc~extract_vector_from_vector extract_vector_from_vector interface~extract_vector extract_vector proc~extract_vector_from_vector->interface~extract_vector interface~extract_vector->proc~extract_vector_from_vector proc~extract_scalar_from_vector extract_scalar_from_vector interface~extract_vector->proc~extract_scalar_from_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~extract_vector_from_vector~~CalledByGraph proc~extract_vector_from_vector extract_vector_from_vector interface~extract_vector extract_vector proc~extract_vector_from_vector->interface~extract_vector interface~extract_vector->proc~extract_vector_from_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine extract_vector_from_vector ( vals , x , i ) implicit none real ( wp ), dimension (:), intent ( out ) :: vals real ( wp ), dimension (:), intent ( in ) :: x integer , intent ( inout ) :: i !! should be initialized to 0 before the first call integer :: j !! counter do j = 1 , size ( vals ) call extract_vector ( vals ( j ), x , i ) end do end subroutine extract_vector_from_vector","tags":"","url":"proc/extract_vector_from_vector.html"},{"title":"extract_scalar_from_vector – fortran-astrodynamics-toolkit","text":"private  subroutine extract_scalar_from_vector(val, x, i) Extract the value from the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out) :: val real(kind=wp), intent(in), dimension(:) :: x integer, intent(inout) :: i should be initialized to 0 before the first call Called by proc~~extract_scalar_from_vector~~CalledByGraph proc~extract_scalar_from_vector extract_scalar_from_vector interface~extract_vector extract_vector interface~extract_vector->proc~extract_scalar_from_vector proc~extract_vector_from_vector extract_vector_from_vector interface~extract_vector->proc~extract_vector_from_vector proc~extract_vector_from_vector->interface~extract_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine extract_scalar_from_vector ( val , x , i ) implicit none real ( wp ), intent ( out ) :: val real ( wp ), dimension (:), intent ( in ) :: x integer , intent ( inout ) :: i !! should be initialized to 0 before the first call i = i + 1 if ( i > size ( x )) error stop 'error in extract_vector: x is not large enough.' val = x ( i ) end subroutine extract_scalar_from_vector","tags":"","url":"proc/extract_scalar_from_vector.html"},{"title":"vector_test – fortran-astrodynamics-toolkit","text":"public  subroutine vector_test() Unit test routine for the vector_module . Arguments None Calls proc~~vector_test~~CallsGraph proc~vector_test vector_test proc~axis_angle_rotation axis_angle_rotation proc~vector_test->proc~axis_angle_rotation proc~axis_angle_rotation_to_rotation_matrix axis_angle_rotation_to_rotation_matrix proc~vector_test->proc~axis_angle_rotation_to_rotation_matrix proc~rotation_matrix rotation_matrix proc~vector_test->proc~rotation_matrix proc~cross cross proc~axis_angle_rotation->proc~cross proc~unit unit proc~axis_angle_rotation->proc~unit proc~cross_matrix cross_matrix proc~axis_angle_rotation_to_rotation_matrix->proc~cross_matrix proc~axis_angle_rotation_to_rotation_matrix->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine vector_test () implicit none integer :: i real ( wp ) :: theta real ( wp ), dimension ( 3 ) :: v , k , v2 , v3 real ( wp ), dimension ( 3 , 3 ) :: rotmat write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' vector_test' write ( * , * ) '---------------' write ( * , * ) '' v = [ 1.2_wp , 3.0_wp , - 5.0_wp ] k = [ - 0.1_wp , 1 6.2_wp , 2.1_wp ] theta = 0.123_wp call axis_angle_rotation ( v , k , theta , v2 ) call axis_angle_rotation_to_rotation_matrix ( k , theta , rotmat ) v3 = matmul ( rotmat , v ) write ( * , * ) 'Single test:' write ( * , * ) '' write ( * , * ) '  v1   :' , v write ( * , * ) '  v2   :' , v2 write ( * , * ) '  v3   :' , v3 write ( * , * ) '  Error:' , v3 - v2 write ( * , * ) '' write ( * , * ) '0-360 test:' write ( * , * ) '' do i = 0 , 360 , 10 theta = i * 18 0.0_wp / pi call axis_angle_rotation ( v , k , theta , v2 ) call axis_angle_rotation_to_rotation_matrix ( k , theta , rotmat ) v3 = matmul ( rotmat , v ) write ( * , * ) 'Error:' , norm2 ( v3 - v2 ) end do !z-axis rotation test: theta = pi / 4.0_wp v = [ one / cos ( theta ), 0.0_wp , 0.0_wp ] rotmat = rotation_matrix ( z_axis , theta ) v2 = matmul ( rotmat , v ) write ( * , * ) v2 !should be [1, -1, 0] end subroutine vector_test","tags":"","url":"proc/vector_test.html"},{"title":"fill_vector – fortran-astrodynamics-toolkit","text":"public interface fill_vector Calls interface~~fill_vector~~CallsGraph interface~fill_vector fill_vector proc~fill_char_vector_with_scalar fill_char_vector_with_scalar interface~fill_vector->proc~fill_char_vector_with_scalar proc~fill_char_vector_with_vector fill_char_vector_with_vector interface~fill_vector->proc~fill_char_vector_with_vector proc~fill_vector_with_scalar fill_vector_with_scalar interface~fill_vector->proc~fill_vector_with_scalar proc~fill_vector_with_vector fill_vector_with_vector interface~fill_vector->proc~fill_vector_with_vector proc~fill_char_vector_with_vector->interface~fill_vector proc~fill_vector_with_vector->interface~fill_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~fill_vector~~CalledByGraph interface~fill_vector fill_vector proc~fill_char_vector_with_vector fill_char_vector_with_vector interface~fill_vector->proc~fill_char_vector_with_vector proc~fill_vector_with_vector fill_vector_with_vector interface~fill_vector->proc~fill_vector_with_vector proc~fill_char_vector_with_vector->interface~fill_vector proc~fill_vector_with_vector->interface~fill_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine fill_vector_with_vector (x, vals, i) Put the vector in the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: vals integer, intent(inout) :: i should be initialized to 0 before the first call private  subroutine fill_vector_with_scalar (x, val, i) Put the value in the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: x real(kind=wp), intent(in) :: val integer, intent(inout) :: i should be initialized to 0 before the first call private  subroutine fill_char_vector_with_vector (x, vals, i) Put the vector in the vector and update the index (character version) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout), dimension(:) :: x character(len=*), intent(in), dimension(:) :: vals integer, intent(inout) :: i should be initialized to 0 before the first call private  subroutine fill_char_vector_with_scalar (x, val, i) Put the value in the vector and update the index (character version) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout), dimension(:) :: x character(len=*), intent(in) :: val integer, intent(inout) :: i should be initialized to 0 before the first call","tags":"","url":"interface/fill_vector.html"},{"title":"extract_vector – fortran-astrodynamics-toolkit","text":"public interface extract_vector Calls interface~~extract_vector~~CallsGraph interface~extract_vector extract_vector proc~extract_scalar_from_vector extract_scalar_from_vector interface~extract_vector->proc~extract_scalar_from_vector proc~extract_vector_from_vector extract_vector_from_vector interface~extract_vector->proc~extract_vector_from_vector proc~extract_vector_from_vector->interface~extract_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~extract_vector~~CalledByGraph interface~extract_vector extract_vector proc~extract_vector_from_vector extract_vector_from_vector interface~extract_vector->proc~extract_vector_from_vector proc~extract_vector_from_vector->interface~extract_vector Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine extract_vector_from_vector (vals, x, i) Extract a vector from the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:) :: vals real(kind=wp), intent(in), dimension(:) :: x integer, intent(inout) :: i should be initialized to 0 before the first call private  subroutine extract_scalar_from_vector (val, x, i) Extract the value from the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out) :: val real(kind=wp), intent(in), dimension(:) :: x integer, intent(inout) :: i should be initialized to 0 before the first call","tags":"","url":"interface/extract_vector.html"},{"title":"magnitude – fortran-astrodynamics-toolkit","text":"public pure elemental function magnitude(a, mina) result(m) Returns a positive number the same magnitude as the input,\n  with only one significant digit. If mina is present, then max(mina,mag(a)) is returned Examples: mag ( 1234.56 ) -> 1000.0 mag ( - 999.99 ) -> 900.0 mag ( 1.456e-4 ) -> 0.0001 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in), optional :: mina Return Value real(kind=wp) Source Code pure elemental function magnitude ( a , mina ) result ( m ) implicit none real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ), optional :: mina real ( wp ) :: m real ( wp ) :: x , tmp x = abs ( a ) if ( x == 0.0_wp ) then if (. not . present ( mina )) then m = 1.0_wp else m = mina end if else tmp = 1 0.0_wp ** floor ( log10 ( x )) m = tmp * floor ( x / tmp ) if ( present ( mina )) m = max ( mina , m ) end if end function magnitude","tags":"","url":"proc/magnitude.html"},{"title":"wrap_angle – fortran-astrodynamics-toolkit","text":"public pure elemental function wrap_angle(a) result(r) Wrap an angle (in rad) from -pi to pi. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a Return Value real(kind=wp) Called by proc~~wrap_angle~~CalledByGraph proc~wrap_angle wrap_angle proc~cubic_shadow_model cubic_shadow_model proc~cubic_shadow_model->proc~wrap_angle proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~wrap_angle proc~rv_to_orbital_elements rv_to_orbital_elements proc~rv_to_orbital_elements->proc~wrap_angle proc~get_sun_fraction get_sun_fraction proc~get_sun_fraction->proc~cubic_shadow_model Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental function wrap_angle ( a ) result ( r ) implicit none real ( wp ), intent ( in ) :: a real ( wp ) :: r r = mod ( a , twopi ) if ( abs ( r ) > pi ) r = r - sign ( twopi , r ) end function wrap_angle","tags":"","url":"proc/wrap_angle.html"},{"title":"cube_root – fortran-astrodynamics-toolkit","text":"public pure elemental function cube_root(x) result(y) Uses numbers_module proc~~cube_root~~UsesGraph proc~cube_root cube_root module~numbers_module numbers_module proc~cube_root->module~numbers_module module~kind_module kind_module module~numbers_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Cube root of a number (real solution only). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Called by proc~~cube_root~~CalledByGraph proc~cube_root cube_root proc~compute_libration_points compute_libration_points proc~compute_libration_points->proc~cube_root proc~compute_libration_points_v2 compute_libration_points_v2 proc~compute_libration_points_v2->proc~cube_root proc~compute_libration_points_v2->proc~compute_libration_points proc~crtbp_test crtbp_test proc~crtbp_test->proc~compute_libration_points proc~crtbp_test->proc~compute_libration_points_v2 proc~halo_to_rv halo_to_rv proc~halo_to_rv->proc~compute_libration_points proc~halo_orbit_test halo_orbit_test proc~halo_orbit_test->proc~halo_to_rv proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~halo_to_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure elemental function cube_root ( x ) result ( y ) use numbers_module , only : one , three implicit none real ( wp ), intent ( in ) :: x real ( wp ) :: y real ( wp ), parameter :: one_third = one / three y = sign ( abs ( x ) ** one_third , x ) end function cube_root","tags":"","url":"proc/cube_root.html"},{"title":"dpmpar – fortran-astrodynamics-toolkit","text":"public  function dpmpar(i) Replacement for the original Minpack routine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value real(kind=wp) Called by proc~~dpmpar~~CalledByGraph proc~dpmpar dpmpar proc~dogleg dogleg proc~dogleg->proc~dpmpar proc~fdjac1 fdjac1 proc~fdjac1->proc~dpmpar proc~hybrd hybrd proc~hybrd->proc~dpmpar proc~hybrd->proc~dogleg proc~hybrd->proc~fdjac1 proc~qrfac qrfac proc~hybrd->proc~qrfac proc~r1updt r1updt proc~hybrd->proc~r1updt proc~hybrj hybrj proc~hybrj->proc~dpmpar proc~hybrj->proc~dogleg proc~hybrj->proc~qrfac proc~hybrj->proc~r1updt proc~qrfac->proc~dpmpar proc~r1updt->proc~dpmpar proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~hybrd1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code real ( wp ) function dpmpar ( i ) implicit none integer , intent ( in ) :: i real ( wp ), dimension ( 3 ), parameter :: dmach = [ epsilon ( 1.0_wp ),& tiny ( 1.0_wp ),& huge ( 1.0_wp )] dpmpar = dmach ( i ) end function dpmpar","tags":"","url":"proc/dpmpar.html"},{"title":"enorm – fortran-astrodynamics-toolkit","text":"public  function enorm(n, x) given an n-vector x, this function calculates the\neuclidean norm of x. the euclidean norm is computed by accumulating the sum of\nsquares in three different sums. the sums of squares for the\nsmall and large components are scaled so that no overflows\noccur. non-destructive underflows are permitted. underflows\nand overflows do not occur in the computation of the unscaled\nsum of squares for the intermediate components.\nthe definitions of small, intermediate and large components\ndepend on two constants, rdwarf and rgiant. the main\nrestrictions on these constants are that rdwarf 2 not\nunderflow and rgiant 2 not overflow. the constants\ngiven here are suitable for every known computer. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n size of x real(kind=wp), intent(in), dimension(n) :: x input array Return Value real(kind=wp) Called by proc~~enorm~~CalledByGraph proc~enorm enorm proc~dogleg dogleg proc~dogleg->proc~enorm proc~hybrd hybrd proc~hybrd->proc~enorm proc~hybrd->proc~dogleg proc~qrfac qrfac proc~hybrd->proc~qrfac proc~hybrj hybrj proc~hybrj->proc~enorm proc~hybrj->proc~dogleg proc~hybrj->proc~qrfac proc~qrfac->proc~enorm proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~hybrd1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code real ( wp ) function enorm ( n , x ) implicit none integer , intent ( in ) :: n !! size of `x` real ( wp ), dimension ( n ), intent ( in ) :: x !! input array integer i real ( wp ) agiant , floatn , s1 , s2 , s3 , xabs , x1max , x3max real ( wp ), parameter :: rdwarf = 3.834e-20_wp real ( wp ), parameter :: rgiant = 1.304e19_wp s1 = zero s2 = zero s3 = zero x1max = zero x3max = zero floatn = n agiant = rgiant / floatn do i = 1 , n xabs = abs ( x ( i )) if ( xabs > rdwarf . and . xabs < agiant ) then ! !           sum for intermediate components. ! s2 = s2 + xabs ** 2 elseif ( xabs <= rdwarf ) then ! !              sum for small components. ! if ( xabs <= x3max ) then if ( xabs /= zero ) s3 = s3 + ( xabs / x3max ) ** 2 else s3 = one + s3 * ( x3max / xabs ) ** 2 x3max = xabs endif ! !              sum for large components. ! elseif ( xabs <= x1max ) then s1 = s1 + ( xabs / x1max ) ** 2 else s1 = one + s1 * ( x1max / xabs ) ** 2 x1max = xabs endif enddo ! !     calculation of norm. ! if ( s1 /= zero ) then enorm = x1max * sqrt ( s1 + ( s2 / x1max ) / x1max ) elseif ( s2 == zero ) then enorm = x3max * sqrt ( s3 ) else if ( s2 >= x3max ) enorm = sqrt ( s2 * ( one + ( x3max / s2 ) * ( x3max * s3 ))) if ( s2 < x3max ) enorm = sqrt ( x3max * (( s2 / x3max ) + ( x3max * s3 ))) endif end function enorm","tags":"","url":"proc/enorm.html"},{"title":"dogleg – fortran-astrodynamics-toolkit","text":"public  subroutine dogleg(n, r, lr, diag, qtb, delta, x, wa1, wa2) given an m by n matrix a, an n by n nonsingular diagonal\nmatrix d, an m-vector b, and a positive number delta, the\nproblem is to determine the convex combination x of the\ngauss-newton and scaled gradient directions that minimizes\n(a x - b) in the least squares sense, subject to the\nrestriction that the euclidean norm of d x be at most delta. this subroutine completes the solution of the problem\nif it is provided with the necessary information from the\nqr factorization of a. that is, if a = q r, where q has\northogonal columns and r is an upper triangular matrix,\nthen dogleg expects the full upper triangle of r and\nthe first n components of (q transpose) b. the subroutine statement is subroutine dogleg(n,r,lr,diag,qtb,delta,x,wa1,wa2) where n is a positive integer input variable set to the order of r. r is an input array of length lr which must contain the upper\n    triangular matrix r stored by rows. lr is a positive integer input variable not less than\n    (n*(n+1))/2. diag is an input array of length n which must contain the\n    diagonal elements of the matrix d. qtb is an input array of length n which must contain the first\n    n elements of the vector (q transpose)*b. delta is a positive input variable which specifies an upper\n    bound on the euclidean norm of d*x. x is an output array of length n which contains the desired\n    convex combination of the gauss-newton direction and the\n    scaled gradient direction. wa1 and wa2 are work arrays of length n. Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: r (lr) integer :: lr real(kind=wp) :: diag (n) real(kind=wp) :: qtb (n) real(kind=wp) :: delta real(kind=wp) :: x (n) real(kind=wp) :: wa1 (n) real(kind=wp) :: wa2 (n) Calls proc~~dogleg~~CallsGraph proc~dogleg dogleg proc~dpmpar dpmpar proc~dogleg->proc~dpmpar proc~enorm enorm proc~dogleg->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dogleg~~CalledByGraph proc~dogleg dogleg proc~hybrd hybrd proc~hybrd->proc~dogleg proc~hybrj hybrj proc~hybrj->proc~dogleg proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~hybrd1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine dogleg ( n , r , lr , diag , qtb , delta , x , wa1 , wa2 ) implicit none integer n , lr real ( wp ) delta real ( wp ) r ( lr ) , diag ( n ) , qtb ( n ) , x ( n ) , wa1 ( n ) , wa2 ( n ) integer i , j , jj , jp1 , k , l real ( wp ) alpha , bnorm , epsmch , gnorm , qnorm , sgnorm , sum , temp epsmch = dpmpar ( 1 ) ! the machine precision ! !     first, calculate the gauss-newton direction. ! jj = ( n * ( n + 1 )) / 2 + 1 do k = 1 , n j = n - k + 1 jp1 = j + 1 jj = jj - k l = jj + 1 sum = zero if ( n >= jp1 ) then do i = jp1 , n sum = sum + r ( l ) * x ( i ) l = l + 1 enddo endif temp = r ( jj ) if ( temp == zero ) then l = j do i = 1 , j temp = max ( temp , abs ( r ( l ))) l = l + n - i enddo temp = epsmch * temp if ( temp == zero ) temp = epsmch endif x ( j ) = ( qtb ( j ) - sum ) / temp enddo ! !     test whether the gauss-newton direction is acceptable. ! do j = 1 , n wa1 ( j ) = zero wa2 ( j ) = diag ( j ) * x ( j ) enddo qnorm = enorm ( n , wa2 ) if ( qnorm > delta ) then ! !     the gauss-newton direction is not acceptable. !     next, calculate the scaled gradient direction. ! l = 1 do j = 1 , n temp = qtb ( j ) do i = j , n wa1 ( i ) = wa1 ( i ) + r ( l ) * temp l = l + 1 enddo wa1 ( j ) = wa1 ( j ) / diag ( j ) enddo ! !     calculate the norm of the scaled gradient and test for !     the special case in which the scaled gradient is zero. ! gnorm = enorm ( n , wa1 ) sgnorm = zero alpha = delta / qnorm if ( gnorm /= zero ) then ! !     calculate the point along the scaled gradient !     at which the quadratic is minimized. ! do j = 1 , n wa1 ( j ) = ( wa1 ( j ) / gnorm ) / diag ( j ) enddo l = 1 do j = 1 , n sum = zero do i = j , n sum = sum + r ( l ) * wa1 ( i ) l = l + 1 enddo wa2 ( j ) = sum enddo temp = enorm ( n , wa2 ) sgnorm = ( gnorm / temp ) / temp ! !     test whether the scaled gradient direction is acceptable. ! alpha = zero if ( sgnorm < delta ) then ! !     the scaled gradient direction is not acceptable. !     finally, calculate the point along the dogleg !     at which the quadratic is minimized. ! bnorm = enorm ( n , qtb ) temp = ( bnorm / gnorm ) * ( bnorm / qnorm ) * ( sgnorm / delta ) temp = temp - ( delta / qnorm ) * ( sgnorm / delta ) ** 2 + & sqrt (( temp - ( delta / qnorm )) ** 2 + & ( one - ( delta / qnorm ) ** 2 ) * ( one - ( sgnorm / delta ) ** 2 )) alpha = (( delta / qnorm ) * ( one - ( sgnorm / delta ) ** 2 )) / temp endif endif ! !     form appropriate convex combination of the gauss-newton !     direction and the scaled gradient direction. ! temp = ( one - alpha ) * min ( sgnorm , delta ) do j = 1 , n x ( j ) = temp * wa1 ( j ) + alpha * x ( j ) enddo endif end subroutine dogleg","tags":"","url":"proc/dogleg.html"},{"title":"fdjac1 – fortran-astrodynamics-toolkit","text":"public  subroutine fdjac1(fcn, n, x, fvec, fjac, ldfjac, iflag, ml, mu, epsfcn, wa1, wa2) this subroutine computes a forward-difference approximation\nto the n by n jacobian matrix associated with a specified\nproblem of n functions in n variables. if the jacobian has\na banded form, then function evaluations are saved by only\napproximating the nonzero terms. the subroutine statement is subroutine fdjac1(fcn,n,x,fvec,fjac,ldfjac,iflag,ml,mu,epsfcn,wa1,wa2) where fcn is the name of the user-supplied subroutine which\n    calculates the functions. fcn must be declared\n    in an external statement in the user calling\n    program, and should be written as follows. subroutine fcn ( n , x , fvec , iflag ) integer n , iflag real ( wp ) x ( n ) , fvec ( n ) ---------- calculate the functions at x and return this vector in fvec . ---------- return end the value of iflag should not be changed by fcn unless the user wants to terminate execution of fdjac1 . in this case set iflag to a negative integer . n is a positive integer input variable set to the number\n    of functions and variables. x is an input array of length n. fvec is an input array of length n which must contain the\n    functions evaluated at x. fjac is an output n by n array which contains the\n    approximation to the jacobian matrix evaluated at x. ldfjac is a positive integer input variable not less than n\n    which specifies the leading dimension of the array fjac. iflag is an integer variable which can be used to terminate\n    the execution of fdjac1. see description of fcn. ml is a nonnegative integer input variable which specifies\n    the number of subdiagonals within the band of the\n    jacobian matrix. if the jacobian is not banded, set\n    ml to at least n - 1. epsfcn is an input variable used in determining a suitable\n    step length for the forward-difference approximation. this\n    approximation assumes that the relative errors in the\n    functions are of the order of epsfcn. if epsfcn is less\n    than the machine precision, it is assumed that the relative\n    errors in the functions are of the order of the machine\n    precision. mu is a nonnegative integer input variable which specifies\n    the number of superdiagonals within the band of the\n    jacobian matrix. if the jacobian is not banded, set\n    mu to at least n - 1. wa1 and wa2 are work arrays of length n. if ml + mu + 1 is at\n    least n, then the jacobian is considered dense, and wa2 is\n    not referenced. Arguments Type Intent Optional Attributes Name procedure( fcn_hybrd ) :: fcn integer :: n real(kind=wp) :: x (n) real(kind=wp) :: fvec (n) real(kind=wp) :: fjac (ldfjac,n) integer :: ldfjac integer :: iflag integer :: ml integer :: mu real(kind=wp) :: epsfcn real(kind=wp) :: wa1 (n) real(kind=wp) :: wa2 (n) Calls proc~~fdjac1~~CallsGraph proc~fdjac1 fdjac1 proc~dpmpar dpmpar proc~fdjac1->proc~dpmpar Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~fdjac1~~CalledByGraph proc~fdjac1 fdjac1 proc~hybrd hybrd proc~hybrd->proc~fdjac1 proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~hybrd1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine fdjac1 ( fcn , n , x , fvec , fjac , ldfjac , iflag , ml , mu , epsfcn , wa1 , wa2 ) implicit none integer n , ldfjac , iflag , ml , mu real ( wp ) epsfcn real ( wp ) x ( n ) , fvec ( n ) , fjac ( ldfjac , n ) , wa1 ( n ) , wa2 ( n ) procedure ( fcn_hybrd ) :: fcn integer i , j , k , msum real ( wp ) eps , epsmch , h , temp epsmch = dpmpar ( 1 ) ! the machine precision ! eps = sqrt ( max ( epsfcn , epsmch )) msum = ml + mu + 1 if ( msum < n ) then ! !        computation of banded approximate jacobian. ! do k = 1 , msum do j = k , n , msum wa2 ( j ) = x ( j ) h = eps * abs ( wa2 ( j )) if ( h == zero ) h = eps x ( j ) = wa2 ( j ) + h enddo call fcn ( n , x , wa1 , iflag ) if ( iflag < 0 ) return do j = k , n , msum x ( j ) = wa2 ( j ) h = eps * abs ( wa2 ( j )) if ( h == zero ) h = eps do i = 1 , n fjac ( i , j ) = zero if ( i >= j - mu . and . i <= j + ml ) fjac ( i , j ) = ( wa1 ( i ) - fvec ( i )) / h enddo enddo enddo else ! !        computation of dense approximate jacobian. ! do j = 1 , n temp = x ( j ) h = eps * abs ( temp ) if ( h == zero ) h = eps x ( j ) = temp + h call fcn ( n , x , wa1 , iflag ) if ( iflag < 0 ) return x ( j ) = temp do i = 1 , n fjac ( i , j ) = ( wa1 ( i ) - fvec ( i )) / h enddo enddo endif end subroutine fdjac1","tags":"","url":"proc/fdjac1.html"},{"title":"hybrd – fortran-astrodynamics-toolkit","text":"public  subroutine hybrd(fcn, n, x, fvec, xtol, maxfev, ml, mu, epsfcn, diag, mode, factor, nprint, info, nfev, fjac, ldfjac, r, lr, qtf, wa1, wa2, wa3, wa4) The purpose of hybrd is to find a zero of a system of\n  n nonlinear functions in n variables by a modification\n  of the powell hybrid method. the user must provide a\n  subroutine which calculates the functions. the jacobian is\n  then calculated by a forward-difference approximation. Characteristics of the algorithm. HYBRD is a modification of the Powell hybrid method.  Two of its\n  main characteristics involve the choice of the correction as a\n  convex combination of the Newton and scaled gradient directions\n  and the updating of the Jacobian by the rank-1 method of Broy-\n  den.  The choice of the correction guarantees (under reasonable\n  conditions) global convergence for starting points far from the\n  solution and a fast rate of convergence.  The Jacobian is\n  approximated by forward differences at the starting point, but\n  forward differences are not used again until the rank-1 method\n  fails to produce satisfactory progress. References M. J. D. Powell, A Hybrid Method for Nonlinear Equations.\n    Numerical Methods for Nonlinear Algebraic Equations,\n    P. Rabinowitz, editor. Gordon and Breach, 1970. Arguments Type Intent Optional Attributes Name procedure( fcn_hybrd ) :: fcn user-supplied subroutine which calculates the functions integer, intent(in) :: n a positive integer input variable set to the number\nof functions and variables. real(kind=wp), intent(inout) :: x (n) array of length n. on input x must contain\nan initial estimate of the solution vector. on output x contains the final estimate of the solution vector. real(kind=wp), intent(out) :: fvec (n) an output array of length n which contains\nthe functions evaluated at the output x . real(kind=wp), intent(in) :: xtol a nonnegative input variable. termination\noccurs when the relative error between two consecutive\niterates is at most xtol . integer, intent(in) :: maxfev a positive integer input variable. termination\noccurs when the number of calls to fcn is at least maxfev by the end of an iteration. integer, intent(in) :: ml a nonnegative integer input variable which specifies\nthe number of subdiagonals within the band of the\njacobian matrix. if the jacobian is not banded, set ml to at least n - 1 . integer, intent(in) :: mu a nonnegative integer input variable which specifies\nthe number of superdiagonals within the band of the\njacobian matrix. if the jacobian is not banded, set mu to at least n - 1 . real(kind=wp), intent(in) :: epsfcn an input variable used in determining a suitable\nstep length for the forward-difference approximation. this\napproximation assumes that the relative errors in the\nfunctions are of the order of epsfcn . if epsfcn is less\nthan the machine precision, it is assumed that the relative\nerrors in the functions are of the order of the machine\nprecision. real(kind=wp), intent(inout) :: diag (n) an array of length n . if mode = 1 (see\nbelow), diag is internally set. if mode = 2 , diag must contain positive entries that serve as\nmultiplicative scale factors for the variables. integer, intent(in) :: mode if mode = 1 , the\nvariables will be scaled internally. if mode = 2 ,\nthe scaling is specified by the input diag . other\nvalues of mode are equivalent to mode = 1 . real(kind=wp), intent(in) :: factor a positive input variable used in determining the\ninitial step bound. this bound is set to the product of factor and the euclidean norm of diag*x if nonzero, or else\nto factor itself. in most cases factor should lie in the\ninterval (.1,100.). 100. is a generally recommended value. integer, intent(in) :: nprint an integer input variable that enables controlled\nprinting of iterates if it is positive. in this case, fcn is called with iflag = 0 at the beginning of the first\niteration and every nprint iterations thereafter and\nimmediately prior to return, with x and fvec available\nfor printing. if nprint is not positive, no special calls\nof fcn with iflag = 0 are made. integer, intent(out) :: info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag . see description of fcn . otherwise, info is set as follows:\n * info = 0 improper input parameters.\n * info = 1 relative error between two consecutive iterates\n   is at most xtol .\n * info = 2 number of calls to fcn has reached or exceeded maxfev .\n * info = 3 xtol is too small. no further improvement in\n   the approximate solution x is possible.\n * info = 4 iteration is not making good progress, as\n   measured by the improvement from the last\n   five jacobian evaluations.\n * info = 5 iteration is not making good progress, as\n   measured by the improvement from the last\n   ten iterations. integer, intent(out) :: nfev output variable set to the number of calls to fcn . real(kind=wp), intent(out) :: fjac (ldfjac,n) array which contains the\northogonal matrix q produced by the QR factorization\nof the final approximate jacobian. integer, intent(in) :: ldfjac a positive integer input variable not less than n which specifies the leading dimension of the array fjac . real(kind=wp), intent(out) :: r (lr) an output array which contains the\nupper triangular matrix produced by the QR factorization\nof the final approximate jacobian, stored rowwise. integer, intent(in) :: lr a positive integer input variable not less than (n*(n+1))/2 . real(kind=wp), intent(out) :: qtf (n) an output array of length n which contains\nthe vector (q transpose)*fvec . real(kind=wp), intent(inout) :: wa1 (n) work array real(kind=wp), intent(inout) :: wa2 (n) work array real(kind=wp), intent(inout) :: wa3 (n) work array real(kind=wp), intent(inout) :: wa4 (n) work array Calls proc~~hybrd~~CallsGraph proc~hybrd hybrd proc~dogleg dogleg proc~hybrd->proc~dogleg proc~dpmpar dpmpar proc~hybrd->proc~dpmpar proc~enorm enorm proc~hybrd->proc~enorm proc~fdjac1 fdjac1 proc~hybrd->proc~fdjac1 proc~qform qform proc~hybrd->proc~qform proc~qrfac qrfac proc~hybrd->proc~qrfac proc~r1mpyq r1mpyq proc~hybrd->proc~r1mpyq proc~r1updt r1updt proc~hybrd->proc~r1updt proc~dogleg->proc~dpmpar proc~dogleg->proc~enorm proc~fdjac1->proc~dpmpar proc~qrfac->proc~dpmpar proc~qrfac->proc~enorm proc~r1updt->proc~dpmpar Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hybrd~~CalledByGraph proc~hybrd hybrd proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~hybrd1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine hybrd ( fcn , n , x , fvec , xtol , maxfev , ml , mu , epsfcn , diag , mode , & factor , nprint , info , nfev , fjac , ldfjac , r , lr , qtf , wa1 ,& wa2 , wa3 , wa4 ) implicit none procedure ( fcn_hybrd ) :: fcn !! user-supplied subroutine which calculates the functions integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of functions and variables. integer , intent ( in ) :: maxfev !! a positive integer input variable. termination !! occurs when the number of calls to `fcn` is at least `maxfev` !! by the end of an iteration. integer , intent ( in ) :: ml !! a nonnegative integer input variable which specifies !! the number of subdiagonals within the band of the !! jacobian matrix. if the jacobian is not banded, set !! `ml` to at least `n - 1`. integer , intent ( in ) :: mu !! a nonnegative integer input variable which specifies !! the number of superdiagonals within the band of the !! jacobian matrix. if the jacobian is not banded, set !! `mu` to at least` n - 1`. integer , intent ( in ) :: mode !! if `mode = 1`, the !! variables will be scaled internally. if `mode = 2`, !! the scaling is specified by the input `diag`. other !! values of `mode` are equivalent to `mode = 1`. integer , intent ( in ) :: nprint !! an integer input variable that enables controlled !! printing of iterates if it is positive. in this case, !! `fcn` is called with `iflag = 0` at the beginning of the first !! iteration and every `nprint` iterations thereafter and !! immediately prior to return, with `x` and `fvec` available !! for printing. if `nprint` is not positive, no special calls !! of `fcn` with `iflag = 0` are made. integer , intent ( out ) :: info !! an integer output variable. if the user has !! terminated execution, `info` is set to the (negative) !! value of `iflag`. see description of `fcn`. otherwise, !! `info` is set as follows: !!  * ***info = 0*** improper input parameters. !!  * ***info = 1*** relative error between two consecutive iterates !!    is at most `xtol`. !!  * ***info = 2*** number of calls to `fcn` has reached or exceeded !!    `maxfev`. !!  * ***info = 3*** `xtol` is too small. no further improvement in !!    the approximate solution `x` is possible. !!  * ***info = 4*** iteration is not making good progress, as !!    measured by the improvement from the last !!    five jacobian evaluations. !!  * ***info = 5*** iteration is not making good progress, as !!    measured by the improvement from the last !!    ten iterations. integer , intent ( out ) :: nfev !! output variable set to the number of calls to `fcn`. integer , intent ( in ) :: ldfjac !! a positive integer input variable not less than `n` !! which specifies the leading dimension of the array `fjac`. integer , intent ( in ) :: lr !! a positive integer input variable not less than `(n*(n+1))/2`. real ( wp ), intent ( in ) :: xtol !! a nonnegative input variable. termination !! occurs when the relative error between two consecutive !! iterates is at most `xtol`. real ( wp ), intent ( in ) :: epsfcn !! an input variable used in determining a suitable !! step length for the forward-difference approximation. this !! approximation assumes that the relative errors in the !! functions are of the order of `epsfcn`. if `epsfcn` is less !! than the machine precision, it is assumed that the relative !! errors in the functions are of the order of the machine !! precision. real ( wp ), intent ( in ) :: factor !! a positive input variable used in determining the !! initial step bound. this bound is set to the product of !! `factor` and the euclidean norm of `diag*x` if nonzero, or else !! to `factor` itself. in most cases factor should lie in the !! interval (.1,100.). 100. is a generally recommended value. real ( wp ), intent ( inout ) :: x ( n ) !! array of length n. on input `x` must contain !! an initial estimate of the solution vector. on output `x` !! contains the final estimate of the solution vector. real ( wp ), intent ( out ) :: fvec ( n ) !! an output array of length `n` which contains !! the functions evaluated at the output `x`. real ( wp ), intent ( inout ) :: diag ( n ) !! an array of length `n`. if `mode = 1` (see !! below), `diag` is internally set. if `mode = 2`, `diag` !! must contain positive entries that serve as !! multiplicative scale factors for the variables. real ( wp ), intent ( out ) :: fjac ( ldfjac , n ) !! array which contains the !! orthogonal matrix `q` produced by the QR factorization !! of the final approximate jacobian. real ( wp ), intent ( out ) :: r ( lr ) !! an output array which contains the !! upper triangular matrix produced by the QR factorization !! of the final approximate jacobian, stored rowwise. real ( wp ), intent ( out ) :: qtf ( n ) !! an output array of length `n` which contains !! the vector `(q transpose)*fvec`. real ( wp ), intent ( inout ) :: wa1 ( n ) !! work array real ( wp ), intent ( inout ) :: wa2 ( n ) !! work array real ( wp ), intent ( inout ) :: wa3 ( n ) !! work array real ( wp ), intent ( inout ) :: wa4 ( n ) !! work array integer :: i , iflag , iter , j , jm1 , l , msum , ncfail , ncsuc , nslow1 , nslow2 integer :: iwa ( 1 ) logical :: jeval , sing real ( wp ) :: actred , delta , epsmch , fnorm , fnorm1 , & pnorm , prered , ratio ,& sum , temp , xnorm real ( wp ), parameter :: p1 = 1.0e-1_wp real ( wp ), parameter :: p5 = 5.0e-1_wp real ( wp ), parameter :: p001 = 1.0e-3_wp real ( wp ), parameter :: p0001 = 1.0e-4_wp epsmch = dpmpar ( 1 ) ! the machine precision info = 0 iflag = 0 nfev = 0 ! !     check the input parameters for errors. ! if ( n <= 0 . or . xtol < zero . or . maxfev <= 0 . or . ml < 0 . or . mu < 0 . or . & factor <= zero . or . ldfjac < n . or . lr < ( n * ( n + 1 )) / 2 ) goto 300 if ( mode == 2 ) then do j = 1 , n if ( diag ( j ) <= zero ) goto 300 enddo endif ! !     evaluate the function at the starting point !     and calculate its norm. ! iflag = 1 call fcn ( n , x , fvec , iflag ) nfev = 1 if ( iflag < 0 ) goto 300 fnorm = enorm ( n , fvec ) ! !     determine the number of calls to fcn needed to compute !     the jacobian matrix. ! msum = min0 ( ml + mu + 1 , n ) ! !     initialize iteration counter and monitors. ! iter = 1 ncsuc = 0 ncfail = 0 nslow1 = 0 nslow2 = 0 ! !     beginning of the outer loop. ! 100 jeval = . true . ! !        calculate the jacobian matrix. ! iflag = 2 call fdjac1 ( fcn , n , x , fvec , fjac , ldfjac , iflag , ml , mu , epsfcn , wa1 , wa2 ) nfev = nfev + msum if ( iflag < 0 ) goto 300 ! !        compute the qr factorization of the jacobian. ! call qrfac ( n , n , fjac , ldfjac ,. false ., iwa , 1 , wa1 , wa2 , wa3 ) ! !        on the first iteration and if mode is 1, scale according !        to the norms of the columns of the initial jacobian. ! if ( iter == 1 ) then if ( mode /= 2 ) then do j = 1 , n diag ( j ) = wa2 ( j ) if ( wa2 ( j ) == zero ) diag ( j ) = one enddo endif ! !        on the first iteration, calculate the norm of the scaled x !        and initialize the step bound delta. ! do j = 1 , n wa3 ( j ) = diag ( j ) * x ( j ) enddo xnorm = enorm ( n , wa3 ) delta = factor * xnorm if ( delta == zero ) delta = factor endif ! !        form (q transpose)*fvec and store in qtf. ! do i = 1 , n qtf ( i ) = fvec ( i ) enddo do j = 1 , n if ( fjac ( j , j ) /= zero ) then sum = zero do i = j , n sum = sum + fjac ( i , j ) * qtf ( i ) enddo temp = - sum / fjac ( j , j ) do i = j , n qtf ( i ) = qtf ( i ) + fjac ( i , j ) * temp enddo endif enddo ! !        copy the triangular factor of the qr factorization into r. ! sing = . false . do j = 1 , n l = j jm1 = j - 1 if ( jm1 >= 1 ) then do i = 1 , jm1 r ( l ) = fjac ( i , j ) l = l + n - i enddo endif r ( l ) = wa1 ( j ) if ( wa1 ( j ) == zero ) sing = . true . enddo ! !        accumulate the orthogonal factor in fjac. ! call qform ( n , n , fjac , ldfjac , wa1 ) ! !        rescale if necessary. ! if ( mode /= 2 ) then do j = 1 , n diag ( j ) = dmax1 ( diag ( j ), wa2 ( j )) enddo endif ! !        beginning of the inner loop. ! ! !           if requested, call fcn to enable printing of iterates. ! 200 if ( nprint > 0 ) then iflag = 0 if ( mod ( iter - 1 , nprint ) == 0 ) call fcn ( n , x , fvec , iflag ) if ( iflag < 0 ) goto 300 endif ! !           determine the direction p. ! call dogleg ( n , r , lr , diag , qtf , delta , wa1 , wa2 , wa3 ) ! !           store the direction p and x + p. calculate the norm of p. ! do j = 1 , n wa1 ( j ) = - wa1 ( j ) wa2 ( j ) = x ( j ) + wa1 ( j ) wa3 ( j ) = diag ( j ) * wa1 ( j ) enddo pnorm = enorm ( n , wa3 ) ! !           on the first iteration, adjust the initial step bound. ! if ( iter == 1 ) delta = dmin1 ( delta , pnorm ) ! !           evaluate the function at x + p and calculate its norm. ! iflag = 1 call fcn ( n , wa2 , wa4 , iflag ) nfev = nfev + 1 if ( iflag >= 0 ) then fnorm1 = enorm ( n , wa4 ) ! !           compute the scaled actual reduction. ! actred = - one if ( fnorm1 < fnorm ) actred = one - ( fnorm1 / fnorm ) ** 2 ! !           compute the scaled predicted reduction. ! l = 1 do i = 1 , n sum = zero do j = i , n sum = sum + r ( l ) * wa1 ( j ) l = l + 1 enddo wa3 ( i ) = qtf ( i ) + sum enddo temp = enorm ( n , wa3 ) prered = zero if ( temp < fnorm ) prered = one - ( temp / fnorm ) ** 2 ! !           compute the ratio of the actual to the predicted !           reduction. ! ratio = zero if ( prered > zero ) ratio = actred / prered ! !           update the step bound. ! if ( ratio >= p1 ) then ncfail = 0 ncsuc = ncsuc + 1 if ( ratio >= p5 . or . ncsuc > 1 ) delta = dmax1 ( delta , pnorm / p5 ) if ( abs ( ratio - one ) <= p1 ) delta = pnorm / p5 else ncsuc = 0 ncfail = ncfail + 1 delta = p5 * delta endif ! !           test for successful iteration. ! if ( ratio >= p0001 ) then ! !           successful iteration. update x, fvec, and their norms. ! do j = 1 , n x ( j ) = wa2 ( j ) wa2 ( j ) = diag ( j ) * x ( j ) fvec ( j ) = wa4 ( j ) enddo xnorm = enorm ( n , wa2 ) fnorm = fnorm1 iter = iter + 1 endif ! !           determine the progress of the iteration. ! nslow1 = nslow1 + 1 if ( actred >= p001 ) nslow1 = 0 if ( jeval ) nslow2 = nslow2 + 1 if ( actred >= p1 ) nslow2 = 0 ! !           test for convergence. ! if ( delta <= xtol * xnorm . or . fnorm == zero ) info = 1 if ( info == 0 ) then ! !           tests for termination and stringent tolerances. ! if ( nfev >= maxfev ) info = 2 if ( p1 * dmax1 ( p1 * delta , pnorm ) <= epsmch * xnorm ) info = 3 if ( nslow2 == 5 ) info = 4 if ( nslow1 == 10 ) info = 5 if ( info == 0 ) then ! !           criterion for recalculating jacobian approximation !           by forward differences. ! if ( ncfail == 2 ) goto 100 ! !           calculate the rank one modification to the jacobian !           and update qtf if necessary. ! do j = 1 , n sum = zero do i = 1 , n sum = sum + fjac ( i , j ) * wa4 ( i ) enddo wa2 ( j ) = ( sum - wa3 ( j )) / pnorm wa1 ( j ) = diag ( j ) * (( diag ( j ) * wa1 ( j )) / pnorm ) if ( ratio >= p0001 ) qtf ( j ) = sum enddo ! !           compute the qr factorization of the updated jacobian. ! call r1updt ( n , n , r , lr , wa1 , wa2 , wa3 , sing ) call r1mpyq ( n , n , fjac , ldfjac , wa2 , wa3 ) call r1mpyq ( 1 , n , qtf , 1 , wa2 , wa3 ) ! !           end of the inner loop. ! jeval = . false . ! !        end of the outer loop. ! goto 200 endif endif endif ! !     termination, either normal or user imposed. ! 300 if ( iflag < 0 ) info = iflag iflag = 0 if ( nprint > 0 ) call fcn ( n , x , fvec , iflag ) end subroutine hybrd","tags":"","url":"proc/hybrd.html"},{"title":"hybrd1 – fortran-astrodynamics-toolkit","text":"public  subroutine hybrd1(fcn, n, x, fvec, tol, info) the purpose of hybrd1 is to find a zero of a system of n nonlinear functions in n variables by a modification\nof the powell hybrid method. this is done by using the\nmore general nonlinear equation solver hybrd . the user\nmust provide a subroutine which calculates the functions.\nthe jacobian is then calculated by a forward-difference\napproximation. Arguments Type Intent Optional Attributes Name procedure( fcn_hybrd ) :: fcn user-supplied subroutine which calculates the functions integer, intent(in) :: n a positive integer input variable set to the number\nof functions and variables. real(kind=wp), intent(inout), dimension(n) :: x an array of length n . on input x must contain\nan initial estimate of the solution vector. on output x contains the final estimate of the solution vector. real(kind=wp), intent(out), dimension(n) :: fvec an output array of length n which contains\nthe functions evaluated at the output x . real(kind=wp), intent(in) :: tol a nonnegative input variable. termination occurs\nwhen the algorithm estimates that the relative error\nbetween x and the solution is at most tol . integer, intent(out) :: info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag . see description of fcn . otherwise, info is set as follows: info = 0 improper input parameters. info = 1 algorithm estimates that the relative error\n between x and the solution is at most tol . info = 2 number of calls to fcn has reached or exceeded 200*(n+1) . info = 3 tol is too small. no further improvement in\n the approximate solution x is possible. info = 4 iteration is not making good progress. Calls proc~~hybrd1~~CallsGraph proc~hybrd1 hybrd1 proc~hybrd hybrd proc~hybrd1->proc~hybrd proc~dogleg dogleg proc~hybrd->proc~dogleg proc~dpmpar dpmpar proc~hybrd->proc~dpmpar proc~enorm enorm proc~hybrd->proc~enorm proc~fdjac1 fdjac1 proc~hybrd->proc~fdjac1 proc~qform qform proc~hybrd->proc~qform proc~qrfac qrfac proc~hybrd->proc~qrfac proc~r1mpyq r1mpyq proc~hybrd->proc~r1mpyq proc~r1updt r1updt proc~hybrd->proc~r1updt proc~dogleg->proc~dpmpar proc~dogleg->proc~enorm proc~fdjac1->proc~dpmpar proc~qrfac->proc~dpmpar proc~qrfac->proc~enorm proc~r1updt->proc~dpmpar Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hybrd1~~CalledByGraph proc~hybrd1 hybrd1 proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~hybrd1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine hybrd1 ( fcn , n , x , fvec , tol , info ) implicit none procedure ( fcn_hybrd ) :: fcn !! user-supplied subroutine which calculates the functions integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of functions and variables. integer , intent ( out ) :: info !! an integer output variable. if the user has !! terminated execution, info is set to the (negative) !! value of `iflag`. see description of `fcn`. otherwise, !! `info` is set as follows: !!  ***info = 0*** improper input parameters. !!  ***info = 1*** algorithm estimates that the relative error !!  between `x` and the solution is at most `tol`. !!  ***info = 2*** number of calls to `fcn` has reached or exceeded !!  `200*(n+1)`. !!  ***info = 3*** `tol` is too small. no further improvement in !!  the approximate solution `x` is possible. !!  ***info = 4*** iteration is not making good progress. real ( wp ), intent ( in ) :: tol !! a nonnegative input variable. termination occurs !! when the algorithm estimates that the relative error !! between `x` and the solution is at most `tol`. real ( wp ), dimension ( n ), intent ( inout ) :: x !! an array of length `n`. on input `x` must contain !! an initial estimate of the solution vector. on output `x` !! contains the final estimate of the solution vector. real ( wp ), dimension ( n ), intent ( out ) :: fvec !! an output array of length `n` which contains !! the functions evaluated at the output `x`. integer :: lwa !! length of `wa` work array real ( wp ), dimension (:), allocatable :: wa !! work array integer :: index , j , lr , maxfev , ml , mode , mu , nfev , nprint real ( wp ) :: epsfcn , xtol real ( wp ), dimension ( n ) :: diag real ( wp ), parameter :: factor = 10 0.0_wp info = 0 ! check the input parameters for errors. if ( n > 0 . and . tol >= zero ) then !set up inputs: lwa = ( n * ( 3 * n + 13 )) / 2 ! the work array was formerly an input allocate ( wa ( lwa )) ! wa = 0.0_wp ! maxfev = 200 * ( n + 1 ) xtol = tol ml = n - 1 mu = n - 1 epsfcn = zero mode = 2 diag = one nprint = 0 lr = ( n * ( n + 1 )) / 2 index = 6 * n + lr ! call hybrd: call hybrd ( fcn , n , x , fvec , xtol , maxfev , ml , mu , epsfcn , diag , mode ,& factor , nprint , info , nfev , wa ( index + 1 ), n , wa ( 6 * n + 1 ), lr ,& wa ( n + 1 ), wa ( 2 * n + 1 ), wa ( 3 * n + 1 ), wa ( 4 * n + 1 ), wa ( 5 * n + 1 )) if ( info == 5 ) info = 4 deallocate ( wa ) endif end subroutine hybrd1","tags":"","url":"proc/hybrd1.html"},{"title":"hybrj – fortran-astrodynamics-toolkit","text":"public  subroutine hybrj(fcn, n, x, fvec, fjac, ldfjac, xtol, maxfev, diag, mode, factor, nprint, info, nfev, njev, r, lr, qtf, wa1, wa2, wa3, wa4) the purpose of hybrj is to find a zero of a system of\n  n nonlinear functions in n variables by a modification\n  of the powell hybrid method. the user must provide a\n  subroutine which calculates the functions and the jacobian. fcn is the name of the user - supplied subroutine which calculates the functions and the jacobian . fcn must be declared in an external statement in the user calling program , and should be written as follows . subroutine fcn ( n , x , fvec , fjac , ldfjac , iflag ) integer n , ldfjac , iflag real ( wp ) x ( n ), fvec ( n ), fjac ( ldfjac , n ) ---------- if iflag = 1 calculate the functions at x and return this vector in fvec . do not alter fjac . if iflag = 2 calculate the jacobian at x and return this matrix in fjac . do not alter fvec . --------- return end the value of iflag should not be changed by fcn unless the user wants to terminate execution of hybrj . in this case set iflag to a negative integer . n is a positive integer input variable set to the number of functions and variables . x is an array of length n . on input x must contain an initial estimate of the solution vector . on output x contains the final estimate of the solution vector . fvec is an output array of length n which contains the functions evaluated at the output x . fjac is an output n by n array which contains the orthogonal matrix q produced by the qr factorization of the final approximate jacobian . ldfjac is a positive integer input variable not less than n which specifies the leading dimension of the array fjac . xtol is a nonnegative input variable . termination occurs when the relative error between two consecutive iterates is at most xtol . maxfev is a positive integer input variable . termination occurs when the number of calls to fcn with iflag = 1 has reached maxfev . diag is an array of length n . if mode = 1 ( see below ), diag is internally set . if mode = 2 , diag must contain positive entries that serve as multiplicative scale factors for the variables . mode is an integer input variable . if mode = 1 , the variables will be scaled internally . if mode = 2 , the scaling is specified by the input diag . other values of mode are equivalent to mode = 1. factor is a positive input variable used in determining the initial step bound . this bound is set to the product of factor and the euclidean norm of diag * x if nonzero , or else to factor itself . in most cases factor should lie in the interval ( . 1 , 100. ) . 100. is a generally recommended value . nprint is an integer input variable that enables controlled printing of iterates if it is positive . in this case , fcn is called with iflag = 0 at the beginning of the first iteration and every nprint iterations thereafter and immediately prior to return , with x and fvec available for printing . fvec and fjac should not be altered . if nprint is not positive , no special calls of fcn with iflag = 0 are made . info is an integer output variable . if the user has terminated execution , info is set to the ( negative ) value of iflag . see description of fcn . otherwise , info is set as follows . info = 0 improper input parameters . info = 1 relative error between two consecutive iterates is at most xtol . info = 2 number of calls to fcn with iflag = 1 has reached maxfev . info = 3 xtol is too small . no further improvement in the approximate solution x is possible . info = 4 iteration is not making good progress , as measured by the improvement from the last five jacobian evaluations . info = 5 iteration is not making good progress , as measured by the improvement from the last ten iterations . nfev is an integer output variable set to the number of calls to fcn with iflag = 1. njev is an integer output variable set to the number of calls to fcn with iflag = 2. r is an output array of length lr which contains the upper triangular matrix produced by the qr factorization of the final approximate jacobian , stored rowwise . lr is a positive integer input variable not less than ( n * ( n + 1 )) / 2. qtf is an output array of length n which contains the vector ( q transpose ) * fvec . wa1 , wa2 , wa3 , and wa4 are work arrays of length n . Characteristics of the algorithm HYBRJ is a modification of the Powell hybrid method.  Two of its\n  main characteristics involve the choice of the correction as a\n  convex combination of the Newton and scaled gradient directions\n  and the updating of the Jacobian by the rank-1 method of Broy-\n  den.  The choice of the correction guarantees (under reasonable\n  conditions) global convergence for starting points far from the\n  solution and a fast rate of convergence.  The Jacobian is calcu-\n  lated at the starting point, but it is not recalculated until\n  the rank-1 method fails to produce satisfactory progress. References. M. J. D. Powell, A Hybrid Method for Nonlinear Equations.\n   Numerical Methods for Nonlinear Algebraic Equations,\n   P. Rabinowitz, editor. Gordon and Breach, 1970. Arguments Type Intent Optional Attributes Name procedure( fcn_hybrj ) :: fcn integer :: n real(kind=wp) :: x (n) real(kind=wp) :: fvec (n) real(kind=wp) :: fjac (ldfjac,n) integer :: ldfjac real(kind=wp) :: xtol integer :: maxfev real(kind=wp) :: diag (n) integer :: mode real(kind=wp) :: factor integer :: nprint integer :: info integer :: nfev integer :: njev real(kind=wp) :: r (lr) integer :: lr real(kind=wp) :: qtf (n) real(kind=wp) :: wa1 (n) real(kind=wp) :: wa2 (n) real(kind=wp) :: wa3 (n) real(kind=wp) :: wa4 (n) Calls proc~~hybrj~~CallsGraph proc~hybrj hybrj proc~dogleg dogleg proc~hybrj->proc~dogleg proc~dpmpar dpmpar proc~hybrj->proc~dpmpar proc~enorm enorm proc~hybrj->proc~enorm proc~qform qform proc~hybrj->proc~qform proc~qrfac qrfac proc~hybrj->proc~qrfac proc~r1mpyq r1mpyq proc~hybrj->proc~r1mpyq proc~r1updt r1updt proc~hybrj->proc~r1updt proc~dogleg->proc~dpmpar proc~dogleg->proc~enorm proc~qrfac->proc~dpmpar proc~qrfac->proc~enorm proc~r1updt->proc~dpmpar Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hybrj~~CalledByGraph proc~hybrj hybrj proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine hybrj ( fcn , n , x , fvec , fjac , ldfjac , xtol , maxfev , diag , mode , & & factor , nprint , info , nfev , njev , r , lr , qtf , wa1 , wa2 , & & wa3 , wa4 ) implicit none procedure ( fcn_hybrj ) :: fcn integer n , ldfjac , maxfev , mode , nprint , info , nfev , njev , lr real ( wp ) xtol , factor real ( wp ) x ( n ) , fvec ( n ) , fjac ( ldfjac , n ) , diag ( n ) , & r ( lr ) , qtf ( n ) , wa1 ( n ) , wa2 ( n ) , wa3 ( n ) , & wa4 ( n ) integer i , iflag , iter , j , jm1 , l , ncfail , ncsuc , nslow1 , nslow2 integer iwa ( 1 ) logical jeval , sing real ( wp ) actred , delta , epsmch , fnorm , fnorm1 , & pnorm , prered , ratio ,& sum , temp , xnorm real ( wp ), parameter :: p1 = 1.0e-1_wp real ( wp ), parameter :: p5 = 5.0e-1_wp real ( wp ), parameter :: p001 = 1.0e-3_wp real ( wp ), parameter :: p0001 = 1.0e-4_wp epsmch = dpmpar ( 1 ) ! the machine precision ! info = 0 iflag = 0 nfev = 0 njev = 0 ! !     check the input parameters for errors. ! if ( n <= 0 . or . ldfjac < n . or . xtol < zero . or . maxfev <= 0 . or . & factor <= zero . or . lr < ( n * ( n + 1 )) / 2 ) goto 300 if ( mode == 2 ) then do j = 1 , n if ( diag ( j ) <= zero ) goto 300 enddo endif ! !     evaluate the function at the starting point !     and calculate its norm. ! iflag = 1 call fcn ( n , x , fvec , fjac , ldfjac , iflag ) nfev = 1 if ( iflag < 0 ) goto 300 fnorm = enorm ( n , fvec ) ! !     initialize iteration counter and monitors. ! iter = 1 ncsuc = 0 ncfail = 0 nslow1 = 0 nslow2 = 0 ! !     beginning of the outer loop. ! 100 jeval = . true . ! !        calculate the jacobian matrix. ! iflag = 2 call fcn ( n , x , fvec , fjac , ldfjac , iflag ) njev = njev + 1 if ( iflag < 0 ) goto 300 ! !        compute the qr factorization of the jacobian. ! call qrfac ( n , n , fjac , ldfjac ,. false ., iwa , 1 , wa1 , wa2 , wa3 ) ! !        on the first iteration and if mode is 1, scale according !        to the norms of the columns of the initial jacobian. ! if ( iter == 1 ) then if ( mode /= 2 ) then do j = 1 , n diag ( j ) = wa2 ( j ) if ( wa2 ( j ) == zero ) diag ( j ) = one enddo endif ! !        on the first iteration, calculate the norm of the scaled x !        and initialize the step bound delta. ! do j = 1 , n wa3 ( j ) = diag ( j ) * x ( j ) enddo xnorm = enorm ( n , wa3 ) delta = factor * xnorm if ( delta == zero ) delta = factor endif ! !        form (q transpose)*fvec and store in qtf. ! do i = 1 , n qtf ( i ) = fvec ( i ) enddo do j = 1 , n if ( fjac ( j , j ) /= zero ) then sum = zero do i = j , n sum = sum + fjac ( i , j ) * qtf ( i ) enddo temp = - sum / fjac ( j , j ) do i = j , n qtf ( i ) = qtf ( i ) + fjac ( i , j ) * temp enddo endif enddo ! !        copy the triangular factor of the qr factorization into r. ! sing = . false . do j = 1 , n l = j jm1 = j - 1 if ( jm1 >= 1 ) then do i = 1 , jm1 r ( l ) = fjac ( i , j ) l = l + n - i enddo endif r ( l ) = wa1 ( j ) if ( wa1 ( j ) == zero ) sing = . true . enddo ! !        accumulate the orthogonal factor in fjac. ! call qform ( n , n , fjac , ldfjac , wa1 ) ! !        rescale if necessary. ! if ( mode /= 2 ) then do j = 1 , n diag ( j ) = max ( diag ( j ), wa2 ( j )) enddo endif ! !        beginning of the inner loop. ! ! !           if requested, call fcn to enable printing of iterates. ! 200 if ( nprint > 0 ) then iflag = 0 if ( mod ( iter - 1 , nprint ) == 0 ) & & call fcn ( n , x , fvec , fjac , ldfjac , iflag ) if ( iflag < 0 ) goto 300 endif ! !           determine the direction p. ! call dogleg ( n , r , lr , diag , qtf , delta , wa1 , wa2 , wa3 ) ! !           store the direction p and x + p. calculate the norm of p. ! do j = 1 , n wa1 ( j ) = - wa1 ( j ) wa2 ( j ) = x ( j ) + wa1 ( j ) wa3 ( j ) = diag ( j ) * wa1 ( j ) enddo pnorm = enorm ( n , wa3 ) ! !           on the first iteration, adjust the initial step bound. ! if ( iter == 1 ) delta = min ( delta , pnorm ) ! !           evaluate the function at x + p and calculate its norm. ! iflag = 1 call fcn ( n , wa2 , wa4 , fjac , ldfjac , iflag ) nfev = nfev + 1 if ( iflag >= 0 ) then fnorm1 = enorm ( n , wa4 ) ! !           compute the scaled actual reduction. ! actred = - one if ( fnorm1 < fnorm ) actred = one - ( fnorm1 / fnorm ) ** 2 ! !           compute the scaled predicted reduction. ! l = 1 do i = 1 , n sum = zero do j = i , n sum = sum + r ( l ) * wa1 ( j ) l = l + 1 enddo wa3 ( i ) = qtf ( i ) + sum enddo temp = enorm ( n , wa3 ) prered = zero if ( temp < fnorm ) prered = one - ( temp / fnorm ) ** 2 ! !           compute the ratio of the actual to the predicted !           reduction. ! ratio = zero if ( prered > zero ) ratio = actred / prered ! !           update the step bound. ! if ( ratio >= p1 ) then ncfail = 0 ncsuc = ncsuc + 1 if ( ratio >= p5 . or . ncsuc > 1 ) delta = max ( delta , pnorm / p5 ) if ( abs ( ratio - one ) <= p1 ) delta = pnorm / p5 else ncsuc = 0 ncfail = ncfail + 1 delta = p5 * delta endif ! !           test for successful iteration. ! if ( ratio >= p0001 ) then ! !           successful iteration. update x, fvec, and their norms. ! do j = 1 , n x ( j ) = wa2 ( j ) wa2 ( j ) = diag ( j ) * x ( j ) fvec ( j ) = wa4 ( j ) enddo xnorm = enorm ( n , wa2 ) fnorm = fnorm1 iter = iter + 1 endif ! !           determine the progress of the iteration. ! nslow1 = nslow1 + 1 if ( actred >= p001 ) nslow1 = 0 if ( jeval ) nslow2 = nslow2 + 1 if ( actred >= p1 ) nslow2 = 0 ! !           test for convergence. ! if ( delta <= xtol * xnorm . or . fnorm == zero ) info = 1 if ( info == 0 ) then ! !           tests for termination and stringent tolerances. ! if ( nfev >= maxfev ) info = 2 if ( p1 * max ( p1 * delta , pnorm ) <= epsmch * xnorm ) info = 3 if ( nslow2 == 5 ) info = 4 if ( nslow1 == 10 ) info = 5 if ( info == 0 ) then ! !           criterion for recalculating jacobian. ! if ( ncfail == 2 ) goto 100 ! !           calculate the rank one modification to the jacobian !           and update qtf if necessary. ! do j = 1 , n sum = zero do i = 1 , n sum = sum + fjac ( i , j ) * wa4 ( i ) enddo wa2 ( j ) = ( sum - wa3 ( j )) / pnorm wa1 ( j ) = diag ( j ) * (( diag ( j ) * wa1 ( j )) / pnorm ) if ( ratio >= p0001 ) qtf ( j ) = sum enddo ! !           compute the qr factorization of the updated jacobian. ! call r1updt ( n , n , r , lr , wa1 , wa2 , wa3 , sing ) call r1mpyq ( n , n , fjac , ldfjac , wa2 , wa3 ) call r1mpyq ( 1 , n , qtf , 1 , wa2 , wa3 ) ! !           end of the inner loop. ! jeval = . false . ! !        end of the outer loop. ! goto 200 endif endif endif ! !     termination, either normal or user imposed. ! 300 if ( iflag < 0 ) info = iflag iflag = 0 if ( nprint > 0 ) call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end subroutine hybrj","tags":"","url":"proc/hybrj.html"},{"title":"hybrj1 – fortran-astrodynamics-toolkit","text":"public  subroutine hybrj1(fcn, n, x, fvec, fjac, ldfjac, tol, info, wa, lwa) the purpose of hybrj1 is to find a zero of a system of\nn nonlinear functions in n variables by a modification\nof the powell hybrid method. this is done by using the\nmore general nonlinear equation solver hybrj. the user\nmust provide a subroutine which calculates the functions\nand the jacobian. the subroutine statement is subroutine hybrj1(fcn,n,x,fvec,fjac,ldfjac,tol,info,wa,lwa) where fcn is the name of the user-supplied subroutine which\n    calculates the functions and the jacobian. fcn must\n    be declared in an external statement in the user\n    calling program, and should be written as follows. subroutine fcn ( n , x , fvec , fjac , ldfjac , iflag ) integer n , ldfjac , iflag real ( wp ) x ( n ) , fvec ( n ) , fjac ( ldfjac , n ) ---------- if iflag = 1 calculate the functions at x and return this vector in fvec . do not alter fjac . if iflag = 2 calculate the jacobian at x and return this matrix in fjac . do not alter fvec . --------- return end the value of iflag should not be changed by fcn unless the user wants to terminate execution of hybrj1 . in this case set iflag to a negative integer . n is a positive integer input variable set to the number\n    of functions and variables. x is an array of length n. on input x must contain\n    an initial estimate of the solution vector. on output x\n    contains the final estimate of the solution vector. fvec is an output array of length n which contains\n    the functions evaluated at the output x. fjac is an output n by n array which contains the\n    orthogonal matrix q produced by the qr factorization\n    of the final approximate jacobian. ldfjac is a positive integer input variable not less than n\n    which specifies the leading dimension of the array fjac. tol is a nonnegative input variable. termination occurs\n    when the algorithm estimates that the relative error\n    between x and the solution is at most tol. info is an integer output variable. if the user has\n    terminated execution, info is set to the (negative)\n    value of iflag. see description of fcn. otherwise,\n    info is set as follows. info = 0   improper input parameters.\n\ninfo = 1   algorithm estimates that the relative error\n           between x and the solution is at most tol.\n\ninfo = 2   number of calls to fcn with iflag = 1 has\n           reached 100*(n+1).\n\ninfo = 3   tol is too small. no further improvement in\n           the approximate solution x is possible.\n\ninfo = 4   iteration is not making good progress. wa is a work array of length lwa. lwa is a positive integer input variable not less than\n    (n*(n+13))/2. Arguments Type Intent Optional Attributes Name procedure( fcn_hybrj ) :: fcn integer :: n real(kind=wp) :: x (n) real(kind=wp) :: fvec (n) real(kind=wp) :: fjac (ldfjac,n) integer :: ldfjac real(kind=wp) :: tol integer :: info real(kind=wp) :: wa (lwa) integer :: lwa Calls proc~~hybrj1~~CallsGraph proc~hybrj1 hybrj1 proc~hybrj hybrj proc~hybrj1->proc~hybrj proc~dogleg dogleg proc~hybrj->proc~dogleg proc~dpmpar dpmpar proc~hybrj->proc~dpmpar proc~enorm enorm proc~hybrj->proc~enorm proc~qform qform proc~hybrj->proc~qform proc~qrfac qrfac proc~hybrj->proc~qrfac proc~r1mpyq r1mpyq proc~hybrj->proc~r1mpyq proc~r1updt r1updt proc~hybrj->proc~r1updt proc~dogleg->proc~dpmpar proc~dogleg->proc~enorm proc~qrfac->proc~dpmpar proc~qrfac->proc~enorm proc~r1updt->proc~dpmpar Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine hybrj1 ( fcn , n , x , fvec , fjac , ldfjac , tol , info , wa , lwa ) implicit none procedure ( fcn_hybrj ) :: fcn integer n , ldfjac , info , lwa real ( wp ) tol real ( wp ) x ( n ) , fvec ( n ) , fjac ( ldfjac , n ) , wa ( lwa ) integer j , lr , maxfev , mode , nfev , njev , nprint real ( wp ) xtol real ( wp ), parameter :: factor = 10 0.0_wp info = 0 ! check the input parameters for errors. if ( n > 0 . and . ldfjac >= n . and . tol >= zero . and . lwa >= ( n * ( n + 13 )) / 2 ) then ! call hybrj. maxfev = 100 * ( n + 1 ) xtol = tol mode = 2 do j = 1 , n wa ( j ) = one enddo nprint = 0 lr = ( n * ( n + 1 )) / 2 call hybrj ( fcn , n , x , fvec , fjac , ldfjac , xtol , maxfev , wa ( 1 ), mode , & factor , nprint , info , nfev , njev , wa ( 6 * n + 1 ), lr , wa ( n + 1 ), & wa ( 2 * n + 1 ), wa ( 3 * n + 1 ), wa ( 4 * n + 1 ), wa ( 5 * n + 1 )) if ( info == 5 ) info = 4 endif end subroutine hybrj1","tags":"","url":"proc/hybrj1.html"},{"title":"qform – fortran-astrodynamics-toolkit","text":"public  subroutine qform(m, n, q, ldq, wa) this subroutine proceeds from the computed qr factorization of\nan m by n matrix a to accumulate the m by m orthogonal matrix\nq from its factored form. the subroutine statement is subroutine qform(m,n,q,ldq,wa) where m is a positive integer input variable set to the number\n    of rows of a and the order of q. n is a positive integer input variable set to the number\n    of columns of a. q is an m by m array. on input the full lower trapezoid in\n    the first min(m,n) columns of q contains the factored form.\n    on output q has been accumulated into a square matrix. ldq is a positive integer input variable not less than m\n    which specifies the leading dimension of the array q. wa is a work array of length m. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=wp) :: q (ldq,m) integer :: ldq real(kind=wp) :: wa (m) Called by proc~~qform~~CalledByGraph proc~qform qform proc~hybrd hybrd proc~hybrd->proc~qform proc~hybrj hybrj proc~hybrj->proc~qform proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~hybrd1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine qform ( m , n , q , ldq , wa ) implicit none integer m , n , ldq real ( wp ) q ( ldq , m ) , wa ( m ) integer i , j , jm1 , k , l , minmn , np1 real ( wp ) sum , temp ! !     zero out upper triangle of q in the first min(m,n) columns. ! minmn = min ( m , n ) if ( minmn >= 2 ) then do j = 2 , minmn jm1 = j - 1 do i = 1 , jm1 q ( i , j ) = zero enddo enddo endif ! !     initialize remaining columns to those of the identity matrix. ! np1 = n + 1 if ( m >= np1 ) then do j = np1 , m do i = 1 , m q ( i , j ) = zero enddo q ( j , j ) = one enddo endif ! !     accumulate q from its factored form. ! do l = 1 , minmn k = minmn - l + 1 do i = k , m wa ( i ) = q ( i , k ) q ( i , k ) = zero enddo q ( k , k ) = one if ( wa ( k ) /= zero ) then do j = k , m sum = zero do i = k , m sum = sum + q ( i , j ) * wa ( i ) enddo temp = sum / wa ( k ) do i = k , m q ( i , j ) = q ( i , j ) - temp * wa ( i ) enddo enddo endif enddo end subroutine qform","tags":"","url":"proc/qform.html"},{"title":"qrfac – fortran-astrodynamics-toolkit","text":"public  subroutine qrfac(m, n, a, lda, pivot, ipvt, lipvt, rdiag, acnorm, wa) this subroutine uses householder transformations with column\npivoting (optional) to compute a qr factorization of the\nm by n matrix a. that is, qrfac determines an orthogonal\nmatrix q, a permutation matrix p, and an upper trapezoidal\nmatrix r with diagonal elements of nonincreasing magnitude,\nsuch that a p = q r. the householder transformation for\ncolumn k, k = 1,2,...,min(m,n), is of the form t\n  i - (1/u(k))*u*u where u has zeros in the first k-1 positions. the form of\nthis transformation and the method of pivoting first\nappeared in the corresponding linpack subroutine. the subroutine statement is subroutine qrfac(m,n,a,lda,pivot,ipvt,lipvt,rdiag,acnorm,wa) where m is a positive integer input variable set to the number\n    of rows of a. n is a positive integer input variable set to the number\n    of columns of a. a is an m by n array. on input a contains the matrix for\n    which the qr factorization is to be computed. on output\n    the strict upper trapezoidal part of a contains the strict\n    upper trapezoidal part of r, and the lower trapezoidal\n    part of a contains a factored form of q (the non-trivial\n    elements of the u vectors described above). lda is a positive integer input variable not less than m\n    which specifies the leading dimension of the array a. pivot is a logical input variable. if pivot is set true,\n    then column pivoting is enforced. if pivot is set false,\n    then no column pivoting is done. ipvt is an integer output array of length lipvt. ipvt\n    defines the permutation matrix p such that a p = q r.\n    column j of p is column ipvt(j) of the identity matrix.\n    if pivot is false, ipvt is not referenced. lipvt is a positive integer input variable. if pivot is false,\n    then lipvt may be as small as 1. if pivot is true, then\n    lipvt must be at least n. rdiag is an output array of length n which contains the\n    diagonal elements of r. acnorm is an output array of length n which contains the\n    norms of the corresponding columns of the input matrix a.\n    if this information is not needed, then acnorm can coincide\n    with rdiag. wa is a work array of length n. if pivot is false, then wa\n    can coincide with rdiag. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=wp) :: a (lda,n) integer :: lda logical :: pivot integer :: ipvt (lipvt) integer :: lipvt real(kind=wp) :: rdiag (n) real(kind=wp) :: acnorm (n) real(kind=wp) :: wa (n) Calls proc~~qrfac~~CallsGraph proc~qrfac qrfac proc~dpmpar dpmpar proc~qrfac->proc~dpmpar proc~enorm enorm proc~qrfac->proc~enorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~qrfac~~CalledByGraph proc~qrfac qrfac proc~hybrd hybrd proc~hybrd->proc~qrfac proc~hybrj hybrj proc~hybrj->proc~qrfac proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~hybrd1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine qrfac ( m , n , a , lda , pivot , ipvt , lipvt , rdiag , acnorm , wa ) implicit none integer m , n , lda , lipvt integer ipvt ( lipvt ) logical pivot real ( wp ) a ( lda , n ) , rdiag ( n ) , acnorm ( n ) , wa ( n ) integer i , j , jp1 , k , kmax , minmn real ( wp ) ajnorm , epsmch , sum , temp real ( wp ), parameter :: p05 = 5.0e-2_wp epsmch = dpmpar ( 1 ) ! the machine precision ! !     compute the initial column norms and initialize several arrays. ! do j = 1 , n acnorm ( j ) = enorm ( m , a ( 1 , j )) rdiag ( j ) = acnorm ( j ) wa ( j ) = rdiag ( j ) if ( pivot ) ipvt ( j ) = j enddo ! !     reduce a to r with householder transformations. ! minmn = min ( m , n ) do j = 1 , minmn if ( pivot ) then ! !        bring the column of largest norm into the pivot position. ! kmax = j do k = j , n if ( rdiag ( k ) > rdiag ( kmax ) ) kmax = k enddo if ( kmax /= j ) then do i = 1 , m temp = a ( i , j ) a ( i , j ) = a ( i , kmax ) a ( i , kmax ) = temp enddo rdiag ( kmax ) = rdiag ( j ) wa ( kmax ) = wa ( j ) k = ipvt ( j ) ipvt ( j ) = ipvt ( kmax ) ipvt ( kmax ) = k endif endif ! !        compute the householder transformation to reduce the !        j-th column of a to a multiple of the j-th unit vector. ! ajnorm = enorm ( m - j + 1 , a ( j , j )) if ( ajnorm /= zero ) then if ( a ( j , j ) < zero ) ajnorm = - ajnorm do i = j , m a ( i , j ) = a ( i , j ) / ajnorm enddo a ( j , j ) = a ( j , j ) + one ! !        apply the transformation to the remaining columns !        and update the norms. ! jp1 = j + 1 if ( n >= jp1 ) then do k = jp1 , n sum = zero do i = j , m sum = sum + a ( i , j ) * a ( i , k ) enddo temp = sum / a ( j , j ) do i = j , m a ( i , k ) = a ( i , k ) - temp * a ( i , j ) enddo if ( . not .(. not . pivot . or . rdiag ( k ) == zero ) ) then temp = a ( j , k ) / rdiag ( k ) rdiag ( k ) = rdiag ( k ) * sqrt ( max ( zero , one - temp ** 2 )) if ( p05 * ( rdiag ( k ) / wa ( k )) ** 2 <= epsmch ) then rdiag ( k ) = enorm ( m - j , a ( jp1 , k )) wa ( k ) = rdiag ( k ) endif endif enddo endif endif rdiag ( j ) = - ajnorm enddo end subroutine qrfac","tags":"","url":"proc/qrfac.html"},{"title":"r1mpyq – fortran-astrodynamics-toolkit","text":"public  subroutine r1mpyq(m, n, a, lda, v, w) given an m by n matrix a, this subroutine computes a q where\nq is the product of 2 (n - 1) transformations gv(n-1)*...*gv(1)*gw(1)*...*gw(n-1) and gv(i), gw(i) are givens rotations in the (i,n) plane which\neliminate elements in the i-th and n-th planes, respectively.\nq itself is not given, rather the information to recover the\ngv, gw rotations is supplied. the subroutine statement is subroutine r1mpyq(m,n,a,lda,v,w) where m is a positive integer input variable set to the number\n    of rows of a. n is a positive integer input variable set to the number\n    of columns of a. a is an m by n array. on input a must contain the matrix\n    to be postmultiplied by the orthogonal matrix q\n    described above. on output a*q has replaced a. lda is a positive integer input variable not less than m\n    which specifies the leading dimension of the array a. v is an input array of length n. v(i) must contain the\n    information necessary to recover the givens rotation gv(i)\n    described above. w is an input array of length n. w(i) must contain the\n    information necessary to recover the givens rotation gw(i)\n    described above. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=wp) :: a (lda,n) integer :: lda real(kind=wp) :: v (n) real(kind=wp) :: w (n) Called by proc~~r1mpyq~~CalledByGraph proc~r1mpyq r1mpyq proc~hybrd hybrd proc~hybrd->proc~r1mpyq proc~hybrj hybrj proc~hybrj->proc~r1mpyq proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~hybrd1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine r1mpyq ( m , n , a , lda , v , w ) implicit none integer m , n , lda real ( wp ) a ( lda , n ) , v ( n ) , w ( n ) integer i , j , nmj , nm1 real ( wp ) cos , sin , temp ! !     apply the first set of givens rotations to a. ! nm1 = n - 1 if ( nm1 >= 1 ) then do nmj = 1 , nm1 j = n - nmj if ( abs ( v ( j )) > one ) cos = one / v ( j ) if ( abs ( v ( j )) > one ) sin = sqrt ( one - cos ** 2 ) if ( abs ( v ( j )) <= one ) sin = v ( j ) if ( abs ( v ( j )) <= one ) cos = sqrt ( one - sin ** 2 ) do i = 1 , m temp = cos * a ( i , j ) - sin * a ( i , n ) a ( i , n ) = sin * a ( i , j ) + cos * a ( i , n ) a ( i , j ) = temp enddo enddo ! !     apply the second set of givens rotations to a. ! do j = 1 , nm1 if ( abs ( w ( j )) > one ) cos = one / w ( j ) if ( abs ( w ( j )) > one ) sin = sqrt ( one - cos ** 2 ) if ( abs ( w ( j )) <= one ) sin = w ( j ) if ( abs ( w ( j )) <= one ) cos = sqrt ( one - sin ** 2 ) do i = 1 , m temp = cos * a ( i , j ) + sin * a ( i , n ) a ( i , n ) = - sin * a ( i , j ) + cos * a ( i , n ) a ( i , j ) = temp enddo enddo endif end subroutine r1mpyq","tags":"","url":"proc/r1mpyq.html"},{"title":"r1updt – fortran-astrodynamics-toolkit","text":"public  subroutine r1updt(m, n, s, ls, u, v, w, sing) given an m by n lower trapezoidal matrix s, an m-vector u,\nand an n-vector v, the problem is to determine an\northogonal matrix q such that t\n  (s + u*v )*q is again lower trapezoidal. this subroutine determines q as the product of 2*(n - 1)\ntransformations gv(n-1)*...*gv(1)*gw(1)*...*gw(n-1) where gv(i), gw(i) are givens rotations in the (i,n) plane\nwhich eliminate elements in the i-th and n-th planes,\nrespectively. q itself is not accumulated, rather the\ninformation to recover the gv, gw rotations is returned. the subroutine statement is subroutine r1updt(m,n,s,ls,u,v,w,sing) where m is a positive integer input variable set to the number\n    of rows of s. n is a positive integer input variable set to the number\n    of columns of s. n must not exceed m. s is an array of length ls. on input s must contain the lower\n    trapezoidal matrix s stored by columns. on output s contains\n    the lower trapezoidal matrix produced as described above. ls is a positive integer input variable not less than\n    (n (2 m-n+1))/2. u is an input array of length m which must contain the\n    vector u. v is an array of length n. on input v must contain the vector\n    v. on output v(i) contains the information necessary to\n    recover the givens rotation gv(i) described above. w is an output array of length m. w(i) contains information\n    necessary to recover the givens rotation gw(i) described\n    above. sing is a logical output variable. sing is set true if any\n    of the diagonal elements of the output s are zero. otherwise\n    sing is set false. Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=wp) :: s (ls) integer :: ls real(kind=wp) :: u (m) real(kind=wp) :: v (n) real(kind=wp) :: w (m) logical :: sing Calls proc~~r1updt~~CallsGraph proc~r1updt r1updt proc~dpmpar dpmpar proc~r1updt->proc~dpmpar Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~r1updt~~CalledByGraph proc~r1updt r1updt proc~hybrd hybrd proc~hybrd->proc~r1updt proc~hybrj hybrj proc~hybrj->proc~r1updt proc~hybrd1 hybrd1 proc~hybrd1->proc~hybrd proc~hybrj1 hybrj1 proc~hybrj1->proc~hybrj proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~hybrd1 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine r1updt ( m , n , s , ls , u , v , w , sing ) implicit none integer m , n , ls logical sing real ( wp ) s ( ls ) , u ( m ) , v ( n ) , w ( m ) integer i , j , jj , l , nmj , nm1 real ( wp ) cos , cotan , giant , sin , & & tan , tau , temp real ( wp ), parameter :: p5 = 5.0e-1_wp real ( wp ), parameter :: p25 = 2.5e-1_wp ! !     giant is the largest magnitude. ! giant = dpmpar ( 3 ) ! !     initialize the diagonal element pointer. ! jj = ( n * ( 2 * m - n + 1 )) / 2 - ( m - n ) ! !     move the nontrivial part of the last column of s into w. ! l = jj do i = n , m w ( i ) = s ( l ) l = l + 1 enddo ! !     rotate the vector v into a multiple of the n-th unit vector !     in such a way that a spike is introduced into w. ! nm1 = n - 1 if ( nm1 >= 1 ) then do nmj = 1 , nm1 j = n - nmj jj = jj - ( m - j + 1 ) w ( j ) = zero if ( v ( j ) /= zero ) then ! !        determine a givens rotation which eliminates the !        j-th element of v. ! if ( abs ( v ( n )) >= abs ( v ( j )) ) then tan = v ( j ) / v ( n ) cos = p5 / sqrt ( p25 + p25 * tan ** 2 ) sin = cos * tan tau = sin else cotan = v ( n ) / v ( j ) sin = p5 / sqrt ( p25 + p25 * cotan ** 2 ) cos = sin * cotan tau = one if ( abs ( cos ) * giant > one ) tau = one / cos endif ! !        apply the transformation to v and store the information !        necessary to recover the givens rotation. ! v ( n ) = sin * v ( j ) + cos * v ( n ) v ( j ) = tau ! !        apply the transformation to s and extend the spike in w. ! l = jj do i = j , m temp = cos * s ( l ) - sin * w ( i ) w ( i ) = sin * s ( l ) + cos * w ( i ) s ( l ) = temp l = l + 1 enddo endif enddo endif ! !     add the spike from the rank 1 update to w. ! do i = 1 , m w ( i ) = w ( i ) + v ( n ) * u ( i ) enddo ! !     eliminate the spike. ! sing = . false . if ( nm1 >= 1 ) then do j = 1 , nm1 if ( w ( j ) /= zero ) then ! !        determine a givens rotation which eliminates the !        j-th element of the spike. ! if ( abs ( s ( jj )) >= abs ( w ( j )) ) then tan = w ( j ) / s ( jj ) cos = p5 / sqrt ( p25 + p25 * tan ** 2 ) sin = cos * tan tau = sin else cotan = s ( jj ) / w ( j ) sin = p5 / sqrt ( p25 + p25 * cotan ** 2 ) cos = sin * cotan tau = one if ( abs ( cos ) * giant > one ) tau = one / cos endif ! !        apply the transformation to s and reduce the spike in w. ! l = jj do i = j , m temp = cos * s ( l ) + sin * w ( i ) w ( i ) = - sin * s ( l ) + cos * w ( i ) s ( l ) = temp l = l + 1 enddo ! !        store the information necessary to recover the !        givens rotation. ! w ( j ) = tau endif ! !        test for zero diagonal elements in the output s. ! if ( s ( jj ) == zero ) sing = . true . jj = jj + ( m - j + 1 ) enddo endif ! !     move w back into the last column of the output s. ! l = jj do i = n , m s ( l ) = w ( i ) l = l + 1 enddo if ( s ( jj ) == zero ) sing = . true . end subroutine r1updt","tags":"","url":"proc/r1updt.html"},{"title":"solve_lambert_izzo – fortran-astrodynamics-toolkit","text":"public  subroutine solve_lambert_izzo(r1, r2, tof, mu, long_way, multi_revs, v1, v2, status_ok) Solve Lambert's problem using Izzo's method. References D. Izzo, Revisiting Lambert's Problem [v2] Tue, 24 Jun 2014 13:08:37 GMT (606kb,D) PyKEP R. A. Battin, \"An Introduction to the Mathematics and Methods of\n     Astrodynamics (Revised Edition)\", AIAA Education Series, 1999. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r1 first cartesian position [km] real(kind=wp), intent(in), dimension(3) :: r2 second cartesian position [km] real(kind=wp), intent(in) :: tof time of flight [sec] real(kind=wp), intent(in) :: mu gravity parameter [km&#94;3/s&#94;2] logical, intent(in) :: long_way when true, do \"long way\" (>pi) transfers integer, intent(in) :: multi_revs maximum number of multi-rev solutions to compute real(kind=wp), intent(out), dimension(:,:), allocatable :: v1 vector containing 3d arrays with the cartesian components of the velocities at r1 real(kind=wp), intent(out), dimension(:,:), allocatable :: v2 vector containing 3d arrays with the cartesian components of the velocities at r2 logical, intent(out) :: status_ok true if everything is OK Calls proc~~solve_lambert_izzo~~CallsGraph proc~solve_lambert_izzo solve_lambert_izzo proc~ucross ucross proc~solve_lambert_izzo->proc~ucross proc~unit unit proc~solve_lambert_izzo->proc~unit proc~ucross->proc~unit proc~cross cross proc~ucross->proc~cross Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~solve_lambert_izzo~~CalledByGraph proc~solve_lambert_izzo solve_lambert_izzo proc~lambert_test lambert_test proc~lambert_test->proc~solve_lambert_izzo Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine solve_lambert_izzo ( r1 , r2 , tof , mu , long_way , multi_revs , v1 , v2 , status_ok ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r1 !! first cartesian position [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r2 !! second cartesian position [km] real ( wp ), intent ( in ) :: tof !! time of flight [sec] real ( wp ), intent ( in ) :: mu !! gravity parameter [km&#94;3/s&#94;2] logical , intent ( in ) :: long_way !! when true, do \"long way\" (>pi) transfers integer , intent ( in ) :: multi_revs !! maximum number of multi-rev solutions to compute real ( wp ), dimension (:,:), allocatable , intent ( out ) :: v1 !! vector containing 3d arrays with the cartesian components of the velocities at r1 real ( wp ), dimension (:,:), allocatable , intent ( out ) :: v2 !! vector containing 3d arrays with the cartesian components of the velocities at r2 logical , intent ( out ) :: status_ok !! true if everything is OK !local variables: real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension ( 3 ) :: r1_hat , r2_hat , h_hat , it1 , it2 , c real ( wp ) :: s , cmag , lambda2 , lambda3 , lambda5 , t , t00 , t0 , t1 , r1mag , r2mag ,& d3t , d2t , dt , err , t_min , x_old , x_new , term , lambda ,& gamma , rho , sigma , vr1 , vt1 , vr2 , vt2 , y , vt , ly integer :: n_solutions , it , m_nmax , i , iter !tolerances are from [2] integer , parameter :: max_halley_iters = 12 !! for halley iterations real ( wp ), parameter :: halley_tol = 1e-13_wp !! for halley iterations real ( wp ), parameter :: htol_singlerev = 1e-5_wp !! for householder iterations real ( wp ), parameter :: htol_multirev = 1e-8_wp !! for householder iterations !======= Begin Algorithm 1 in [1] ======= r1mag = norm2 ( r1 ) r2mag = norm2 ( r2 ) !check for valid inputs: if ( tof <= zero . or . mu <= zero . or . r1mag == zero . or . r2mag == zero ) then write ( * , * ) 'Error in solve_lambert_izzo: invalid input' status_ok = . false . return end if status_ok = . true . c = r2 - r1 cmag = norm2 ( c ) s = ( cmag + r1mag + r2mag ) / two t = sqrt ( two * mu / ( s * s * s )) * tof r1_hat = unit ( r1 ) r2_hat = unit ( r2 ) h_hat = ucross ( r1_hat , r2_hat ) lambda2 = one - cmag / s lambda = sqrt ( lambda2 ) if ( all ( h_hat == zero ) ) then write ( * , * ) 'Warning: pi transfer in solve_lambert_izzo' !arbitrarily choose the transfer plane: h_hat = [ zero , zero , one ] end if it1 = ucross ( h_hat , r1_hat ) it2 = ucross ( h_hat , r2_hat ) if ( long_way ) then lambda = - lambda it1 = - it1 it2 = - it2 end if lambda3 = lambda * lambda2 lambda5 = lambda2 * lambda3 t1 = two_third * ( one - lambda3 ) !======= Begin Algorithm 2 in [1] ======= ![xlist, ylist] = findxy(lambda, tof) ! maximum number of revolutions for which a solution exists: m_nmax = floor ( t / pi ) t00 = acos ( lambda ) + lambda * sqrt ( one - lambda2 ) t0 = t00 + m_nmax * pi if ( t < t0 . and . m_nmax > 0 ) then ! Compute xm and tm using Halley dt = zero d2t = zero d3t = zero it = 0 err = one t_min = t0 x_old = zero x_new = zero do call dtdx ( dt , d2t , d3t , x_old , t_min ) if ( dt /= zero ) x_new = x_old - dt * d2t / ( d2t * d2t - dt * d3t / two ) err = abs ( x_old - x_new ) if ( ( err < halley_tol ) . or . ( it > max_halley_iters ) ) exit call compute_tof ( x_new , m_nmax , t_min ) x_old = x_new it = it + 1 end do if ( t_min > t ) m_nmax = m_nmax - 1 end if !======= End Algorithm 2 ======= !mmax is the maximum number of revolutions. !Truncate to user-input multi_revs value if it is larger. m_nmax = min ( multi_revs , m_nmax ) !the number of solutions to the problem: n_solutions = m_nmax * 2 + 1 !allocate output arrays: allocate ( v1 ( 3 , n_solutions )) allocate ( v2 ( 3 , n_solutions )) allocate ( x ( n_solutions )) ! Find the x value for each solution: ! initial guess for 0 rev solution: if ( t >= t00 ) then x ( 1 ) = - ( t - t00 ) / ( t - t00 + four ) !from [2] elseif ( t <= t1 ) then x ( 1 ) = five_half * ( t1 * ( t1 - t )) / ( t * ( one - lambda5 )) + one else x ( 1 ) = ( t / t00 ) ** ( log2 / log ( t1 / t00 ) ) - one !from [2] end if ! 0 rev solution: iter = householder ( t , x ( 1 ), 0 , htol_singlerev ) ! multi-rev solutions: do i = 1 , m_nmax !Eqn 31: ! left solution: term = (( i * pi + pi ) / ( eight * t )) ** two_third x ( 2 * i ) = ( term - one ) / ( term + one ) iter = householder ( t , x ( 2 * i ), i , htol_multirev ) ! right solution: term = (( eight * t ) / ( i * pi )) ** two_third x ( 2 * i + 1 ) = ( term - one ) / ( term + one ) iter = householder ( t , x ( 2 * i + 1 ), i , htol_multirev ) end do ! construct terminal velocity vectors using each x: gamma = sqrt ( mu * s / two ) rho = ( r1mag - r2mag ) / cmag sigma = sqrt ( one - rho * rho ) do i = 1 , n_solutions y = sqrt ( one - lambda2 + lambda2 * x ( i ) * x ( i )) ly = lambda * y vr1 = gamma * (( ly - x ( i )) - rho * ( ly + x ( i ))) / r1mag vr2 = - gamma * (( ly - x ( i )) + rho * ( ly + x ( i ))) / r2mag vt = gamma * sigma * ( y + lambda * x ( i )) vt1 = vt / r1mag vt2 = vt / r2mag v1 (:, i ) = vr1 * r1_hat + vt1 * it1 !terminal velocity vectors v2 (:, i ) = vr2 * r2_hat + vt2 * it2 ! end do deallocate ( x ) contains !***************************************************************************************** !************************************************************************************* function householder ( t , x , n , eps ) result ( it ) !! Householder root solver for x. implicit none integer :: it real ( wp ), intent ( in ) :: t real ( wp ), intent ( inout ) :: x !! input is initial guess integer , intent ( in ) :: n real ( wp ), intent ( in ) :: eps real ( wp ) :: xnew , tof , delta , dt , d2t , d3t , dt2 , term integer , parameter :: max_iters = 15 do it = 1 , max_iters call compute_tof ( x , n , tof ) call dtdx ( dt , d2t , d3t , x , tof ) delta = tof - t dt2 = dt * dt term = delta * ( dt2 - delta * d2t / two ) / & ( dt * ( dt2 - delta * d2t ) + d3t * delta * delta / six ) xnew = x - term ! Ref. [1], p. 12. x = xnew if ( abs ( term ) <= eps ) exit end do end function householder !************************************************************************************* !************************************************************************************* subroutine dtdx ( dt , d2t , d3t , x , t ) !! Compute 1st-3rd derivatives for the Householder iterations. implicit none real ( wp ), intent ( out ) :: dt real ( wp ), intent ( out ) :: d2t real ( wp ), intent ( out ) :: d3t real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: t real ( wp ) :: umx2 , y , y2 , y3 , y5 , umx2_inv umx2 = one - x * x umx2_inv = one / umx2 y = sqrt ( one - lambda2 * umx2 ) !Ref [1], p. 6 y2 = y * y y3 = y2 * y y5 = y3 * y2 !Ref [1], Eqn. 22: dt = umx2_inv * ( three * t * x - two + two * lambda3 * x / y ) d2t = umx2_inv * ( three * t + five * x * dt + two * ( one - lambda2 ) * lambda3 / y3 ) d3t = umx2_inv * ( seven * x * d2t + eight * dt - six * ( one - lambda2 ) * lambda5 * x / y5 ) end subroutine dtdx !************************************************************************************* !************************************************************************************* subroutine compute_tof ( x , n , tof ) !!  Compute time of flight from x implicit none real ( wp ), intent ( in ) :: x integer , intent ( in ) :: n real ( wp ), intent ( out ) :: tof real ( wp ), parameter :: battin = 0.01_wp real ( wp ), parameter :: lagrange = 0.2_wp real ( wp ) :: dist , k , e , rho , z , eta , s1 , q , y , g , d , l , f , a , alpha , beta dist = abs ( x - one ) if ( dist < lagrange . and . dist > battin ) then !use lagrange tof expression !See Ref. [1], Eqn. 9 a = one / ( one - x * x ) if ( a > zero ) then !ellipse alpha = two * acos ( x ) beta = two * asin ( sqrt ( lambda2 / a )) if ( lambda < zero ) beta = - beta tof = (( a * sqrt ( a ) * (( alpha - sin ( alpha )) - ( beta - sin ( beta )) + two * pi * n )) / two ) else !hyperbola alpha = two * acosh ( x ) beta = two * asinh ( sqrt ( - lambda2 / a )) if ( lambda < zero ) beta = - beta tof = ( - a * sqrt ( - a ) * (( beta - sinh ( beta )) - ( alpha - sinh ( alpha ))) / two ) end if else k = lambda2 e = x * x - one rho = abs ( e ) z = sqrt ( one + k * e ) if ( dist < battin ) then ! use battin series tof expression !Equation 20 in [1]: ! !See also: Ref. [3], Eqn. 7.30, p. 304. eta = z - lambda * x s1 = ( one - lambda - x * eta ) / two q = four_third * hypergeo ( s1 ) tof = ( eta * eta * eta * q + four * lambda * eta ) / two + n * pi / ( rho ** three_half ) else ! use lancaster tof expresion y = sqrt ( rho ) g = x * z - lambda * e d = zero if ( e < zero ) then l = acos ( g ) d = n * pi + l else f = y * ( z - lambda * x ) d = log ( f + g ) end if tof = ( x - lambda * z - d / y ) / e end if end if end subroutine compute_tof !************************************************************************************* !************************************************************************************* pure function hypergeo ( x ) result ( f ) !!  Evaluate the Gaussian (or ordinary) hypergeometric function: F(3,1,5/2,x) !!  See Ref. [3], p. 34. implicit none real ( wp ) :: f real ( wp ), intent ( in ) :: x real ( wp ) :: term integer :: i real ( wp ), parameter :: tol = 1e-11_wp integer , parameter :: max_iters = 10000 !initialize: f = one term = one !compute the series until the last term is within convergence tolerance: do i = 0 , max_iters term = term * ( three + i ) * ( one + i ) / ( five_half + i ) * x / ( i + one ) f = f + term if ( abs ( term ) <= tol ) exit end do end function hypergeo !************************************************************************************* end subroutine solve_lambert_izzo","tags":"","url":"proc/solve_lambert_izzo.html"},{"title":"solve_lambert_gooding – fortran-astrodynamics-toolkit","text":"public  subroutine solve_lambert_gooding(r1, r2, tof, mu, long_way, multi_revs, v1, v2, status_ok) Solve Lambert's problem using Gooding's method. References R. H, Gooding. \" A procedure for the solution of Lambert's orbital\n     boundary-value problem \"\n     Celestial Mechanics and Dynamical Astronomy,\n     vol. 48, no. 2, 1990, p. 145-165. A. Klumpp, \"Performance Comparision of Lambert and Kepler Algorithms\",\n     JPL Interoffice Memorandum, 314.1-0426-ARK, Jan 2, 1991. Zip Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r1 first cartesian position [km] real(kind=wp), intent(in), dimension(3) :: r2 second cartesian position [km] real(kind=wp), intent(in) :: tof time of flight [sec] real(kind=wp), intent(in) :: mu gravity parameter [km&#94;3/s&#94;2] logical, intent(in) :: long_way when true, do \"long way\" (>pi) transfers integer, intent(in) :: multi_revs maximum number of multi-rev solutions to compute real(kind=wp), intent(out), dimension(:,:), allocatable :: v1 vector containing 3d arrays with the cartesian components of the velocities at r1 real(kind=wp), intent(out), dimension(:,:), allocatable :: v2 vector containing 3d arrays with the cartesian components of the velocities at r2 logical, intent(out) :: status_ok true if everything is OK Calls proc~~solve_lambert_gooding~~CallsGraph proc~solve_lambert_gooding solve_lambert_gooding proc~cross cross proc~solve_lambert_gooding->proc~cross proc~unit unit proc~solve_lambert_gooding->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~solve_lambert_gooding~~CalledByGraph proc~solve_lambert_gooding solve_lambert_gooding proc~lambert_test lambert_test proc~lambert_test->proc~solve_lambert_gooding Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine solve_lambert_gooding ( r1 , r2 , tof , mu , long_way , multi_revs , v1 , v2 , status_ok ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r1 !! first cartesian position [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r2 !! second cartesian position [km] real ( wp ), intent ( in ) :: tof !! time of flight [sec] real ( wp ), intent ( in ) :: mu !! gravity parameter [km&#94;3/s&#94;2] logical , intent ( in ) :: long_way !! when true, do \"long way\" (>pi) transfers integer , intent ( in ) :: multi_revs !! maximum number of multi-rev solutions to compute real ( wp ), dimension (:,:), allocatable , intent ( out ) :: v1 !! vector containing 3d arrays with the cartesian components of the velocities at r1 real ( wp ), dimension (:,:), allocatable , intent ( out ) :: v2 !! vector containing 3d arrays with the cartesian components of the velocities at r2 logical , intent ( out ) :: status_ok !! true if everything is OK integer :: i , j , k , n , n_solutions real ( wp ) :: num_revs , pa , ta , r1mag , r2mag , dr , r1r2 real ( wp ), dimension ( 3 , 2 ) :: vt1 , vt2 real ( wp ), dimension ( 3 ) :: r1hat , r2hat , r1xr2 , rho , r1xr2_hat , etai , etaf real ( wp ), dimension ( 2 ) :: vri , vti , vrf , vtf !temp arrays to hold all the solutions: ! they will be packed into the output arrays logical , dimension ( 2 * multi_revs + 1 ) :: solution_exists real ( wp ), dimension ( 3 , 1 + 2 * multi_revs ) :: all_vt1 , all_vt2 r1mag = norm2 ( r1 ) r2mag = norm2 ( r2 ) if ( r1mag == 0.0_wp . or . r2mag == 0.0_wp . or . mu <= 0.0_wp . or . tof <= 0.0_wp ) then write ( * , * ) 'Error in solve_lambert_gooding: invalid input' status_ok = . false . return end if !initialize: solution_exists = . false . status_ok = . true . dr = r1mag - r2mag r1r2 = r1mag * r2mag r1hat = r1 / r1mag r2hat = r2 / r2mag r1xr2 = cross ( r1 , r2 ) if ( all ( r1xr2 == 0.0_wp )) then !the vectors are parallel, ! so the transfer plane is undefined write ( * , * ) 'Warning: pi transfer in solve_lambert_gooding' r1xr2 = [ 0.0_wp , 0.0_wp , 1.0_wp ] !degenerate conic...choose the x-y plane end if r1xr2_hat = unit ( r1xr2 ) !a trick to make sure argument is between [-1 and 1]: pa = acos ( max ( - 1.0_wp , min ( 1.0_wp , dot_product ( r1hat , r2hat )))) do i = 0 , multi_revs num_revs = real ( i , wp ) !number of complete revs for this case !transfer angle and normal vector: if ( long_way ) then ! greater than pi ta = num_revs * twopi + ( twopi - pa ) rho = - r1xr2_hat else ! less than pi ta = num_revs * twopi + pa rho = r1xr2_hat end if etai = cross ( rho , r1hat ) etaf = cross ( rho , r2hat ) !Gooding routine: call vlamb ( mu , r1mag , r2mag , ta , tof , n , vri , vti , vrf , vtf ) select case ( n ) !number of solutions case ( 1 ) vt1 (:, 1 ) = vri ( 1 ) * r1hat + vti ( 1 ) * etai vt2 (:, 1 ) = vrf ( 1 ) * r2hat + vtf ( 1 ) * etaf case ( 2 ) vt1 (:, 1 ) = vri ( 1 ) * r1hat + vti ( 1 ) * etai vt2 (:, 1 ) = vrf ( 1 ) * r2hat + vtf ( 1 ) * etaf vt1 (:, 2 ) = vri ( 2 ) * r1hat + vti ( 2 ) * etai vt2 (:, 2 ) = vrf ( 2 ) * r2hat + vtf ( 2 ) * etaf end select if ( i == 0 . and . n == 1 ) then !there can be only one solution all_vt1 (:, 1 ) = vt1 (:, 1 ) all_vt2 (:, 1 ) = vt2 (:, 1 ) solution_exists ( 1 ) = . true . else select case ( n ) case ( 1 ) all_vt1 (:, 2 * i ) = vt1 (:, 1 ) all_vt2 (:, 2 * i ) = vt2 (:, 1 ) solution_exists ( 2 * i ) = . true . case ( 2 ) all_vt1 (:, 2 * i ) = vt1 (:, 1 ) all_vt2 (:, 2 * i ) = vt2 (:, 1 ) solution_exists ( 2 * i ) = . true . all_vt1 (:, 2 * i + 1 ) = vt1 (:, 2 ) all_vt2 (:, 2 * i + 1 ) = vt2 (:, 2 ) solution_exists ( 2 * i + 1 ) = . true . end select end if end do !return all the solutions: n_solutions = count ( solution_exists ) allocate ( v1 ( 3 , n_solutions )) allocate ( v2 ( 3 , n_solutions )) k = 0 do i = 1 , size ( solution_exists ) if ( solution_exists ( i )) then k = k + 1 v1 (:, k ) = all_vt1 (:, i ) v2 (:, k ) = all_vt2 (:, i ) end if end do contains !***************************************************************************************** !************************************************************************************* subroutine vlamb ( gm , r1 , r2 , th , tdelt , n , vri , vti , vrf , vtf ) !!  Gooding support routine !!  Note: this contains the modification from [2] implicit none real ( wp ), intent ( in ) :: gm real ( wp ), intent ( in ) :: r1 real ( wp ), intent ( in ) :: r2 real ( wp ), intent ( in ) :: th real ( wp ), intent ( in ) :: tdelt integer , intent ( out ) :: n real ( wp ), dimension ( 2 ), intent ( out ) :: vri real ( wp ), dimension ( 2 ), intent ( out ) :: vti real ( wp ), dimension ( 2 ), intent ( out ) :: vrf real ( wp ), dimension ( 2 ), intent ( out ) :: vtf integer :: m , i real ( wp ) :: thr2 , r1r2th , csq , c , s , gms , qsqfm1 , q , rho , sig , t , x1 , x2 , x , unused ,& qzminx , qzplx , zplqx , vt2 , vr1 , vt1 , vr2 !the following yields m = 0 when th = 2 pi exactly ! neither this nor the original code works for th < 0.0 thr2 = th m = 0 do while ( thr2 > twopi ) thr2 = thr2 - twopi m = m + 1 end do thr2 = thr2 / 2.0_wp !note: dr and r1r2 are computed in the calling routine r1r2th = 4.0_wp * r1r2 * sin ( thr2 ) ** 2 csq = dr * dr + r1r2th c = sqrt ( csq ) s = ( r1 + r2 + c ) / 2.0_wp gms = sqrt ( gm * s / 2.0_wp ) qsqfm1 = c / s q = sqrt ( r1r2 ) * cos ( thr2 ) / s if ( c /= 0.0_wp ) then rho = dr / c sig = r1r2th / csq else rho = 0.0_wp sig = 1.0_wp end if t = 4.0_wp * gms * tdelt / s ** 2 call xlamb ( m , q , qsqfm1 , t , n , x1 , x2 ) !proceed for single solution, or a pair do i = 1 , n if ( i == 1 ) then x = x1 else x = x2 end if call tlamb ( m , q , qsqfm1 , x , - 1 , unused , qzminx , qzplx , zplqx ) vt2 = gms * zplqx * sqrt ( sig ) vr1 = gms * ( qzminx - qzplx * rho ) / r1 vt1 = vt2 / r1 vr2 = - gms * ( qzminx + qzplx * rho ) / r2 vt2 = vt2 / r2 vri ( i ) = vr1 vti ( i ) = vt1 vrf ( i ) = vr2 vtf ( i ) = vt2 end do end subroutine vlamb !************************************************************************************* !************************************************************************************* subroutine tlamb ( m , q , qsqfm1 , x , n , t , dt , d2t , d3t ) !!  Gooding support routine implicit none real ( wp ), intent ( in ) :: q real ( wp ), intent ( in ) :: qsqfm1 real ( wp ), intent ( in ) :: x integer , intent ( in ) :: n real ( wp ), intent ( out ) :: t real ( wp ), intent ( out ) :: dt real ( wp ), intent ( out ) :: d2t real ( wp ), intent ( out ) :: d3t integer :: m , i real ( wp ) :: qsq , xsq , u , y , z ,& qx , a , b , aa , bb , g , f , fg1 , term , fg1sq , twoi1 ,& told , qz , qz2 , u0i , u1i , u2i , u3i , tq , tqsum ,& ttmold , p , tterm , tqterm logical :: lm1 , l1 , l2 , l3 real ( wp ), parameter :: sw = 0.4_wp lm1 = n ==- 1 l1 = n >= 1 l2 = n >= 2 l3 = n == 3 qsq = q * q xsq = x * x u = ( 1.0_wp - x ) * ( 1.0_wp + x ) if (. not . lm1 ) then !(needed if series, and otherwise useful when z = 0) dt = 0.0_wp d2t = 0.0_wp d3t = 0.0_wp end if if ( lm1 . or . m > 0 . or . x < 0.0_wp . or . abs ( u ) > sw ) then !direct computation (not series) y = sqrt ( abs ( u )) z = sqrt ( qsqfm1 + qsq * xsq ) qx = q * x if ( qx <= 0.0_wp ) then a = z - qx b = q * z - x end if if ( qx < 0.0_wp . and . lm1 ) then aa = qsqfm1 / a bb = qsqfm1 * ( qsq * u - xsq ) / b end if if ( qx == 0.0_wp . and . lm1 . or . qx > 0.0_wp ) then aa = z + qx bb = q * z + x end if if ( qx > 0.0_wp ) then a = qsqfm1 / aa b = qsqfm1 * ( qsq * u - xsq ) / bb end if if (. not . lm1 ) then if ( qx * u >= 0.0_wp ) then g = x * z + q * u else g = ( xsq - qsq * u ) / ( x * z - q * u ) end if f = a * y if ( x <= 1.0_wp ) then t = m * pi + atan2 ( f , g ) else if ( f > sw ) then t = log ( f + g ) else fg1 = f / ( g + 1.0_wp ) term = 2.0_wp * fg1 fg1sq = fg1 * fg1 t = term twoi1 = 1.0_wp do twoi1 = twoi1 + 2.0_wp term = term * fg1sq told = t t = t + term / twoi1 if ( t /= told ) cycle exit end do !(continue looping for inverse tanh) end if end if t = 2.0_wp * ( t / y + b ) / u if ( l1 . and . z /= 0.0_wp ) then qz = q / z qz2 = qz * qz qz = qz * qz2 dt = ( 3.0_wp * x * t - 4.0_wp * ( a + qx * qsqfm1 ) / z ) / u if ( l2 ) d2t = ( 3.0_wp * t + 5.0_wp * x * dt + 4.0_wp * qz * qsqfm1 ) / u if ( l3 ) d3t = ( 8.0_wp * dt + 7.0_wp * x * d2t - 1 2.0_wp * qz * qz2 * x * qsqfm1 ) / u end if else dt = b d2t = bb d3t = aa end if else !compute by series u0i = 1.0_wp if ( l1 ) u1i = 1.0_wp if ( l2 ) u2i = 1.0_wp if ( l3 ) u3i = 1.0_wp term = 4.0_wp tq = q * qsqfm1 i = 0 if ( q < 0.5_wp ) tqsum = 1.0_wp - q * qsq if ( q >= 0.5_wp ) tqsum = ( 1.0_wp / ( 1.0_wp + q ) + q ) * qsqfm1 ttmold = term / 3.0_wp t = ttmold * tqsum do i = i + 1 p = i u0i = u0i * u if ( l1 . and . i > 1 ) u1i = u1i * u if ( l2 . and . i > 2 ) u2i = u2i * u if ( l3 . and . i > 3 ) u3i = u3i * u term = term * ( p - 0.5_wp ) / p tq = tq * qsq tqsum = tqsum + tq told = t tterm = term / ( 2.0_wp * p + 3.0_wp ) tqterm = tterm * tqsum t = t - u0i * (( 1.5_wp * p + 0.25_wp ) * tqterm / ( p * p - 0.25_wp ) - ttmold * tq ) ttmold = tterm tqterm = tqterm * p if ( l1 ) dt = dt + tqterm * u1i if ( l2 ) d2t = d2t + tqterm * u2i * ( p - 1.0_wp ) if ( l3 ) d3t = d3t + tqterm * u3i * ( p - 1.0_wp ) * ( p - 2.0_wp ) if ( i < n . or . t /= told ) cycle exit end do if ( l3 ) d3t = 8.0_wp * x * ( 1.5_wp * d2t - xsq * d3t ) if ( l2 ) d2t = 2.0_wp * ( 2.0_wp * xsq * d2t - dt ) if ( l1 ) dt = - 2.0_wp * x * dt t = t / xsq end if end subroutine tlamb !************************************************************************************* !************************************************************************************* pure function d8rt ( x ) !!  8th root function, used by xlamb implicit none real ( wp ) :: d8rt real ( wp ), intent ( in ) :: x d8rt = sqrt ( sqrt ( sqrt ( x ))) end function d8rt !************************************************************************************* !************************************************************************************* subroutine xlamb ( m , q , qsqfm1 , tin , n , x , xpl ) !!  Gooding support routine implicit none integer , intent ( in ) :: m real ( wp ), intent ( in ) :: q real ( wp ), intent ( in ) :: qsqfm1 real ( wp ), intent ( in ) :: tin integer , intent ( out ) :: n real ( wp ), intent ( out ) :: x real ( wp ), intent ( out ) :: xpl integer :: i , ij real ( wp ) :: thr2 , t0 , dt , d2t , d3t , tdiff , w , xm , tmin ,& xmold , xtest , tdiffm , d2t2 , t , tdiff0 real ( wp ), parameter :: tol = 3.0e-7_wp real ( wp ), parameter :: c0 = 1.7_wp real ( wp ), parameter :: c1 = 0.5_wp real ( wp ), parameter :: c2 = 0.03_wp real ( wp ), parameter :: c3 = 0.15_wp real ( wp ), parameter :: c41 = 1.0_wp real ( wp ), parameter :: c42 = 0.24_wp thr2 = atan2 ( qsqfm1 , 2.0_wp * q ) / pi if ( m == 0 ) then !single-rev starter from t (at x = 0) & bilinear (usually) n = 1 call tlamb ( m , q , qsqfm1 , 0.0_wp , 0 , t0 , dt , d2t , d3t ) tdiff = tin - t0 if ( tdiff <= 0.0_wp ) then x = t0 * tdiff / ( - 4.0_wp * tin ) !(-4 is the value of dt, for x = 0) else x = - tdiff / ( tdiff + 4.0_wp ) w = x + c0 * sqrt ( 2.0_wp * ( 1.0_wp - thr2 )) if ( w < 0.0_wp ) x = x - sqrt ( d8rt ( - w )) * ( x + sqrt ( tdiff / ( tdiff + 1.5_wp * t0 ))) w = 4.0_wp / ( 4.0_wp + tdiff ) x = x * ( 1.0_wp + x * ( c1 * w - c2 * x * sqrt ( w ))) end if else !with multirevs, first get t(min) as basis for starter xm = 1.0_wp / ( 1.5_wp * ( m + 0.5_wp ) * pi ) if ( thr2 < 0.5_wp ) xm = d8rt ( 2.0_wp * thr2 ) * xm if ( thr2 > 0.5_wp ) xm = ( 2.0_wp - d8rt ( 2.0_wp - 2.0_wp * thr2 )) * xm !(starter for tmin) do i = 1 , 12 call tlamb ( m , q , qsqfm1 , xm , 3 , tmin , dt , d2t , d3t ) if ( d2t == 0.0_wp ) exit xmold = xm xm = xm - dt * d2t / ( d2t * d2t - dt * d3t / 2.0_wp ) xtest = abs ( xmold / xm - 1.0_wp ) if ( xtest <= tol ) exit end do if ( i > 12 ) then !(break off & exit if tmin not located - should never happen) !now proceed from t(min) to full starter n = - 1 return end if tdiffm = tin - tmin if ( tdiffm < 0.0_wp ) then n = 0 return !(exit if no solution with this m) else if ( tdiffm == 0.0_wp ) then x = xm n = 1 return !(exit if unique solution already from x(tmin)) else n = 3 if ( d2t == 0.0_wp ) d2t = 6.0_wp * m * pi x = sqrt ( tdiffm / ( d2t / 2.0_wp + tdiffm / ( 1.0_wp - xm ) ** 2 )) w = xm + x w = w * 4.0_wp / ( 4.0_wp + tdiffm ) + ( 1.0_wp - w ) ** 2 x = x * ( 1.0_wp - ( 1.0_wp + m + c41 * ( thr2 - 0.5_wp )) / & ( 1.0_wp + c3 * m ) * x * ( c1 * w + c2 * x * sqrt ( w ))) + xm d2t2 = d2t / 2.0_wp if ( x >= 1.0_wp ) then n = 1 goto 3 end if !(no finite solution with x > xm) end if end if !(now have a starter, so proceed by halley) 5 continue do i = 1 , 3 call tlamb ( m , q , qsqfm1 , x , 2 , t , dt , d2t , d3t ) t = tin - t if ( dt /= 0.0_wp ) x = x + t * dt / ( dt * dt + t * d2t / 2.0_wp ) end do if ( n /= 3 ) return !(exit if only one solution, normally when m = 0) n = 2 xpl = x !(second multi-rev starter) 3 call tlamb ( m , q , qsqfm1 , 0.0_wp , 0 , t0 , dt , d2t , d3t ) tdiff0 = t0 - tmin tdiff = tin - t0 if ( tdiff <= 0 ) then x = xm - sqrt ( tdiffm / ( d2t2 - tdiffm * ( d2t2 / tdiff0 - 1.0_wp / xm ** 2 ))) else x = - tdiff / ( tdiff + 4.0_wp ) ij = 200 w = x + c0 * sqrt ( 2.0_wp * ( 1.0_wp - thr2 )) if ( w < 0.0_wp ) x = x - sqrt ( d8rt ( - w )) * ( x + sqrt ( tdiff / ( tdiff + 1.5_wp * t0 ))) w = 4.0_wp / ( 4.0_wp + tdiff ) x = x * ( 1.0_wp + ( 1.0_wp + m + c42 * ( thr2 - 0.5_wp )) / & ( 1.0_wp + c3 * m ) * x * ( c1 * w - c2 * x * sqrt ( w ))) if ( x <=- 1.0_wp ) then n = n - 1 !(no finite solution with x < xm) if ( n == 1 ) x = xpl end if end if goto 5 end subroutine xlamb !************************************************************************************* end subroutine solve_lambert_gooding","tags":"","url":"proc/solve_lambert_gooding.html"},{"title":"solve_lambert_arorarussell – fortran-astrodynamics-toolkit","text":"public  subroutine solve_lambert_arorarussell(r1, r2, tofin, mu, lu, nrev, long_way, shortperiod, tolerance, max_iterations, v1, v2) Solve Lambert's problem using the Arora/Russell method. Reference Arora and Russell, \"A fast and robust multiple revolution lambert algorithm\n   using a cosine transformation\", AAS Hilton Head 2013, AAS 13-728.\n   [see also the journal article] Lambert_AroraRussell.cpp from EMTG . !!!!!! test: use ZEROIN for the rootfinder rather than bisection !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ORIGINAL bisection function for root solve: l(k) = tof(k) - t* Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r1 real(kind=wp), intent(in), dimension(3) :: r2 real(kind=wp), intent(in) :: tofin real(kind=wp), intent(in) :: mu real(kind=wp), intent(in) :: lu scale factor in km integer, intent(in) :: nrev logical, intent(in) :: long_way logical, intent(in) :: shortperiod real(kind=wp), intent(in) :: tolerance integer, intent(in) :: max_iterations real(kind=wp), intent(out), dimension(3) :: v1 real(kind=wp), intent(out), dimension(3) :: v2 Called by proc~~solve_lambert_arorarussell~~CalledByGraph proc~solve_lambert_arorarussell solve_lambert_arorarussell proc~lambert_test lambert_test proc~lambert_test->proc~solve_lambert_arorarussell Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine solve_lambert_arorarussell ( r1 , r2 , tofin , mu , lu , nrev , long_way ,& shortperiod , tolerance ,& max_iterations , v1 , v2 ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r1 real ( wp ), dimension ( 3 ), intent ( in ) :: r2 real ( wp ), intent ( in ) :: tofin real ( wp ), intent ( in ) :: mu real ( wp ), intent ( in ) :: lu !! scale factor in km integer , intent ( in ) :: nrev logical , intent ( in ) :: long_way logical , intent ( in ) :: shortperiod real ( wp ), intent ( in ) :: tolerance integer , intent ( in ) :: max_iterations real ( wp ), dimension ( 3 ), intent ( out ) :: v1 real ( wp ), dimension ( 3 ), intent ( out ) :: v2 !integer,parameter  :: max_iterations_bisection = 50         ! original !real(wp),parameter :: bisection_error_tolerance = 1e-8_wp integer , parameter :: max_iterations_bisection = 100 !! modified from original - better match for izzo and gooding real ( wp ), parameter :: bisection_error_tolerance = 1e-14_wp !! modified from original - better match for izzo and gooding real ( wp ), parameter :: sq2 = sqrt ( two ) logical , parameter :: use_zeroin = . false . !! jw test ! precomputed values for for dele_bi0 for first 20 revs ! (deltae_b point where tau crosses zero from arora eqn 55) real ( wp ), dimension ( 0 : 19 ), parameter :: dele_bi0 = [ & 2.848574_wp , 2.969742_wp , 3.019580_wp , 3.046927_wp ,& 3.064234_wp , 3.076182_wp , 3.084929_wp , 3.091610_wp ,& 3.096880_wp , 3.101145_wp , 3.104666_wp , 3.107623_wp ,& 3.110142_wp , 3.112312_wp , 3.114203_wp , 3.115864_wp ,& 3.117335_wp , 3.118646_wp , 3.119824_wp , 3.120886_wp ] real ( wp ) :: cos_transfer_angle , error real ( wp ) :: k , k_n , k_m , deltak , r1mag , r2mag , tu , r1mag_n , r2mag_n , tof , mu_n real ( wp ) :: theta , s , eps , d , tau , r_buff , t_parabolic , m_k , w_k real ( wp ) :: k_i , z , alpha , f_0 , f_1 , f_i , f_star real ( wp ) :: tof20 , tof100 , m_i , w_ki , x_star , w , t0 , t1 , sgn_tau real ( wp ) :: var2 , var1 , dele_biguess , var3 , sgn_var3 , k_biguess real ( wp ) :: m_kbiguess , w_kbiguess , t_biguess , k_bi , t_bi , m_bi , w_bi real ( wp ) :: w_km1 , w_kmp5 , w_k0 , w_kp5 , w_k1 , tof_km1 , tof_kmp5 , tof_k0 , tof_kp5 , tof_k1 real ( wp ) :: m_ki , tof_ki , w_km1p41 , w_km1p38 , w_k1dsq2 real ( wp ) :: tof_km1p41 , tof_km1p38 , tof_k1dsq2 real ( wp ) :: c_1 , c_2 , c_3 , c_4 , f_n , gamma_1 , gamma_2 , gamma_3 real ( wp ) :: k_initialguess , m real ( wp ) :: dw , ddw real ( wp ) :: v , vv , v3 , v4 , v5 , v6 , v7 real ( wp ) :: tofc , c , sqrtctau , dtofc , ddtofc real ( wp ) :: low_k , high_k , middle_k , tof_low_k , tof_high_k , tof_middle_k , l_low_k , l_high_k real ( wp ) :: l_middle_k real ( wp ) :: f , g , gdot real ( wp ) :: lu3 , luptu real ( wp ) :: r1mag_n_plus_r2mag_n , r1mag_n_times_r2mag_n , omkt integer :: sgn_l_middle_k , sgn_l_low_k integer :: iterations , iterations_bisection , iflag real ( wp ), dimension ( 3 ) :: r1_n , r2_n , v1_n , v2_n lu3 = lu * lu * lu k = - one ! iteration variable, initialized to -1. it gets overwritten soon but this prevents an annoying compiler warning. k_n = - sq2 ! lower bound for iteration variable k (will be overwritten based on transfer type) k_m = huge ( one ) ! upper bound for iteration variable k (will be overwritten based on transfer type) deltak = huge ( one ) ! error in current solution for k r1mag = norm2 ( r1 ) ! magnitude of initial position r2mag = norm2 ( r2 ) ! magnitude of initial position tu = sqrt (( one / mu ) * lu3 ) ! time unit set so that mu = 1 luptu = lu / tu ! normalize r1, r2, and mu r1_n = r1 / lu r2_n = r2 / lu r1mag_n = r1mag / lu r2mag_n = r2mag / lu tof = tofin / tu mu_n = mu * ( tu * tu ) / lu3 r1mag_n_plus_r2mag_n = r1mag_n + r2mag_n r1mag_n_times_r2mag_n = r1mag_n * r2mag_n ! define transfer angle based on long_way flag cos_transfer_angle = dot_product ( r1_n , r2_n ) / r1mag_n_times_r2mag_n !cosine of the transfer angle theta = safe_acos ( cos_transfer_angle ) !transfer angle if ( long_way ) then !long_way == 1 theta = twopi - theta else theta = theta end if ! calculate s and tau s = sqrt ( r1mag_n_plus_r2mag_n ** 3 / mu_n ) !semi-perimeter iterations = 0 !iterations counter eps = 2.0e-2_wp !to prevent singularity at k = sqrt(2) !d = theta <= pi ? one : -one if ( theta <= pi ) then d = one else d = - one end if tau = d * sqrt ( r1mag_n_times_r2mag_n * ( one + cos_transfer_angle )) / & r1mag_n_plus_r2mag_n !lambert geometry parameter r_buff = 0.2_wp !user-defined parameter to determine when to skip k_bi root solve !step 1: generate appropriate initial guess !declare some variables that will be used in the initial guess !step 1.1 compare the desired time of flight to the parabolic time of flight t_parabolic = s * sqrt ( one - sq2 * tau ) * ( tau + sq2 ) / three if ( tof <= t_parabolic ) then !a hyperbolic trajectory is desired tof20 = s * sqrt ( one - 2 0.0_wp * tau ) * ( tau + 0.04940968903_wp * ( one - 2 0.0_wp * tau )) tof100 = s * sqrt ( one - 10 0.0_wp * tau ) * ( tau + 0.00999209404_wp * ( one - 10 0.0_wp * tau )) if ( d > zero ) then k_n = sq2 k_m = one / tau k_i = ( k_n + k_m ) / two z = one / sq2 alpha = 0.5_wp f_0 = t_parabolic f_1 = zero m_i = two - k_i * k_i w_ki = compute_w ( k_i , m_i , nrev ) f_i = s * sqrt ( one - k_i * tau ) * ( tau + ( one - k_i * tau ) * w_ki ) f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else if ( tof > tof20 ) then !arora's \"h1\" region k_n = sq2 k_m = 2 0.0_wp k_i = ( two * k_n + k_m ) / three z = one / three alpha = one f_0 = t_parabolic f_1 = tof20 m_i = two - k_i * k_i w = compute_w ( k_i , m_i , nrev ) f_i = s * sqrt ( one - k_i * tau ) * ( tau + ( one - k_i * tau ) * w ) f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else !arora's \"h2\" region k_n = 2 0.0_wp k_m = huge ( 1.0_wp ) t0 = tof20 t1 = tof100 k = (( t1 * ( t0 - tof ) * 1 0.0_wp - & t0 * sqrt ( 2 0.0_wp ) * ( t1 - tof )) / ( tof * ( t0 - t1 ))) * & (( t1 * ( t0 - tof ) * 1 0.0_wp - & t0 * sqrt ( 2 0.0_wp ) * ( t1 - tof )) / ( tof * ( t0 - t1 ))) end if else if ( nrev >= 1 ) then !a multi-revolution elliptical orbit is desired m_k = two - k * k w_k = compute_w ( k , m_k , nrev ) error = tof - compute_tof ( k , s , tau , w_k ) ! calculate estimate for k_bi (k_biguess) !sgn_tau = tau >= 0 ? one : -one sgn_tau = sign ( one , tau ) var2 = dele_bi0 ( nrev - 1 ) ! dummy variable 2 var1 = eight * abs ( tau ) / ( var2 * ( sq2 - two * abs ( tau ))) ! dummy variable 1 dele_biguess = var2 * ( one - sgn_tau ) + var2 * sgn_tau * pow (( one / ( one + var1 )), 0.25_wp ) var3 = pi - dele_biguess !sgn_var3 = var3 >= 0 ? one : -one sgn_var3 = sign ( one , var3 ) k_biguess = sgn_var3 * sqrt ( cos ( dele_biguess ) + one ) ! calculate t_biguess m_kbiguess = two - k_biguess * k_biguess ! m based on k_biguess w_kbiguess = compute_w ( k_biguess , m_kbiguess , nrev ) t_biguess = s * sqrt ( one - k_biguess * tau ) * ( tau + ( one - k_biguess * tau ) * w_kbiguess ) ! root solve to find k_bi and t_bi if ( ( abs ( tof - t_biguess ) > ( r_buff * tof )) . and . ( tof > t_biguess )) then !do not need to root solve k_bi = k_biguess t_bi = t_biguess else ! find k_bi using newton raphson k_bi = compute_kb ( k_biguess , tau , s , nrev , & tolerance , max_iterations , sq2 , eps ) ! solve via newton raphson m_bi = two - k_bi * k_bi w_bi = compute_w ( k_bi , m_bi , nrev ) t_bi = s * sqrt ( one - k_bi * tau ) * ( tau + ( one - k_bi * tau ) * w_bi ) end if if ( tof < t_bi ) then !return - no solution for this nrev write ( * , * ) 'no solution for this nrev' return end if w_km1 = 5.71238898_wp + two * pi * nrev w_kmp5 = 1.95494660_wp + 2.71408094_wp * nrev w_k0 = sq2 / four * ( pi + two * pi * nrev ) w_kp5 = 0.75913433_wp + 2.71408094_wp * nrev w_k1 = 0.57079632_wp + two * pi * nrev tof_km1 = compute_tof ( - one , s , tau , w_km1 ) ! (k,s,tau,w) tof_kmp5 = compute_tof ( - 0.5_wp , s , tau , w_kmp5 ) ! (k,s,tau,w) tof_k0 = compute_tof ( zero , s , tau , w_k0 ) ! (k,s,tau,w) tof_kp5 = compute_tof ( 0.5_wp , s , tau , w_kp5 ) ! (k,s,tau,w) tof_k1 = compute_tof ( one , s , tau , w_k1 ) ! (k,s,tau,w) ! generate initial guess for k (k_star) for long period and short ! period solutions for a given nrev if ( k_bi >= zero ) then if (. not . shortperiod ) then ! long period solution if (( tof >= tof_k1 ) . and . ( k_bi >= one )) then ! use first row of table 5 ! compute intial guess for k k_n = k_bi k_m = sq2 k_i = ( k_bi + sq2 ) * 0.5_wp z = 0.25_wp alpha = two f_0 = one / t_bi f_1 = zero m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = one / tof_ki f_star = one / tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else if (( tof >= tof_k1 ) . and . ( k_bi <= one )) then ! use second row of table 5 ! compute intial guess for k k_n = one k_m = sq2 k_i = ( one + two * sq2 ) / three z = 4.0_wp / 9.0_wp alpha = two f_0 = one / tof_k1 f_1 = zero m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = one / tof_ki f_star = one / tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else !((tof < tof_k1) .and. (k_bi <= one)) ! use third row of table 5 ! compute intial guess for k k_n = k_bi k_m = one k_i = ( one + k_bi ) * 0.5_wp z = 0.25_wp alpha = two f_0 = t_bi f_1 = tof_k1 m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = tof_ki f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + & ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star end if else ! long period solution if ( tof < tof_k0 ) then ! use fourth row of table 5 ! compute intial guess for k k_n = zero k_m = k_bi k_i = k_bi * 0.5_wp z = 0.5_wp ** ( 6.0_wp / 5.0_wp ) alpha = 6.0_wp / 5.0_wp f_0 = tof_k0 f_1 = t_bi m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = tof_ki f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else if (( tof > tof_k0 ) . and . ( tof < tof_km1 )) then ! use fifth row of table 5 ! compute intial guess for k k_n = - one k_m = zero k_i = - 0.5_wp z = 0.5_wp alpha = one f_0 = tof_km1 f_1 = tof_k0 f_i = tof_kmp5 f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else !(tof > tof_km1) ! use sixth row of table 5 ! compute intial guess for k k_n = - one k_m = - one * sq2 k_i = ( - one - two * sq2 ) / three z = 4.0_wp / 9.0_wp alpha = two f_0 = one / tof_km1 f_1 = zero m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = one / tof_ki f_star = one / tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star end if end if else ! k_bi < 0 if ( shortperiod ) then ! short period solution if (( tof >= tof_km1 ) . and . ( k_bi <= - one )) then ! use first row of table 6 ! compute intial guess for k k_n = k_bi k_m = - one * sq2 k_i = ( k_bi - sq2 ) * 0.5_wp z = 0.25_wp alpha = two f_0 = one / t_bi f_1 = zero m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = one / tof_ki f_star = one / tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else if (( tof >= tof_km1 ) . and . ( k_bi >= - one )) then ! use second row of table 6 ! compute intial guess for k k_n = - one k_m = - sq2 k_i = ( - one - two * sq2 ) / three z = 4.0_wp / 9.0_wp alpha = two f_0 = one / tof_km1 f_1 = zero m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = one / tof_ki f_star = one / tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else ! ((tof <= tof_km1) .and. (k_bi >= -one)) ! use third row of table 6 ! compute intial guess for k k_n = k_bi k_m = - one k_i = ( - one + k_bi ) * 0.5_wp z = 0.25_wp alpha = two f_0 = t_bi f_1 = tof_km1 m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = tof_ki f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star end if else ! long period solution if ( tof <= tof_k0 ) then ! use fourth row of table 6 ! compute intial guess for k k_n = k_bi k_m = zero k_i = k_bi * 0.5_wp z = 0.25_wp alpha = two f_0 = t_bi f_1 = tof_k0 m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = tof_ki f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else if (( tof > tof_k0 ) . and . ( tof < tof_k1 )) then ! use fifth row of table 6 ! compute intial guess for k k_n = zero k_m = one k_i = 0.5_wp z = 0.5_wp ** ( 6.0_wp / 5.0_wp ) alpha = 6.0_wp / 5.0_wp f_0 = tof_k0 f_1 = tof_k1 f_i = tof_kp5 f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else !(tof > tof_k1) ! use sixth row of table 6 ! compute intial guess for k k_n = one k_m = sq2 k_i = ( one + two * sq2 ) / three z = 4.0_wp / 9.0_wp alpha = two f_0 = one / tof_k1 f_1 = zero m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = one / tof_ki f_star = one / tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star end if end if end if else if ( nrev < 1 ) then ! a single-revolution elliptical orbit is desired !determine elliptical region by comparing actual tof (i.e., tstar) with tof(k) function value w_km1 = 5.712388981_wp ! w calculated at k=-1 w_km1p41 = 483 9.684497246_wp ! w calculated at k=-1.41 w_km1p38 = 21 2.087279879_wp ! w calculated at k=-1.38 w_kmp5 = 1.954946607_wp ! w calculated at k=-0.5 w_k1dsq2 = 0.6686397730_wp ! w calculate at k=a/sqrt(2) tof_km1p41 = s * sqrt ( one + 1.41_wp * tau ) * ( tau + ( one + 1.41_wp * tau ) * w_km1p41 ) tof_km1p38 = s * sqrt ( one + 1.38_wp * tau ) * ( tau + ( one + 1.38_wp * tau ) * w_km1p38 ) tof_km1 = s * sqrt ( one + tau ) * ( tau + ( one + tau ) * w_km1 ) tof_k0 = s * ( sq2 / 4.0_wp * pi + tau ) tof_k1dsq2 = s * sqrt ( one - one / sq2 * tau ) * ( tau + ( one - one / sq2 * tau ) * w_k1dsq2 ) tof_kmp5 = s * sqrt ( one + 0.5_wp * tau ) * ( tau + ( one + 0.5_wp * tau ) * w_kmp5 ) if ( tof >= tof_km1p38 ) then ! use region e4 for guess k_n = - 1.38_wp k_m = - sq2 k_i = - 1.41_wp c_1 = 4926 7.0_wp / 2705 9.0_wp c_2 = 6728 6.0_wp / 1789 7.0_wp c_3 = 281 3.0_wp / 28744 3.0_wp c_4 = 443 9.0_wp / 315 6.0_wp alpha = 24 3.0_wp f_n = 1.0_wp / tof_km1p38 f_i = 1.0_wp / tof_km1p41 f_star = 1.0_wp / tof gamma_1 = f_i * ( f_star - f_n ) gamma_2 = f_star * ( f_n - f_i ) gamma_3 = f_n * ( f_star - f_i ) k = - c_4 * pow ((( gamma_1 * c_1 - c_3 * gamma_3 ) * c_2 + c_3 * c_1 * gamma_2 ) / & ( gamma_3 * c_1 - gamma_1 * c_3 - gamma_2 * c_2 ), ( one / alpha )) else if (( tof_km1p38 >= tof ) . and . ( tof >= tof_km1 )) then ! use region e3 for guess k_n = - one k_m = - one * sq2 k_i = - 1.38_wp c_1 = 54064 9.0_wp / 312 5.0_wp c_2 = 25 6.0_wp c_3 = one c_4 = one alpha = 1 6.0_wp f_n = 1.0_wp / tof_km1 f_i = 1.0_wp / tof_km1p38 f_star = 1.0_wp / tof gamma_1 = f_i * ( f_star - f_n ) gamma_2 = f_star * ( f_n - f_i ) gamma_3 = f_n * ( f_star - f_i ) k = - c_4 * pow ((( gamma_1 * c_1 - c_3 * gamma_3 ) * c_2 + c_3 * c_1 * gamma_2 ) / & ( gamma_3 * c_1 - gamma_1 * c_3 - gamma_2 * c_2 ), & ( one / alpha )) else if (( tof_km1 >= tof ) . and . ( tof >= tof_k0 )) then ! use region e2 for guess k_n = zero k_m = - one k_i = - 0.5_wp z = 0.5_wp alpha = one f_0 = tof_k0 f_1 = tof_km1 f_i = tof_kmp5 f_star = tof x_star = ( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + & ( f_0 - f_i ) * ( f_1 - f_star )) k = k_n + ( k_m - k_n ) * x_star else ! use region e1 for guess k_n = zero k_m = sq2 k_i = 1.0_wp / sq2 z = 0.5_wp alpha = one f_0 = tof_k0 f_1 = t_parabolic f_i = tof_k1dsq2 f_star = tof x_star = ( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + & ( f_0 - f_i ) * ( f_1 - f_star )) k = k_n + ( k_m - k_n ) * x_star end if end if !step 2: iterate to find k k_initialguess = k do while ( abs ( deltak ) > tolerance . and . iterations < max_iterations ) !step 2.1 increment the iterations counter iterations = iterations + 1 !step 2.2 compute w, dw, ddw m = two - k * k !double sgnk = k >= 0 ? one : -one  ! JW : unnecessary w = compute_w ( k , m , nrev ) !dw and ddw if (( k < sq2 - eps ) . or . ( k > sq2 + eps )) then dw = ( - two + three * w * k ) / m ddw = ( five * dw * k + three * w ) / m else v = k - sq2 vv = v * v v3 = v * vv v4 = v3 * v v5 = v4 * v v6 = v5 * v v7 = v6 * v dw = - one / five & + sq2 * v * ( four / 3 5.0_wp ) - vv * ( 6.0_wp / 6 3.0_wp ) & + sq2 * v3 * ( eight / 23 1.0_wp ) - v4 * ( 1 0.0_wp / 42 9.0_wp ) & + sq2 * v5 * ( 4 8.0_wp / 643 5.0_wp ) - v6 * ( 5 6.0_wp / 1215 5.0_wp ) & + sq2 * v7 * ( 6 4.0_wp / 4618 9.0_wp ) ddw = sq2 * ( four / 3 5.0_wp ) - v * ( 1 2.0_wp / 6 3.0_wp ) & + sq2 * vv * ( 2 4.0_wp / 23 1.0_wp ) - v3 * ( 4 0.0_wp / 42 9.0_wp ) & + sq2 * v4 * ( 24 0.0_wp / 643 5.0_wp ) - v5 * ( 33 6.0_wp / 1215 5.0_wp ) & + sq2 * v6 * ( 44 8.0_wp / 4618 9.0_wp ) end if omkt = one - k * tau !step 2.3 compute tofc, dtofc, ddtofc tofc = s * sqrt ( omkt ) * ( tau + ( omkt ) * w ) if ( abs ( tof - tofc ) < tolerance ) exit c = ( one - k * tau ) / tau sqrtctau = sqrt ( omkt ) dtofc = - tofc / ( two * c ) + s * tau * sqrtctau * ( dw * c - w ) ddtofc = - tofc / ( four * c * c ) + s * tau * sqrtctau * ( w / c + c * ddw - three * dw ) !step 2.4 compute deltak deltak = - ( tofc - tof ) / ( dtofc - ( tofc - tof ) * ddtofc / ( two * dtofc )) !step 2.5 update k from deltak k = k + deltak ! step 2.6 bound k ! ensure k is not less than -sqrt(2) if ( k < - sq2 ) k = - sq2 + 1e-12_wp ! ensure k doesn't bleed into to elliptic area when hyperbolic if (( tof < t_parabolic ) . and . ( k < sq2 )) k = sq2 + 1e-12_wp ! ensure k doesn't bleed into to hyperbolic area when elliptic if (( tof > t_parabolic ) . and . ( k > sq2 )) k = sq2 - 1e-12_wp ! ensure tof doesn't become indeterminate when d=1 if (( tof < t_parabolic ) . and . ( d > zero ) . and . & (( one - tau * k ) < zero )) k = one / tau - 1e-5_wp end do m_k = two - k * k w_k = compute_w ( k , m_k , nrev ) error = tof - compute_tof ( k , s , tau , w_k ) ! step 3: if error is too large from halley's method, try bisection method if ( abs ( error ) > 1.0e-4_wp ) then iterations_bisection = 0 ! set initial low and high bounds for bisection method based on k_n and k_m low_k = k_n + 1.0e-14_wp high_k = k_m - 1.0e-14_wp ! calculate initial low value of tof(k) and l(k) m = two - low_k * low_k w = compute_w ( low_k , m , nrev ) tof_low_k = s * sqrt ( one - low_k * tau ) * ( tau + ( one - low_k * tau ) * w ) l_low_k = tof_low_k - tof ! calculate initial high value of tof(k) and l(k) m = two - high_k * high_k w = compute_w ( high_k , m , nrev ) tof_high_k = s * sqrt ( one - high_k * tau ) * ( tau + ( one - high_k * tau ) * w ) l_high_k = tof_high_k - tof if ( use_zeroin ) then !!!!!!!! test: use ZEROIN for the rootfinder rather than bisection call zeroin ( l_func , low_k , high_k , l_low_k , l_high_k ,& bisection_error_tolerance , k , l_middle_k , iflag ) error = abs ( l_middle_k ) else !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ORIGINAL bisection ! iterate using bisection method until within tolerance or maximum number iterations do while ( iterations_bisection < max_iterations_bisection ) middle_k = ( low_k + high_k ) / two m = two - middle_k * middle_k w = compute_w ( middle_k , m , nrev ) tof_middle_k = s * sqrt ( one - middle_k * tau ) * ( tau + ( one - middle_k * tau ) * w ) l_middle_k = tof_middle_k - tof !! function for root solve: l(k) = tof(k) - t* if ( abs ( l_middle_k ) < bisection_error_tolerance ) exit !sgn_l_middle_k = l_middle_k >= 0 ? 1 : -1 !sgn_l_low_k = l_low_k >= 0 ? 1 : -1 sgn_l_middle_k = sign ( one , l_middle_k ) sgn_l_low_k = sign ( one , l_low_k ) if ( sgn_l_middle_k == sgn_l_low_k ) then low_k = middle_k tof_low_k = tof_middle_k l_low_k = l_middle_k else high_k = middle_k tof_high_k = tof_middle_k l_high_k = l_middle_k end if iterations_bisection = iterations_bisection + 1 end do k = middle_k error = abs ( l_middle_k ) iterations = iterations + iterations_bisection end if end if ! end bisection method error catch ! step 3: calculate f & g (typos in arora-russell 2013 aas paper, fixed in journal paper) omkt = one - k * tau f = one - omkt * r1mag_n_plus_r2mag_n / r1mag_n g = s * tau * sqrt ( omkt * mu_n ) gdot = one - omkt * r1mag_n_plus_r2mag_n / r2mag_n ! step 4: calculate v1 and v2 v1_n = ( r2_n - f * r1_n ) / g v2_n = ( gdot * r2_n - r1_n ) / g !step 5: transform to input length and time units (final output) v1 = v1_n * luptu v2 = v2_n * luptu contains !*************************************************************************** function l_func ( k ) result ( lk ) !! function for root solve: `l(k) = tof(k) - t*` !! interface to the [[zeroin]] input function implicit none real ( wp ), intent ( in ) :: k real ( wp ) :: lk real ( wp ) :: tof_k , omkt omkt = one - k * tau m = two - k * k w = compute_w ( k , m , nrev ) tof_k = s * sqrt ( omkt ) * ( tau + omkt * w ) lk = tof_k - tof end function l_func !*************************************************************************** !*************************************************************************** pure elemental real ( wp ) function acoshar ( b ) !! fast computation of acosh implicit none real ( wp ), intent ( in ) :: b acoshar = log ( b + sqrt ( b * b - one )) end function acoshar !*************************************************************************** !*************************************************************************** pure function compute_kb ( k_bguess , tau , s , nrev , tolerance , max_iterations , sq2 , eps ) result ( k ) !! newton's method to find k_bi given tau, s, nrev, and initial guess for k_bi implicit none real ( wp ), intent ( in ) :: k_bguess real ( wp ), intent ( in ) :: tau real ( wp ), intent ( in ) :: s integer , intent ( in ) :: nrev real ( wp ), intent ( in ) :: tolerance integer , intent ( in ) :: max_iterations !note: was double in original (typo?) real ( wp ), intent ( in ) :: sq2 real ( wp ), intent ( in ) :: eps real ( wp ) :: k integer :: iterations real ( wp ) :: deltak , m , w , dw , ddw , tofc , c , sqrtctau , dtofc , ddtofc , omkt !,sgnk ! initialize iterations = 0 deltak = 1.0e+10_wp k = k_bguess ! perform iteration loop do while ( iterations < max_iterations ) !step 1.1 increment the iterations counter iterations = iterations + 1 ! step 1.2 bound k ! ensure k is not less than -sqrt(2) if ( k < - sq2 ) k = - sq2 + 0.00001_wp if ( k > sq2 ) k = sq2 - 0.00001_wp !step 1.3 compute w, dw, ddw m = two - k * k !sgnk = k >= 0 ? one : -one  ! JW : unnecessary w = compute_w ( k , m , nrev ) dw = ( - two + three * w * k ) / m ddw = ( five * dw * k + three * w ) / m !step 2.3 compute tofc, dtofc, ddtofc omkt = one - k * tau tofc = s * sqrt ( omkt ) * ( tau + omkt * w ) c = ( one - k * tau ) / tau sqrtctau = sqrt ( omkt ) dtofc = - tofc / ( two * c ) + s * tau * sqrtctau * ( dw * c - w ) ! check for convergence if ( abs ( dtofc ) < tolerance ) exit ddtofc = - tofc / ( four * c * c ) + s * tau * sqrtctau * ( w / c + c * ddw - three * dw ) !step 2.4 compute deltak deltak = - one * dtofc / ddtofc !step 2.5 update k from deltak k = k + deltak end do end function compute_kb !*************************************************************************** !*************************************************************************** pure function compute_tof ( k , s , tau , w ) result ( tofc ) !! calculate tof function for a given k, tau, implicit none real ( wp ), intent ( in ) :: k real ( wp ), intent ( in ) :: s real ( wp ), intent ( in ) :: tau real ( wp ), intent ( in ) :: w real ( wp ) :: tofc real ( wp ) :: omkt omkt = one - k * tau tofc = s * sqrt ( omkt ) * ( tau + omkt * w ) end function compute_tof !*************************************************************************** !*************************************************************************** pure elemental real ( wp ) function acosar ( x ) !! fast, rough computation of acos() implicit none real ( wp ), intent ( in ) :: x real ( wp ) :: coeff , fx , sgnx fx = abs ( x ) !sgnx = x >= zero ? one : -one if ( x >= zero ) then sgnx = one else sgnx = - one end if if ( fx <= 0.6_wp ) then coeff = ( 0.000014773722_wp + ( 1.1782782_wp - 0.52020038_wp * fx ) * fx ) / & ( 1.1793469_wp + ( - 0.53277664_wp - 0.14454764_wp * fx ) * fx ) else if ( fx <= 0.97_wp ) then coeff = ( 0.011101554_wp + ( 8.9810074_wp + ( - 1 4.816468_wp + 5.9249913_wp * fx ) * fx ) * fx ) / & ( 9.2299851_wp + ( - 1 6.001036_wp + 6.8381053_wp * fx ) * fx ) else if ( fx <= 0.99_wp ) then coeff = ( - 3 5.750586_wp + ( 10 7.24325_wp - 7 0.780244_wp * fx ) * fx ) / & ( 2 7.105764_wp - 2 6.638535_wp * fx ) else coeff = safe_asin ( fx ) end if acosar = pi / two - sgnx * coeff end function acosar !*************************************************************************** !*************************************************************************** pure function compute_w ( k , m , nrev ) result ( w ) !! function to compute the parameter w implicit none real ( wp ), intent ( in ) :: k real ( wp ), intent ( in ) :: m integer , intent ( in ) :: nrev real ( wp ) :: w real ( wp ), parameter :: sq2 = sqrt ( two ) real ( wp ), parameter :: eps = 2.0e-2_wp real ( wp ) :: sgnk , v , v2 , v3 , v4 , v5 , v6 , v7 , v8 !sgnk = k < zero ? -one : one sgnk = sign ( one , k ) if ( - sq2 <= k . and . k < sq2 - eps ) then !elliptical orbit case w = (( one - sgnk ) * pi + sgnk * acos ( one - m ) + two * pi * nrev ) / sqrt ( m * m * m ) - k / m else if ( k < sq2 . and . nrev > 0 ) then w = (( one - sgnk ) * pi + sgnk * acos ( one - m ) + two * pi * nrev ) / sqrt ( m * m * m ) - k / m else if ( k > sq2 + eps ) then !hyperbolic orbits w = - one * acoshar ( one - m ) / sqrt ( - m * m * m ) - k / m else if ( sq2 - eps <= k . and . k <= sq2 + eps ) then !nrev = 0 case v = k - sq2 v2 = v * v v3 = v * v2 v4 = v3 * v v5 = v4 * v v6 = v5 * v v7 = v6 * v v8 = v7 * v w = sq2 / three - v / five & + sq2 * v2 * ( two / 3 5.0_wp ) - v3 * ( two / 6 3.0_wp ) & + sq2 * v4 * ( two / 23 1.0_wp ) - v5 * ( two / 42 9.0_wp ) & + sq2 * v6 * ( eight / 643 5.0_wp ) - v7 * ( eight / 1215 5.0_wp ) & + sq2 * v8 * ( eight / 4618 9.0_wp ) else !write(*,*) 'error on w compute *************************', k    !!! this needs to set status_ok = .false. w = huge ( 1.0_wp ) end if end function compute_w !*************************************************************************** !*************************************************************************** pure elemental real ( wp ) function safe_acos ( x ) !! return x > one ? zero : (x < -one ? pi : acos(x)) implicit none real ( wp ), intent ( in ) :: x if ( x > one ) then safe_acos = zero else if ( x <- one ) then safe_acos = pi else safe_acos = acos ( x ) end if end if end function safe_acos !*************************************************************************** !*************************************************************************** pure elemental real ( wp ) function safe_asin ( x ) !! safe_asin = x > one ? -piover2 : (x < -one ? piover2 : asin(x)) implicit none real ( wp ), intent ( in ) :: x real ( wp ), parameter :: piover2 = pi / two if ( x > one ) then safe_asin = - piover2 else if ( x < - one ) then safe_asin = piover2 else safe_asin = asin ( x ) end if end if end function safe_asin !*************************************************************************** !*************************************************************************** pure elemental real ( wp ) function pow ( x , y ) !! return x**y implicit none real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y pow = x ** y end function pow !*************************************************************************** !***************************************************************************************** !> !  Find a zero of the function  f(x)  in the given interval !   [a_x,b_x]  to within a tolerance  4 \\epsilon |x| + tol , !  where  \\epsilon  is the relative machine precision defined as !  the smallest representable number such that  1.0 + \\epsilon > 1.0 . ! !  It is assumed that  f(a_x)  and  f(b_x)  have opposite signs. ! !#References !  * R. P. Brent, \"[An algorithm with guaranteed convergence for !    finding a zero of a function](http://maths-people.anu.edu.au/~brent/pd/rpb005.pdf)\", !    The Computer Journal, Vol 14, No. 4., 1971. !  * R. P. Brent, \"[Algorithms for minimization without derivatives](http://maths-people.anu.edu.au/~brent/pub/pub011.html)\", !    Prentice-Hall, Inc., 1973. ! !# See also !  1. [zeroin.f](http://www.netlib.org/go/zeroin.f) from Netlib subroutine zeroin ( f , ax , bx , fax , fbx , tol , xzero , fzero , iflag ) use iso_fortran_env , only : error_unit implicit none procedure ( func ) :: f !! the function to find the root of real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( in ) :: fax !! `f(ax)` for endpoint real ( wp ), intent ( in ) :: fbx !! `f(ax)` for endpoint real ( wp ), intent ( in ) :: tol !! desired length of the interval of !! uncertainty of the final result (>=0) real ( wp ), intent ( out ) :: xzero !! abscissa approximating a zero of `f` !! in the interval `ax`,`bx` real ( wp ), intent ( out ) :: fzero !! value of `f` at the root (`f(xzero)`) integer , intent ( out ) :: iflag !! status flag (`-1`=error, `0`=root found) real ( wp ) :: a , b , c , d , e , fa , fb , fc , tol1 , xm , p , q , r , s real ( wp ), parameter :: eps = epsilon ( one ) tol1 = eps + one a = ax b = bx fa = fax fb = fbx !check trivial cases first: if ( fa == zero ) then iflag = 0 xzero = a fzero = fa elseif ( fb == zero ) then iflag = 0 xzero = b fzero = fb elseif ( fa * ( fb / abs ( fb )) < zero ) then ! check that f(ax) and f(bx) have different signs c = a fc = fa d = b - a e = d do if ( abs ( fc ) < abs ( fb )) then a = b b = c c = a fa = fb fb = fc fc = fa end if tol1 = two * eps * abs ( b ) + 0.5_wp * tol xm = 0.5_wp * ( c - b ) if (( abs ( xm ) <= tol1 ). or .( fb == zero )) exit ! see if a bisection is forced if (( abs ( e ) >= tol1 ). and .( abs ( fa ) > abs ( fb ))) then s = fb / fa if ( a /= c ) then ! inverse quadratic interpolation q = fa / fc r = fb / fc p = s * ( two * xm * q * ( q - r ) - ( b - a ) * ( r - one )) q = ( q - one ) * ( r - one ) * ( s - one ) else ! linear interpolation p = two * xm * s q = one - s end if if ( p <= zero ) then p =- p else q =- q end if s = e e = d if ((( two * p ) >= ( three * xm * q - abs ( tol1 * q ))) . or . & ( p >= abs ( 0.5_wp * s * q ))) then d = xm e = d else d = p / q end if else d = xm e = d end if a = b fa = fb if ( abs ( d ) <= tol1 ) then if ( xm <= zero ) then b = b - tol1 else b = b + tol1 end if else b = b + d end if fb = f ( b ) if (( fb * ( fc / abs ( fc ))) > zero ) then c = a fc = fa d = b - a e = d end if end do iflag = 0 xzero = b fzero = fb else iflag = - 1 write ( error_unit , '(A)' )& 'Error in zeroin: f(ax) and f(bx) do not have different signs.' end if end subroutine zeroin !***************************************************************************************** end subroutine solve_lambert_arorarussell","tags":"","url":"proc/solve_lambert_arorarussell.html"},{"title":"lambert_test – fortran-astrodynamics-toolkit","text":"public  subroutine lambert_test() Uses gooding_module random_module proc~~lambert_test~~UsesGraph proc~lambert_test lambert_test module~gooding_module gooding_module proc~lambert_test->module~gooding_module module~random_module random_module proc~lambert_test->module~random_module module~kind_module kind_module module~gooding_module->module~kind_module module~numbers_module numbers_module module~gooding_module->module~numbers_module module~random_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Compare the Lambert routines. Arguments None Calls proc~~lambert_test~~CallsGraph proc~lambert_test lambert_test proc~get_random_number get_random_number proc~lambert_test->proc~get_random_number proc~pv3els pv3els proc~lambert_test->proc~pv3els proc~solve_lambert_arorarussell solve_lambert_arorarussell proc~lambert_test->proc~solve_lambert_arorarussell proc~solve_lambert_gooding solve_lambert_gooding proc~lambert_test->proc~solve_lambert_gooding proc~solve_lambert_izzo solve_lambert_izzo proc~lambert_test->proc~solve_lambert_izzo proc~pv2els pv2els proc~pv3els->proc~pv2els proc~cross cross proc~solve_lambert_gooding->proc~cross proc~unit unit proc~solve_lambert_gooding->proc~unit proc~ucross ucross proc~solve_lambert_izzo->proc~ucross proc~solve_lambert_izzo->proc~unit proc~emkep emkep proc~pv2els->proc~emkep proc~shmkep shmkep proc~pv2els->proc~shmkep proc~ucross->proc~cross proc~ucross->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lambert_test () use gooding_module , only : pv3els use random_module , only : get_random_number implicit none real ( wp ), parameter :: tol = 1.0e-11_wp real ( wp ), dimension (:,:), allocatable :: izzo_v1 , izzo_v2 real ( wp ), dimension (:,:), allocatable :: gooding_v1 , gooding_v2 real ( wp ), dimension ( 6 ) :: rv1 , rv2 , pv , e integer :: imeth , icases , i , multi_revs , iway , n_cases real ( wp ) :: tof , err1 , err2 logical :: long_way , status_ok character ( len = 100 ) :: str real :: tstart , tend real ( wp ), dimension ( 3 ) :: arora_v1 , arora_v2 real ( wp ), dimension ( 6 ), parameter :: rv1_base = & [ 1e6_wp , 1e6_wp , 1e6_wp , 1 0.0_wp , 1 0.0_wp , 1 0.0_wp ] real ( wp ), dimension ( 6 ), parameter :: rv2_base = & [ 1e6_wp , 1e6_wp , 1e6_wp , 1 0.0_wp , 1 0.0_wp , 1 0.0_wp ] real ( wp ), parameter :: tof_base = 8640 0.0_wp !sec real ( wp ), parameter :: mu = 3.986004362330e+05_wp !real(wp),parameter :: auora_tol      = 1.0e-14_wp   !  122946 cases/sec real ( wp ), parameter :: auora_tol = 1.0e-9_wp !! 203025 cases/sec integer , parameter :: max_iterations = 100 logical , parameter :: shortperiod = . true . !! \"solution 1\" for mult-rev case. real ( wp ), parameter :: lu = 1.0e5_wp write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' lambert_test' write ( * , * ) '---------------' write ( * , * ) '' write ( * , * ) '' write ( * , * ) '   Test 1' write ( * , * ) '' n_cases = 10 multi_revs = 0 !1 !reseed the random number generator: call random_seed () do icases = 1 , n_cases write ( * , * ) '' do i = 1 , 6 rv1 ( i ) = get_random_number ( - rv1_base ( i ), rv1_base ( i )) end do do i = 1 , 6 rv2 ( i ) = get_random_number ( - rv2_base ( i ), rv2_base ( i )) end do tof = get_random_number ( 100 0.0_wp , tof_base ) do iway = 1 , 2 !short and long way long_way = ( iway == 1 ) do imeth = 1 , 3 ![izzo, gooding, auora] !if (icases==1 .and. imeth==1 .and. iway==1) & !        write(*,'(*(A30,1X))') & !        'case',& !        'x1','y1','z1','vx1','vy1','vz1',& !        'x2','y2','z2','vx2','vy2','vz2','tof' !if (imeth==1) write(*,'(I30,1X,*(F30.6,1X))') icases, rv1, rv2, tof select case ( imeth ) case ( 1 ) call solve_lambert_izzo ( rv1 ( 1 : 3 ), rv2 ( 1 : 3 ), tof , mu , long_way ,& multi_revs , izzo_v1 , izzo_v2 ,& status_ok ) case ( 2 ) call solve_lambert_gooding ( rv1 ( 1 : 3 ), rv2 ( 1 : 3 ), tof , mu , long_way ,& multi_revs , gooding_v1 , gooding_v2 ,& status_ok ) case ( 3 ) call solve_lambert_arorarussell ( rv1 ( 1 : 3 ), rv2 ( 1 : 3 ), tof , mu , lu , multi_revs , long_way ,& shortperiod , auora_tol ,& max_iterations , arora_v1 , arora_v2 ) end select end do !results: if ( size ( izzo_v1 , 2 ) == size ( gooding_v1 , 2 )) then do i = 1 , size ( izzo_v1 , 2 ) !orb. elements of transfer orbit: pv = [ rv1 ( 1 : 3 ), gooding_v1 (:, i )] call pv3els ( mu , pv , e ) err1 = norm2 ( izzo_v1 (:, i ) - gooding_v1 (:, i ) ) err2 = norm2 ( izzo_v2 (:, i ) - gooding_v2 (:, i ) ) if ( err1 > tol ) then str = '*****IZZO-GOODING ERROR*****' else str = '     IZZO-GOODING v1' end if write ( * , '(I5,1X,E25.16,1X,E25.16,1X,E25.16,1X,A)' )& icases , e ( 1 : 2 ), err1 , trim ( str ) if ( err2 > tol ) then str = '*****IZZO-GOODING ERROR*****' else str = '     IZZO-GOODING v2' end if write ( * , '(I5,1X,E25.16,1X,E25.16,1X,E25.16,1X,A)' )& icases , e ( 1 : 2 ), err2 , trim ( str ) err1 = norm2 ( arora_v1 - gooding_v1 (:, i ) ) err2 = norm2 ( arora_v2 - gooding_v2 (:, i ) ) if ( err1 > tol ) then str = '*****ARORA-GOODING ERROR*****' else str = '     ARORA-GOODING v1' end if write ( * , '(I5,1X,E25.16,1X,E25.16,1X,E25.16,1X,A)' )& icases , e ( 1 : 2 ), err1 , trim ( str ) if ( err2 > tol ) then str = '*****ARORA-GOODING ERROR*****' else str = '     ARORA-GOODING v2' end if write ( * , '(I5,1X,E25.16,1X,E25.16,1X,E25.16,1X,A)' )& icases , e ( 1 : 2 ), err2 , trim ( str ) end do else write ( * , * ) icases , 'Error: arrays sizes are not the same' stop end if end do end do write ( * , * ) '' write ( * , * ) '   Test 2: Speed test' write ( * , * ) '' n_cases = 1000000 do imeth = 1 , 3 ![izzo, gooding, auora] !reseed the random number generator: call random_seed () call cpu_time ( tstart ) do icases = 1 , n_cases do i = 1 , 6 rv1 ( i ) = get_random_number ( - rv1_base ( i ), rv1_base ( i )) end do do i = 1 , 6 rv2 ( i ) = get_random_number ( - rv2_base ( i ), rv2_base ( i )) end do tof = get_random_number ( 100 0.0_wp , tof_base ) do iway = 1 , 2 !short and long way long_way = ( iway == 1 ) select case ( imeth ) case ( 1 ) call solve_lambert_izzo ( rv1 ( 1 : 3 ), rv2 ( 1 : 3 ), tof , mu , long_way ,& multi_revs , izzo_v1 , izzo_v2 ,& status_ok ) case ( 2 ) call solve_lambert_gooding ( rv1 ( 1 : 3 ), rv2 ( 1 : 3 ), tof , mu , long_way ,& multi_revs , gooding_v1 , gooding_v2 ,& status_ok ) case ( 3 ) call solve_lambert_arorarussell ( rv1 ( 1 : 3 ), rv2 ( 1 : 3 ), tof , mu , lu , multi_revs , long_way ,& shortperiod , auora_tol ,& max_iterations , arora_v1 , arora_v2 ) end select end do end do call cpu_time ( tend ) select case ( imeth ) case ( 1 ) write ( * , * ) 'run time for Izzo   : ' , tend - tstart , ' sec.  ' , dble ( n_cases ) / ( tend - tstart ), ' cases/sec' case ( 2 ) write ( * , * ) 'run time for Gooding: ' , tend - tstart , ' sec.  ' , dble ( n_cases ) / ( tend - tstart ), ' cases/sec' case ( 3 ) write ( * , * ) 'run time for Arora  : ' , tend - tstart , ' sec.  ' , dble ( n_cases ) / ( tend - tstart ), ' cases/sec' end select write ( * , * ) '' end do end subroutine lambert_test","tags":"","url":"proc/lambert_test.html"},{"title":"drag_acceleration – fortran-astrodynamics-toolkit","text":"public pure subroutine drag_acceleration(vrel, cd, area, m, rho, acc) Acceleration due to atmospheric drag. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: vrel velocity relative to the atmosphere [km/s] real(kind=wp), intent(in) :: cd spacecraft drag coefficient [--] real(kind=wp), intent(in) :: area cross-section area [km&#94;2] real(kind=wp), intent(in) :: m spacecraft mass [kg] real(kind=wp), intent(in) :: rho atmospheric density [kg/km&#94;3] real(kind=wp), intent(out), dimension(3) :: acc drag acceleration vector [km/s&#94;2] Source Code pure subroutine drag_acceleration ( vrel , cd , area , m , rho , acc ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: vrel !! velocity relative to the atmosphere [km/s] real ( wp ), intent ( in ) :: cd !! spacecraft drag coefficient [--] real ( wp ), intent ( in ) :: area !! cross-section area [km&#94;2] real ( wp ), intent ( in ) :: m !! spacecraft mass [kg] real ( wp ), intent ( in ) :: rho !! atmospheric density [kg/km&#94;3] real ( wp ), dimension ( 3 ), intent ( out ) :: acc !! drag acceleration vector [km/s&#94;2] real ( wp ) :: vrel_mag !! magnitude of the relative velocity [km/s] vrel_mag = norm2 ( vrel ) acc = - ( 0.5_wp * rho * cd * area * vrel_mag / m ) * vrel end subroutine drag_acceleration","tags":"","url":"proc/drag_acceleration.html"},{"title":"halo_to_rv_diffcorr – fortran-astrodynamics-toolkit","text":"public  subroutine halo_to_rv_diffcorr(libpoint, mu1, mu2, dist, A_z, n, t1, rv, info, period) Uses math_module rk_module minpack_module proc~~halo_to_rv_diffcorr~~UsesGraph proc~halo_to_rv_diffcorr halo_to_rv_diffcorr module~math_module math_module proc~halo_to_rv_diffcorr->module~math_module module~minpack_module minpack_module proc~halo_to_rv_diffcorr->module~minpack_module module~rk_module rk_module proc~halo_to_rv_diffcorr->module~rk_module module~kind_module kind_module module~math_module->module~kind_module module~numbers_module numbers_module module~math_module->module~numbers_module module~minpack_module->module~kind_module module~minpack_module->module~numbers_module module~rk_module->module~kind_module module~rk_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Compute the state vector for a halo orbit.\nThis uses the approximation, which is retargeted in the\nreal CR3BP system to produce a periodic orbit. Arguments Type Intent Optional Attributes Name integer, intent(in) :: libpoint Libration point number: [1,2,3] real(kind=wp), intent(in) :: mu1 grav param for primary body [km3/s2] real(kind=wp), intent(in) :: mu2 grav param for secondary body [km3/s2] real(kind=wp), intent(in) :: dist distance between bodies [km] real(kind=wp), intent(in) :: A_z halo z amplitude [km] integer, intent(in) :: n halo family: 1, 3 real(kind=wp), intent(in) :: t1 tau1 [rad] real(kind=wp), intent(out), dimension(6) :: rv cr3bp normalized state vector\n[wrt barycenter] integer, intent(out) :: info status code (1=no errors) real(kind=wp), intent(out), optional :: period period of halo (normalized time units) Calls proc~~halo_to_rv_diffcorr~~CallsGraph proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~compute_crtpb_parameter compute_crtpb_parameter proc~halo_to_rv_diffcorr->proc~compute_crtpb_parameter proc~halo_to_rv halo_to_rv proc~halo_to_rv_diffcorr->proc~halo_to_rv proc~hybrd1 hybrd1 proc~halo_to_rv_diffcorr->proc~hybrd1 proc~initialize rk_class%initialize proc~halo_to_rv_diffcorr->proc~initialize proc~integrate rk_class%integrate proc~halo_to_rv_diffcorr->proc~integrate proc~integrate_to_event rk_class%integrate_to_event proc~halo_to_rv_diffcorr->proc~integrate_to_event proc~wrap_angle wrap_angle proc~halo_to_rv_diffcorr->proc~wrap_angle proc~halo_to_rv->proc~compute_crtpb_parameter proc~compute_libration_points compute_libration_points proc~halo_to_rv->proc~compute_libration_points proc~hybrd hybrd proc~hybrd1->proc~hybrd proc~destroy rk_class%destroy proc~initialize->proc~destroy step step proc~integrate->step proc~set_function brent_class%set_function proc~integrate_to_event->proc~set_function proc~zeroin brent_class%zeroin proc~integrate_to_event->proc~zeroin proc~integrate_to_event->step proc~cube_root cube_root proc~compute_libration_points->proc~cube_root proc~dogleg dogleg proc~hybrd->proc~dogleg proc~dpmpar dpmpar proc~hybrd->proc~dpmpar proc~enorm enorm proc~hybrd->proc~enorm proc~fdjac1 fdjac1 proc~hybrd->proc~fdjac1 proc~qform qform proc~hybrd->proc~qform proc~qrfac qrfac proc~hybrd->proc~qrfac proc~r1mpyq r1mpyq proc~hybrd->proc~r1mpyq proc~r1updt r1updt proc~hybrd->proc~r1updt proc~dogleg->proc~dpmpar proc~dogleg->proc~enorm proc~fdjac1->proc~dpmpar proc~qrfac->proc~dpmpar proc~qrfac->proc~enorm proc~r1updt->proc~dpmpar Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine halo_to_rv_diffcorr ( libpoint , mu1 , mu2 , dist , A_z , n , t1 , rv , info , period ) use rk_module use minpack_module use math_module , only : wrap_angle implicit none integer , intent ( in ) :: libpoint !! Libration point number: [1,2,3] real ( wp ), intent ( in ) :: mu1 !! grav param for primary body [km3/s2] real ( wp ), intent ( in ) :: mu2 !! grav param for secondary body [km3/s2] real ( wp ), intent ( in ) :: dist !! distance between bodies [km] real ( wp ), intent ( in ) :: A_z !! halo z amplitude [km] integer , intent ( in ) :: n !! halo family: 1, 3 real ( wp ), intent ( in ) :: t1 !! tau1 [rad] real ( wp ), dimension ( 6 ), intent ( out ) :: rv !! cr3bp normalized state vector !! [wrt barycenter] integer , intent ( out ) :: info !! status code (1=no errors) real ( wp ), intent ( out ), optional :: period !! period of halo (normalized time units) integer , parameter :: n_state_vars = 6 !! number of state variables in the equations of motion integer , parameter :: n_opt_vars = 2 !! number of variables in the targeting problem real ( wp ), parameter :: t0 = 0.0_wp !! initial time (normalized) (epoch doesn't matter for cr3bp) real ( wp ), parameter :: tol = 1.0e-8_wp !! tolerance for event finding real ( wp ), parameter :: xtol = 1.0e-6_wp !! tolerance for [[hybrd]] integer , parameter :: maxfev = 1000 !! max number of function evaluations for [[hybrd]] integer , parameter :: n_steps_per_rev = 100 !! number of integration steps per orbit rev type ( rk8_10_class ) :: prop !! integrator real ( wp ), dimension ( n_opt_vars ) :: x_vy0 !! variables in the targeting problem (x0 and vy0) real ( wp ), dimension ( n_opt_vars ) :: vx_vzf !! constraints in the targeting problem (vxf and vzf) real ( wp ), dimension ( n_state_vars ) :: x0 !! halo initial guess from richardson approximation real ( wp ), dimension ( n_state_vars ) :: xf !! state after 1/2 rev (to get the period) real ( wp ) :: tf_actual !! 1/2 period for retargeted orbit (normalized time) real ( wp ) :: actual_period !! actual halo orbit period for retargeted orbit (normalized time) real ( wp ) :: approx_period !! period approximation (normalized time) real ( wp ) :: dt_to_t1 !! time from `t1=0` to input `t1` real ( wp ) :: gf !! function value after 1/2 rev (y-coordinate) real ( wp ) :: tau !! `t1` wrapped from - \\pi  to  \\pi  real ( wp ) :: dt !! time step (normalized) real ( wp ) :: tmax !! max final time for event finding integration real ( wp ) :: mu !! CRTBP parameter ! compute the CRTBP mu parameter: mu = compute_crtpb_parameter ( mu1 , mu2 ) ! first we get the halo state approximation at tau1=0: call halo_to_rv ( libpoint , mu1 , mu2 , dist , A_z , n , zero , x0 , approx_period ) ! for now, fixed number of integration steps per period: dt = approx_period / real ( n_steps_per_rev , wp ) tmax = two * approx_period ! should be enough to find the x-z crossing ! initialize the integrator: call prop % initialize ( n_state_vars , func , g = xz_plane_crossing ) ! now, solve for a halo: x_vy0 = [ x0 ( 1 ), x0 ( 5 )] ! x0 and vy0 call hybrd1 ( halo_fcn , 2 , x_vy0 , vx_vzf , tol = xtol , info = info ) if ( info == 1 ) then ! solution converged ! now have the solution at t1=0: x0 ( 1 ) = x_vy0 ( 1 ) x0 ( 5 ) = x_vy0 ( 2 ) ! this is the t1 we want: tau = wrap_angle ( t1 ) ! if we need the period: if ( present ( period ) . or . tau /= zero ) then ! integrate to the first x-axis crossings (one half rev): ! [need to check output...] call prop % integrate_to_event ( t0 , x0 , dt , tmax , tol , tf_actual , xf , gf ) actual_period = two * tf_actual ! normalized period end if ! now we want to propagate to the input tau1 if ( tau == zero ) then ! already have the solution rv = x0 else ! now, integrate from t1=0 to input t1 to get rv: dt_to_t1 = actual_period * ( tau / twopi ) call prop % integrate ( t0 , x0 , dt , dt_to_t1 , rv ) end if if ( present ( period )) period = actual_period else ! there was an error write ( error_unit , '(A)' ) 'Error: the halo targeting problem did not converge.' rv = x0 end if !call prop%destroy() contains !******************************************************************************* !*************************************************************************** subroutine halo_fcn ( n , xvec , fvec , iflag ) !! Halo function for [[hybrd1]] implicit none integer , intent ( in ) :: n !! `n=2` in this case real ( wp ), dimension ( n ), intent ( in ) :: xvec !! x_vy0 real ( wp ), dimension ( n ), intent ( out ) :: fvec !! [vxf,vzf] integer , intent ( inout ) :: iflag !! status flag (set negative !! to terminate solver) real ( wp ) :: gf real ( wp ), dimension ( 6 ) :: x , x1 , xf x = x0 ! initial guess state (z is held fixed) x ( 1 ) = xvec ( 1 ) ! x0 x ( 5 ) = xvec ( 2 ) ! vy0 !integrate to the next x-z-plane crossing: call prop % integrate_to_event ( t0 , x , dt , tmax , tol , tf_actual , xf , gf ) !want x and z-velocity at the x-z-plane crossing to be zero: fvec = [ xf ( 4 ), xf ( 6 )] end subroutine halo_fcn !*************************************************************************** !*************************************************************************** subroutine func ( me , t , x , xdot ) !! CRTBP derivative function implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension ( me % n ), intent ( in ) :: x real ( wp ), dimension ( me % n ), intent ( out ) :: xdot call crtbp_derivs ( mu , x , xdot ) end subroutine func !************************************************************************** !*************************************************************************** subroutine xz_plane_crossing ( me , t , x , g ) !! x-z-plane crossing event function implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension ( me % n ), intent ( in ) :: x real ( wp ), intent ( out ) :: g g = x ( 2 ) ! y = 0 at x-z-plane crossing end subroutine xz_plane_crossing !*************************************************************************** end subroutine halo_to_rv_diffcorr","tags":"","url":"proc/halo_to_rv_diffcorr.html"},{"title":"halo_to_rv – fortran-astrodynamics-toolkit","text":"public  subroutine halo_to_rv(libpoint, mu1, mu2, dist, A_z, n, t1, rv, period) Compute the state vector from the halo orbit approximation.\nThis will be an approximation of a halo orbit in the CR3BP system,\nand will need to be corrected to produce a real halo orbit. Arguments Type Intent Optional Attributes Name integer, intent(in) :: libpoint Libration point number: [1,2,3] real(kind=wp), intent(in) :: mu1 grav param for primary body [km3/s2] real(kind=wp), intent(in) :: mu2 grav param for secondary body [km3/s2] real(kind=wp), intent(in) :: dist distance between bodies [km] real(kind=wp), intent(in) :: A_z halo z amplitude [km] integer, intent(in) :: n halo family: 1, 3 real(kind=wp), intent(in) :: t1 tau1 [rad] real(kind=wp), intent(out), dimension(6) :: rv cr3bp normalized state vector\n[wrt barycenter] real(kind=wp), intent(out), optional :: period normalized halo orbit period Calls proc~~halo_to_rv~~CallsGraph proc~halo_to_rv halo_to_rv proc~compute_crtpb_parameter compute_crtpb_parameter proc~halo_to_rv->proc~compute_crtpb_parameter proc~compute_libration_points compute_libration_points proc~halo_to_rv->proc~compute_libration_points proc~cube_root cube_root proc~compute_libration_points->proc~cube_root Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~halo_to_rv~~CalledByGraph proc~halo_to_rv halo_to_rv proc~halo_orbit_test halo_orbit_test proc~halo_orbit_test->proc~halo_to_rv proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~halo_to_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine halo_to_rv ( libpoint , mu1 , mu2 , dist , A_z , n , t1 , rv , period ) implicit none integer , intent ( in ) :: libpoint !! Libration point number: [1,2,3] real ( wp ), intent ( in ) :: mu1 !! grav param for primary body [km3/s2] real ( wp ), intent ( in ) :: mu2 !! grav param for secondary body [km3/s2] real ( wp ), intent ( in ) :: dist !! distance between bodies [km] real ( wp ), intent ( in ) :: A_z !! halo z amplitude [km] integer , intent ( in ) :: n !! halo family: 1, 3 real ( wp ), intent ( in ) :: t1 !! tau1 [rad] real ( wp ), dimension ( 6 ), intent ( out ) :: rv !! cr3bp normalized state vector !! [wrt barycenter] real ( wp ), intent ( out ), optional :: period !! normalized halo orbit period real ( wp ) :: mu !! CRTBP parameter integer :: delta_n !! 2 - n real ( wp ) :: gamma_l !! dimensionless quantity from reference real ( wp ) :: lambda !! linearized frequency real ( wp ) :: Ax , Ay , Az , Ax2 , Az2 real ( wp ) :: x , y , z , vx , vy , vz real ( wp ) :: a1 , a2 , a21 , a22 , a23 , a24 , a31 , a32 , b21 ,& b22 , b31 , b32 , c2 , c3 , c4 , delta , w ,& d1 , d2 , d21 , d3 , d31 , d32 , k , l1 , l2 , s1 , s2 , term real ( wp ), dimension ( 3 ) :: x_libpoint !! x-coordinates of the libration !! point (wrt barycenter, normalized) logical :: ok ! error check: if ( n /= 1 . and . n /= 3 ) then error stop 'invalid n input to halo_to_rv' end if ! compute all the intermediate parameters: mu = compute_crtpb_parameter ( mu1 , mu2 ) ! lib point x-coordinate: wrt to barycenter - normalized select case ( libpoint ) case ( 1 ) call compute_libration_points ( mu , r1 = x_libpoint ( 1 )) gamma_l = ( 1.0_wp - mu ) - x_libpoint ( 1 ) case ( 2 ) call compute_libration_points ( mu , r2 = x_libpoint ( 2 )) gamma_l = x_libpoint ( 2 ) - ( 1.0_wp - mu ) case ( 3 ) call compute_libration_points ( mu , r3 = x_libpoint ( 3 )) gamma_l = - ( x_libpoint ( 3 ) + mu ) case default error stop 'invalid libration point input to halo_to_rv' end select Az = A_z / ( dist * gamma_l ) ! normalized z-Amplitude c2 = c_n ( libpoint , 2 , mu , gamma_l ) c3 = c_n ( libpoint , 3 , mu , gamma_l ) c4 = c_n ( libpoint , 4 , mu , gamma_l ) lambda = sqrt (( - c2 + two + sqrt ( nine * c2 ** 2 - eight * c2 )) / two ) ! root of quartic eqn k = two * lambda / ( lambda ** 2 + one - c2 ) delta = lambda ** 2 - c2 d1 = 1 6.0_wp * lambda ** 4 + four * lambda ** 2 * ( c2 - two ) - two * c2 ** 2 + c2 + one d2 = 8 1.0_wp * lambda ** 4 + nine * lambda ** 2 * ( c2 - two ) - two * c2 ** 2 + c2 + one d3 = two * lambda * ( lambda * ( one + k ** 2 ) - two * k ) a21 = three * c3 * ( k ** 2 - two ) / four / ( one + two * c2 ) a23 = - three * lambda * c3 * ( three * k ** 3 * lambda - six * k * ( k - lambda ) + four ) / four / k / d1 b21 = - three * c3 * lambda * ( three * lambda * k - four ) / two / d1 s1 = (( three / two ) * c3 * ( two * a21 * ( k ** 2 - two ) - a23 * ( k ** 2 + two ) - & two * k * b21 ) - ( three / eight ) * c4 * ( three * k ** 4 - eight * k ** 2 + eight )) / d3 a22 = three * c3 / four / ( one + two * c2 ) a24 = - three * c3 * lambda * ( two + three * lambda * k ) / four / k / d1 b22 = three * lambda * c3 / d1 d21 = - c3 / two / lambda ** 2 s2 = (( three / two ) * c3 * ( two * a22 * ( k ** 2 - two ) + & a24 * ( k ** 2 + two ) + two * k * b22 + five * d21 ) + & ( three / eight ) * c4 * ( 1 2.0_wp - k ** 2 )) / d3 a1 = - ( three / two ) * c3 * ( two * a21 + a23 + five * d21 ) - & ( three / eight ) * c4 * ( 1 2.0_wp - k ** 2 ) a2 = ( three / two ) * c3 * ( a24 - two * a22 ) + ( nine / eight ) * c4 l1 = two * s1 * lambda ** 2 + a1 l2 = two * s2 * lambda ** 2 + a2 Az2 = Az ** 2 ! check if this Az is feasible ok = ( l1 /= zero ) if ( ok ) then term = ( - delta - l2 * Az2 ) / l1 ok = ( term >= zero ) end if if (. not . ok ) then rv = zero if ( present ( period )) period = zero write ( error_unit , '(A)' ) 'Error: infeasible input.' return end if Ax = sqrt ( term ) ! equation 18 Ax2 = Ax ** 2 Ay = k * Ax w = one + s1 * Ax2 + s2 * Az2 ! frequency correction a31 = - nine * lambda * ( c3 * ( k * a23 - b21 ) + k * c4 * ( one + ( one / four ) * k ** 2 )) / d2 + & ( nine * lambda ** 2 + one - c2 ) * ( three * c3 * ( two * a23 - k * b21 ) + & c4 * ( two + three * k ** 2 )) / two / d2 a32 = - nine * lambda * ( four * c3 * ( k * a24 - b22 ) + k * c4 ) / four / d2 - & three * ( nine * lambda ** 2 + one - c2 ) * ( c3 * ( k * b22 + d21 - two * a24 ) - c4 ) / two / d2 b31 = ( three * lambda * ( three * c3 * ( k * b21 - two * a23 ) - c4 * ( two + three * k ** 2 )) + & ( nine * lambda ** 2 + 1 + two * c2 ) * ( 1 2.0_wp * c3 * ( k * a23 - b21 ) + & three * k * c4 * ( four + k ** 2 )) / eight ) / d2 b32 = ( three * lambda * ( three * c3 * ( k * b22 + d21 - two * a24 ) - three * c4 ) + & ( nine * lambda ** 2 + one + two * c2 ) * ( 1 2.0_wp * c3 * ( k * a24 - b22 ) + three * c4 * k ) / eight ) / d2 d31 = three * ( four * c3 * a24 + c4 ) / 6 4.0_wp / lambda ** 2 d32 = three * ( four * c3 * ( a23 - d21 ) + c4 * ( four + k ** 2 )) / 6 4.0_wp / lambda ** 2 delta_n = 2 - n ! equation 21 if ( present ( period )) period = twopi / ( lambda * w ) ! Equations 20a, 20b, 20c (and their derivatives): x = a21 * Ax2 + a22 * Az2 - Ax * cos ( t1 ) + & ( a23 * Ax2 - a24 * Az2 ) * cos ( two * t1 ) + & ( a31 * Ax ** 3 - a32 * Ax * Az2 ) * cos ( three * t1 ) y = k * Ax * sin ( t1 ) + ( b21 * Ax2 - b22 * Az2 ) * sin ( two * t1 ) + & ( b31 * Ax ** 3 - b32 * Ax * Az2 ) * sin ( three * t1 ) z = delta_n * ( Az * cos ( t1 ) + d21 * Ax * Az * ( cos ( two * t1 ) - three ) + & ( d32 * Az * Ax2 - d31 * Az ** 3 ) * cos ( three * t1 )) vx = Ax * sin ( t1 ) - ( a23 * Ax2 - a24 * Az2 ) * sin ( two * t1 ) * two - & ( a31 * Ax ** 3 - a32 * Ax * Az2 ) * sin ( three * t1 ) * three vy = k * Ax * cos ( t1 ) + ( b21 * Ax2 - b22 * Az2 ) * cos ( two * t1 ) * two + & ( b31 * Ax ** 3 - b32 * Ax * Az2 ) * cos ( three * t1 ) * three vz = delta_n * ( - Az * sin ( t1 ) + d21 * Ax * Az * ( - sin ( two * t1 ) * two ) - & ( d32 * Az * Ax2 - d31 * Az ** 3 ) * sin ( three * t1 ) * three ) rv = [ x , y , z , vx , vy , vz ] ! convert from richardson scale, libration point centered to ! standard normalized coordinates wrt barycenter: rv ( 1 : 3 ) = rv ( 1 : 3 ) * gamma_l rv ( 4 : 6 ) = rv ( 4 : 6 ) * gamma_l * ( lambda * w ) rv ( 1 ) = rv ( 1 ) + x_libpoint ( libpoint ) contains !******************************************************************************* !*************************************************************************** pure function c_n ( lib , n , mu , gl ) result ( cn ) !! Equations 8a, 8b in the reference. implicit none integer , intent ( in ) :: lib !! libration point (1,2,3) integer , intent ( in ) :: n !! the n in cn real ( wp ), intent ( in ) :: mu !! cr3bp normalized grav parameter real ( wp ), intent ( in ) :: gl !!  \\gamma_l  real ( wp ) :: cn !! result ! Equation 8a and 8b: select case ( lib ) case ( 1 ); cn = ( mu + ( - 1 ) ** n * ( one - mu ) * ( gl / ( one - gl )) ** ( n + 1 ) ) / gl ** 3 case ( 2 ); cn = (( - 1 ) ** n * ( mu + ( one - mu ) * ( gl / ( one + gl )) ** ( n + 1 ))) / gl ** 3 case ( 3 ); cn = ( one - mu + mu * ( gl / ( one + gl )) ** ( n + 1 ) ) / gl ** 3 end select end function c_n !*************************************************************************** end subroutine halo_to_rv","tags":"","url":"proc/halo_to_rv.html"},{"title":"compute_halo_monodromy_matrix – fortran-astrodynamics-toolkit","text":"public  subroutine compute_halo_monodromy_matrix(mu, rv, period, phi) Uses rk_module proc~~compute_halo_monodromy_matrix~~UsesGraph proc~compute_halo_monodromy_matrix compute_halo_monodromy_matrix module~rk_module rk_module proc~compute_halo_monodromy_matrix->module~rk_module module~kind_module kind_module module~rk_module->module~kind_module module~numbers_module numbers_module module~rk_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Compute the halo orbit monodromy matrix\n(which is the state transition matrix propagated for one period)\nThe input should be the result from the halo_to_rv_diffcorr routine. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu CRTBP parameter real(kind=wp), intent(in), dimension(6) :: rv halo orbit state vector\n(normalized) real(kind=wp), intent(in) :: period halo orbit period\n(normalized) real(kind=wp), intent(out), dimension(6,6) :: phi monodromy matrix Calls proc~~compute_halo_monodromy_matrix~~CallsGraph proc~compute_halo_monodromy_matrix compute_halo_monodromy_matrix proc~initialize rk_class%initialize proc~compute_halo_monodromy_matrix->proc~initialize proc~integrate rk_class%integrate proc~compute_halo_monodromy_matrix->proc~integrate proc~destroy rk_class%destroy proc~initialize->proc~destroy step step proc~integrate->step Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_halo_monodromy_matrix ( mu , rv , period , phi ) use rk_module implicit none real ( wp ), intent ( in ) :: mu !! CRTBP parameter real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! halo orbit state vector !! (normalized) real ( wp ), intent ( in ) :: period !! halo orbit period !! (normalized) real ( wp ), dimension ( 6 , 6 ), intent ( out ) :: phi !! monodromy matrix real ( wp ), parameter :: t0 = zero !! initial time (normalized) !! (epoch doesn't matter for cr3bp) integer , parameter :: n_steps_per_rev = 100 !! number of integration steps !! per orbit rev real ( wp ), dimension ( 42 ) :: x0 !! initial normalized state and STM real ( wp ), dimension ( 42 ) :: xf !! final normalized state and STM real ( wp ), dimension ( 6 , 6 ) :: phi0 !! initial STM integer :: i !! counter type ( rk8_10_class ) :: prop !! integrator real ( wp ) :: dt !! integration time step (normalized) ! initial state: x0 ( 1 : 6 ) = rv ! initial stm is the identity matrix: phi0 = zero do i = 1 , 6 phi0 ( i , i ) = one end do x0 ( 7 : 42 ) = pack ( phi0 , mask = . true .) ! for now, use a fixed time step: ! (same as was used in [[halo_to_rv_diffcorr]]) dt = period / real ( n_steps_per_rev , wp ) ! initialize the integrator: call prop % initialize ( 42 , func ) ! propagate for one period: call prop % integrate ( t0 , x0 , dt , period , xf ) ! extract the STM: phi = reshape ( xf ( 7 : 42 ), shape = [ 6 , 6 ]) contains !******************************************************************************* !*************************************************************************** subroutine func ( me , t , x , xdot ) !! CRTBP derivative function (with STM) implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension ( me % n ), intent ( in ) :: x real ( wp ), dimension ( me % n ), intent ( out ) :: xdot call crtbp_derivs_with_stm ( mu , x , xdot ) end subroutine func !************************************************************************** end subroutine compute_halo_monodromy_matrix","tags":"","url":"proc/compute_halo_monodromy_matrix.html"},{"title":"compute_monodromy_matrix_eigenvalues – fortran-astrodynamics-toolkit","text":"public  subroutine compute_monodromy_matrix_eigenvalues(phi, lambda) Uses matrix_module proc~~compute_monodromy_matrix_eigenvalues~~UsesGraph proc~compute_monodromy_matrix_eigenvalues compute_monodromy_matrix_eigenvalues module~matrix_module matrix_module proc~compute_monodromy_matrix_eigenvalues->module~matrix_module module~kind_module kind_module module~matrix_module->module~kind_module module~numbers_module numbers_module module~matrix_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Compute the eigenvalues of the monodromy matrix. Reference J.S. Parker, R.L. Anderson, \"Low-Energy Lunar Trajectory Design\", (p 79) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6,6) :: phi monodromy matrix complex(kind=wp), intent(out), dimension(6) :: lambda eigenvalues of phi Calls proc~~compute_monodromy_matrix_eigenvalues~~CallsGraph proc~compute_monodromy_matrix_eigenvalues compute_monodromy_matrix_eigenvalues proc~matrix_trace matrix_trace proc~compute_monodromy_matrix_eigenvalues->proc~matrix_trace Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_monodromy_matrix_eigenvalues ( phi , lambda ) use matrix_module , only : matrix_trace implicit none real ( wp ), dimension ( 6 , 6 ), intent ( in ) :: phi !! monodromy matrix complex ( wp ), dimension ( 6 ), intent ( out ) :: lambda !! eigenvalues of `phi` real ( wp ) :: alpha , beta , alpha2 complex ( wp ) :: p , q , a , b , c alpha = two - matrix_trace ( 6 , phi ) alpha2 = alpha * alpha beta = ( alpha2 - matrix_trace ( 6 , matmul ( phi , phi ))) / two + one a = sqrt ( alpha2 - four * beta + eight ) p = ( alpha + a ) / two q = ( alpha - a ) / two b = sqrt ( p * p - four ) c = sqrt ( q * q - four ) ! eigenvalues: lambda ( 1 ) = ( - p + b ) / two lambda ( 2 ) = ( - p - b ) / two lambda ( 3 ) = ( - q + c ) / two lambda ( 4 ) = ( - q - c ) / two lambda ( 5 ) = ( one , zero ) lambda ( 6 ) = ( one , zero ) end subroutine compute_monodromy_matrix_eigenvalues","tags":"","url":"proc/compute_monodromy_matrix_eigenvalues.html"},{"title":"halo_orbit_test – fortran-astrodynamics-toolkit","text":"public  subroutine halo_orbit_test() Uses celestial_body_module proc~~halo_orbit_test~~UsesGraph proc~halo_orbit_test halo_orbit_test module~celestial_body_module celestial_body_module proc~halo_orbit_test->module~celestial_body_module module~base_class_module base_class_module module~celestial_body_module->module~base_class_module module~kind_module kind_module module~celestial_body_module->module~kind_module module~numbers_module numbers_module module~celestial_body_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Unit test for the halo orbit module. Arguments None Calls proc~~halo_orbit_test~~CallsGraph proc~halo_orbit_test halo_orbit_test proc~halo_to_rv halo_to_rv proc~halo_orbit_test->proc~halo_to_rv proc~compute_crtpb_parameter compute_crtpb_parameter proc~halo_to_rv->proc~compute_crtpb_parameter proc~compute_libration_points compute_libration_points proc~halo_to_rv->proc~compute_libration_points proc~cube_root cube_root proc~compute_libration_points->proc~cube_root Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine halo_orbit_test () use celestial_body_module implicit none integer :: libpoint !! Libration point number: [1,2,3] real ( wp ) :: mu1 !! grav param for primary body [km3/s2] real ( wp ) :: mu2 !! grav param for secondary body [km3/s2] real ( wp ) :: dist !! distance between bodies [km] real ( wp ) :: Az !! halo z amplitude [km] integer :: n !! halo family: 1, 3 real ( wp ) :: t1 !! tau1 [rad] real ( wp ), dimension ( 6 ) :: rv !! normalized state [wrt barycenter] write ( * , * ) '' write ( * , * ) '----------------' write ( * , * ) ' halo_orbit_test' write ( * , * ) '----------------' write ( * , * ) '' libpoint = 2 mu1 = body_earth % mu mu2 = body_moon % mu dist = 38440 0.0_wp Az = 1000 0.0_wp n = 1 t1 = 0.0_wp call halo_to_rv ( libpoint , mu1 , mu2 , dist , Az , n , t1 , rv ) write ( * , * ) '' write ( * , * ) 'halo orbit state:' write ( * , * ) rv write ( * , * ) '' end subroutine halo_orbit_test","tags":"","url":"proc/halo_orbit_test.html"},{"title":"replace_char – fortran-astrodynamics-toolkit","text":"public pure function replace_char(str, s1, s2) result(newstr) Replace all occurrences of a single character s1 in str with s2 . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str original string character(len=1), intent(in) :: s1 find all occurrences of this character character(len=1), intent(in) :: s2 replace with this character Return Value character(len=:), allocatable new string Source Code pure function replace_char ( str , s1 , s2 ) result ( newstr ) character ( len =* ), intent ( in ) :: str !! original string character ( len = 1 ), intent ( in ) :: s1 !! find all occurrences of this character character ( len = 1 ), intent ( in ) :: s2 !! replace with this character character ( len = :), allocatable :: newstr !! new string integer :: i !! counter newstr = str do i = 1 , len ( newstr ) if ( newstr ( i : i ) == s1 ) newstr ( i : i ) = s2 end do end function replace_char","tags":"","url":"proc/replace_char.html"},{"title":"lchop – fortran-astrodynamics-toolkit","text":"public pure function lchop(str, chars) result(newstr) Chop leading chars string from str .\nNote that trailing spaces are not ignored in either string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str original string character(len=*), intent(in) :: chars characters to strip Return Value character(len=:), allocatable new string Called by proc~~lchop~~CalledByGraph proc~lchop lchop proc~rchop rchop proc~rchop->proc~lchop Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function lchop ( str , chars ) result ( newstr ) character ( len =* ), intent ( in ) :: str !! original string character ( len =* ), intent ( in ) :: chars !! characters to strip character ( len = :), allocatable :: newstr !! new string ! this logic here is to account for trailing spaces, which we preserve if ( len ( chars ) > len ( str )) then newstr = str ! not possible to chop else if ( str == chars ) then if ( len ( str ) > len ( chars )) then newstr = str ( len ( chars ) + 1 :) ! only trailing spaces remain else newstr = '' ! string is now empty end if else if ( index ( str , chars ) == 1 ) then newstr = str ( len ( chars ) + 1 :) ! chop leading chars, keep rest of string else newstr = str ! original string, noting to chop end if end if end if end function lchop","tags":"","url":"proc/lchop.html"},{"title":"rchop – fortran-astrodynamics-toolkit","text":"public pure function rchop(str, chars) result(newstr) Chop trailing chars string from str .\nNote that trailing spaces are not ignored in either string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str original string character(len=*), intent(in) :: chars characters to strip Return Value character(len=:), allocatable new string Calls proc~~rchop~~CallsGraph proc~rchop rchop proc~lchop lchop proc~rchop->proc~lchop proc~reverse reverse proc~rchop->proc~reverse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function rchop ( str , chars ) result ( newstr ) character ( len =* ), intent ( in ) :: str !! original string character ( len =* ), intent ( in ) :: chars !! characters to strip character ( len = :), allocatable :: newstr !! new string newstr = reverse ( lchop ( reverse ( str ), reverse ( chars ))) end function rchop","tags":"","url":"proc/rchop.html"},{"title":"reverse – fortran-astrodynamics-toolkit","text":"public pure function reverse(str) result(newstr) Reverse a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str original string Return Value character(len=:), allocatable new string Called by proc~~reverse~~CalledByGraph proc~reverse reverse proc~rchop rchop proc~rchop->proc~reverse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function reverse ( str ) result ( newstr ) character ( len =* ), intent ( in ) :: str !! original string character ( len = :), allocatable :: newstr !! new string integer :: i , j !! counter integer :: n !! length of `str` n = len ( str ) allocate ( character ( len = n ) :: newstr ) if ( n == 0 ) then newstr = '' else j = 0 do i = n , 1 , - 1 j = j + 1 newstr ( j : j ) = str ( i : i ) end do end if end function reverse","tags":"","url":"proc/reverse.html"},{"title":"strip – fortran-astrodynamics-toolkit","text":"public pure function strip(str, chars) result(newstr) Strip all occurances of chars from the beginning and end of the string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str original string character(len=*), intent(in), optional :: chars characters to strip Return Value character(len=:), allocatable new string Source Code pure function strip ( str , chars ) result ( newstr ) character ( len =* ), intent ( in ) :: str !! original string character ( len =* ), intent ( in ), optional :: chars !! characters to strip character ( len = :), allocatable :: newstr !! new string integer :: i !! counter integer :: n !! length of str integer :: idx !! for using scan integer :: start_idx , end_idx !! substring to keep if ( present ( chars )) then if ( chars /= '' ) then ! have to step through manually from beginning and end n = len ( str ) start_idx = 1 end_idx = n ! forward search do i = 1 , n idx = scan ( str ( i : i ), chars ) if ( idx > 0 ) then start_idx = start_idx + 1 else exit end if end do ! backward search do i = n , 1 , - 1 idx = scan ( str ( i : i ), chars ) if ( idx > 0 ) then end_idx = end_idx - 1 else exit end if end do if ( end_idx <= start_idx ) then newstr = '' ! all stripped else newstr = str ( start_idx : end_idx ) ! return substring end if return ! done end if end if ! in this case assuming it's a space, so use intrinsic functions newstr = trim ( adjustl ( str )) end function strip","tags":"","url":"proc/strip.html"},{"title":"uppercase – fortran-astrodynamics-toolkit","text":"public pure subroutine uppercase(str) Convert the string to uppercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str Source Code pure subroutine uppercase ( str ) character ( len =* ), intent ( inout ) :: str integer :: i , idx do i = 1 , len_trim ( str ) idx = index ( lower , str ( i : i )) if ( idx > 0 ) str ( i : i ) = upper ( idx : idx ) end do end subroutine uppercase","tags":"","url":"proc/uppercase.html"},{"title":"lowercase – fortran-astrodynamics-toolkit","text":"public pure subroutine lowercase(str) Convert the string to lowercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str Source Code pure subroutine lowercase ( str ) character ( len =* ), intent ( inout ) :: str integer :: i , idx do i = 1 , len_trim ( str ) idx = index ( upper , str ( i : i )) if ( idx > 0 ) str ( i : i ) = lower ( idx : idx ) end do end subroutine lowercase","tags":"","url":"proc/lowercase.html"},{"title":"iau_rotation_matrix – fortran-astrodynamics-toolkit","text":"public pure function iau_rotation_matrix(w, dec, ra) result(rotmat) Uses vector_module proc~~iau_rotation_matrix~~UsesGraph proc~iau_rotation_matrix iau_rotation_matrix module~vector_module vector_module proc~iau_rotation_matrix->module~vector_module module~kind_module kind_module module~vector_module->module~kind_module module~numbers_module numbers_module module~vector_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Returns the rotation matrix for a coordinate transformation from\nthe International Celestial Reference Frame (ICRF) frame to the\nIAU rotating frame associated with a body.\nThe IAU orientation models use three Euler angles to describe\nthe pole and prime meridian location (ra, dec, and w). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: w right ascension of the pole [rad] real(kind=wp), intent(in) :: dec declination of the pole [rad] real(kind=wp), intent(in) :: ra prime meridian location [rad] Return Value real(kind=wp), dimension(3,3) the rotation matrix Calls proc~~iau_rotation_matrix~~CallsGraph proc~iau_rotation_matrix iau_rotation_matrix proc~rotation_matrix rotation_matrix proc~iau_rotation_matrix->proc~rotation_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~iau_rotation_matrix~~CalledByGraph proc~iau_rotation_matrix iau_rotation_matrix proc~icrf_to_iau_earth icrf_to_iau_earth proc~icrf_to_iau_earth->proc~iau_rotation_matrix proc~icrf_to_iau_moon icrf_to_iau_moon proc~icrf_to_iau_moon->proc~iau_rotation_matrix proc~get_c_cdot_iau_earth iau_earth_rotating_frame%get_c_cdot_iau_earth proc~get_c_cdot_iau_earth->proc~icrf_to_iau_earth proc~get_c_cdot_iau_moon iau_moon_rotating_frame%get_c_cdot_iau_moon proc~get_c_cdot_iau_moon->proc~icrf_to_iau_moon proc~iau_test iau_test proc~iau_test->proc~icrf_to_iau_earth proc~iau_test->proc~icrf_to_iau_moon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function iau_rotation_matrix ( w , dec , ra ) result ( rotmat ) use vector_module , only : rotation_matrix , x_axis , y_axis , z_axis implicit none real ( wp ), intent ( in ) :: w !! right ascension of the pole [rad] real ( wp ), intent ( in ) :: dec !! declination of the pole [rad] real ( wp ), intent ( in ) :: ra !! prime meridian location [rad] real ( wp ), dimension ( 3 , 3 ) :: rotmat !! the rotation matrix real ( wp ), parameter :: pi2 = pi / two real ( wp ), dimension ( 3 , 3 ) :: tmp !it is a 3-1-3 rotation: tmp = matmul ( rotation_matrix ( x_axis , pi2 - dec ), rotation_matrix ( z_axis , pi2 + ra ) ) rotmat = matmul ( rotation_matrix ( z_axis , w ), tmp ) end function iau_rotation_matrix","tags":"","url":"proc/iau_rotation_matrix.html"},{"title":"icrf_to_iau_earth – fortran-astrodynamics-toolkit","text":"public pure function icrf_to_iau_earth(et) result(rotmat) Rotation matrix from ICRF to IAU_EARTH. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: et ephemeris time [sec] Return Value real(kind=wp), dimension(3,3) the rotation matrix Calls proc~~icrf_to_iau_earth~~CallsGraph proc~icrf_to_iau_earth icrf_to_iau_earth proc~iau_rotation_matrix iau_rotation_matrix proc~icrf_to_iau_earth->proc~iau_rotation_matrix proc~rotation_matrix rotation_matrix proc~iau_rotation_matrix->proc~rotation_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~icrf_to_iau_earth~~CalledByGraph proc~icrf_to_iau_earth icrf_to_iau_earth proc~get_c_cdot_iau_earth iau_earth_rotating_frame%get_c_cdot_iau_earth proc~get_c_cdot_iau_earth->proc~icrf_to_iau_earth proc~iau_test iau_test proc~iau_test->proc~icrf_to_iau_earth Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function icrf_to_iau_earth ( et ) result ( rotmat ) implicit none real ( wp ), intent ( in ) :: et !! ephemeris time [sec] real ( wp ), dimension ( 3 , 3 ) :: rotmat !! the rotation matrix real ( wp ) :: w , dec , ra , d , t d = et * sec2day !interval in days from the J2000 epoch t = et * sec2century !interval in Julian centuries (36525 days) from the J2000 epoch ra = ( - 0.641_wp * t ) * deg2rad dec = ( 9 0.0_wp - 0.557_wp * t ) * deg2rad w = ( 19 0.147_wp + 36 0.9856235_wp * d ) * deg2rad rotmat = iau_rotation_matrix ( w , dec , ra ) end function icrf_to_iau_earth","tags":"","url":"proc/icrf_to_iau_earth.html"},{"title":"icrf_to_iau_moon – fortran-astrodynamics-toolkit","text":"public pure function icrf_to_iau_moon(et) result(rotmat) Rotation matrix from ICRF to IAU_MOON. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: et ephemeris time [sec] Return Value real(kind=wp), dimension(3,3) the rotation matrix Calls proc~~icrf_to_iau_moon~~CallsGraph proc~icrf_to_iau_moon icrf_to_iau_moon proc~iau_rotation_matrix iau_rotation_matrix proc~icrf_to_iau_moon->proc~iau_rotation_matrix proc~rotation_matrix rotation_matrix proc~iau_rotation_matrix->proc~rotation_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~icrf_to_iau_moon~~CalledByGraph proc~icrf_to_iau_moon icrf_to_iau_moon proc~get_c_cdot_iau_moon iau_moon_rotating_frame%get_c_cdot_iau_moon proc~get_c_cdot_iau_moon->proc~icrf_to_iau_moon proc~iau_test iau_test proc~iau_test->proc~icrf_to_iau_moon Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function icrf_to_iau_moon ( et ) result ( rotmat ) implicit none real ( wp ), intent ( in ) :: et !! ephemeris time [sec] real ( wp ), dimension ( 3 , 3 ) :: rotmat !! the rotation matrix real ( wp ) :: w , dec , ra , d , t real ( wp ) :: e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 , e9 , e10 , e11 , e12 , e13 d = et * sec2day !interval in days from the J2000 epoch t = et * sec2century !interval in Julian centuries (36525 days) from the J2000 epoch ! Nutation/precession angles: e1 = ( 12 5.045_wp - 0.0529921_wp * d ) * deg2rad e2 = ( 25 0.089_wp - 0.1059842_wp * d ) * deg2rad e3 = ( 26 0.008_wp + 1 3.0120009_wp * d ) * deg2rad e4 = ( 17 6.625_wp + 1 3.3407154_wp * d ) * deg2rad e5 = ( 35 7.529_wp + 0.9856003_wp * d ) * deg2rad e6 = ( 31 1.589_wp + 2 6.4057084_wp * d ) * deg2rad e7 = ( 13 4.963_wp + 1 3.0649930_wp * d ) * deg2rad e8 = ( 27 6.617_wp + 0.3287146_wp * d ) * deg2rad e9 = ( 3 4.226_wp + 1.7484877_wp * d ) * deg2rad e10 = ( 1 5.134_wp - 0.1589763_wp * d ) * deg2rad e11 = ( 11 9.743_wp + 0.0036096_wp * d ) * deg2rad e12 = ( 23 9.961_wp + 0.1643573_wp * d ) * deg2rad e13 = ( 2 5.053_wp + 1 2.9590088_wp * d ) * deg2rad ra = ( 26 9.9949_wp + 0.0031_wp * t & - 3.8787_wp * sin ( E1 ) & - 0.1204_wp * sin ( E2 ) & + 0.0700_wp * sin ( E3 ) & - 0.0172_wp * sin ( E4 ) & + 0.0072_wp * sin ( E6 ) & - 0.0052_wp * sin ( E10 ) & + 0.0043_wp * sin ( E13 ) ) * deg2rad dec = ( 6 6.5392_wp + 0.0130_wp * t & + 1.5419_wp * cos ( E1 ) & + 0.0239_wp * cos ( E2 ) & - 0.0278_wp * cos ( E3 ) & + 0.0068_wp * cos ( E4 ) & - 0.0029_wp * cos ( E6 ) & + 0.0009_wp * cos ( E7 ) & + 0.0008_wp * cos ( E10 ) & - 0.0009_wp * cos ( E13 ) ) * deg2rad w = ( 3 8.3213_wp + 1 3.17635815_wp * d - 1.4e-12_wp * d ** 2 & + 3.5610_wp * sin ( E1 ) & + 0.1208_wp * sin ( E2 ) & - 0.0642_wp * sin ( E3 ) & + 0.0158_wp * sin ( E4 ) & + 0.0252_wp * sin ( E5 ) & - 0.0066_wp * sin ( E6 ) & - 0.0047_wp * sin ( E7 ) & - 0.0046_wp * sin ( E8 ) & + 0.0028_wp * sin ( E9 ) & + 0.0052_wp * sin ( E10 ) & + 0.0040_wp * sin ( E11 ) & + 0.0019_wp * sin ( E12 ) & - 0.0044_wp * sin ( E13 ) ) * deg2rad rotmat = iau_rotation_matrix ( w , dec , ra ) end function icrf_to_iau_moon","tags":"","url":"proc/icrf_to_iau_moon.html"},{"title":"iau_test – fortran-astrodynamics-toolkit","text":"public  subroutine iau_test() Unit test routine for iau_module. Arguments None Calls proc~~iau_test~~CallsGraph proc~iau_test iau_test proc~icrf_to_iau_earth icrf_to_iau_earth proc~iau_test->proc~icrf_to_iau_earth proc~icrf_to_iau_moon icrf_to_iau_moon proc~iau_test->proc~icrf_to_iau_moon proc~iau_rotation_matrix iau_rotation_matrix proc~icrf_to_iau_earth->proc~iau_rotation_matrix proc~icrf_to_iau_moon->proc~iau_rotation_matrix proc~rotation_matrix rotation_matrix proc~iau_rotation_matrix->proc~rotation_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine iau_test () implicit none real ( wp ) :: et real ( wp ), dimension ( 3 , 3 ) :: rotmat integer :: i write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' iau_test' write ( * , * ) '---------------' write ( * , * ) '' et = 100 0.0_wp !epoch [sec from J2000] rotmat = icrf_to_iau_earth ( et ) !rotation matrix from J2000 to IAU_EARTH write ( * , * ) '---icrf_to_iau_earth---' write ( * , * ) 'et    =' , et write ( * , * ) 'rotmat=' do i = 1 , 3 write ( * , * ) rotmat ( i ,:) end do ! ---icrf_to_iau_earth--- ! et    =   1000.0000000000000 ! rotmat= !  0.24742305587604752      -0.96890754534215406       -7.6219971891330182E-010 !  0.96890754534215406       0.24742305587604752       -2.9847705387722482E-009 !  3.0805524797727912E-009  -1.0920940632167532E-017   1.0000000000000000 ! ! Compare to SPICE: ! call PXFORM( 'J2000', 'IAU_EARTH', ET, ROTMAT ) ! rotmat= !  0.24742305587604752      -0.96890754534215406       -7.6219971891330182E-010 !  0.96890754534215406       0.24742305587604752       -2.9847705387722482E-009 !  3.0805524797727912E-009  -1.0920940632167532E-017    1.0000000000000000 et = 100 0.0_wp !epoch [sec from J2000] rotmat = icrf_to_iau_moon ( et ) !rotation matrix from J2000 to IAU_MOON write ( * , * ) '---icrf_to_iau_moon---' write ( * , * ) 'et    =' , et write ( * , * ) 'rotmat=' do i = 1 , 3 write ( * , * ) rotmat ( i ,:) end do ! ---icrf_to_iau_moon--- ! et    =   1000.0000000000000 ! rotmat= !  0.78257369718829173       0.55976292119480831       0.27247730276942850 ! -0.62214729926548507       0.71906872303263469       0.30963350847878057 ! -2.2608548951909870E-002 -0.41183205753276536       0.91097925876642116 ! ! Compare to SPICE: ! call PXFORM( 'J2000', 'IAU_MOON', ET, ROTMAT ) ! rotmat= !  0.78257369718829173       0.55976292119480819       0.27247730276942861 ! -0.62214729926548507       0.71906872303263458       0.30963350847878074 ! -2.2608548951909880E-002 -0.41183205753276558       0.91097925876642105 end subroutine iau_test","tags":"","url":"proc/iau_test.html"},{"title":"simpson_lunar_ephemeris – fortran-astrodynamics-toolkit","text":"public  subroutine simpson_lunar_ephemeris(jd, r_moon, v_moon) A simple analytical lunar ephemeris model.\n  Returns Lunar cartesian coordinates\n  (mean equator and equinox of epoch J2000). Reference \"An alternative lunar ephemeris model for on-board flight software use\",\n    D. G. Simpson, Proceedings of the 1999 NASA/GSFC Flight Mechanics Symposium,\n    p. 175-184). David G. Simpson Personal Web Site Reference code T = ( JD - 245154 5.0D0 ) / 3652 5.0D0 X = 38 3.0D3 * SIN ( 839 9.685D0 * T + 5.381D0 ) & + 3 1.5D3 * SIN ( 7 0.990D0 * T + 6.169D0 ) & + 1 0.6D3 * SIN ( 1672 8.377D0 * T + 1.453D0 ) & + 6.2D3 * SIN ( 118 5.622D0 * T + 0.481D0 ) & + 3.2D3 * SIN ( 714 3.070D0 * T + 5.017D0 ) & + 2.3D3 * SIN ( 1561 3.745D0 * T + 0.857D0 ) & + 0.8D3 * SIN ( 846 7.263D0 * T + 1.010D0 ) Y = 35 1.0D3 * SIN ( 839 9.687D0 * T + 3.811D0 ) & + 2 8.9D3 * SIN ( 7 0.997D0 * T + 4.596D0 ) & + 1 3.7D3 * SIN ( 843 3.466D0 * T + 4.766D0 ) & + 9.7D3 * SIN ( 1672 8.380D0 * T + 6.165D0 ) & + 5.7D3 * SIN ( 118 5.667D0 * T + 5.164D0 ) & + 2.9D3 * SIN ( 714 3.058D0 * T + 0.300D0 ) & + 2.1D3 * SIN ( 1561 3.755D0 * T + 5.565D0 ) Z = 15 3.2D3 * SIN ( 839 9.672D0 * T + 3.807D0 ) & + 3 1.5D3 * SIN ( 843 3.464D0 * T + 1.629D0 ) & + 1 2.5D3 * SIN ( 7 0.996D0 * T + 4.595D0 ) & + 4.2D3 * SIN ( 1672 8.364D0 * T + 6.162D0 ) & + 2.5D3 * SIN ( 118 5.645D0 * T + 5.167D0 ) & + 3.0D3 * SIN ( 10 4.881D0 * T + 2.555D0 ) & + 1.8D3 * SIN ( 839 9.116D0 * T + 6.248D0 ) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: jd Julian date real(kind=wp), intent(out), dimension(3) :: r_moon Moon position (km) real(kind=wp), intent(out), optional, dimension(3) :: v_moon Moon velocity (km/s) Source Code subroutine simpson_lunar_ephemeris ( jd , r_moon , v_moon ) implicit none real ( wp ), intent ( in ) :: jd !! Julian date real ( wp ), dimension ( 3 ), intent ( out ) :: r_moon !! Moon position (km) real ( wp ), dimension ( 3 ), intent ( out ), optional :: v_moon !! Moon velocity (km/s) real ( wp ) :: t !! time in Julian centuries from J2000 real ( wp ), dimension ( 7 ) :: xterms , yterms , zterms !coefficients: real ( wp ), dimension ( 7 ), parameter :: xcoeffs = [ 38 3.0e3_wp , 3 1.5e3_wp , & 1 0.6e3_wp , 6.2e3_wp , & 3.2e3_wp , 2.3e3_wp , & 0.8e3_wp ] real ( wp ), dimension ( 7 ), parameter :: ycoeffs = [ 35 1.0e3_wp , 2 8.9e3_wp , & 1 3.7e3_wp , 9.7e3_wp , & 5.7e3_wp , 2.9e3_wp , & 2.1e3_wp ] real ( wp ), dimension ( 7 ), parameter :: zcoeffs = [ 15 3.2e3_wp , 3 1.5e3_wp , & 1 2.5e3_wp , 4.2e3_wp , & 2.5e3_wp , 3.0e3_wp , & 1.8e3_wp ] real ( wp ), dimension ( 7 ), parameter :: xa = [ 839 9.685_wp , 7 0.990_wp , & 1672 8.377_wp , 118 5.622_wp , & 714 3.070_wp , 1561 3.745_wp , & 846 7.263_wp ] real ( wp ), dimension ( 7 ), parameter :: xp = [ 5.381_wp , 6.169_wp , & 1.453_wp , 0.481_wp , & 5.017_wp , 0.857_wp , & 1.010_wp ] real ( wp ), dimension ( 7 ), parameter :: ya = [ 839 9.687_wp , 7 0.997_wp , & 843 3.466_wp , 1672 8.380_wp , & 118 5.667_wp , 714 3.058_wp , & 1561 3.755_wp ] real ( wp ), dimension ( 7 ), parameter :: yp = [ 3.811_wp , 4.596_wp , & 4.766_wp , 6.165_wp , & 5.164_wp , 0.300_wp , & 5.565_wp ] real ( wp ), dimension ( 7 ), parameter :: za = [ 839 9.672_wp , 843 3.464_wp , & 7 0.996_wp , 1672 8.364_wp , & 118 5.645_wp , 10 4.881_wp , & 839 9.116_wp ] real ( wp ), dimension ( 7 ), parameter :: zp = [ 3.807_wp , 1.629_wp , & 4.595_wp , 6.162_wp , & 5.167_wp , 2.555_wp , & 6.248_wp ] real ( wp ), dimension ( 7 ), parameter :: vxcoeffs = xcoeffs * xa real ( wp ), dimension ( 7 ), parameter :: vycoeffs = ycoeffs * ya real ( wp ), dimension ( 7 ), parameter :: vzcoeffs = zcoeffs * za t = ( jd - 245154 5.0_wp ) * day2century xterms = xa * t + xp yterms = ya * t + yp zterms = za * t + zp r_moon ( 1 ) = dot_product ( xcoeffs , sin ( xterms )) r_moon ( 2 ) = dot_product ( ycoeffs , sin ( yterms )) r_moon ( 3 ) = dot_product ( zcoeffs , sin ( zterms )) !v_moon is just d(r_moon)/dt: ! [convert units to km/s] if ( present ( v_moon )) then v_moon ( 1 ) = dot_product ( vxcoeffs , cos ( xterms )) / ( century2day * day2sec ) v_moon ( 2 ) = dot_product ( vycoeffs , cos ( yterms )) / ( century2day * day2sec ) v_moon ( 3 ) = dot_product ( vzcoeffs , cos ( zterms )) / ( century2day * day2sec ) end if end subroutine simpson_lunar_ephemeris","tags":"","url":"proc/simpson_lunar_ephemeris.html"},{"title":"matrix_determinant – fortran-astrodynamics-toolkit","text":"public pure recursive function matrix_determinant(n, a) result(det) Matrix determinant of an matrix (recursive formulation). Reference https://rosettacode.org/wiki/Matrix_arithmetic#Fortran Arguments Type Intent Optional Attributes Name integer, intent(in) :: n size of a matrix real(kind=wp), intent(in), dimension(n,n) :: a the matrix Return Value real(kind=wp) the determinant of a matrix Called by proc~~matrix_determinant~~CalledByGraph proc~matrix_determinant matrix_determinant proc~matrix_determinant->proc~matrix_determinant proc~matrix_cofactor matrix_cofactor proc~matrix_cofactor->proc~matrix_determinant Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure recursive function matrix_determinant ( n , a ) result ( det ) implicit none integer , intent ( in ) :: n !! size of `a` matrix real ( wp ), dimension ( n , n ), intent ( in ) :: a !! the matrix real ( wp ) :: det !! the determinant of `a` matrix integer :: i !! counter integer :: sgn !! `(-1)**(i-1)` term real ( wp ), dimension ( n - 1 , n - 1 ) :: b !! temp matrix if ( n == 1 ) then det = a ( 1 , 1 ) else det = zero sgn = 1 do i = 1 , n b (:, :( i - 1 )) = a ( 2 :, : i - 1 ) b (:, i :) = a ( 2 :, i + 1 :) det = det + sgn * a ( 1 , i ) * matrix_determinant ( n - 1 , b ) sgn = - sgn end do end if end function matrix_determinant","tags":"","url":"proc/matrix_determinant.html"},{"title":"matrix_cofactor – fortran-astrodynamics-toolkit","text":"public pure function matrix_cofactor(n, a) result(c) Compute the cofactors matrix (the transpose of the adjugate matrix). References https://warwick.ac.uk/fac/sci/physics/research/condensedmatt/imr_cdt/students/david_goodwin/teaching/cis008-2/determinant_algorithm_cis008-2_lec_21.pdf https://groups.google.com/forum/#!topic/comp.lang.fortran/Y6jCv-QdDhc Arguments Type Intent Optional Attributes Name integer, intent(in) :: n size of a matrix real(kind=wp), intent(in), dimension(n,n) :: a the matrix Return Value real(kind=wp), dimension(n,n) the cofactors of a matrix Calls proc~~matrix_cofactor~~CallsGraph proc~matrix_cofactor matrix_cofactor proc~matrix_determinant matrix_determinant proc~matrix_cofactor->proc~matrix_determinant proc~matrix_determinant->proc~matrix_determinant Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function matrix_cofactor ( n , a ) result ( c ) implicit none integer , intent ( in ) :: n !! size of `a` matrix real ( wp ), dimension ( n , n ), intent ( in ) :: a !! the matrix real ( wp ), dimension ( n , n ) :: c !! the cofactors of `a` matrix integer :: i !! counter integer :: j !! counter real ( wp ), dimension ( n - 1 , n - 1 ) :: c_temp !! temp matrix logical , dimension ( n , n ) :: m !! mask for row/col removal if ( n == 1 ) then c ( 1 , 1 ) = one else do i = 1 , n do j = 1 , n ! remove the ith row and jth col from a: m = . true . m (:, j ) = . false . m ( i ,:) = . false . c_temp = reshape ( pack ( a , m ),[ n - 1 , n - 1 ]) c ( i , j ) = ( ( - 1 ) ** ( i + j ) ) * matrix_determinant ( n - 1 , c_temp ) end do end do end if end function matrix_cofactor","tags":"","url":"proc/matrix_cofactor.html"},{"title":"matrix_trace – fortran-astrodynamics-toolkit","text":"public pure function matrix_trace(n, mat) result(trace) Compute the matrix trace (sum of the diagonal elements). Arguments Type Intent Optional Attributes Name integer, intent(in) :: n size of the matrix real(kind=wp), intent(in), dimension(n,n) :: mat the matrix Return Value real(kind=wp) the matrix trace Called by proc~~matrix_trace~~CalledByGraph proc~matrix_trace matrix_trace proc~compute_monodromy_matrix_eigenvalues compute_monodromy_matrix_eigenvalues proc~compute_monodromy_matrix_eigenvalues->proc~matrix_trace Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function matrix_trace ( n , mat ) result ( trace ) implicit none integer , intent ( in ) :: n !! size of the matrix real ( wp ), dimension ( n , n ), intent ( in ) :: mat !! the matrix real ( wp ) :: trace !! the matrix trace integer :: i !! counter trace = zero do i = 1 , n trace = trace + mat ( i , i ) end do end function matrix_trace","tags":"","url":"proc/matrix_trace.html"},{"title":"print_matrix – fortran-astrodynamics-toolkit","text":"public  subroutine print_matrix(mat, unit) Uses iso_fortran_env proc~~print_matrix~~UsesGraph proc~print_matrix print_matrix iso_fortran_env iso_fortran_env proc~print_matrix->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Print a matrix to the console. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: mat the matrix to print integer, intent(in), optional :: unit unit number (assumed to be an open file).\nif not present, then the standard output is used. Source Code subroutine print_matrix ( mat , unit ) use iso_fortran_env , only : output_unit implicit none real ( wp ), dimension (:,:), intent ( in ) :: mat !! the matrix to print integer , intent ( in ), optional :: unit !! unit number (assumed to be an open file). !! if not present, then the standard output is used. integer :: i !! counter integer :: n !! number of rows in the matrix integer :: iunit !! the file unit to print to integer :: istat !! `iostat` flag for write statement character ( len =* ), parameter :: fmt = 'E26.16' !! real number format statement if ( present ( unit )) then iunit = unit else iunit = output_unit end if n = size ( mat , 1 ) do i = 1 , n write ( iunit , fmt = '(*(' // fmt // ',1X))' , iostat = istat ) mat ( i ,:) end do end subroutine print_matrix","tags":"","url":"proc/print_matrix.html"},{"title":"close_spice_ephemeris – fortran-astrodynamics-toolkit","text":"private  subroutine close_spice_ephemeris(me) Close the SPICE ephemeris and unload all the kernels. Type Bound spice_ephemeris Arguments Type Intent Optional Attributes Name class( spice_ephemeris ), intent(inout) :: me Source Code subroutine close_spice_ephemeris ( me ) implicit none class ( spice_ephemeris ), intent ( inout ) :: me integer :: i !! counter #ifdef HAS_SPICELIB !unload all the kernels: if ( allocated ( me % kernels )) then do i = 1 , size ( me % kernels ) call unload ( trim ( me % kernels ( i ))) end do deallocate ( me % kernels ) end if !clear the system: call kclear () #else error stop 'this library was not built with SPICELIB support' #endif end subroutine close_spice_ephemeris","tags":"","url":"proc/close_spice_ephemeris.html"},{"title":"initialize_spice_ephemeris – fortran-astrodynamics-toolkit","text":"private  subroutine initialize_spice_ephemeris(me, kernels) Initialize a SPICE ephemeris by loading the specified kernels. Type Bound spice_ephemeris Arguments Type Intent Optional Attributes Name class( spice_ephemeris ), intent(inout) :: me character(len=*), intent(in), dimension(:) :: kernels list of kernels to load Source Code subroutine initialize_spice_ephemeris ( me , kernels ) implicit none class ( spice_ephemeris ), intent ( inout ) :: me character ( len =* ), dimension (:), intent ( in ) :: kernels !! list of kernels to load integer :: i !! counter #ifdef HAS_SPICELIB ! disable the SPICE traceback system to speed it up. call trcoff () call me % close () ! just in case !save the kernel list for unloading later: allocate ( character ( len = len ( kernels )) :: me % kernels ( size ( kernels ))) !load all the kernels: do i = 1 , size ( kernels ) call furnsh ( trim ( kernels ( i ))) end do #else error stop 'this library was not built with SPICELIB support' #endif end subroutine initialize_spice_ephemeris","tags":"","url":"proc/initialize_spice_ephemeris.html"},{"title":"get_rv_from_spice_ephemeris – fortran-astrodynamics-toolkit","text":"private  subroutine get_rv_from_spice_ephemeris(me, et, targ, obs, rv, status_ok) Uses numbers_module celestial_body_module proc~~get_rv_from_spice_ephemeris~~UsesGraph proc~get_rv_from_spice_ephemeris spice_ephemeris%get_rv_from_spice_ephemeris module~celestial_body_module celestial_body_module proc~get_rv_from_spice_ephemeris->module~celestial_body_module module~numbers_module numbers_module proc~get_rv_from_spice_ephemeris->module~numbers_module module~celestial_body_module->module~numbers_module module~base_class_module base_class_module module~celestial_body_module->module~base_class_module module~kind_module kind_module module~celestial_body_module->module~kind_module module~numbers_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interface for the ephemeris_module . Return the Cartesian state of targ relative to obs in the J2000 frame. Type Bound spice_ephemeris Arguments Type Intent Optional Attributes Name class( spice_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(6) :: rv state of targ w.r.t. obs [km,km/s] in ICRF frame logical, intent(out) :: status_ok true if there were no problems Source Code subroutine get_rv_from_spice_ephemeris ( me , et , targ , obs , rv , status_ok ) use celestial_body_module , only : celestial_body use numbers_module , only : zero implicit none class ( spice_ephemeris ), intent ( inout ) :: me real ( wp ), intent ( in ) :: et !! ephemeris time [sec] type ( celestial_body ), intent ( in ) :: targ !! target body type ( celestial_body ), intent ( in ) :: obs !! observer body real ( wp ), dimension ( 6 ), intent ( out ) :: rv !! state of targ w.r.t. obs [km,km/s] in ICRF frame logical , intent ( out ) :: status_ok !! true if there were no problems real ( wp ) :: lt !! light time output from spkgeo #ifdef HAS_SPICELIB call spkgeo ( targ % id , et , 'J2000' , obs % id , rv , lt ) status_ok = . not . failed () #else error stop 'this library was not built with SPICELIB support' #endif end subroutine get_rv_from_spice_ephemeris","tags":"","url":"proc/get_rv_from_spice_ephemeris.html"},{"title":"get_r_from_spice_ephemeris – fortran-astrodynamics-toolkit","text":"private  subroutine get_r_from_spice_ephemeris(me, et, targ, obs, r, status_ok) Uses numbers_module celestial_body_module proc~~get_r_from_spice_ephemeris~~UsesGraph proc~get_r_from_spice_ephemeris spice_ephemeris%get_r_from_spice_ephemeris module~celestial_body_module celestial_body_module proc~get_r_from_spice_ephemeris->module~celestial_body_module module~numbers_module numbers_module proc~get_r_from_spice_ephemeris->module~numbers_module module~celestial_body_module->module~numbers_module module~base_class_module base_class_module module~celestial_body_module->module~base_class_module module~kind_module kind_module module~celestial_body_module->module~kind_module module~numbers_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interface for the ephemeris_module . Return the Cartesian position vector of targ relative to obs in the J2000 frame. Type Bound spice_ephemeris Arguments Type Intent Optional Attributes Name class( spice_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(3) :: r position of targ w.r.t. obs [km] in ICRF frame logical, intent(out) :: status_ok true if there were no problems Source Code subroutine get_r_from_spice_ephemeris ( me , et , targ , obs , r , status_ok ) use celestial_body_module , only : celestial_body use numbers_module , only : zero implicit none class ( spice_ephemeris ), intent ( inout ) :: me real ( wp ), intent ( in ) :: et !! ephemeris time [sec] type ( celestial_body ), intent ( in ) :: targ !! target body type ( celestial_body ), intent ( in ) :: obs !! observer body real ( wp ), dimension ( 3 ), intent ( out ) :: r !! position of targ w.r.t. obs [km] in ICRF frame logical , intent ( out ) :: status_ok !! true if there were no problems real ( wp ) :: lt !! light time output from spkgeo #ifdef HAS_SPICELIB call spkgps ( targ % id , et , 'J2000' , obs % id , r , lt ) status_ok = . not . failed () #else error stop 'this library was not built with SPICELIB support' #endif end subroutine get_r_from_spice_ephemeris","tags":"","url":"proc/get_r_from_spice_ephemeris.html"},{"title":"orbit_period – fortran-astrodynamics-toolkit","text":"public pure function orbit_period(mu, a) result(period) Compute the two-body orbital period. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [ ] real(kind=wp), intent(in) :: a semimajor axis [km] Return Value real(kind=wp) two-body orbital period [s] Source Code pure function orbit_period ( mu , a ) result ( period ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;{3}/s&#94;{2}] real ( wp ), intent ( in ) :: a !! semimajor axis [km] real ( wp ) :: period !! two-body orbital period [s] period = twopi / sqrt ( mu / a ** 3 ) end function orbit_period","tags":"","url":"proc/orbit_period.html"},{"title":"orbit_energy – fortran-astrodynamics-toolkit","text":"public pure function orbit_energy(mu, rv) result(energy) Compute the two-body orbital energy. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [ ] real(kind=wp), intent(in), dimension(6) :: rv position and velocity vector [km,km/s] Return Value real(kind=wp) two-body orbital energy [ ] Source Code pure function orbit_energy ( mu , rv ) result ( energy ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;{3}/s&#94;{2}] real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! position and velocity vector [km,km/s] real ( wp ) :: energy !! two-body orbital energy [km&#94;{2}/s&#94;{2}] real ( wp ) :: rmag !! position vector magnitude [km] real ( wp ) :: vmag !! velocity vector magnitude [km] rmag = norm2 ( rv ( 1 : 3 )) vmag = norm2 ( rv ( 4 : 6 )) energy = ( vmag ** 2 / two ) - ( mu / rmag ) end function orbit_energy","tags":"","url":"proc/orbit_energy.html"},{"title":"sphere_of_influence – fortran-astrodynamics-toolkit","text":"public pure function sphere_of_influence(mu_primary, mu_secondary, r_ps) result(r_soi) Computes the sphere-of-influence radius of the secondary body. See also R.H. Battin, \"An Introduction to the Mathematics and\n    Methods of Astrodynamics, Revised Edition\", AIAA, 1999. This is the approximate formula (8.74 from Battin). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu_primary primary body gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: mu_secondary secondary body gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: r_ps distance between the two bodies [km] Return Value real(kind=wp) sphere of influence radius [km] Source Code pure function sphere_of_influence ( mu_primary , mu_secondary , r_ps ) result ( r_soi ) implicit none real ( wp ), intent ( in ) :: mu_primary !! primary body gravitational parameter [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: mu_secondary !! secondary body gravitational parameter [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: r_ps !! distance between the two bodies [km] real ( wp ) :: r_soi !! sphere of influence radius [km] real ( wp ), parameter :: two_fifths = two / five if ( mu_primary > zero . and . mu_secondary > zero . and . r_ps > zero ) then r_soi = r_ps * ( mu_secondary / mu_primary ) ** two_fifths else r_soi = zero end if end function sphere_of_influence","tags":"","url":"proc/sphere_of_influence.html"},{"title":"sphere_of_influence_earth_moon – fortran-astrodynamics-toolkit","text":"public pure function sphere_of_influence_earth_moon(mu_primary, mu_secondary, r, r_sp) result(r_soi) Computes the sphere-of-influence radius of the secondary body. Notes r and r_sp should be in the same inertial frame. The mass of the spacecraft is neglected. See also R.H. Battin, \"An Introduction to the Mathematics and\n    Methods of Astrodynamics, Revised Edition\", AIAA, 1999. This is the more complex formula, on p. 397 of Battin,\n    which is better for the Earth/Moon system. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu_primary primary body gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: mu_secondary secondary body gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r vector from the secondary body to the spacecraft [km] real(kind=wp), intent(in), dimension(3) :: r_sp vector from the secondary to the primary body [km] Return Value real(kind=wp) sphere of influence radius of the secondary body [km] Calls proc~~sphere_of_influence_earth_moon~~CallsGraph proc~sphere_of_influence_earth_moon sphere_of_influence_earth_moon proc~angle_between_vectors angle_between_vectors proc~sphere_of_influence_earth_moon->proc~angle_between_vectors proc~cross cross proc~angle_between_vectors->proc~cross Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function sphere_of_influence_earth_moon ( mu_primary , mu_secondary , r , r_sp ) result ( r_soi ) implicit none real ( wp ), intent ( in ) :: mu_primary !! primary body gravitational parameter [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: mu_secondary !! secondary body gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! vector from the secondary body to the spacecraft [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r_sp !! vector from the secondary to the primary body [km] real ( wp ) :: r_soi !! sphere of influence radius of the secondary body [km] real ( wp ) :: r_mag , r_sp_mag , alpha , ca , ca2 , denom r_mag = norm2 ( r ) r_sp_mag = norm2 ( r_sp ) if ( mu_primary > zero . and . mu_secondary > zero . and . r_mag > zero . and . r_sp_mag > zero ) then alpha = angle_between_vectors ( r , r_sp ) ca = cos ( alpha ) ca2 = ca * ca denom = ( mu_secondary ** 2 / mu_primary ** 2 ) ** ( one / five ) * ( one + three * ca2 ) ** ( one / ten ) + & ( two / five ) * ca * (( one + six * ca2 ) / ( one + three * ca2 )) r_soi = r_sp_mag / denom else r_soi = zero end if end function sphere_of_influence_earth_moon","tags":"","url":"proc/sphere_of_influence_earth_moon.html"},{"title":"rv_to_orbital_elements – fortran-astrodynamics-toolkit","text":"public pure subroutine rv_to_orbital_elements(mu, r, v, p, ecc, inc, raan, aop, tru) Convert position and velocity vectors to orbital elements. See also The poliastro routine rv2coe . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [ ] real(kind=wp), intent(in), dimension(3) :: r position vector [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector [km/s] real(kind=wp), intent(out) :: p semiparameter [km] real(kind=wp), intent(out) :: ecc eccentricity [--] real(kind=wp), intent(out) :: inc inclination [rad] real(kind=wp), intent(out) :: raan raan [rad] real(kind=wp), intent(out) :: aop argument of peripsis [rad] real(kind=wp), intent(out) :: tru true anomaly [rad] Calls proc~~rv_to_orbital_elements~~CallsGraph proc~rv_to_orbital_elements rv_to_orbital_elements proc~cross cross proc~rv_to_orbital_elements->proc~cross proc~orbit_check orbit_check proc~rv_to_orbital_elements->proc~orbit_check proc~wrap_angle wrap_angle proc~rv_to_orbital_elements->proc~wrap_angle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine rv_to_orbital_elements ( mu , r , v , p , ecc , inc , raan , aop , tru ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;{3}/s&#94;{2}] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector [km/s] real ( wp ), intent ( out ) :: p !! semiparameter a(1-e&#94;{2}) [km] real ( wp ), intent ( out ) :: ecc !! eccentricity [--] real ( wp ), intent ( out ) :: inc !! inclination [rad] real ( wp ), intent ( out ) :: raan !! raan [rad] real ( wp ), intent ( out ) :: aop !! argument of peripsis [rad] real ( wp ), intent ( out ) :: tru !! true anomaly [rad] real ( wp ), dimension ( 3 ) :: h , n , e logical :: circular , equatorial reaL ( wp ) :: hmag , rmag , vmag rmag = norm2 ( r ) vmag = norm2 ( v ) h = cross ( r , v ) hmag = norm2 ( h ) n = cross ([ zero , zero , one ], h ) / hmag e = (( vmag ** 2 - mu / rmag ) * r - dot_product ( r , v ) * v ) / mu ecc = norm2 ( e ) p = hmag ** 2 / mu inc = atan2 ( norm2 ( h ( 1 : 2 )), h ( 3 )) call orbit_check ( ecc , inc , circular , equatorial ) if ( equatorial . and . . not . circular ) then raan = zero aop = wrap_angle ( atan2 ( e ( 2 ), e ( 1 ))) ! Longitude of periapsis tru = wrap_angle ( atan2 ( dot_product ( h , cross ( e , r )) / hmag , dot_product ( r , e ))) elseif ( . not . equatorial . and . circular ) then raan = wrap_angle ( atan2 ( n ( 2 ), n ( 1 ))) aop = zero tru = wrap_angle ( atan2 ( dot_product ( r , cross ( h , n )) / hmag , dot_product ( r , n ))) ! Argument of latitude elseif ( equatorial . and . circular ) then raan = zero aop = zero tru = wrap_angle ( atan2 ( r ( 2 ), r ( 1 ))) ! True longitude else raan = wrap_angle ( atan2 ( n ( 2 ), n ( 1 ))) aop = wrap_angle ( atan2 ( dot_product ( e , cross ( h , n )) / hmag , dot_product ( e , n ))) tru = wrap_angle ( atan2 ( dot_product ( r , cross ( h , e )) / hmag , dot_product ( r , e ))) endif end subroutine rv_to_orbital_elements","tags":"","url":"proc/rv_to_orbital_elements.html"},{"title":"orbital_elements_to_rv – fortran-astrodynamics-toolkit","text":"public pure subroutine orbital_elements_to_rv(mu, p, ecc, inc, raan, aop, tru, r, v) Convert orbital elements to position and velocity vectors. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [ ] real(kind=wp), intent(in) :: p semiparameter [km] real(kind=wp), intent(in) :: ecc eccentricity [--] real(kind=wp), intent(in) :: inc inclination [rad] real(kind=wp), intent(in) :: raan raan [rad] real(kind=wp), intent(in) :: aop argument of peripsis [rad] real(kind=wp), intent(in) :: tru true anomaly [rad] real(kind=wp), intent(out), dimension(3) :: r position vector [km] real(kind=wp), intent(out), dimension(3) :: v velocity vector [km/s] Calls proc~~orbital_elements_to_rv~~CallsGraph proc~orbital_elements_to_rv orbital_elements_to_rv proc~orbit_check orbit_check proc~orbital_elements_to_rv->proc~orbit_check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~orbital_elements_to_rv~~CalledByGraph proc~orbital_elements_to_rv orbital_elements_to_rv proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->proc~orbital_elements_to_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine orbital_elements_to_rv ( mu , p , ecc , inc , raan , aop , tru , r , v ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;{3}/s&#94;{2}] real ( wp ), intent ( in ) :: p !! semiparameter a(1-e&#94;{2}) [km] real ( wp ), intent ( in ) :: ecc !! eccentricity [--] real ( wp ), intent ( in ) :: inc !! inclination [rad] real ( wp ), intent ( in ) :: raan !! raan [rad] real ( wp ), intent ( in ) :: aop !! argument of peripsis [rad] real ( wp ), intent ( in ) :: tru !! true anomaly [rad] real ( wp ), dimension ( 3 ), intent ( out ) :: r !! position vector [km] real ( wp ), dimension ( 3 ), intent ( out ) :: v !! velocity vector [km/s] real ( wp ), dimension ( 3 , 2 ) :: rotmat real ( wp ), dimension ( 2 ) :: r_pqw , v_pqw logical :: circular , equatorial real ( wp ) :: ctru , stru , sr , cr , si , ci , sa , ca , raan_tmp , aop_tmp call orbit_check ( ecc , inc , circular , equatorial ) if ( circular ) then ! periapsis undefined aop_tmp = zero else aop_tmp = aop end if if ( equatorial ) then ! node undefined raan_tmp = zero else raan_tmp = raan end if ! perifocal position and velocity: ctru = cos ( tru ) stru = sin ( tru ) r_pqw = [ ctru , stru ] * p / ( one + ecc * ctru ) v_pqw = [ - stru , ( ecc + ctru )] * sqrt ( mu / p ) ! perifocal to cartesian: sr = sin ( raan_tmp ) cr = cos ( raan_tmp ) si = sin ( inc ) ci = cos ( inc ) sa = sin ( aop_tmp ) ca = cos ( aop_tmp ) rotmat ( 1 ,:) = [ cr * ca - sr * sa * ci , - cr * sa - sr * ca * ci ] rotmat ( 2 ,:) = [ sr * ca + cr * sa * ci , - sr * sa + cr * ca * ci ] rotmat ( 3 ,:) = [ sa * si , ca * si ] ! transform: r = matmul ( rotmat , r_pqw ) v = matmul ( rotmat , v_pqw ) end subroutine orbital_elements_to_rv","tags":"","url":"proc/orbital_elements_to_rv.html"},{"title":"orbit_check – fortran-astrodynamics-toolkit","text":"private pure subroutine orbit_check(ecc, inc, circular, equatorial) Check the orbit for singularities. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ecc eccentricity real(kind=wp), intent(in) :: inc inclination [rad] logical, intent(out) :: circular is the orbit circular? logical, intent(out) :: equatorial is the orbit equatorial? Called by proc~~orbit_check~~CalledByGraph proc~orbit_check orbit_check proc~orbital_elements_to_rv orbital_elements_to_rv proc~orbital_elements_to_rv->proc~orbit_check proc~rv_to_orbital_elements rv_to_orbital_elements proc~rv_to_orbital_elements->proc~orbit_check proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->proc~orbital_elements_to_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine orbit_check ( ecc , inc , circular , equatorial ) implicit none real ( wp ), intent ( in ) :: ecc !! eccentricity real ( wp ), intent ( in ) :: inc !! inclination [rad] logical , intent ( out ) :: circular !! is the orbit circular? logical , intent ( out ) :: equatorial !! is the orbit equatorial? real ( wp ), parameter :: tol = 1.0e-10_wp !! tolerance for circular & equatorial checks circular = ecc < tol equatorial = ( one - abs ( cos ( inc ))) < tol ! 0 or 180 deg end subroutine orbit_check","tags":"","url":"proc/orbit_check.html"},{"title":"periapsis_apoapsis – fortran-astrodynamics-toolkit","text":"public pure subroutine periapsis_apoapsis(mu, a, e, rp, ra, vp, va) Compute the periapsis and apoapsis position and velocity magnitudes. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [ ] real(kind=wp), intent(in) :: a semimajor axis [km] real(kind=wp), intent(in) :: e eccentricity [--] real(kind=wp), intent(out) :: rp periapsis position magnitude [km] real(kind=wp), intent(out) :: ra apoapsis position magnitude [km] real(kind=wp), intent(out) :: vp periapsis velocity magnitude [km/s] real(kind=wp), intent(out) :: va apoapsis velocity magnitude [km/s] Source Code pure subroutine periapsis_apoapsis ( mu , a , e , rp , ra , vp , va ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;{3}/s&#94;{2}] real ( wp ), intent ( in ) :: a !! semimajor axis [km] real ( wp ), intent ( in ) :: e !! eccentricity [--] real ( wp ), intent ( out ) :: rp !! periapsis position magnitude [km] real ( wp ), intent ( out ) :: ra !! apoapsis position magnitude [km] real ( wp ), intent ( out ) :: vp !! periapsis velocity magnitude [km/s] real ( wp ), intent ( out ) :: va !! apoapsis velocity magnitude [km/s] real ( wp ) :: rarp !! r_a + r_p  real ( wp ) :: twomu !!  2 \\mu  twomu = two * mu rp = a * ( one - e ) ra = a * ( one + e ) rarp = ra + rp vp = sqrt ( twomu * ra / ( rp * rarp )) va = sqrt ( twomu * rp / ( ra * rarp )) end subroutine periapsis_apoapsis","tags":"","url":"proc/periapsis_apoapsis.html"},{"title":"number_of_coefficients – fortran-astrodynamics-toolkit","text":"private pure function number_of_coefficients(n, m) result(np) Number of (c,s) coefficients for n x m geopotential model\nStarting with n=2,m=0. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n degree integer, intent(in) :: m order Return Value integer number of coefficients Called by proc~~number_of_coefficients~~CalledByGraph proc~number_of_coefficients number_of_coefficients proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->proc~number_of_coefficients proc~read_geopotential_file geopotential_model%read_geopotential_file proc~geopotential_module_test->proc~read_geopotential_file proc~read_geopotential_file->proc~number_of_coefficients Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function number_of_coefficients ( n , m ) result ( np ) implicit none integer :: np !! number of coefficients integer , intent ( in ) :: n !! degree integer , intent ( in ) :: m !! order integer :: i !counter if ( n >= m . and . n > 1 ) then np = m - 1 + sum ( [ ( i , i = n , 2 , - 1 ) ] ) else np = - 999 !error end if end function number_of_coefficients","tags":"","url":"proc/number_of_coefficients.html"},{"title":"FL – fortran-astrodynamics-toolkit","text":"private  function FL(n) The FL factorial function from [1]. References W. M. Lear, \"The Programs TRAJ1 and TRAJ2\",\n     JSC Mission Planning and Analysis Division,\n     JSC-22512, 87-FM-4, April 1987 SOURCE Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=wp) Called by proc~~fl~~CalledByGraph proc~fl FL proc~convert convert proc~convert->proc~fl proc~read_geopotential_file geopotential_model%read_geopotential_file proc~read_geopotential_file->proc~fl proc~read_geopotential_file->proc~convert proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->proc~read_geopotential_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function FL ( n ) implicit none real ( wp ) :: FL integer , intent ( in ) :: n integer :: i FL = one if ( n == 0 . or . n == 1 ) return do i = 2 , n FL = FL * i end do end function FL","tags":"","url":"proc/fl.html"},{"title":"pinesnorm – fortran-astrodynamics-toolkit","text":"private pure function pinesnorm(mu, req, r_f, cnm, snm, nmax, mmax) result(accel) Normalized Pines geopotential code. Reference pinesnorm.m Matlab code from \"Normalization and Implementation of\n    Three Gravitational Acceleration Models\", NASA/TP-2016-218604. link added at the end, once the harmonic terms have been computed. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational constant [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: req body equatorial radius [km] real(kind=wp), intent(in), dimension(3) :: r_f body-fixed Cartesian position vector [km] real(kind=wp), intent(in), dimension(:,0:) :: cnm c coefficients (Normalized) real(kind=wp), intent(in), dimension(:,0:) :: snm s coefficients (Normalized) integer, intent(in) :: nmax desired degree integer, intent(in) :: mmax desired order Return Value real(kind=wp), dimension(3) body-fixed Cartesian acceleration vector [km/s&#94;2] Called by proc~~pinesnorm~~CalledByGraph proc~pinesnorm pinesnorm proc~compute_gravity_acceleration_normalized_pines geopotential_model_normalized_pines%compute_gravity_acceleration_normalized_pines proc~compute_gravity_acceleration_normalized_pines->proc~pinesnorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function pinesnorm ( mu , req , r_f , cnm , snm , nmax , mmax ) result ( accel ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational constant [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: req !! body equatorial radius [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r_f !! body-fixed Cartesian position vector [km] real ( wp ), dimension (:, 0 :), intent ( in ) :: cnm !! c coefficients (Normalized) real ( wp ), dimension (:, 0 :), intent ( in ) :: snm !! s coefficients (Normalized) integer , intent ( in ) :: nmax !! desired degree integer , intent ( in ) :: mmax !! desired order real ( wp ), dimension ( 3 ) :: accel !! body-fixed Cartesian acceleration vector [km/s&#94;2] real ( wp ), dimension ( nmax + 3 , nmax + 3 ) :: anm real ( wp ), dimension ( mmax + 2 ) :: rm , im real ( wp ), dimension ( 3 ) :: harmonics_acc real ( wp ) :: alpha , alpha_den , alpha_num , beta , beta_den ,& beta_num , dnm , enm , fnm , g1 , g1temp , g2 ,& g2temp , g3 , g3temp , g4 , g4temp , rho , rhop , rmag ,& s , sm , t , u integer :: m , n , m_a , n_a , m_ri , nmodel rmag = norm2 ( r_f ) s = r_f ( 1 ) / rmag t = r_f ( 2 ) / rmag u = r_f ( 3 ) / rmag anm = 0.0_wp anm ( 1 , 1 ) = sqrt ( 2.0_wp ) do m = 0 , nmax + 2 m_a = m + 1 if ( m /= 0 ) then ! diagonal recursion anm ( m_a , m_a ) = sqrt ( 1 + ( 1.0_wp / ( 2 * m ))) * anm ( m_a - 1 , m_a - 1 ) end if if ( m /= nmax + 2 ) then ! first off-diagonal recursion anm ( m_a + 1 , m_a ) = sqrt ( real ( 2 * m + 3 , wp )) * u * anm ( m_a , m_a ) end if if ( m < nmax + 1 ) then ! column recursion do n = m + 2 , nmax + 2 n_a = n + 1 alpha_num = ( 2 * n + 1 ) * ( 2 * n - 1 ) alpha_den = ( n - m ) * ( n + m ) alpha = sqrt ( alpha_num / alpha_den ) beta_num = ( 2 * n + 1 ) * ( n - m - 1 ) * ( n + m - 1 ) beta_den = ( 2 * n - 3 ) * ( n + m ) * ( n - m ) beta = sqrt ( beta_num / beta_den ) anm ( n_a , m_a ) = alpha * u * anm ( n_a - 1 , m_a ) - beta * anm ( n_a - 2 , m_a ) end do end if end do do n = 0 , nmax + 2 n_a = n + 1 anm ( n_a , 1 ) = anm ( n_a , 1 ) * sqrt ( 0.5_wp ) end do rm = 0.0_wp im = 0.0_wp rm ( 1 ) = 0.0_wp im ( 1 ) = 0.0_wp rm ( 2 ) = 1.0_wp im ( 2 ) = 0.0_wp do m = 1 , mmax m_ri = m + 2 rm ( m_ri ) = s * rm ( m_ri - 1 ) - t * im ( m_ri - 1 ) im ( m_ri ) = s * im ( m_ri - 1 ) + t * rm ( m_ri - 1 ) end do rho = ( mu ) / ( req * rmag ) rhop = ( req ) / ( rmag ) g1 = 0.0_wp g2 = 0.0_wp g3 = 0.0_wp g4 = 0.0_wp do n = 0 , nmax n_a = n + 1 g1temp = 0.0_wp g2temp = 0.0_wp g3temp = 0.0_wp g4temp = 0.0_wp sm = 0.5_wp if ( n > mmax ) then nmodel = mmax else nmodel = n end if do m = 0 , nmodel if ( n >= 2 ) then m_a = m + 1 m_ri = m + 2 dnm = cnm ( n , m ) * rm ( m_ri ) + snm ( n , m ) * im ( m_ri ) enm = cnm ( n , m ) * rm ( m_ri - 1 ) + snm ( n , m ) * im ( m_ri - 1 ) fnm = snm ( n , m ) * rm ( m_ri - 1 ) - cnm ( n , m ) * im ( m_ri - 1 ) alpha = sqrt ( sm * ( n - m ) * ( n + m + 1 )) g1temp = g1temp + anm ( n_a , m_a ) * ( m ) * enm g2temp = g2temp + anm ( n_a , m_a ) * ( m ) * fnm g3temp = g3temp + alpha * anm ( n_a , m_a + 1 ) * dnm g4temp = g4temp + (( n + m + 1 ) * anm ( n_a , m_a ) + alpha * u * anm ( n_a , m_a + 1 )) * dnm if ( m == 0 ) sm = 1.0_wp end if end do rho = rhop * rho g1 = g1 + rho * g1temp g2 = g2 + rho * g2temp g3 = g3 + rho * g3temp g4 = g4 + rho * g4temp end do ! include central body term here: accel = ( - mu / rmag ** 3 * r_f ) + [ g1 - g4 * s , g2 - g4 * t , g3 - g4 * u ] end function pinesnorm","tags":"","url":"proc/pinesnorm.html"},{"title":"destroy_geopotential_model – fortran-astrodynamics-toolkit","text":"private  subroutine destroy_geopotential_model(me) Destroy a gravity model. Type Bound geopotential_model Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me Called by proc~~destroy_geopotential_model~~CalledByGraph proc~destroy_geopotential_model geopotential_model%destroy_geopotential_model proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->proc~destroy_geopotential_model proc~read_geopotential_file geopotential_model%read_geopotential_file proc~geopotential_module_test->proc~read_geopotential_file proc~read_geopotential_file->proc~destroy_geopotential_model Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_geopotential_model ( me ) implicit none class ( geopotential_model ), intent ( inout ) :: me !common to all: if ( allocated ( me % name )) deallocate ( me % name ) if ( allocated ( me % filename )) deallocate ( me % filename ) me % nmax = 0 me % mmax = 0 me % re = zero me % mu = zero select type ( me ) class is ( geopotential_model_vector_coeff ) if ( allocated ( me % c )) deallocate ( me % c ) if ( allocated ( me % s )) deallocate ( me % s ) class is ( geopotential_model_matrix_coeff ) if ( allocated ( me % cnm )) deallocate ( me % cnm ) if ( allocated ( me % snm )) deallocate ( me % snm ) end select end subroutine destroy_geopotential_model","tags":"","url":"proc/destroy_geopotential_model.html"},{"title":"compute_gravity_acceleration_mueller – fortran-astrodynamics-toolkit","text":"private  subroutine compute_gravity_acceleration_mueller(me, r, n, m, a) Wrapper for Mueller method. Type Bound geopotential_model_mueller Arguments Type Intent Optional Attributes Name class( geopotential_model_mueller ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Calls proc~~compute_gravity_acceleration_mueller~~CallsGraph proc~compute_gravity_acceleration_mueller geopotential_model_mueller%compute_gravity_acceleration_mueller proc~geopot geopot proc~compute_gravity_acceleration_mueller->proc~geopot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_gravity_acceleration_mueller~~CalledByGraph proc~compute_gravity_acceleration_mueller geopotential_model_mueller%compute_gravity_acceleration_mueller proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->proc~compute_gravity_acceleration_mueller Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_gravity_acceleration_mueller ( me , r , n , m , a ) implicit none class ( geopotential_model_mueller ), intent ( inout ) :: me real ( wp ), dimension ( 3 ), intent ( in ) :: r integer , intent ( in ) :: n integer , intent ( in ) :: m real ( wp ), dimension ( 3 ), intent ( out ) :: a call geopot ( r ( 1 ), r ( 2 ), r ( 3 ), n , m + 1 , me % re , me % mu , me % c , me % s , a ( 1 ), a ( 2 ), a ( 3 )) end subroutine compute_gravity_acceleration_mueller","tags":"","url":"proc/compute_gravity_acceleration_mueller.html"},{"title":"compute_gravity_acceleration_pines – fortran-astrodynamics-toolkit","text":"private  subroutine compute_gravity_acceleration_pines(me, r, n, m, a) Wrapper for Pines method. Type Bound geopotential_model_pines Arguments Type Intent Optional Attributes Name class( geopotential_model_pines ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Calls proc~~compute_gravity_acceleration_pines~~CallsGraph proc~compute_gravity_acceleration_pines geopotential_model_pines%compute_gravity_acceleration_pines proc~gravpot gravpot proc~compute_gravity_acceleration_pines->proc~gravpot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_gravity_acceleration_pines ( me , r , n , m , a ) implicit none class ( geopotential_model_pines ), intent ( inout ) :: me real ( wp ), dimension ( 3 ), intent ( in ) :: r integer , intent ( in ) :: n integer , intent ( in ) :: m real ( wp ), dimension ( 3 ), intent ( out ) :: a call gravpot ( r , n , me % re , me % mu , me % cnm , me % snm , a ) end subroutine compute_gravity_acceleration_pines","tags":"","url":"proc/compute_gravity_acceleration_pines.html"},{"title":"compute_gravity_acceleration_lear – fortran-astrodynamics-toolkit","text":"private  subroutine compute_gravity_acceleration_lear(me, r, n, m, a) Wrapper for Lear method. Type Bound geopotential_model_lear Arguments Type Intent Optional Attributes Name class( geopotential_model_lear ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Calls proc~~compute_gravity_acceleration_lear~~CallsGraph proc~compute_gravity_acceleration_lear geopotential_model_lear%compute_gravity_acceleration_lear proc~grav grav proc~compute_gravity_acceleration_lear->proc~grav Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_gravity_acceleration_lear ( me , r , n , m , a ) implicit none class ( geopotential_model_lear ), intent ( inout ) :: me real ( wp ), dimension ( 3 ), intent ( in ) :: r integer , intent ( in ) :: n integer , intent ( in ) :: m real ( wp ), dimension ( 3 ), intent ( out ) :: a call grav ( me % mu , r , me % re , n , m , me % cnm , me % snm , a ) end subroutine compute_gravity_acceleration_lear","tags":"","url":"proc/compute_gravity_acceleration_lear.html"},{"title":"compute_gravity_acceleration_kuga_carrara – fortran-astrodynamics-toolkit","text":"private  subroutine compute_gravity_acceleration_kuga_carrara(me, r, n, m, a) Wrapper for Kuga/Carrara method. Type Bound geopotential_model_kuga_carrara Arguments Type Intent Optional Attributes Name class( geopotential_model_kuga_carrara ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Calls proc~~compute_gravity_acceleration_kuga_carrara~~CallsGraph proc~compute_gravity_acceleration_kuga_carrara geopotential_model_kuga_carrara%compute_gravity_acceleration_kuga_carrara proc~kuga_carrara_geopotential kuga_carrara_geopotential proc~compute_gravity_acceleration_kuga_carrara->proc~kuga_carrara_geopotential Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_gravity_acceleration_kuga_carrara ( me , r , n , m , a ) implicit none class ( geopotential_model_kuga_carrara ), intent ( inout ) :: me real ( wp ), dimension ( 3 ), intent ( in ) :: r integer , intent ( in ) :: n integer , intent ( in ) :: m real ( wp ), dimension ( 3 ), intent ( out ) :: a call kuga_carrara_geopotential ( me % nmax , n , me % re , me % mu , me % cnm , me % snm , r , a ) end subroutine compute_gravity_acceleration_kuga_carrara","tags":"","url":"proc/compute_gravity_acceleration_kuga_carrara.html"},{"title":"compute_gravity_acceleration_normalized_pines – fortran-astrodynamics-toolkit","text":"private  subroutine compute_gravity_acceleration_normalized_pines(me, r, n, m, a) Wrapper for normalized Pines method. Type Bound geopotential_model_normalized_pines Arguments Type Intent Optional Attributes Name class( geopotential_model_normalized_pines ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Calls proc~~compute_gravity_acceleration_normalized_pines~~CallsGraph proc~compute_gravity_acceleration_normalized_pines geopotential_model_normalized_pines%compute_gravity_acceleration_normalized_pines proc~pinesnorm pinesnorm proc~compute_gravity_acceleration_normalized_pines->proc~pinesnorm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_gravity_acceleration_normalized_pines ( me , r , n , m , a ) implicit none class ( geopotential_model_normalized_pines ), intent ( inout ) :: me real ( wp ), dimension ( 3 ), intent ( in ) :: r integer , intent ( in ) :: n integer , intent ( in ) :: m real ( wp ), dimension ( 3 ), intent ( out ) :: a a = pinesnorm ( me % mu , me % re , r , me % cnm , me % snm , n , m ) end subroutine compute_gravity_acceleration_normalized_pines","tags":"","url":"proc/compute_gravity_acceleration_normalized_pines.html"},{"title":"read_geopotential_file – fortran-astrodynamics-toolkit","text":"private  subroutine read_geopotential_file(me, filename, nmax, mmax, status_ok) Read the gravity coefficient file.\nExample file: ftp://ftp.csr.utexas.edu/pub/grav/EGM96.GEO.Z Type Bound geopotential_model Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me character(len=*), intent(in) :: filename integer, intent(in) :: nmax integer, intent(in) :: mmax logical, intent(out) :: status_ok Calls proc~~read_geopotential_file~~CallsGraph proc~read_geopotential_file geopotential_model%read_geopotential_file c c proc~read_geopotential_file->c cnm cnm proc~read_geopotential_file->cnm proc~convert convert proc~read_geopotential_file->proc~convert proc~destroy_geopotential_model geopotential_model%destroy_geopotential_model proc~read_geopotential_file->proc~destroy_geopotential_model proc~fl FL proc~read_geopotential_file->proc~fl proc~get_format_statement get_format_statement proc~read_geopotential_file->proc~get_format_statement proc~number_of_coefficients number_of_coefficients proc~read_geopotential_file->proc~number_of_coefficients s s proc~read_geopotential_file->s snm snm proc~read_geopotential_file->snm proc~convert->proc~fl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~read_geopotential_file~~CalledByGraph proc~read_geopotential_file geopotential_model%read_geopotential_file proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->proc~read_geopotential_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine read_geopotential_file ( me , filename , nmax , mmax , status_ok ) implicit none class ( geopotential_model ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: nmax integer , intent ( in ) :: mmax logical , intent ( out ) :: status_ok character ( len = 100 ) :: c1 , c2 , fmt ! for reading the format statements integer :: iunit , istat , i1 , i2 , nc , i , ii , n , m real ( wp ) :: d1 , d2 , d3 , d4 , f1 , t1 , t2 call me % destroy () if ( nmax > 0 . and . mmax > 0 . and . mmax <= nmax ) then status_ok = . true . nc = number_of_coefficients ( nmax , mmax ) me % nmax = nmax me % mmax = mmax me % filename = trim ( filename ) open ( newunit = iunit , file = me % filename , status = 'OLD' , iostat = istat ) if ( istat == 0 ) then !size the coefficient arrays: select type ( me ) class is ( geopotential_model_vector_coeff ) allocate ( me % c ( nc )) !they are stored compressed into arrays allocate ( me % s ( nc )) ! me % c = zero me % s = zero class is ( geopotential_model_matrix_coeff ) !Note: will get all the nmax x nmax coefficients, even if mmax < nmax allocate ( me % cnm ( nmax , 0 : nmax )) !probably could replace with 2:nmax allocate ( me % snm ( nmax , 0 : nmax )) me % cnm = zero me % snm = zero class default write ( * , * ) 'ERROR: INVALID geopotential_model CLASS!' status_ok = . false . return end select !Read the file: ! (2A10,2E20.10)                                               J2-DOT = -26x10-12 !EGM 96                  398600.44150E+09          6378136.30 ! (A6,2I3,2D19.12,2D13.6,F4.0) !RECOEF  2  0-0.484165371736E-03 0.000000000000E+00 0.356106E-10 0.000000E+00 -1. !HONKCR  2  0-0.484169544736E-03 0.000000000000E+00 0.356106E-10 0.000000E+00 -1. !IERS    2  1-0.186987640000E-09 0.119528010000E-08 0.100000E-29 0.100000E-29 -1. !RECOEF  2  2 0.243914352398E-05-0.140016683654E-05 0.537392E-10 0.543533E-10 -1. !RECOEF  3  0 0.957254173792E-06 0.000000000000E+00 0.180942E-10 0.000000E+00 -1. !RECOEF  3  1 0.202998882184E-05 0.248513158716E-06 0.139652E-09 0.136459E-09 -1. read ( iunit , '(A)' , iostat = istat ) c1 !this is the FMT statement for the next line call get_format_statement ( c1 , fmt ) ! read ( iunit , trim ( fmt ), iostat = istat ) c1 , c2 , d1 , d2 me % name = trim ( c1 ) // trim ( c2 ) me % mu = d1 / 100 0.0_wp ** 3 !km3/s2 me % re = d2 / 100 0.0_wp !km read ( iunit , '(A)' , iostat = istat ) c1 !this is the FMT statement for the next lines call get_format_statement ( c1 , fmt ) ! do i = 1 , nc !...until end of file or all the coefficients have been read... read ( iunit , trim ( fmt ), iostat = istat ) c1 , i1 , i2 , d1 , d2 , d3 , d4 , f1 if ( istat > 0 ) then write ( * , * ) 'Error reading file:' // trim ( filename ) call me % destroy () status_ok = . false . exit else if ( istat < 0 ) then ! end of file: if ( i > nc ) then write ( * , * ) 'Error: not enough coefficients in file.' call me % destroy () status_ok = . false . exit end if end if select type ( me ) class is ( geopotential_model_vector_coeff ) me % c ( i ) = d1 me % s ( i ) = d2 class is ( geopotential_model_matrix_coeff ) me % cnm ( i1 , i2 ) = d1 me % snm ( i1 , i2 ) = d2 end select end do close ( iunit , iostat = istat ) else write ( * , * ) 'Error reading file: ' // trim ( filename ) call me % destroy () status_ok = . false . end if else write ( * , * ) 'Error: invalid n,m values: ' , nmax , mmax call me % destroy () status_ok = . false . end if !unnormalize the coefficients if necessary: if ( status_ok ) then select type ( me ) class is ( geopotential_model_vector_coeff ) !for this one, the coefficients are stored in arrays ii = 0 !counter do n = 2 , me % nmax ! based on Lear's CONVERT routine t1 = 2 * n + 1 ii = ii + 1 me % c ( ii ) = sqrt ( t1 ) * me % c ( ii ) me % s ( ii ) = zero do m = 1 , n ii = ii + 1 t2 = sqrt ( FL ( n - m ) * t1 * two / FL ( n + m )) me % c ( ii ) = t2 * me % c ( ii ) me % s ( ii ) = t2 * me % s ( ii ) end do end do class is ( geopotential_model_matrix_coeff ) !for this one, the coefficients are stored in matrices select type ( me ) class is ( geopotential_model_kuga_carrara ) !this model uses the normalized coefficients return class is ( geopotential_model_normalized_pines ) !this model uses the normalized coefficients return end select call convert ( me % nmax , me % cnm , me % snm ) end select end if end subroutine read_geopotential_file","tags":"","url":"proc/read_geopotential_file.html"},{"title":"get_format_statement – fortran-astrodynamics-toolkit","text":"private  subroutine get_format_statement(str, fmt) Returns the format statement from a line\nin a .GEO gravity coefficient file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(out) :: fmt Called by proc~~get_format_statement~~CalledByGraph proc~get_format_statement get_format_statement proc~read_geopotential_file geopotential_model%read_geopotential_file proc~read_geopotential_file->proc~get_format_statement proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->proc~read_geopotential_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_format_statement ( str , fmt ) implicit none character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( out ) :: fmt integer :: i1 , i2 !note: other text after the format statement is ignored i1 = index ( str , '(' ) i2 = index ( str , ')' ) if ( i1 /= 0 . and . i2 /= 0 . and . i2 > i1 ) then fmt = str ( i1 : i2 ) else write ( * , * ) 'ERROR: THE STRING DOES NOT CONTAIN A FORMAT STATEMENT: ' // trim ( str ) fmt = '' end if end subroutine get_format_statement","tags":"","url":"proc/get_format_statement.html"},{"title":"convert – fortran-astrodynamics-toolkit","text":"private  subroutine convert(nmodel, cnm, snm) Based on the CONVERT subroutine from [1].\n  Unnormalizes the C,S coefficients. References W. M. Lear, \"The Programs TRAJ1 and TRAJ2\",\n     JSC Mission Planning and Analysis Division,\n     JSC-22512, 87-FM-4, April 1987 Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmodel real(kind=wp), intent(inout), dimension(nmodel,0:nmodel) :: cnm real(kind=wp), intent(inout), dimension(nmodel,0:nmodel) :: snm Calls proc~~convert~~CallsGraph proc~convert convert proc~fl FL proc~convert->proc~fl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~convert~~CalledByGraph proc~convert convert proc~read_geopotential_file geopotential_model%read_geopotential_file proc~read_geopotential_file->proc~convert proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->proc~read_geopotential_file Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine convert ( nmodel , cnm , snm ) implicit none integer , intent ( in ) :: nmodel real ( wp ), dimension ( nmodel , 0 : nmodel ), intent ( inout ) :: cnm real ( wp ), dimension ( nmodel , 0 : nmodel ), intent ( inout ) :: snm integer :: n , m real ( wp ) :: t1 , t2 do n = 1 , nmodel !JW : this could be 2,nmodel ... t1 = 2 * n + 1 cnm ( n , 0 ) = sqrt ( t1 ) * cnm ( n , 0 ) do m = 1 , n t2 = sqrt ( FL ( n - m ) * t1 * two / FL ( n + m )) cnm ( n , m ) = t2 * cnm ( n , m ) snm ( n , m ) = t2 * snm ( n , m ) end do end do end subroutine convert","tags":"","url":"proc/convert.html"},{"title":"gravpot – fortran-astrodynamics-toolkit","text":"private  subroutine gravpot(r, nmax, re, mu, c, s, fg) Spencer's implementation of the Pines algorithms from [1] References J.L. Spencer, \"Pines' nonsingular gravitational potential\n     derivation, description, and implementation\",\n     NASA-CR-147478, MDC-W0013, Feb 9, 1976.\n     http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19760011100.pdf Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r position vector integer, intent(in) :: nmax degree/order real(kind=wp), intent(in) :: re body radius real(kind=wp), intent(in) :: mu grav constant real(kind=wp), intent(in), dimension(nmax,0:nmax) :: c C coefficients real(kind=wp), intent(in), dimension(nmax,0:nmax) :: s S coefficients real(kind=wp), intent(out), dimension(3) :: fg grav acceleration Called by proc~~gravpot~~CalledByGraph proc~gravpot gravpot proc~compute_gravity_acceleration_pines geopotential_model_pines%compute_gravity_acceleration_pines proc~compute_gravity_acceleration_pines->proc~gravpot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine gravpot ( r , nmax , re , mu , c , s , fg ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector integer , intent ( in ) :: nmax !! degree/order real ( wp ), intent ( in ) :: re !! body radius real ( wp ), intent ( in ) :: mu !! grav constant real ( wp ), dimension ( nmax , 0 : nmax ), intent ( in ) :: c !! C coefficients real ( wp ), dimension ( nmax , 0 : nmax ), intent ( in ) :: s !! S coefficients real ( wp ), dimension ( 3 ), intent ( out ) :: fg !! grav acceleration !local variables: real ( wp ), dimension ( nmax + 1 ) :: creal , cimag , rho real ( wp ), dimension ( nmax + 1 , nmax + 1 ) :: a , d , e , f integer :: nax0 , i , j , k , l , n , m real ( wp ) :: rinv , ess , t , u , r0 , rhozero , a1 , a2 , a3 , a4 , fac1 , fac2 , fac3 , fac4 real ( wp ) :: ci1 , si1 , temp !JW : not done in original paper, !     but seems to be necessary !     (probably assumed the compiler !      did it automatically) a = zero d = zero e = zero f = zero !get the direction cosines ess, t and u: nax0 = nmax + 1 rinv = one / norm2 ( r ) ess = r ( 1 ) * rinv t = r ( 2 ) * rinv u = r ( 3 ) * rinv !generate the functions creal, cimag, a, d, e, f and rho: r0 = re * rinv rhozero = mu * rinv !JW: typo in original paper (see p.18) rho ( 1 ) = r0 * rhozero creal ( 1 ) = ess cimag ( 1 ) = t d ( 1 , 1 ) = zero e ( 1 , 1 ) = zero f ( 1 , 1 ) = zero a ( 1 , 1 ) = one main_loop : do i = 2 , nax0 if ( i /= nax0 ) then !JW : to prevent access of c,s outside bounds ci1 = c ( i , 1 ) si1 = s ( i , 1 ) else ci1 = zero si1 = zero end if rho ( i ) = r0 * rho ( i - 1 ) creal ( i ) = ess * creal ( i - 1 ) - t * cimag ( i - 1 ) cimag ( i ) = ess * cimag ( i - 1 ) + t * creal ( i - 1 ) d ( i , 1 ) = ess * ci1 + t * si1 e ( i , 1 ) = ci1 f ( i , 1 ) = si1 a ( i , i ) = ( 2 * i - 1 ) * a ( i - 1 , i - 1 ) a ( i , i - 1 ) = u * a ( i , i ) do k = 2 , i if ( i /= nax0 ) then d ( i , k ) = c ( i , k ) * creal ( k ) + s ( i , k ) * cimag ( k ) e ( i , k ) = c ( i , k ) * creal ( k - 1 ) + s ( i , k ) * cimag ( k - 1 ) f ( i , k ) = s ( i , k ) * creal ( k - 1 ) - c ( i , k ) * cimag ( k - 1 ) end if !JW : typo in original paper !  (should be GOTO 1, rather than GOTO 10) if ( i /= 2 ) then L = i - 2 do j = 1 , L a ( i , i - j - 1 ) = ( u * a ( i , i - j ) - a ( i - 1 , i - j )) / ( j + 1 ) end do end if end do end do main_loop !compute auxiliary quantities a1, a2, a3, a4 a1 = zero a2 = zero a3 = zero a4 = rhozero * rinv do n = 2 , nmax fac1 = zero fac2 = zero fac3 = a ( n , 1 ) * c ( n , 0 ) fac4 = a ( n + 1 , 1 ) * c ( n , 0 ) do m = 1 , n temp = m * a ( n , m ) fac1 = fac1 + temp * e ( n , m ) fac2 = fac2 + temp * f ( n , m ) fac3 = fac3 + a ( n , m + 1 ) * d ( n , m ) fac4 = fac4 + a ( n + 1 , m + 1 ) * d ( n , m ) end do temp = rinv * rho ( n ) a1 = a1 + temp * fac1 a2 = a2 + temp * fac2 a3 = a3 + temp * fac3 a4 = a4 + temp * fac4 end do fg ( 1 ) = a1 - ess * a4 fg ( 2 ) = a2 - t * a4 fg ( 3 ) = a3 - u * a4 end subroutine gravpot","tags":"","url":"proc/gravpot.html"},{"title":"geopot – fortran-astrodynamics-toolkit","text":"private  subroutine geopot(x, y, z, nmax, mmax, re, ksq, c, s, fx, fy, fz) Compute the gravitational acceleration vector using the Mueller method. References Alan C. Mueller, \"A Fast Recursive Algorithm for Calculating the\n     Forces due to the Geopotential (Program GEOPOT)\",\n     JSC Internal Note 75-FM-42, June 9, 1975. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x position vector x-component real(kind=wp), intent(in) :: y position vector y-component real(kind=wp), intent(in) :: z position vector z-component integer, intent(in) :: nmax degree of model integer, intent(in) :: mmax order+1 of model real(kind=wp), intent(in) :: re body radius real(kind=wp), intent(in) :: ksq body GM real(kind=wp), intent(in), dimension(:) :: c C coefficients real(kind=wp), intent(in), dimension(:) :: s S coefficients real(kind=wp), intent(out) :: fx gravitational acceleration x-component real(kind=wp), intent(out) :: fy gravitational acceleration y-component real(kind=wp), intent(out) :: fz gravitational acceleration z-component Called by proc~~geopot~~CalledByGraph proc~geopot geopot proc~compute_gravity_acceleration_mueller geopotential_model_mueller%compute_gravity_acceleration_mueller proc~compute_gravity_acceleration_mueller->proc~geopot proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->proc~compute_gravity_acceleration_mueller Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine geopot ( x , y , z , nmax , mmax , re , ksq , c , s , fx , fy , fz ) implicit none !subroutine arguments: real ( wp ), intent ( in ) :: x !! position vector x-component real ( wp ), intent ( in ) :: y !! position vector y-component real ( wp ), intent ( in ) :: z !! position vector z-component integer , intent ( in ) :: nmax !! degree of model integer , intent ( in ) :: mmax !! order+1 of model real ( wp ), intent ( in ) :: re !! body radius real ( wp ), intent ( in ) :: ksq !! body GM real ( wp ), dimension (:), intent ( in ) :: c !! C coefficients real ( wp ), dimension (:), intent ( in ) :: s !! S coefficients real ( wp ), intent ( out ) :: fx !! gravitational acceleration x-component real ( wp ), intent ( out ) :: fy !! gravitational acceleration y-component real ( wp ), intent ( out ) :: fz !! gravitational acceleration z-component !local variables: real ( wp ) :: r , ri , reor , reorn , ksqor2 , xor , yor , zor , rdedx , rdedy , rdedz ,& sum1 , sum2 , sum3 , sum4 , temp1 , temp2 , temp3 , temp4 , fact , dcstld , temp integer :: i , j , k , im1 , l , jm1 , jp1 , kk real ( wp ), dimension ( 0 : mmax ) :: p0 , p1 , p2 , ctil , stil !write(*,'(A,1x,*(e20.5,1x/))') 'c=',c !write(*,'(A,1x,*(e20.5,1x/))') 's=',s !abbreviations: r = sqrt ( x * x + y * y + z * z ) ri = one / r reor = re * ri reorn = reor ksqor2 = ksq * ri * ri zor = z * ri xor = x * ri yor = y * ri !the derivatives of the argument of the legendre polynomial - zor rdedz = zor * zor - one rdedx = zor * xor rdedy = zor * yor !initialization: k = 0 do i = 1 , mmax p0 ( i ) = zero p1 ( i ) = zero end do p0 ( 0 ) = one p1 ( 0 ) = zor p1 ( 1 ) = one ctil ( 0 ) = one stil ( 0 ) = zero ctil ( 1 ) = xor stil ( 1 ) = yor sum1 = zero !sum2   = zero       !original sum2 = one !JW : include central body term sum3 = zero sum4 = zero !computation of forces: do i = 2 , nmax reorn = reorn * reor fact = 2 * i - 1 im1 = i - 1 l = 1 !recursion formulas for legendre polynomial - p2(0) p2 ( 0 ) = ( fact * zor * p1 ( 0 ) - im1 * p0 ( 0 )) / i k = k + 1 p2 ( 1 ) = p0 ( 1 ) + fact * p1 ( 0 ) temp1 = p2 ( 1 ) * c ( k ) temp2 = p2 ( 0 ) * c ( k ) * ( i + 1 ) if ( i < mmax ) then !recursive formulas for: !    'ctilda' - ctil !    'stilda' - stil ctil ( i ) = ctil ( 1 ) * ctil ( im1 ) - stil ( 1 ) * stil ( im1 ) stil ( i ) = stil ( 1 ) * ctil ( im1 ) + ctil ( 1 ) * stil ( im1 ) temp3 = zero temp4 = zero do j = 1 , i jm1 = j - 1 jp1 = j + 1 !recursive formula for derivative of legendre polynomial - p2(j) p2 ( jp1 ) = p0 ( jp1 ) + fact * p1 ( j ) kk = k + j dcstld = j * p2 ( j ) temp = ( c ( kk ) * ctil ( j ) + s ( kk ) * stil ( j )) temp1 = temp1 + p2 ( jp1 ) * temp temp2 = temp2 + ( i + jp1 ) * p2 ( j ) * temp temp3 = temp3 + dcstld * ( c ( kk ) * ctil ( jm1 ) + s ( kk ) * stil ( jm1 )) temp4 = temp4 - dcstld * ( c ( kk ) * stil ( jm1 ) - s ( kk ) * ctil ( jm1 )) end do l = i sum3 = sum3 + reorn * temp3 sum4 = sum4 + reorn * temp4 end if sum1 = sum1 + reorn * temp1 sum2 = sum2 + reorn * temp2 k = k + i !shift indices: do j = 0 , l p0 ( j ) = p1 ( j ) p1 ( j ) = p2 ( j ) end do end do fx = - ksqor2 * ( sum1 * rdedx + sum2 * xor - sum3 ) fy = - ksqor2 * ( sum1 * rdedy + sum2 * yor - sum4 ) fz = - ksqor2 * ( sum1 * rdedz + sum2 * zor ) end subroutine geopot","tags":"","url":"proc/geopot.html"},{"title":"grav – fortran-astrodynamics-toolkit","text":"private  subroutine grav(mu, rgr, rbar, nmodel, mmodel, cnm, snm, agr) Based on the GRAV subroutine from [1]. References W. M. Lear, \"The Programs TRAJ1 and TRAJ2\",\n     JSC Internal Note 87-FM-4, April 1987. W. M. Lear, \"The Gravitational Acceleration Equations\",\n     JSC Internal Note 86-FM-15, April 1986. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational constant real(kind=wp), intent(in), dimension(3) :: rgr position vector [body-fixed coordinates] real(kind=wp), intent(in) :: rbar gravitational scaling radius (generally the equatorial radius) integer, intent(in) :: nmodel the degree of the gravity model (>=2) integer, intent(in) :: mmodel the order of the gravity model (>=0, <=nmodel) real(kind=wp), intent(in), dimension(nmodel,0:nmodel) :: cnm C gravity coefficients real(kind=wp), intent(in), dimension(nmodel,0:nmodel) :: snm S gravity coefficients real(kind=wp), intent(out), dimension(3) :: agr gravitational acceleration vector [body-fixed coordinates] Called by proc~~grav~~CalledByGraph proc~grav grav proc~compute_gravity_acceleration_lear geopotential_model_lear%compute_gravity_acceleration_lear proc~compute_gravity_acceleration_lear->proc~grav Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine grav ( mu , rgr , rbar , nmodel , mmodel , cnm , snm , agr ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: rgr !! position vector [body-fixed coordinates] real ( wp ), intent ( in ) :: mu !! gravitational constant real ( wp ), intent ( in ) :: rbar !! gravitational scaling radius (generally the equatorial radius) integer , intent ( in ) :: nmodel !! the degree of the gravity model (>=2) integer , intent ( in ) :: mmodel !! the order of the gravity model (>=0, <=nmodel) real ( wp ), dimension ( nmodel , 0 : nmodel ), intent ( in ) :: cnm !! C gravity coefficients real ( wp ), dimension ( nmodel , 0 : nmodel ), intent ( in ) :: snm !! S gravity coefficients real ( wp ), dimension ( 3 ), intent ( out ) :: agr !! gravitational acceleration vector [body-fixed coordinates] !local variables: real ( wp ), dimension ( nmodel , nmodel ) :: pnm , ppnm real ( wp ), dimension ( nmodel ) :: cm , sm , pn , rb , ppn real ( wp ), dimension ( 3 ) :: asph real ( wp ) :: e1 , e2 , e3 , e4 , e5 , r1 , r2 , t1 , t3 , absr , sphi , cphi , tcm , tsm , tsnm , tcnm , tpnm integer :: n , nm1 , nm2 , m do n = 2 , nmodel pnm ( n - 1 , n ) = zero end do e1 = rgr ( 1 ) ** 2 + rgr ( 2 ) ** 2 r2 = e1 + rgr ( 3 ) ** 2 absr = sqrt ( r2 ) r1 = sqrt ( e1 ) sphi = rgr ( 3 ) / absr cphi = r1 / absr if ( r1 == zero ) then sm ( 1 ) = zero cm ( 1 ) = one else sm ( 1 ) = rgr ( 2 ) / r1 cm ( 1 ) = rgr ( 1 ) / r1 end if rb ( 1 ) = rbar / absr rb ( 2 ) = rb ( 1 ) ** 2 sm ( 2 ) = two * cm ( 1 ) * sm ( 1 ) cm ( 2 ) = two * cm ( 1 ) ** 2 - one pn ( 1 ) = sphi pn ( 2 ) = ( three * sphi ** 2 - one ) / two ppn ( 1 ) = one ppn ( 2 ) = three * sphi pnm ( 1 , 1 ) = one pnm ( 2 , 2 ) = three * cphi pnm ( 2 , 1 ) = ppn ( 2 ) ppnm ( 1 , 1 ) = - sphi ppnm ( 2 , 2 ) = - six * sphi * cphi ppnm ( 2 , 1 ) = three - six * sphi ** 2 if ( nmodel >= 3 ) then do n = 3 , nmodel nm1 = n - 1 nm2 = n - 2 rb ( n ) = rb ( nm1 ) * rb ( 1 ) sm ( n ) = two * cm ( 1 ) * sm ( nm1 ) - sm ( nm2 ) cm ( n ) = two * cm ( 1 ) * cm ( nm1 ) - cm ( nm2 ) e1 = 2 * n - 1 pn ( n ) = ( e1 * sphi * pn ( nm1 ) - nm1 * pn ( nm2 )) / n ppn ( n ) = sphi * ppn ( nm1 ) + n * pn ( nm1 ) pnm ( n , n ) = e1 * cphi * pnm ( nm1 , nm1 ) ppnm ( n , n ) = - n * sphi * pnm ( n , n ) end do do n = 3 , nmodel nm1 = n - 1 e1 = ( 2 * n - 1 ) * sphi e2 = - n * sphi do m = 1 , nm1 e3 = pnm ( nm1 , m ) e4 = n + m e5 = ( e1 * e3 - ( e4 - one ) * pnm ( n - 2 , m )) / ( n - m ) pnm ( n , m ) = e5 ppnm ( n , m ) = e2 * e5 + e4 * e3 end do end do end if asph ( 1 ) = - one ![NOTE: set to zero to only output the harmonic terms] asph ( 3 ) = zero do n = 2 , nmodel e1 = cnm ( n , 0 ) * rb ( n ) asph ( 1 ) = asph ( 1 ) - ( n + 1 ) * e1 * pn ( n ) asph ( 3 ) = asph ( 3 ) + e1 * ppn ( n ) end do asph ( 3 ) = cphi * asph ( 3 ) t1 = zero t3 = zero asph ( 2 ) = zero do n = 2 , nmodel e1 = zero e2 = zero e3 = zero !do m = 1, n                !original do m = 1 , min ( n , mmodel ) !JW - allow for specifying order !!!!!! tsnm = snm ( n , m ) tcnm = cnm ( n , m ) tsm = sm ( m ) tcm = cm ( m ) tpnm = pnm ( n , m ) e4 = tsnm * tsm + tcnm * tcm e1 = e1 + e4 * tpnm e2 = e2 + m * ( tsnm * tcm - tcnm * tsm ) * tpnm e3 = e3 + e4 * ppnm ( n , m ) end do t1 = t1 + ( n + 1 ) * rb ( n ) * e1 asph ( 2 ) = asph ( 2 ) + rb ( n ) * e2 t3 = t3 + rb ( n ) * e3 end do e4 = mu / r2 asph ( 1 ) = e4 * ( asph ( 1 ) - cphi * t1 ) asph ( 2 ) = e4 * asph ( 2 ) asph ( 3 ) = e4 * ( asph ( 3 ) + t3 ) e5 = asph ( 1 ) * cphi - asph ( 3 ) * sphi agr ( 1 ) = e5 * cm ( 1 ) - asph ( 2 ) * sm ( 1 ) agr ( 2 ) = e5 * sm ( 1 ) + asph ( 2 ) * cm ( 1 ) agr ( 3 ) = asph ( 1 ) * sphi + asph ( 3 ) * cphi end subroutine grav","tags":"","url":"proc/grav.html"},{"title":"kuga_carrara_geopotential – fortran-astrodynamics-toolkit","text":"private  subroutine kuga_carrara_geopotential(nmax, nm, re, gm, c, s, x, ac) Compute geopotential acceleration using the Kuga/Carrara algorithm.\n  Based on Leg_ForCol_Ac from [1]. References Kuga, H.K. & Carrara, V. Fortran- and C-codes for higher order and degree geopotential computation Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmax max. order and degree loaded integer, intent(in) :: nm desired order and degree (nm <= nmax) real(kind=wp), intent(in) :: re body equatorial radius [km] real(kind=wp), intent(in) :: gm gravitational constant [km3/s2] real(kind=wp), intent(in), dimension(nmax,0:nm) :: c c coefficients (Normalized) real(kind=wp), intent(in), dimension(nmax,0:nm) :: s s coefficients (Normalized) real(kind=wp), intent(in), dimension(3) :: x body-fixed cartesian position vector [km] real(kind=wp), intent(out), dimension(3) :: ac body-fixed cartesian acceleration vector [km/s2] Called by proc~~kuga_carrara_geopotential~~CalledByGraph proc~kuga_carrara_geopotential kuga_carrara_geopotential proc~compute_gravity_acceleration_kuga_carrara geopotential_model_kuga_carrara%compute_gravity_acceleration_kuga_carrara proc~compute_gravity_acceleration_kuga_carrara->proc~kuga_carrara_geopotential Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine kuga_carrara_geopotential ( nmax , nm , re , gm , c , s , x , ac ) implicit none integer , intent ( in ) :: nmax !! max. order and degree loaded integer , intent ( in ) :: nm !! desired order and degree (nm <= nmax) real ( wp ), intent ( in ) :: re !! body equatorial radius [km] real ( wp ), intent ( in ) :: gm !! gravitational constant [km3/s2] real ( wp ), dimension ( nmax , 0 : nm ), intent ( in ) :: c !! c coefficients (Normalized) real ( wp ), dimension ( nmax , 0 : nm ), intent ( in ) :: s !! s coefficients (Normalized) real ( wp ), dimension ( 3 ), intent ( in ) :: x !! body-fixed cartesian position vector [km] real ( wp ), dimension ( 3 ), intent ( out ) :: ac !! body-fixed cartesian acceleration vector [km/s2] integer :: n , m real ( wp ), dimension ( 0 : nm ) :: pn , qn real ( wp ) :: r , q , t , u2 , u , um , tf , al , sl , cl , gmr real ( wp ) :: pnm , dpnm , anm , bnm , fnm , cmm , smm real ( wp ) :: am , an , pnn , pnm1m , pnm2m , sm , cm , sml , cml real ( wp ) :: qc , qs , xc , xs , xcf , xsf , xcr , xsr , vl , vf , vr real ( wp ), parameter :: sqrt3 = sqrt ( 3.0_wp ) ! auxiliary variables r = norm2 ( x ) q = re / r t = x ( 3 ) / r ! sin (lat) u = sqrt ( 1.0_wp - t * t ) tf = t / u ! tan (lat) al = atan2 ( x ( 2 ), x ( 1 )) sl = sin ( al ) ! sin (long) cl = cos ( al ) ! cos (long) gmr = gm / r ! initialize vl = 0.0_wp vf = 0.0_wp vr = 0.0_wp ! store sectoral pn ( 0 ) = 1.0_wp pn ( 1 ) = sqrt3 * u ! sqrt(3) * cos (lat) qn ( 0 ) = 1.0_wp qn ( 1 ) = q do m = 2 , nm am = real ( m , wp ) pn ( m ) = u * sqrt ( 1.0_wp + 0.5_wp / am ) * pn ( m - 1 ) qn ( m ) = q * qn ( m - 1 ) end do ! initialize sin and cos recursions sm = 0.0_wp cm = 1.0_wp ! outer loop do m = 0 , nm ! init am = real ( m , wp ) ! for m = n (sectoral) pnm = pn ( m ) dpnm = - am * pnm * tf pnm1m = pnm pnm2m = 0.0_wp ! initialize Horner's scheme if ( m < 2 ) then cmm = 0.0_wp smm = 0.0_wp else cmm = c ( m , m ) smm = s ( m , m ) end if qc = qn ( m ) * cmm qs = qn ( m ) * smm xc = qc * pnm xs = qs * pnm xcf = qc * dpnm xsf = qs * dpnm xcr = ( am + 1.0_wp ) * qc * pnm xsr = ( am + 1.0_wp ) * qs * pnm ! inner loop do n = m + 1 , nm an = real ( n , wp ) anm = sqrt ((( an + an - 1.0_wp ) * ( an + an + 1.0_wp )) / (( an - am ) * ( an + am ))) bnm = sqrt ((( an + an + 1.0_wp ) * ( an + am - 1.0_wp ) * ( an - am - 1.0_wp )) / (( an - am ) * ( an + am ) * ( an + an - 3.0_wp ))) fnm = sqrt ((( an * an - am * am ) * ( an + an + 1.0_wp )) / ( an + an - 1.0_wp )) ! recursion p and dp pnm = anm * t * pnm1m - bnm * pnm2m dpnm = - an * pnm * tf + fnm * pnm1m / u ! signal opposite to paper ! store pnm2m = pnm1m pnm1m = pnm ! inner sum if ( n >= 2 ) then qc = qn ( n ) * c ( n , m ) qs = qn ( n ) * s ( n , m ) xc = xc + qc * pnm xs = xs + qs * pnm xcf = xcf + qc * dpnm xsf = xsf + qs * dpnm xcr = xcr + ( an + 1.0_wp ) * qc * pnm xsr = xsr + ( an + 1.0_wp ) * qs * pnm end if end do ! outer sum vl = vl + am * ( xc * sm - xs * cm ) vf = vf + ( xcf * cm + xsf * sm ) vr = vr + ( xcr * cm + xsr * sm ) ! sin and cos recursions for next m cml = cl * cm - sm * sl sml = cl * sm + cm * sl cm = cml ! save for next m sm = sml ! save for next m end do ! gradient vl = - gmr * vl vf = gmr * vf vr = - ( gmr / r ) * ( 1.0_wp + vr ) ! body x, y, z accelerations ac ( 1 ) = u * cl * vr - t * cl * vf / r - sl * vl / ( u * r ) ac ( 2 ) = u * sl * vr - t * sl * vf / r + cl * vl / ( u * r ) ac ( 3 ) = t * vr + u * vf / r end subroutine kuga_carrara_geopotential","tags":"","url":"proc/kuga_carrara_geopotential.html"},{"title":"geopotential_module_test – fortran-astrodynamics-toolkit","text":"public  subroutine geopotential_module_test() Uses conversion_module random_module vector_module proc~~geopotential_module_test~~UsesGraph proc~geopotential_module_test geopotential_module_test module~conversion_module conversion_module proc~geopotential_module_test->module~conversion_module module~random_module random_module proc~geopotential_module_test->module~random_module module~vector_module vector_module proc~geopotential_module_test->module~vector_module module~kind_module kind_module module~conversion_module->module~kind_module module~numbers_module numbers_module module~conversion_module->module~numbers_module module~random_module->module~kind_module module~vector_module->module~kind_module module~vector_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Unit test routine for geopotential_module Arguments None Calls proc~~geopotential_module_test~~CallsGraph proc~geopotential_module_test geopotential_module_test proc~compute_gravity_acceleration_mueller geopotential_model_mueller%compute_gravity_acceleration_mueller proc~geopotential_module_test->proc~compute_gravity_acceleration_mueller proc~destroy_geopotential_model geopotential_model%destroy_geopotential_model proc~geopotential_module_test->proc~destroy_geopotential_model proc~get_random_number get_random_number proc~geopotential_module_test->proc~get_random_number proc~number_of_coefficients number_of_coefficients proc~geopotential_module_test->proc~number_of_coefficients proc~read_geopotential_file geopotential_model%read_geopotential_file proc~geopotential_module_test->proc~read_geopotential_file proc~spherical_to_cartesian spherical_to_cartesian proc~geopotential_module_test->proc~spherical_to_cartesian proc~geopot geopot proc~compute_gravity_acceleration_mueller->proc~geopot proc~read_geopotential_file->proc~destroy_geopotential_model proc~read_geopotential_file->proc~number_of_coefficients c c proc~read_geopotential_file->c cnm cnm proc~read_geopotential_file->cnm proc~convert convert proc~read_geopotential_file->proc~convert proc~fl FL proc~read_geopotential_file->proc~fl proc~get_format_statement get_format_statement proc~read_geopotential_file->proc~get_format_statement s s proc~read_geopotential_file->s snm snm proc~read_geopotential_file->snm proc~convert->proc~fl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine geopotential_module_test () use conversion_module use vector_module , only : spherical_to_cartesian use random_module , only : get_random_number implicit none character ( len =* ), parameter :: gravfile = './grav/GGM03C.GEO' !! the coefficient file class ( geopotential_model ), pointer :: g type ( geopotential_model_mueller ) , target :: g_mueller type ( geopotential_model_lear ) , target :: g_lear type ( geopotential_model_pines ) , target :: g_pines type ( geopotential_model_normalized_pines ) , target :: g_normalized_pines type ( geopotential_model_kuga_carrara ), target :: g_kuga_carrara real ( wp ), dimension ( 3 ) :: a1 , a2 , a3 , a4 , a5 , rvec logical :: status_ok integer :: lat , lon , i , j , nmax , mmax real ( wp ) :: h , err1 , err2 , err3 , err4 , rlon , rlat , tmp character ( len = 20 ) :: name real :: tstart , tstop real ( wp ), dimension ( 3 ), parameter :: r = [ 0.1275627320e+05_wp , & 0.1275627320e+05_wp , & 0.1275627320e+05_wp ] !! test case [km] integer , parameter :: n = 9 !! degree integer , parameter :: m = 9 !! order integer , parameter :: n_repeat = 1000000 !! number of time to repeat speed test write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' geopotential_module_test' write ( * , * ) '---------------' write ( * , * ) '' write ( * , * ) '' write ( * , * ) '*** number_of_coefficients routine ***' write ( * , * ) '' !tests: write ( * , * ) '' write ( * , * ) 6 , 6 , number_of_coefficients ( 6 , 6 ) ! 25 write ( * , * ) 3 , 2 , number_of_coefficients ( 3 , 2 ) ! 6 write ( * , * ) 4 , 0 , number_of_coefficients ( 4 , 0 ) ! 8 write ( * , * ) 4 , 1 , number_of_coefficients ( 4 , 1 ) ! 9 write ( * , * ) 0 , 0 , number_of_coefficients ( 0 , 0 ) ! -99 (error) write ( * , * ) '' write ( * , * ) '' write ( * , * ) '*** test case for the four methods ***' write ( * , * ) '' write ( * , * ) '' write ( * , * ) 'reading file: ' // gravfile write ( * , '(A,*(E30.16,1X))' ) 'r =' , r call g_mueller % initialize ( gravfile , n , m , status_ok ) if (. not . status_ok ) stop 'Error' call g_mueller % get_acc ( r , n , m , a1 ) call g_lear % initialize ( gravfile , n , m , status_ok ) if (. not . status_ok ) stop 'Error' call g_lear % get_acc ( r , n , m , a2 ) call g_pines % initialize ( gravfile , n , m , status_ok ) if (. not . status_ok ) stop 'Error' call g_pines % get_acc ( r , n , m , a3 ) call g_kuga_carrara % initialize ( gravfile , n , m , status_ok ) if (. not . status_ok ) stop 'Error' call g_kuga_carrara % get_acc ( r , n , m , a4 ) call g_normalized_pines % initialize ( gravfile , n , m , status_ok ) if (. not . status_ok ) stop 'Error' call g_normalized_pines % get_acc ( r , n , m , a5 ) write ( * , * ) '' write ( * , '(A,*(E30.16,1X))' ) 'mueller      =' , a1 write ( * , '(A,*(E30.16,1X))' ) 'lear         =' , a2 write ( * , '(A,*(E30.16,1X))' ) 'pines        =' , a3 write ( * , '(A,*(E30.16,1X))' ) 'kuga_carrara =' , a4 write ( * , '(A,*(E30.16,1X))' ) 'norm_pines   =' , a3 write ( * , * ) '' write ( * , '(A,*(E30.16,1X))' ) 'mueller-lear difference      =' , norm2 ( a1 - a2 ) write ( * , '(A,*(E30.16,1X))' ) 'mueller-pines difference     =' , norm2 ( a1 - a3 ) write ( * , '(A,*(E30.16,1X))' ) 'mueller-normpines difference =' , norm2 ( a1 - a5 ) write ( * , '(A,*(E30.16,1X))' ) 'lear-pines difference        =' , norm2 ( a2 - a3 ) write ( * , '(A,*(E30.16,1X))' ) 'lear-kuga_carrara difference =' , norm2 ( a2 - a4 ) write ( * , * ) '' write ( * , * ) '' write ( * , * ) '*** accuracy test ***' write ( * , * ) '' h = 677 8.0_wp !radius magnitude status_ok = . true . do lat = - 90 , 90 do lon = 0 , 360 rvec = spherical_to_cartesian ( h , lon * deg2rad , lat * deg2rad ) call g_mueller % get_acc ( rvec , n , m , a1 ) ! mueller call g_lear % get_acc ( rvec , n , m , a2 ) ! lear call g_pines % get_acc ( rvec , n , m , a3 ) ! pines call g_normalized_pines % get_acc ( rvec , n , m , a5 ) ! normalized pines call g_kuga_carrara % get_acc ( rvec , n , m , a4 ) ! kuga/carrara err1 = norm2 ( a2 - a1 ) err2 = norm2 ( a3 - a2 ) err3 = norm2 ( a4 - a1 ) err4 = norm2 ( a5 - a1 ) if ( err2 > 1.0e-15_wp . or . err1 > 1.0e-15_wp . or . err3 > 1.0e-15_wp . or . err4 > 1.0e-15_wp ) then write ( * , * ) lat , lon , norm2 ( a1 ), norm2 ( a2 ), norm2 ( a2 ), norm2 ( a3 ), err1 , err2 , err3 , err4 status_ok = . false . end if if ( abs ( lat ) == 90 ) exit !only do poles once end do end do call g_mueller % destroy () call g_lear % destroy () call g_pines % destroy () call g_normalized_pines % destroy () call g_kuga_carrara % destroy () if ( status_ok ) write ( * , * ) 'All tests passed.' write ( * , * ) '' write ( * , * ) '*** speed test ***' write ( * , * ) '' nmax = 10 mmax = 10 do i = 1 , 5 select case ( i ) case ( 1 ) g => g_mueller name = 'Mueller' case ( 2 ) g => g_lear name = 'Lear' case ( 3 ) g => g_pines name = 'Pines' case ( 4 ) g => g_kuga_carrara name = 'Kuga/Carrara' case ( 5 ) g => g_normalized_pines name = 'Normalized Pines' end select call g % initialize ( gravfile , nmax , mmax , status_ok ) if (. not . status_ok ) stop 'Error' call random_seed () tmp = zero call cpu_time ( tstart ) do j = 1 , n_repeat h = get_random_number ( 677 8.0_wp , 1000 0.0_wp ) rlon = get_random_number ( 0.0_wp , 36 0.0_wp ) rlat = get_random_number ( - 9 0.0_wp , 9 0.0_wp ) rvec = spherical_to_cartesian ( h , rlon * deg2rad , rlat * deg2rad ) call g % get_acc ( rvec , nmax , mmax , a1 ) tmp = tmp + norm2 ( a1 ) end do call cpu_time ( tstop ) call g % destroy () write ( * , '(A10,1X,E30.16,1X,F13.6,1X,A)' ) trim ( name ), tmp , tstop - tstart , 'sec' end do end subroutine geopotential_module_test","tags":"","url":"proc/geopotential_module_test.html"},{"title":"balanc – fortran-astrodynamics-toolkit","text":"private  subroutine balanc(Nm, n, a, Low, Igh, Scale) Balance a real general matrix and isolate eigenvalues\n  whenever possible. This subroutine is a translation of the ALGOL procedure BALANCE,\n  NUM. MATH. 13, 293-304(1969) by Parlett and Reinsch.\n  HANDBOOK FOR AUTO. COMP., Vol.II-LINEAR ALGEBRA, 315-326(1971). This subroutine balances a REAL matrix and isolates\n  eigenvalues whenever possible. On INPUT NM must be set to the row dimension of the two - dimensional array parameter , A , as declared in the calling program dimension statement . NM is an INTEGER variable . N is the order of the matrix A . N is an INTEGER variable . N must be less than or equal to NM . A contains the input matrix to be balanced . A is a two - dimensional REAL array , dimensioned A ( NM , N ) . On OUTPUT A contains the balanced matrix . LOW and IGH are two INTEGER variables such that A ( I , J ) is equal to zero if ( 1 ) I is greater than J and ( 2 ) J = 1 , ... , LOW - 1 or I = IGH + 1 , ... , N . SCALE contains information determining the permutations and scaling factors used . SCALE is a one - dimensional REAL array , dimensioned SCALE ( N ) . Suppose that the principal submatrix in rows LOW through IGH has been balanced , that P ( J ) denotes the index interchanged with J during the permutation step , and that the elements of the diagonal matrix used are denoted by D ( I , J ) . Then SCALE ( J ) = P ( J ), for J = 1 , ... , LOW - 1 = D ( J , J ), J = LOW , ... , IGH = P ( J ) J = IGH + 1 , ... , N . The order in which the interchanges are made is N to IGH + 1 , then 1 TO LOW - 1. Note that 1 is returned for IGH if IGH is zero formally . The ALGOL procedure EXC contained in BALANCE appears in\n  BALANC in line.  (Note that the ALGOL roles of identifiers\n  K,L have been reversed.) Questions and comments should be directed to B. S. Garbow,\n  Applied Mathematics Division, ARGONNE NATIONAL LABORATORY References B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow,\n    Y. Ikebe, V. C. Klema and C. B. Moler, Matrix Eigen-\n    system Routines - EISPACK Guide, Springer-Verlag,\n    1976. Revision history Author: Smith, B. T., et al. 760101  DATE WRITTEN 890831  Modified array declarations.  (WRB) 890831  REVISION DATE from Version 3.2 891214  Prologue converted to Version 4.0 format.  (BAB) 920501  Reformatted the REFERENCES section.  (WRB) Arguments Type Intent Optional Attributes Name integer :: Nm integer :: n real(kind=wp) :: a (Nm,*) integer :: Low integer :: Igh real(kind=wp) :: Scale (*) Called by proc~~balanc~~CalledByGraph proc~balanc balanc proc~rg rg proc~rg->proc~balanc proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors proc~compute_eigenvalues_and_eigenvectors->proc~rg proc~compute_real_eigenvalues_and_normalized_eigenvectors compute_real_eigenvalues_and_normalized_eigenvectors proc~compute_real_eigenvalues_and_normalized_eigenvectors->proc~compute_eigenvalues_and_eigenvectors proc~eispack_test eispack_test proc~eispack_test->proc~compute_eigenvalues_and_eigenvectors Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine balanc ( Nm , n , a , Low , Igh , Scale ) implicit none integer :: i , j , k , l , m , n , jj , Nm , Igh , Low , iexc , igo , igo1 , igo2 real ( wp ) :: a ( Nm , * ), Scale ( * ) real ( wp ) :: c , f , g , r , s , b2 logical :: noconv real ( wp ), parameter :: radix = 1 6.0_wp b2 = radix * radix k = 1 l = n igo = 1 igo1 = 0 igo2 = 1 ! IN-LINE PROCEDURE FOR ROW AND ! COLUMN EXCHANGE do while ( igo2 == 1 ) igo2 = 0 if ( igo1 == 1 ) then Scale ( m ) = j if ( j /= m ) then do i = 1 , l f = a ( i , j ) a ( i , j ) = a ( i , m ) a ( i , m ) = f enddo do i = k , n f = a ( j , i ) a ( j , i ) = a ( m , i ) a ( m , i ) = f enddo endif if ( iexc == 2 ) then ! SEARCH FOR COLUMNS ISOLATING AN EIGENVALUE ! AND PUSH THEM LEFT k = k + 1 igo = 0 else ! SEARCH FOR ROWS ISOLATING AN EIGENVALUE ! AND PUSH THEM DOWN if ( l == 1 ) then Low = k Igh = l return end if l = l - 1 endif end if ! FOR J=L STEP -1 UNTIL 1 DO -- igo1 = 1 if ( igo == 1 ) then do jj = 1 , l igo = 1 j = l + 1 - jj do i = 1 , l if ( i /= j ) then if ( a ( j , i ) /= 0.0_wp ) then igo = 0 exit end if endif enddo if ( igo == 0 ) cycle m = l iexc = 1 igo2 = 1 exit enddo if ( igo2 == 1 ) cycle end if do j = k , l igo = 1 do i = k , l if ( i /= j ) then if ( a ( i , j ) /= 0.0_wp ) then igo = 0 exit end if endif enddo if ( igo == 0 ) cycle m = k iexc = 2 igo2 = 1 exit enddo if ( igo2 == 1 ) cycle end do ! NOW BALANCE THE SUBMATRIX IN ROWS K TO L do i = k , l Scale ( i ) = 1.0_wp enddo ! ITERATIVE LOOP FOR NORM REDUCTION noconv = . true . do while ( noconv ) noconv = . false . do i = k , l c = 0.0_wp r = 0.0_wp do j = k , l if ( j /= i ) then c = c + abs ( a ( j , i )) r = r + abs ( a ( i , j )) endif enddo ! GUARD AGAINST ZERO C OR R DUE TO UNDERFLOW if ( c /= 0.0_wp . and . r /= 0.0_wp ) then g = r / radix f = 1.0_wp s = c + r do while ( c < g ) f = f * radix c = c * b2 end do g = r * radix do while ( c >= g ) f = f / radix c = c / b2 end do ! NOW BALANCE if (( c + r ) / f < 0.95_wp * s ) then g = 1.0_wp / f Scale ( i ) = Scale ( i ) * f noconv = . true . do j = k , n a ( i , j ) = a ( i , j ) * g enddo do j = 1 , l a ( j , i ) = a ( j , i ) * f enddo endif endif enddo end do Low = k Igh = l end subroutine balanc","tags":"","url":"proc/balanc.html"},{"title":"balbak – fortran-astrodynamics-toolkit","text":"private  subroutine balbak(Nm, n, Low, Igh, Scale, m, z) Form the eigenvectors of a real general matrix from the\n  eigenvectors of matrix output from BALANC. This subroutine is a translation of the ALGOL procedure BALBAK,\n  NUM. MATH. 13, 293-304(1969) by Parlett and Reinsch.\n  HANDBOOK FOR AUTO. COMP., Vol.II-LINEAR ALGEBRA, 315-326(1971). This subroutine forms the eigenvectors of a REAL GENERAL\n  matrix by back transforming those of the corresponding\n  balanced matrix determined by  BALANC. On Input NM must be set to the row dimension of the two - dimensional array parameter , Z , as declared in the calling program dimension statement . NM is an INTEGER variable . N is the number of components of the vectors in matrix Z . N is an INTEGER variable . N must be less than or equal to NM . LOW and IGH are INTEGER variables determined by BALANC . SCALE contains information determining the permutations and scaling factors used by BALANC . SCALE is a one - dimensional REAL array , dimensioned SCALE ( N ) . M is the number of columns of Z to be back transformed . M is an INTEGER variable . Z contains the real and imaginary parts of the eigen - vectors to be back transformed in its first M columns . Z is a two - dimensional REAL array , dimensioned Z ( NM , M ) . On Output Z contains the real and imaginary parts of the\n      transformed eigenvectors in its first M columns.\n\n Questions and comments should be directed to B. S. Garbow,\n Applied Mathematics Division, ARGONNE NATIONAL LABORATORY References B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow,\n    Y. Ikebe, V. C. Klema and C. B. Moler, Matrix Eigen-\n    system Routines - EISPACK Guide, Springer-Verlag,\n    1976. Revision History Author: Smith, B. T., et al. 760101  DATE WRITTEN 890831  Modified array declarations.  (WRB) 890831  REVISION DATE from Version 3.2 891214  Prologue converted to Version 4.0 format.  (BAB) 920501  Reformatted the REFERENCES section.  (WRB) Arguments Type Intent Optional Attributes Name integer :: Nm integer :: n integer :: Low integer :: Igh real(kind=wp) :: Scale (*) integer :: m real(kind=wp) :: z (Nm,*) Called by proc~~balbak~~CalledByGraph proc~balbak balbak proc~rg rg proc~rg->proc~balbak proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors proc~compute_eigenvalues_and_eigenvectors->proc~rg proc~compute_real_eigenvalues_and_normalized_eigenvectors compute_real_eigenvalues_and_normalized_eigenvectors proc~compute_real_eigenvalues_and_normalized_eigenvectors->proc~compute_eigenvalues_and_eigenvectors proc~eispack_test eispack_test proc~eispack_test->proc~compute_eigenvalues_and_eigenvectors Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine balbak ( Nm , n , Low , Igh , Scale , m , z ) implicit none integer :: i , j , k , m , n , ii , Nm , Igh , Low real ( wp ) :: Scale ( * ), z ( Nm , * ) real ( wp ) :: s if ( m /= 0 ) then if ( Igh /= Low ) then do i = Low , Igh s = Scale ( i ) ! LEFT HAND EIGENVECTORS ARE BACK TRANSFORMED ! IF THE FOREGOING STATEMENT IS REPLACED BY ! S=1.0_wp/SCALE(I). do j = 1 , m z ( i , j ) = z ( i , j ) * s enddo enddo endif ! FOR I=LOW-1 STEP -1 UNTIL 1, ! IGH+1 STEP 1 UNTIL N DO -- do ii = 1 , n i = ii if ( i < Low . or . i > Igh ) then if ( i < Low ) i = Low - ii k = Scale ( i ) if ( k /= i ) then do j = 1 , m s = z ( i , j ) z ( i , j ) = z ( k , j ) z ( k , j ) = s enddo endif endif enddo endif end subroutine balbak","tags":"","url":"proc/balbak.html"},{"title":"cdiv – fortran-astrodynamics-toolkit","text":"private  subroutine cdiv(Ar, Ai, Br, Bi, Cr, Ci) Compute the complex quotient of two complex numbers. Complex division, (CR,CI) = (AR,AI)/(BR,BI) Revision History 811101  DATE WRITTEN 891214  Prologue converted to Version 4.0 format.  (BAB) 900402  Added TYPE section.  (WRB) Arguments Type Intent Optional Attributes Name real(kind=wp) :: Ar real(kind=wp) :: Ai real(kind=wp) :: Br real(kind=wp) :: Bi real(kind=wp) :: Cr real(kind=wp) :: Ci Called by proc~~cdiv~~CalledByGraph proc~cdiv cdiv proc~hqr2 hqr2 proc~hqr2->proc~cdiv proc~rg rg proc~rg->proc~hqr2 proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors proc~compute_eigenvalues_and_eigenvectors->proc~rg proc~compute_real_eigenvalues_and_normalized_eigenvectors compute_real_eigenvalues_and_normalized_eigenvectors proc~compute_real_eigenvalues_and_normalized_eigenvectors->proc~compute_eigenvalues_and_eigenvectors proc~eispack_test eispack_test proc~eispack_test->proc~compute_eigenvalues_and_eigenvectors Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine cdiv ( Ar , Ai , Br , Bi , Cr , Ci ) implicit none real ( wp ) :: Ar , Ai , Br , Bi , Cr , Ci real ( wp ) :: s , ars , ais , brs , bis s = abs ( Br ) + abs ( Bi ) ars = Ar / s ais = Ai / s brs = Br / s bis = Bi / s s = brs ** 2 + bis ** 2 Cr = ( ars * brs + ais * bis ) / s Ci = ( ais * brs - ars * bis ) / s end subroutine cdiv","tags":"","url":"proc/cdiv.html"},{"title":"elmhes – fortran-astrodynamics-toolkit","text":"private  subroutine elmhes(Nm, n, Low, Igh, a, Intv) Reduce a real general matrix to upper Hessenberg form\n  using stabilized elementary similarity transformations. This subroutine is a translation of the ALGOL procedure ELMHES,\n  NUM. MATH. 12, 349-368(1968) by Martin and Wilkinson.\n  HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 339-358(1971). Given a REAL GENERAL matrix, this subroutine\n  reduces a submatrix situated in rows and columns\n  LOW through IGH to upper Hessenberg form by\n  stabilized elementary similarity transformations. On Input NM must be set to the row dimension of the two - dimensional array parameter , A , as declared in the calling program dimension statement . NM is an INTEGER variable . N is the order of the matrix , A . N is an INTEGER variable . N must be less than or equal to NM . LOW and IGH are two INTEGER variables determined by the balancing subroutine BALANC . If BALANC has not been used , set LOW = 1 and IGH equal to the order of the matrix , N . A contains the input matrix . A is a two - dimensional REAL array , dimensioned A ( NM , N ) . On Output A contains the upper Hessenberg matrix.  The multipliers which\n      were used in the reduction are stored in the remaining\n      triangle under the Hessenberg matrix.\n\n    INTV contains information on the rows and columns interchanged\n      in the reduction.  Only elements LOW through IGH are used.\n      INTV is a one-dimensional INTEGER array, dimensioned INTV(IGH).\n\n Questions and comments should be directed to B. S. Garbow,\n APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY References B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow,\n    Y. Ikebe, V. C. Klema and C. B. Moler, Matrix Eigen-\n    system Routines - EISPACK Guide, Springer-Verlag,\n    1976. Revision History Author: Smith, B. T., et al. 760101  DATE WRITTEN 890831  Modified array declarations.  (WRB) 890831  REVISION DATE from Version 3.2 891214  Prologue converted to Version 4.0 format.  (BAB) 920501  Reformatted the REFERENCES section.  (WRB) Arguments Type Intent Optional Attributes Name integer :: Nm integer :: n integer :: Low integer :: Igh real(kind=wp) :: a (Nm,*) integer :: Intv (*) Called by proc~~elmhes~~CalledByGraph proc~elmhes elmhes proc~rg rg proc~rg->proc~elmhes proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors proc~compute_eigenvalues_and_eigenvectors->proc~rg proc~compute_real_eigenvalues_and_normalized_eigenvectors compute_real_eigenvalues_and_normalized_eigenvectors proc~compute_real_eigenvalues_and_normalized_eigenvectors->proc~compute_eigenvalues_and_eigenvectors proc~eispack_test eispack_test proc~eispack_test->proc~compute_eigenvalues_and_eigenvectors Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine elmhes ( Nm , n , Low , Igh , a , Intv ) implicit none integer :: i , j , m , n , la , Nm , Igh , kp1 , Low , mm1 , mp1 real ( wp ) :: a ( Nm , * ) real ( wp ) :: x , y integer :: Intv ( * ) la = Igh - 1 kp1 = Low + 1 if ( la >= kp1 ) then do m = kp1 , la mm1 = m - 1 x = 0.0_wp i = m do j = m , Igh if ( abs ( a ( j , mm1 )) > abs ( x )) then x = a ( j , mm1 ) i = j endif enddo Intv ( m ) = i if ( i /= m ) then ! INTERCHANGE ROWS AND COLUMNS OF A do j = mm1 , n y = a ( i , j ) a ( i , j ) = a ( m , j ) a ( m , j ) = y enddo do j = 1 , Igh y = a ( j , i ) a ( j , i ) = a ( j , m ) a ( j , m ) = y enddo endif ! END INTERCHANGE if ( x /= 0.0_wp ) then mp1 = m + 1 do i = mp1 , Igh y = a ( i , mm1 ) if ( y /= 0.0_wp ) then y = y / x a ( i , mm1 ) = y do j = m , n a ( i , j ) = a ( i , j ) - y * a ( m , j ) enddo do j = 1 , Igh a ( j , m ) = a ( j , m ) + y * a ( j , i ) enddo endif enddo endif enddo endif end subroutine elmhes","tags":"","url":"proc/elmhes.html"},{"title":"eltran – fortran-astrodynamics-toolkit","text":"private  subroutine eltran(Nm, n, Low, Igh, a, Int, z) Accumulates the stabilized elementary similarity\n  transformations used in the reduction of a real general\n  matrix to upper Hessenberg form by ELMHES. This subroutine is a translation of the ALGOL procedure ELMTRANS,\n  NUM. MATH. 16, 181-204(1970) by Peters and Wilkinson.\n  HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 372-395(1971). This subroutine accumulates the stabilized elementary\n  similarity transformations used in the reduction of a\n  REAL GENERAL matrix to upper Hessenberg form by  ELMHES. On Input NM must be set to the row dimension of the two - dimensional array parameters , A and Z , as declared in the calling program dimension statement . NM is an INTEGER variable . N is the order of the matrix A . N is an INTEGER variable . N must be less than or equal to NM . LOW and IGH are two INTEGER variables determined by the balancing subroutine BALANC . If BALANC has not been used , set LOW = 1 and IGH equal to the order of the matrix , N . A contains the multipliers which were used in the reduction by ELMHES in its lower triangle below the subdiagonal . A is a two - dimensional REAL array , dimensioned A ( NM , IGH ) . INT contains information on the rows and columns interchanged in the reduction by ELMHES . Only elements LOW through IGH are used . INT is a one - dimensional INTEGER array , dimensioned INT ( IGH ) . On Output Z contains the transformation matrix produced in the reduction\n      by  ELMHES.  Z is a two-dimensional REAL array, dimensioned\n      Z(NM,N).\n\n Questions and comments should be directed to B. S. Garbow,\n APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY References B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow,\n    Y. Ikebe, V. C. Klema and C. B. Moler, Matrix Eigen-\n    system Routines - EISPACK Guide, Springer-Verlag,\n    1976. Revision History Author: Smith, B. T., et al. 760101  DATE WRITTEN 890831  Modified array declarations.  (WRB) 890831  REVISION DATE from Version 3.2 891214  Prologue converted to Version 4.0 format.  (BAB) 920501  Reformatted the REFERENCES section.  (WRB) Arguments Type Intent Optional Attributes Name integer :: Nm integer :: n integer :: Low integer :: Igh real(kind=wp) :: a (Nm,*) integer :: Int (*) real(kind=wp) :: z (Nm,*) Called by proc~~eltran~~CalledByGraph proc~eltran eltran proc~rg rg proc~rg->proc~eltran proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors proc~compute_eigenvalues_and_eigenvectors->proc~rg proc~compute_real_eigenvalues_and_normalized_eigenvectors compute_real_eigenvalues_and_normalized_eigenvectors proc~compute_real_eigenvalues_and_normalized_eigenvectors->proc~compute_eigenvalues_and_eigenvectors proc~eispack_test eispack_test proc~eispack_test->proc~compute_eigenvalues_and_eigenvectors Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine eltran ( Nm , n , Low , Igh , a , Int , z ) implicit none integer i , j , n , kl , mm , mp , Nm , Igh , Low , mp1 real ( wp ) a ( Nm , * ), z ( Nm , * ) integer Int ( * ) do i = 1 , n do j = 1 , n z ( i , j ) = 0.0_wp enddo z ( i , i ) = 1.0_wp enddo kl = Igh - Low - 1 if ( kl >= 1 ) then ! for mp=igh-1 step -1 until low+1 do -- do mm = 1 , kl mp = Igh - mm mp1 = mp + 1 do i = mp1 , Igh z ( i , mp ) = a ( i , mp - 1 ) enddo i = Int ( mp ) if ( i /= mp ) then do j = mp , Igh z ( mp , j ) = z ( i , j ) z ( i , j ) = 0.0_wp enddo z ( i , mp ) = 1.0_wp endif enddo endif end subroutine eltran","tags":"","url":"proc/eltran.html"},{"title":"hqr – fortran-astrodynamics-toolkit","text":"private  subroutine hqr(Nm, n, Low, Igh, h, Wr, Wi, Ierr) Compute the eigenvalues of a real upper Hessenberg matrix\n  using the QR method. This subroutine is a translation of the ALGOL procedure HQR,\n  NUM. MATH. 14, 219-231(1970) by Martin, Peters, and Wilkinson.\n  HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 359-371(1971). This subroutine finds the eigenvalues of a REAL\n  UPPER Hessenberg matrix by the QR method. On Input NM must be set to the row dimension of the two - dimensional array parameter , H , as declared in the calling program dimension statement . NM is an INTEGER variable . N is the order of the matrix H . N is an INTEGER variable . N must be less than or equal to NM . LOW and IGH are two INTEGER variables determined by the balancing subroutine BALANC . If BALANC has not been used , set LOW = 1 and IGH equal to the order of the matrix , N . H contains the upper Hessenberg matrix . Information about the transformations used in the reduction to Hessenberg form by ELMHES or ORTHES , if performed , is stored in the remaining triangle under the Hessenberg matrix . H is a two - dimensional REAL array , dimensioned H ( NM , N ) . On Output H has been destroyed.  Therefore, it must be saved before\n      calling  HQR  if subsequent calculation and back\n      transformation of eigenvectors is to be performed.\n\n    WR and WI contain the real and imaginary parts, respectively,\n      of the eigenvalues.  The eigenvalues are unordered except\n      that complex conjugate pairs of values appear consecutively\n      with the eigenvalue having the positive imaginary part first.\n      If an error exit is made, the eigenvalues should be correct\n      for indices IERR+1, IERR+2, ..., N.  WR and WI are one-\n      dimensional REAL arrays, dimensioned WR(N) and WI(N).\n\n    IERR is an INTEGER flag set to\n      Zero       for normal return,\n      J          if the J-th eigenvalue has not been\n                 determined after a total of 30*N iterations.\n                 The eigenvalues should be correct for indices\n                 IERR+1, IERR+2, ..., N. Questions and comments should be directed to B. S. Garbow,\n  APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY References B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow,\n    Y. Ikebe, V. C. Klema and C. B. Moler, Matrix Eigen-\n    system Routines - EISPACK Guide, Springer-Verlag,\n    1976. Revision History Author: Smith, B. T., et al. 760101  DATE WRITTEN 890531  Changed all specific intrinsics to generic.  (WRB) 890831  Modified array declarations.  (WRB) 890831  REVISION DATE from Version 3.2 891214  Prologue converted to Version 4.0 format.  (BAB) 920501  Reformatted the REFERENCES section.  (WRB) Arguments Type Intent Optional Attributes Name integer :: Nm integer :: n integer :: Low integer :: Igh real(kind=wp) :: h (Nm,*) real(kind=wp) :: Wr (*) real(kind=wp) :: Wi (*) integer :: Ierr Called by proc~~hqr~~CalledByGraph proc~hqr hqr proc~rg rg proc~rg->proc~hqr proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors proc~compute_eigenvalues_and_eigenvectors->proc~rg proc~compute_real_eigenvalues_and_normalized_eigenvectors compute_real_eigenvalues_and_normalized_eigenvectors proc~compute_real_eigenvalues_and_normalized_eigenvectors->proc~compute_eigenvalues_and_eigenvectors proc~eispack_test eispack_test proc~eispack_test->proc~compute_eigenvalues_and_eigenvectors Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine hqr ( Nm , n , Low , Igh , h , Wr , Wi , Ierr ) implicit none integer :: i , j , k , l , m , n , en , ll , mm , na , Nm , Igh , & itn , its , Low , mp2 , enm2 , Ierr , gt real ( wp ) :: h ( Nm , * ), Wr ( * ), Wi ( * ) real ( wp ) :: p , q , r , s , t , w , x , y , zz , norm , s1 , s2 logical :: notlas gt = 0 Ierr = 0 norm = 0.0_wp k = 1 ! STORE ROOTS ISOLATED BY BALANC ! AND COMPUTE MATRIX NORM do i = 1 , n do j = k , n norm = norm + abs ( h ( i , j )) enddo k = i if ( i < Low . or . i > Igh ) then Wr ( i ) = h ( i , i ) Wi ( i ) = 0.0_wp endif enddo en = Igh t = 0.0_wp itn = 30 * n ! SEARCH FOR NEXT EIGENVALUES do while ( en >= Low ) gt = 0 its = 0 na = en - 1 enm2 = na - 1 ! LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT ! FOR L=EN STEP -1 UNTIL LOW DO -- do while (. true .) do ll = Low , en l = en + Low - ll if ( l == Low ) exit s = abs ( h ( l - 1 , l - 1 )) + abs ( h ( l , l )) if ( s == 0.0_wp ) s = norm s2 = s + abs ( h ( l , l - 1 )) if ( s2 == s ) exit enddo ! FORM SHIFT x = h ( en , en ) if ( l == en ) then ! ONE ROOT FOUND Wr ( en ) = x + t Wi ( en ) = 0.0_wp en = na gt = 1 exit else y = h ( na , na ) w = h ( en , na ) * h ( na , en ) if ( l == na ) exit if ( itn == 0 ) then ! SET ERROR -- NO CONVERGENCE TO AN ! EIGENVALUE AFTER 30*N ITERATIONS Ierr = en return else if ( its == 10 . or . its == 20 ) then ! FORM EXCEPTIONAL SHIFT t = t + x do i = Low , en h ( i , i ) = h ( i , i ) - x enddo s = abs ( h ( en , na )) + abs ( h ( na , enm2 )) x = 0.75_wp * s y = x w = - 0.4375_wp * s * s endif its = its + 1 itn = itn - 1 ! LOOK FOR TWO CONSECUTIVE SMALL ! SUB-DIAGONAL ELEMENTS. ! FOR M=EN-2 STEP -1 UNTIL L DO -- do mm = l , enm2 m = enm2 + l - mm zz = h ( m , m ) r = x - zz s = y - zz p = ( r * s - w ) / h ( m + 1 , m ) + h ( m , m + 1 ) q = h ( m + 1 , m + 1 ) - zz - r - s r = h ( m + 2 , m + 1 ) s = abs ( p ) + abs ( q ) + abs ( r ) p = p / s q = q / s r = r / s if ( m == l ) exit s1 = abs ( p ) * ( abs ( h ( m - 1 , m - 1 )) + abs ( zz ) + abs ( h ( m + 1 , m + 1 ))) s2 = s1 + abs ( h ( m , m - 1 )) * ( abs ( q ) + abs ( r )) if ( s2 == s1 ) exit enddo mp2 = m + 2 do i = mp2 , en h ( i , i - 2 ) = 0.0_wp if ( i /= mp2 ) h ( i , i - 3 ) = 0.0_wp enddo ! DOUBLE QR STEP INVOLVING ROWS L TO EN AND ! COLUMNS M TO EN do k = m , na notlas = k /= na if ( k /= m ) then p = h ( k , k - 1 ) q = h ( k + 1 , k - 1 ) r = 0.0_wp if ( notlas ) r = h ( k + 2 , k - 1 ) x = abs ( p ) + abs ( q ) + abs ( r ) if ( x == 0.0_wp ) cycle p = p / x q = q / x r = r / x endif s = sign ( sqrt ( p * p + q * q + r * r ), p ) if ( k == m ) then if ( l /= m ) h ( k , k - 1 ) = - h ( k , k - 1 ) else h ( k , k - 1 ) = - s * x endif p = p + s x = p / s y = q / s zz = r / s q = q / p r = r / p ! ROW MODIFICATION do j = k , en p = h ( k , j ) + q * h ( k + 1 , j ) if ( notlas ) then p = p + r * h ( k + 2 , j ) h ( k + 2 , j ) = h ( k + 2 , j ) - p * zz endif h ( k + 1 , j ) = h ( k + 1 , j ) - p * y h ( k , j ) = h ( k , j ) - p * x enddo j = min ( en , k + 3 ) ! COLUMN MODIFICATION do i = l , j p = x * h ( i , k ) + y * h ( i , k + 1 ) if ( notlas ) then p = p + zz * h ( i , k + 2 ) h ( i , k + 2 ) = h ( i , k + 2 ) - p * r endif h ( i , k + 1 ) = h ( i , k + 1 ) - p * q h ( i , k ) = h ( i , k ) - p enddo enddo endif endif enddo ! TWO ROOTS FOUND if ( gt == 0 ) then p = ( y - x ) / 2.0_wp q = p * p + w zz = sqrt ( abs ( q )) x = x + t if ( q < 0.0_wp ) then ! COMPLEX PAIR Wr ( na ) = x + p Wr ( en ) = x + p Wi ( na ) = zz Wi ( en ) = - zz else ! REAL PAIR zz = p + sign ( zz , p ) Wr ( na ) = x + zz Wr ( en ) = Wr ( na ) if ( zz /= 0.0_wp ) Wr ( en ) = x - w / zz Wi ( na ) = 0.0_wp Wi ( en ) = 0.0_wp endif en = enm2 end if enddo end subroutine hqr","tags":"","url":"proc/hqr.html"},{"title":"hqr2 – fortran-astrodynamics-toolkit","text":"private  subroutine hqr2(Nm, n, Low, Igh, h, Wr, Wi, z, Ierr) Compute the eigenvalues and eigenvectors of a real upper\n  Hessenberg matrix using QR method. This subroutine is a translation of the ALGOL procedure HQR2,\n  NUM. MATH. 16, 181-204(1970) by Peters and Wilkinson.\n  HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 372-395(1971). This subroutine finds the eigenvalues and eigenvectors\n  of a REAL UPPER Hessenberg matrix by the QR method.  The\n  eigenvectors of a REAL GENERAL matrix can also be found\n  if  ELMHES  and  ELTRAN  or  ORTHES  and  ORTRAN  have\n  been used to reduce this general matrix to Hessenberg form\n  and to accumulate the similarity transformations. On Input NM must be set to the row dimension of the two - dimensional array parameters , H and Z , as declared in the calling program dimension statement . NM is an INTEGER variable . N is the order of the matrix H . N is an INTEGER variable . N must be less than or equal to NM . LOW and IGH are two INTEGER variables determined by the balancing subroutine BALANC . If BALANC has not been used , set LOW = 1 and IGH equal to the order of the matrix , N . H contains the upper Hessenberg matrix . H is a two - dimensional REAL array , dimensioned H ( NM , N ) . Z contains the transformation matrix produced by ELTRAN after the reduction by ELMHES , or by ORTRAN after the reduction by ORTHES , if performed . If the eigenvectors of the Hessenberg matrix are desired , Z must contain the identity matrix . Z is a two - dimensional REAL array , dimensioned Z ( NM , M ) . On Output H has been destroyed.\n\n    WR and WI contain the real and imaginary parts, respectively,\n      of the eigenvalues.  The eigenvalues are unordered except\n      that complex conjugate pairs of values appear consecutively\n      with the eigenvalue having the positive imaginary part first.\n      If an error exit is made, the eigenvalues should be correct\n      for indices IERR+1, IERR+2, ..., N.  WR and WI are one-\n      dimensional REAL arrays, dimensioned WR(N) and WI(N).\n\n    Z contains the real and imaginary parts of the eigenvectors.\n      If the J-th eigenvalue is real, the J-th column of Z\n      contains its eigenvector.  If the J-th eigenvalue is complex\n      with positive imaginary part, the J-th and (J+1)-th\n      columns of Z contain the real and imaginary parts of its\n      eigenvector.  The eigenvectors are unnormalized.  If an\n      error exit is made, none of the eigenvectors has been found.\n\n    IERR is an INTEGER flag set to\n      Zero       for normal return,\n      J          if the J-th eigenvalue has not been\n                 determined after a total of 30*N iterations.\n                 The eigenvalues should be correct for indices\n                 IERR+1, IERR+2, ..., N, but no eigenvectors are\n                 computed.\n\n Calls CDIV for complex division. Questions and comments should be directed to B. S. Garbow,\n  APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY References B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow,\n    Y. Ikebe, V. C. Klema and C. B. Moler, Matrix Eigen-\n    system Routines - EISPACK Guide, Springer-Verlag,\n    1976. Revision History Smith, B. T., et al. 760101  DATE WRITTEN 890531  Changed all specific intrinsics to generic.  (WRB) 890831  Modified array declarations.  (WRB) 890831  REVISION DATE from Version 3.2 891214  Prologue converted to Version 4.0 format.  (BAB) 920501  Reformatted the REFERENCES section.  (WRB) Arguments Type Intent Optional Attributes Name integer :: Nm integer :: n integer :: Low integer :: Igh real(kind=wp) :: h (Nm,*) real(kind=wp) :: Wr (*) real(kind=wp) :: Wi (*) real(kind=wp) :: z (Nm,*) integer :: Ierr Calls proc~~hqr2~~CallsGraph proc~hqr2 hqr2 proc~cdiv cdiv proc~hqr2->proc~cdiv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~hqr2~~CalledByGraph proc~hqr2 hqr2 proc~rg rg proc~rg->proc~hqr2 proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors proc~compute_eigenvalues_and_eigenvectors->proc~rg proc~compute_real_eigenvalues_and_normalized_eigenvectors compute_real_eigenvalues_and_normalized_eigenvectors proc~compute_real_eigenvalues_and_normalized_eigenvectors->proc~compute_eigenvalues_and_eigenvectors proc~eispack_test eispack_test proc~eispack_test->proc~compute_eigenvalues_and_eigenvectors Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine hqr2 ( Nm , n , Low , Igh , h , Wr , Wi , z , Ierr ) implicit none integer :: i , j , k , l , m , n , en , ii , jj , ll , mm , na , Nm , & nn , gt integer :: Igh , itn , its , Low , mp2 , enm2 , Ierr real ( wp ) :: h ( Nm , * ), Wr ( * ), Wi ( * ), z ( Nm , * ) real ( wp ) :: p , q , r , s , t , w , x , y , ra , sa , vi , vr , zz , & norm , s1 , s2 logical :: notlas gt = 0 Ierr = 0 norm = 0.0_wp k = 1 ! STORE ROOTS ISOLATED BY BALANC ! AND COMPUTE MATRIX NORM do i = 1 , n do j = k , n norm = norm + abs ( h ( i , j )) enddo k = i if ( i < Low . or . i > Igh ) then Wr ( i ) = h ( i , i ) Wi ( i ) = 0.0_wp endif enddo en = Igh t = 0.0_wp itn = 30 * n ! SEARCH FOR NEXT EIGENVALUES do while ( en >= Low ) gt = 0 its = 0 na = en - 1 enm2 = na - 1 ! LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT ! FOR L=EN STEP -1 UNTIL LOW DO -- do while (. true .) do ll = Low , en l = en + Low - ll if ( l == Low ) exit s = abs ( h ( l - 1 , l - 1 )) + abs ( h ( l , l )) if ( s == 0.0_wp ) s = norm s2 = s + abs ( h ( l , l - 1 )) if ( s2 == s ) exit enddo ! FORM SHIFT x = h ( en , en ) if ( l == en ) then ! ONE ROOT FOUND h ( en , en ) = x + t Wr ( en ) = h ( en , en ) Wi ( en ) = 0.0_wp en = na gt = 1 exit else y = h ( na , na ) w = h ( en , na ) * h ( na , en ) if ( l == na ) exit if ( itn == 0 ) then ! SET ERROR -- NO CONVERGENCE TO AN ! EIGENVALUE AFTER 30*N ITERATIONS Ierr = en return else if ( its == 10 . or . its == 20 ) then ! FORM EXCEPTIONAL SHIFT t = t + x do i = Low , en h ( i , i ) = h ( i , i ) - x enddo s = abs ( h ( en , na )) + abs ( h ( na , enm2 )) x = 0.75_wp * s y = x w = - 0.4375_wp * s * s endif its = its + 1 itn = itn - 1 ! LOOK FOR TWO CONSECUTIVE SMALL ! SUB-DIAGONAL ELEMENTS. ! FOR M=EN-2 STEP -1 UNTIL L DO -- do mm = l , enm2 m = enm2 + l - mm zz = h ( m , m ) r = x - zz s = y - zz p = ( r * s - w ) / h ( m + 1 , m ) + h ( m , m + 1 ) q = h ( m + 1 , m + 1 ) - zz - r - s r = h ( m + 2 , m + 1 ) s = abs ( p ) + abs ( q ) + abs ( r ) p = p / s q = q / s r = r / s if ( m == l ) exit s1 = abs ( p ) * ( abs ( h ( m - 1 , m - 1 )) + abs ( zz ) + abs ( h ( m + 1 , m + 1 ))) s2 = s1 + abs ( h ( m , m - 1 )) * ( abs ( q ) + abs ( r )) if ( s2 == s1 ) exit enddo mp2 = m + 2 do i = mp2 , en h ( i , i - 2 ) = 0.0_wp if ( i /= mp2 ) h ( i , i - 3 ) = 0.0_wp enddo ! DOUBLE QR STEP INVOLVING ROWS L TO EN AND ! COLUMNS M TO EN do k = m , na notlas = k /= na if ( k /= m ) then p = h ( k , k - 1 ) q = h ( k + 1 , k - 1 ) r = 0.0_wp if ( notlas ) r = h ( k + 2 , k - 1 ) x = abs ( p ) + abs ( q ) + abs ( r ) if ( x == 0.0_wp ) cycle p = p / x q = q / x r = r / x endif s = sign ( sqrt ( p * p + q * q + r * r ), p ) if ( k == m ) then if ( l /= m ) h ( k , k - 1 ) = - h ( k , k - 1 ) else h ( k , k - 1 ) = - s * x endif p = p + s x = p / s y = q / s zz = r / s q = q / p r = r / p ! ROW MODIFICATION do j = k , n p = h ( k , j ) + q * h ( k + 1 , j ) if ( notlas ) then p = p + r * h ( k + 2 , j ) h ( k + 2 , j ) = h ( k + 2 , j ) - p * zz endif h ( k + 1 , j ) = h ( k + 1 , j ) - p * y h ( k , j ) = h ( k , j ) - p * x enddo j = min ( en , k + 3 ) ! COLUMN MODIFICATION do i = 1 , j p = x * h ( i , k ) + y * h ( i , k + 1 ) if ( notlas ) then p = p + zz * h ( i , k + 2 ) h ( i , k + 2 ) = h ( i , k + 2 ) - p * r endif h ( i , k + 1 ) = h ( i , k + 1 ) - p * q h ( i , k ) = h ( i , k ) - p enddo ! ACCUMULATE TRANSFORMATIONS do i = Low , Igh ! p = x * z ( i , k ) + y * z ( i , k + 1 ) if ( notlas ) then p = p + zz * z ( i , k + 2 ) z ( i , k + 2 ) = z ( i , k + 2 ) - p * r endif z ( i , k + 1 ) = z ( i , k + 1 ) - p * q z ( i , k ) = z ( i , k ) - p ! enddo enddo endif endif enddo if ( gt == 1 ) cycle ! TWO ROOTS FOUND p = ( y - x ) / 2.0_wp q = p * p + w zz = sqrt ( abs ( q )) h ( en , en ) = x + t x = h ( en , en ) h ( na , na ) = y + t if ( q < 0.0_wp ) then ! COMPLEX PAIR Wr ( na ) = x + p Wr ( en ) = x + p Wi ( na ) = zz Wi ( en ) = - zz else ! REAL PAIR zz = p + sign ( zz , p ) Wr ( na ) = x + zz Wr ( en ) = Wr ( na ) if ( zz /= 0.0_wp ) Wr ( en ) = x - w / zz Wi ( na ) = 0.0_wp Wi ( en ) = 0.0_wp x = h ( en , na ) s = abs ( x ) + abs ( zz ) p = x / s q = zz / s r = sqrt ( p * p + q * q ) p = p / r q = q / r ! ROW MODIFICATION do j = na , n zz = h ( na , j ) h ( na , j ) = q * zz + p * h ( en , j ) h ( en , j ) = q * h ( en , j ) - p * zz enddo ! COLUMN MODIFICATION do i = 1 , en zz = h ( i , na ) h ( i , na ) = q * zz + p * h ( i , en ) h ( i , en ) = q * h ( i , en ) - p * zz enddo ! ACCUMULATE TRANSFORMATIONS do i = Low , Igh zz = z ( i , na ) z ( i , na ) = q * zz + p * z ( i , en ) z ( i , en ) = q * z ( i , en ) - p * zz enddo endif en = enm2 enddo ! ALL ROOTS FOUND.  BACKSUBSTITUTE TO FIND ! VECTORS OF UPPER TRIANGULAR FORM if ( norm /= 0.0_wp ) then ! FOR EN=N STEP -1 UNTIL 1 DO -- do nn = 1 , n en = n + 1 - nn p = Wr ( en ) q = Wi ( en ) na = en - 1 if ( q < 0 ) then ! END COMPLEX VECTOR ! COMPLEX VECTOR m = na ! LAST VECTOR COMPONENT CHOSEN IMAGINARY SO THAT ! EIGENVECTOR MATRIX IS TRIANGULAR if ( abs ( h ( en , na )) <= abs ( h ( na , en ))) then call cdiv ( 0.0_wp , - h ( na , en ), h ( na , na ) - p , q , h ( na , na ), h ( na , en )) else h ( na , na ) = q / h ( en , na ) h ( na , en ) = - ( h ( en , en ) - p ) / h ( en , na ) endif h ( en , na ) = 0.0_wp h ( en , en ) = 1.0_wp enm2 = na - 1 if ( enm2 /= 0 ) then ! FOR I=EN-2 STEP -1 UNTIL 1 DO -- do ii = 1 , enm2 i = na - ii w = h ( i , i ) - p ra = 0.0_wp sa = h ( i , en ) ! do j = m , na ra = ra + h ( i , j ) * h ( j , na ) sa = sa + h ( i , j ) * h ( j , en ) enddo ! if ( Wi ( i ) >= 0.0_wp ) then m = i if ( Wi ( i ) == 0.0_wp ) then call cdiv ( - ra , - sa , w , q , h ( i , na ), h ( i , en )) else ! SOLVE COMPLEX EQUATIONS x = h ( i , i + 1 ) y = h ( i + 1 , i ) vr = ( Wr ( i ) - p ) * ( Wr ( i ) - p ) + Wi ( i ) * Wi ( i ) - q * q vi = ( Wr ( i ) - p ) * 2.0_wp * q if ( vr == 0.0_wp . and . vi == 0.0_wp ) then s1 = norm * ( abs ( w ) + abs ( q ) + abs ( x ) + abs ( y ) + abs ( zz )) vr = s1 do while (. true .) vr = 0.5_wp * vr if ( s1 + vr <= s1 ) exit enddo vr = 2.0_wp * vr endif call cdiv ( x * r - zz * ra + q * sa , x * s - zz * sa - q * ra , vr , vi , h ( i , na ), & h ( i , en )) if ( abs ( x ) <= abs ( zz ) + abs ( q )) then call cdiv ( - r - y * h ( i , na ), - s - y * h ( i , en ), zz , q , h ( i + 1 , na ), & h ( i + 1 , en )) else h ( i + 1 , na ) = ( - ra - w * h ( i , na ) + q * h ( i , en )) / x h ( i + 1 , en ) = ( - sa - w * h ( i , en ) - q * h ( i , na )) / x endif endif else zz = w r = ra s = sa endif enddo endif elseif ( q == 0 ) then ! REAL VECTOR m = en h ( en , en ) = 1.0_wp if ( na /= 0 ) then ! FOR I=EN-1 STEP -1 UNTIL 1 DO -- do ii = 1 , na i = en - ii w = h ( i , i ) - p r = h ( i , en ) if ( m <= na ) then do j = m , na r = r + h ( i , j ) * h ( j , en ) enddo endif if ( Wi ( i ) >= 0.0_wp ) then ! END REAL VECTOR m = i if ( Wi ( i ) == 0.0_wp ) then t = w if ( t == 0.0_wp ) then t = norm do while (. true .) t = 0.5_wp * t if ( norm + t <= norm ) exit enddo t = 2.0_wp * t endif h ( i , en ) = - r / t else ! SOLVE REAL EQUATIONS x = h ( i , i + 1 ) y = h ( i + 1 , i ) q = ( Wr ( i ) - p ) * ( Wr ( i ) - p ) + Wi ( i ) * Wi ( i ) t = ( x * s - zz * r ) / q h ( i , en ) = t if ( abs ( x ) <= abs ( zz )) then h ( i + 1 , en ) = ( - s - y * t ) / zz else h ( i + 1 , en ) = ( - r - w * t ) / x endif endif else zz = w s = r endif enddo endif endif enddo ! END BACK SUBSTITUTION. ! VECTORS OF ISOLATED ROOTS do i = 1 , n if ( i < Low . or . i > Igh ) then do j = i , n z ( i , j ) = h ( i , j ) enddo endif enddo ! MULTIPLY BY TRANSFORMATION MATRIX TO GIVE ! VECTORS OF ORIGINAL FULL MATRIX. ! FOR J=N STEP -1 UNTIL LOW DO -- do jj = Low , n j = n + Low - jj m = min ( j , Igh ) do i = Low , Igh zz = 0.0_wp do k = Low , m zz = zz + z ( i , k ) * h ( k , j ) enddo z ( i , j ) = zz enddo enddo endif end subroutine hqr2","tags":"","url":"proc/hqr2.html"},{"title":"rg – fortran-astrodynamics-toolkit","text":"private  subroutine rg(Nm, n, a, Wr, Wi, Matz, z, Iv1, Fv1, Ierr) Compute the eigenvalues and, optionally, the eigenvectors\n  of a real general matrix. This subroutine calls the recommended sequence of\n  subroutines from the eigensystem subroutine package (EISPACK)\n  To find the eigenvalues and eigenvectors (if desired)\n  of a REAL GENERAL matrix. References B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow,\n    Y. Ikebe, V. C. Klema and C. B. Moler, Matrix Eigen-\n    system Routines - EISPACK Guide, Springer-Verlag,\n    1976. Author Smith, B. T., et al. History  (YYMMDD) 760101  DATE WRITTEN 890831  Modified array declarations.  (WRB) 890831  REVISION DATE from Version 3.2 891214  Prologue converted to Version 4.0 format.  (BAB) 920501  Reformatted the REFERENCES section.  (WRB) 921103  Corrected description of IV1.  (DWL, FNF and WRB) Jacob Williams, refactored into modern Fortran (3/25/2018) Arguments Type Intent Optional Attributes Name integer, intent(in) :: Nm must be set to the row dimension of the two-dimensional\narray parameters, A and Z, as declared in the calling\nprogram dimension statement. integer, intent(in) :: n the order of the matrix A.\nN must be less than or equal to NM. real(kind=wp), intent(inout) :: a (Nm,*) contains the real general matrix.\ndimensioned A(NM,N).\nNote: A is destroyed on output. real(kind=wp), intent(out) :: Wr (*) real part of the eigenvalues.  The eigenvalues are unordered except\nthat complex conjugate pairs of eigenvalues appear consecutively\nwith the eigenvalue having the positive imaginary part\nfirst.  If an error exit is made, the eigenvalues should be\ncorrect for indices IERR+1, IERR+2, ..., N.  WR and WI are\none-dimensional REAL arrays, dimensioned WR(N) and WI(N). real(kind=wp), intent(out) :: Wi (*) imaginary part of the eigenvalues. integer, intent(in) :: Matz an INTEGER variable set equal to zero if only\neigenvalues are desired.  Otherwise, it is set to any\nnon-zero integer for both eigenvalues and eigenvectors. real(kind=wp), intent(out) :: z (Nm,*) contains the real and imaginary parts of the eigenvectors\nif MATZ is not zero.  If the J-th eigenvalue is real, the\nJ-th column of Z contains its eigenvector.  If the J-th\neigenvalue is complex with positive imaginary part, the\nJ-th and (J+1)-th columns of Z contain the real and\nimaginary parts of its eigenvector.  The conjugate of this\nvector is the eigenvector for the conjugate eigenvalue.\nZ is a two-dimensional REAL array, dimensioned Z(NM,N). integer, intent(inout) :: Iv1 (*) one-dimensional temporary storage arrays of dimension N. real(kind=wp), intent(inout) :: Fv1 (*) one-dimensional temporary storage arrays of dimension N. integer, intent(out) :: Ierr an INTEGER flag set to: 0 -- for normal return, 10*N -- if N is greater than NM, J    -- if the J-th eigenvalue has not been\n          determined after a total of 30 iterations.\n          The eigenvalues should be correct for indices\n          IERR+1, IERR+2, ..., N, but no eigenvectors are\n          computed. Calls proc~~rg~~CallsGraph proc~rg rg proc~balanc balanc proc~rg->proc~balanc proc~balbak balbak proc~rg->proc~balbak proc~elmhes elmhes proc~rg->proc~elmhes proc~eltran eltran proc~rg->proc~eltran proc~hqr hqr proc~rg->proc~hqr proc~hqr2 hqr2 proc~rg->proc~hqr2 proc~cdiv cdiv proc~hqr2->proc~cdiv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~rg~~CalledByGraph proc~rg rg proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors proc~compute_eigenvalues_and_eigenvectors->proc~rg proc~compute_real_eigenvalues_and_normalized_eigenvectors compute_real_eigenvalues_and_normalized_eigenvectors proc~compute_real_eigenvalues_and_normalized_eigenvectors->proc~compute_eigenvalues_and_eigenvectors proc~eispack_test eispack_test proc~eispack_test->proc~compute_eigenvalues_and_eigenvectors Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine rg ( Nm , n , a , Wr , Wi , Matz , z , Iv1 , Fv1 , Ierr ) implicit none integer , intent ( in ) :: n !! the order of the matrix A. !! N must be less than or equal to NM. integer , intent ( in ) :: Nm !! must be set to the row dimension of the two-dimensional !! array parameters, A and Z, as declared in the calling !! program dimension statement. integer , intent ( in ) :: Matz !! an INTEGER variable set equal to zero if only !! eigenvalues are desired.  Otherwise, it is set to any !! non-zero integer for both eigenvalues and eigenvectors. real ( wp ), intent ( inout ) :: a ( Nm , * ) !! contains the real general matrix. !! dimensioned A(NM,N). !! Note: A is destroyed on output. integer , intent ( out ) :: Ierr !! an INTEGER flag set to: !! !! * 0 -- for normal return, !! * 10*N -- if N is greater than NM, !! * J    -- if the J-th eigenvalue has not been !!           determined after a total of 30 iterations. !!           The eigenvalues should be correct for indices !!           IERR+1, IERR+2, ..., N, but no eigenvectors are !!           computed. real ( wp ), intent ( out ) :: Wr ( * ) !! real part of the eigenvalues.  The eigenvalues are unordered except !! that complex conjugate pairs of eigenvalues appear consecutively !! with the eigenvalue having the positive imaginary part !! first.  If an error exit is made, the eigenvalues should be !! correct for indices IERR+1, IERR+2, ..., N.  WR and WI are !! one-dimensional REAL arrays, dimensioned WR(N) and WI(N). real ( wp ), intent ( out ) :: Wi ( * ) !! imaginary part of the eigenvalues. real ( wp ), intent ( out ) :: z ( Nm , * ) !! contains the real and imaginary parts of the eigenvectors !! if MATZ is not zero.  If the J-th eigenvalue is real, the !! J-th column of Z contains its eigenvector.  If the J-th !! eigenvalue is complex with positive imaginary part, the !! J-th and (J+1)-th columns of Z contain the real and !! imaginary parts of its eigenvector.  The conjugate of this !! vector is the eigenvector for the conjugate eigenvalue. !! Z is a two-dimensional REAL array, dimensioned Z(NM,N). real ( wp ), intent ( inout ) :: Fv1 ( * ) !! one-dimensional temporary storage arrays of dimension N. integer , intent ( inout ) :: Iv1 ( * ) !! one-dimensional temporary storage arrays of dimension N. integer :: is1 integer :: is2 if ( n <= Nm ) then call balanc ( Nm , n , a , is1 , is2 , Fv1 ) call elmhes ( Nm , n , is1 , is2 , a , Iv1 ) if ( Matz /= 0 ) then ! find both eigenvalues and eigenvectors call eltran ( Nm , n , is1 , is2 , a , Iv1 , z ) call hqr2 ( Nm , n , is1 , is2 , a , Wr , Wi , z , Ierr ) if ( Ierr == 0 ) call balbak ( Nm , n , is1 , is2 , Fv1 , n , z ) else ! find eigenvalues only call hqr ( Nm , n , is1 , is2 , a , Wr , Wi , Ierr ) endif else Ierr = 10 * n endif end subroutine rg","tags":"","url":"proc/rg.html"},{"title":"compute_eigenvalues_and_eigenvectors – fortran-astrodynamics-toolkit","text":"public  subroutine compute_eigenvalues_and_eigenvectors(n, a, w, z, ierr) Uses numbers_module proc~~compute_eigenvalues_and_eigenvectors~~UsesGraph proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors module~numbers_module numbers_module proc~compute_eigenvalues_and_eigenvectors->module~numbers_module module~kind_module kind_module module~numbers_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Compute the eigenvalues and, optionally, the eigenvectors\n  of a real general matrix. See also See rg for more details. This routine is just a wrapper to that one. Author Jacob Williams, 3/25/2018 Arguments Type Intent Optional Attributes Name integer, intent(in) :: n the order of the matrix a real(kind=wp), intent(in), dimension(n,n) :: a contains the real general matrix real(kind=wp), intent(out), dimension(n,2) :: w real and imaginary parts of the eigenvalues real(kind=wp), intent(out), dimension(n,n) :: z real and imaginary parts of the eigenvectors integer, intent(out) :: ierr output flag from rg Calls proc~~compute_eigenvalues_and_eigenvectors~~CallsGraph proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors proc~rg rg proc~compute_eigenvalues_and_eigenvectors->proc~rg proc~balanc balanc proc~rg->proc~balanc proc~balbak balbak proc~rg->proc~balbak proc~elmhes elmhes proc~rg->proc~elmhes proc~eltran eltran proc~rg->proc~eltran proc~hqr hqr proc~rg->proc~hqr proc~hqr2 hqr2 proc~rg->proc~hqr2 proc~cdiv cdiv proc~hqr2->proc~cdiv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_eigenvalues_and_eigenvectors~~CalledByGraph proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors proc~compute_real_eigenvalues_and_normalized_eigenvectors compute_real_eigenvalues_and_normalized_eigenvectors proc~compute_real_eigenvalues_and_normalized_eigenvectors->proc~compute_eigenvalues_and_eigenvectors proc~eispack_test eispack_test proc~eispack_test->proc~compute_eigenvalues_and_eigenvectors Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_eigenvalues_and_eigenvectors ( n , a , w , z , ierr ) use numbers_module implicit none integer , intent ( in ) :: n !! the order of the matrix `a` real ( wp ), dimension ( n , n ), intent ( in ) :: a !! contains the real general matrix real ( wp ), dimension ( n , 2 ), intent ( out ) :: w !! real and imaginary parts of the eigenvalues real ( wp ), dimension ( n , n ), intent ( out ) :: z !! real and imaginary parts of the eigenvectors integer , intent ( out ) :: ierr !! output flag from [[rg]] integer , parameter :: matz = 1 !! tells [[rg]] to compute eigenvalues and eigenvectors integer :: i !! counter real ( wp ), dimension ( n , n ) :: a_tmp !! copy of [[a]] matrix real ( wp ), dimension ( n ) :: fv1 !! work array for [[rg]] integer , dimension ( n ) :: iv1 !! work array for [[rg]] real ( wp ), dimension ( n ) :: wr !! real part of the eigenvalues real ( wp ), dimension ( n ) :: wi !! imaginary part of the eigenvalues ! temp arrays: a_tmp = a wr = zero wi = zero ! call the general routine: call rg ( n , n , a_tmp , wr , wi , matz , z , iv1 , fv1 , ierr ) ! pack outputs: do i = 1 , n w ( i , 1 ) = wr ( i ) w ( i , 2 ) = wi ( i ) end do end subroutine compute_eigenvalues_and_eigenvectors","tags":"","url":"proc/compute_eigenvalues_and_eigenvectors.html"},{"title":"compute_real_eigenvalues_and_normalized_eigenvectors – fortran-astrodynamics-toolkit","text":"public  subroutine compute_real_eigenvalues_and_normalized_eigenvectors(n, a, e, v, n_results, ierr) Uses numbers_module proc~~compute_real_eigenvalues_and_normalized_eigenvectors~~UsesGraph proc~compute_real_eigenvalues_and_normalized_eigenvectors compute_real_eigenvalues_and_normalized_eigenvectors module~numbers_module numbers_module proc~compute_real_eigenvalues_and_normalized_eigenvectors->module~numbers_module module~kind_module kind_module module~numbers_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Returns only the real eigenvalues and the associated eigenvectors.\nWrapper for compute_eigenvalues_and_eigenvectors . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n the order of the matrix a real(kind=wp), intent(in), dimension(n,n) :: a contains the real general matrix real(kind=wp), intent(out), dimension(:), allocatable :: e eigenvalues (size n_results ) real(kind=wp), intent(out), dimension(:,:), allocatable :: v eigenvectors (size n,n_results ) integer, intent(out) :: n_results number of real eigenvalues integer, intent(out) :: ierr output flag from rg Calls proc~~compute_real_eigenvalues_and_normalized_eigenvectors~~CallsGraph proc~compute_real_eigenvalues_and_normalized_eigenvectors compute_real_eigenvalues_and_normalized_eigenvectors proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors proc~compute_real_eigenvalues_and_normalized_eigenvectors->proc~compute_eigenvalues_and_eigenvectors proc~rg rg proc~compute_eigenvalues_and_eigenvectors->proc~rg proc~balanc balanc proc~rg->proc~balanc proc~balbak balbak proc~rg->proc~balbak proc~elmhes elmhes proc~rg->proc~elmhes proc~eltran eltran proc~rg->proc~eltran proc~hqr hqr proc~rg->proc~hqr proc~hqr2 hqr2 proc~rg->proc~hqr2 proc~cdiv cdiv proc~hqr2->proc~cdiv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_real_eigenvalues_and_normalized_eigenvectors ( n , a , e , v , n_results , ierr ) use numbers_module implicit none integer , intent ( in ) :: n !! the order of the matrix `a` real ( wp ), dimension ( n , n ), intent ( in ) :: a !! contains the real general matrix real ( wp ), dimension (:), allocatable , intent ( out ) :: e !! eigenvalues (size `n_results`) real ( wp ), dimension (:,:), allocatable , intent ( out ) :: v !! eigenvectors (size `n,n_results`) integer , intent ( out ) :: n_results !! number of real eigenvalues integer , intent ( out ) :: ierr !! output flag from [[rg]] real ( wp ), dimension ( n , 2 ) :: w !! real and imaginary parts of the eigenvalues real ( wp ), dimension ( n , n ) :: z !! real and imaginary parts of the eigenvectors integer :: i !! counter integer :: j !! counter call compute_eigenvalues_and_eigenvectors ( n , a , w , z , ierr ) if ( ierr == 0 ) then n_results = count ( w (:, 2 ) == 0.0_wp ) if ( n_results > 0 ) then allocate ( e ( n_results )) allocate ( v ( n , n_results )) j = 0 do i = 1 , n if ( w ( i , 2 ) == 0.0_wp ) then ! real eigenvalue j = j + 1 e ( j ) = w ( i , 1 ) v (:, j ) = z (:, i ) / norm2 ( z (:, i )) ! normalized eigenvector end if end do end if else n_results = 0 end if end subroutine compute_real_eigenvalues_and_normalized_eigenvectors","tags":"","url":"proc/compute_real_eigenvalues_and_normalized_eigenvectors.html"},{"title":"eispack_test – fortran-astrodynamics-toolkit","text":"public  subroutine eispack_test() Unit test Arguments None Calls proc~~eispack_test~~CallsGraph proc~eispack_test eispack_test proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors proc~eispack_test->proc~compute_eigenvalues_and_eigenvectors proc~rg rg proc~compute_eigenvalues_and_eigenvectors->proc~rg proc~balanc balanc proc~rg->proc~balanc proc~balbak balbak proc~rg->proc~balbak proc~elmhes elmhes proc~rg->proc~elmhes proc~eltran eltran proc~rg->proc~eltran proc~hqr hqr proc~rg->proc~hqr proc~hqr2 hqr2 proc~rg->proc~hqr2 proc~cdiv cdiv proc~hqr2->proc~cdiv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine eispack_test () implicit none real ( wp ), dimension ( 3 , 3 ), parameter :: a = reshape ([ 1.0_wp , 4.0_wp , - 3.0_wp ,& 2.0_wp , 3.0_wp , - 8.0_wp ,& 3.0_wp , 2.0_wp , 1.001_wp ], [ 3 , 3 ]) real ( wp ), dimension ( 3 , 2 ) :: w !! real and imaginary parts of the eigenvalues real ( wp ), dimension ( 3 , 3 ) :: z !! real and imaginary parts of the eigenvectors integer :: ierr !! output flag integer :: i !! counter integer :: j !! counter complex ( wp ), dimension ( 3 ) :: v call compute_eigenvalues_and_eigenvectors ( 3 , a , w , z , ierr ) write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' eispack_test' write ( * , * ) '---------------' write ( * , * ) '' write ( * , * ) '' write ( * , * ) 'ierr = ' , ierr write ( * , * ) '' write ( * , * ) 'eigenvalues:' do i = 1 , 3 write ( * , * ) w ( i ,:) end do write ( * , * ) '' write ( * , * ) 'eigenvectors (normalized):' do i = 1 , 3 if ( w ( i , 2 ) == 0.0_wp ) then ! If the J-th eigenvalue is real, the ! J-th column of Z contains its eigenvector do j = 1 , 3 v ( j ) = cmplx ( z ( j , i ), 0.0_wp , wp ) end do elseif ( w ( i , 2 ) > 0.0_wp ) then ! If the J-th eigenvalue is complex with positive imaginary part, the ! J-th and (J+1)-th columns of Z contain the real and ! imaginary parts of its eigenvector. do j = 1 , 3 v ( j ) = cmplx ( z ( j , i ), z ( j , i + 1 ), wp ) end do else do j = 1 , 3 v ( j ) = cmplx ( z ( j , i - 1 ), - z ( j , i ), wp ) end do end if v = v / sqrt ( dot_product ( v , v )) do j = 1 , 3 write ( * , '(F16.6,F16.6)' ) v ( j )% re , v ( j )% im end do write ( * , * ) '' end do ! ... results: ! eigenvalues: ! -1.89041207397761       0.000000000000000E+000 ! 3.44570603698881        5.01584673789593 ! 3.44570603698881       -5.01584673789593 ! ! eigenvectors: ! 0.650411095383963      -0.379058329718174      -0.373946474570154 ! 0.605673686824173       0.640277015571315      -7.629236177444867E-002 ! 8.565310483790509E-002 -0.395692850335186        1.34627813418190 ! ... from numpy: ! eigenvalues: ! array([-1.89041207+0.j        ,  3.44570604+5.01584674j, 3.44570604-5.01584674j]) ! ! eigenvectors: ! array([[ 0.77377504  ,  0.03085326-0.3669729j  ,  0.03085326+0.3669729j ], !        [-0.4509546   , -0.25965047-0.37137631j , -0.25965047+0.37137631j], !        [-0.44487317  ,  0.81181293             ,  0.81181293            ] ]) end subroutine eispack_test","tags":"","url":"proc/eispack_test.html"},{"title":"initialize_geopotential_model – fortran-astrodynamics-toolkit","text":"private  function initialize_geopotential_model(itype, gravfile, n, m) result(cp) bind(c,name='initialize_geopotential_model') mueller method Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: itype mode : 1 (Mueller) is only mode\ncurrently supported type(c_ptr), intent(in), value :: gravfile gravity coefficient file name integer(kind=c_int), intent(in), value :: n degree integer(kind=c_int), intent(in), value :: m order Return Value type(c_ptr) pointer to a container containing a geopotential_model Calls proc~~initialize_geopotential_model~~CallsGraph proc~initialize_geopotential_model initialize_geopotential_model destroy destroy proc~initialize_geopotential_model->destroy initialize initialize proc~initialize_geopotential_model->initialize proc~c_ptr_to_f_string c_ptr_to_f_string proc~initialize_geopotential_model->proc~c_ptr_to_f_string interface~strlen strlen proc~c_ptr_to_f_string->interface~strlen s s proc~c_ptr_to_f_string->s Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function initialize_geopotential_model ( itype , gravfile , n , m ) & result ( cp ) bind ( c , name = 'initialize_geopotential_model' ) implicit none integer ( c_int ), intent ( in ), value :: itype !! mode : !! !! * 1 (Mueller) is only mode !! currently supported type ( c_ptr ), intent ( in ), value :: gravfile !! gravity coefficient file name integer ( c_int ), intent ( in ), value :: n !! degree integer ( c_int ), intent ( in ), value :: m !! order type ( c_ptr ) :: cp !! pointer to a [[container]] !! containing a [[geopotential_model]] type ( container ), pointer :: grav_container !! Fortran version of `cp` class ( geopotential_model ), pointer :: grav !! the data in the container logical :: status_ok !! initialization status flag character ( len = :), allocatable :: gravfile_f !! Fortran version of `gravfile` allocate ( grav_container ) select case ( itype ) case ( 1 ) !! mueller method allocate ( geopotential_model_mueller :: grav_container % data ) select type ( g => grav_container % data ) class is ( geopotential_model_mueller ) ! get the gravity file name: call c_ptr_to_f_string ( gravfile , gravfile_f ) call g % initialize ( gravfile_f , n , m , status_ok ) if (. not . status_ok ) then write ( * , * ) 'error in initialize!' call g % destroy () cp = c_null_ptr else cp = c_loc ( grav_container ) end if end select case default error stop 'error: invalid itype input' end select ! if there was an error: if ( c_associated ( cp , c_null_ptr )) then deallocate ( grav_container ) end if end function initialize_geopotential_model","tags":"","url":"proc/initialize_geopotential_model.html"},{"title":"destroy_geopotential_model – fortran-astrodynamics-toolkit","text":"private  subroutine destroy_geopotential_model(cp) bind(c,name='destroy_geopotential_model') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: cp pointer to a container containing a geopotential_model Calls proc~~destroy_geopotential_model~2~~CallsGraph proc~destroy_geopotential_model~2 destroy_geopotential_model destroy destroy proc~destroy_geopotential_model~2->destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy_geopotential_model ( cp ) bind ( c , name = 'destroy_geopotential_model' ) implicit none type ( c_ptr ), intent ( in ), value :: cp !! pointer to a [[container]] !! containing a [[geopotential_model]] type ( container ), pointer :: grav_container !! Fortran version of `cp` ! convert cp to fortran: call c_f_pointer ( cp , grav_container ) if ( associated ( grav_container )) then select type ( g => grav_container % data ) class is ( geopotential_model ) call g % destroy () !cp = c_null_ptr  ! should we do this too (make inout ?) end select deallocate ( grav_container ) else error stop 'error: pointer is not associated' end if end subroutine destroy_geopotential_model","tags":"","url":"proc/destroy_geopotential_model~2.html"},{"title":"get_acceleration – fortran-astrodynamics-toolkit","text":"private  subroutine get_acceleration(cp, n, m, rvec, acc) bind(c,name='get_acceleration') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: cp pointer to a container containing a geopotential_model integer(kind=c_int), intent(in), value :: n degree integer(kind=c_int), intent(in), value :: m order real(kind=c_double), intent(in), dimension(3) :: rvec position vector real(kind=c_double), intent(out), dimension(3) :: acc acceleration vector Calls proc~~get_acceleration~~CallsGraph proc~get_acceleration get_acceleration get_acc get_acc proc~get_acceleration->get_acc Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_acceleration ( cp , n , m , rvec , acc ) bind ( c , name = 'get_acceleration' ) implicit none type ( c_ptr ), intent ( in ), value :: cp !! pointer to a [[container]] !! containing a [[geopotential_model]] integer ( c_int ), intent ( in ), value :: n !! degree integer ( c_int ), intent ( in ), value :: m !! order real ( c_double ), dimension ( 3 ), intent ( in ) :: rvec !! position vector real ( c_double ), dimension ( 3 ), intent ( out ) :: acc !! acceleration vector type ( container ), pointer :: grav_container !! Fortran version of `cp` ! just in case wp /= c_double, we have to make a copy here real ( wp ), dimension ( 3 ) :: rvec_f !! position vector real ( wp ), dimension ( 3 ) :: acc_f !! acceleration vector ! convert cp to fortran: call c_f_pointer ( cp , grav_container ) if ( associated ( grav_container )) then select type ( g => grav_container % data ) class is ( geopotential_model ) rvec_f = rvec call g % get_acc ( rvec_f , n , m , acc_f ) acc = acc_f end select else error stop 'error: pointer is not associated' end if end subroutine get_acceleration","tags":"","url":"proc/get_acceleration.html"},{"title":"c_ptr_to_f_string – fortran-astrodynamics-toolkit","text":"private  subroutine c_ptr_to_f_string(cp, fstr) Convert a c_ptr to a string into a Fortran string. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: cp character(len=:), intent(out), allocatable :: fstr Calls proc~~c_ptr_to_f_string~~CallsGraph proc~c_ptr_to_f_string c_ptr_to_f_string interface~strlen strlen proc~c_ptr_to_f_string->interface~strlen s s proc~c_ptr_to_f_string->s Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~c_ptr_to_f_string~~CalledByGraph proc~c_ptr_to_f_string c_ptr_to_f_string proc~initialize_geopotential_model initialize_geopotential_model proc~initialize_geopotential_model->proc~c_ptr_to_f_string Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine c_ptr_to_f_string ( cp , fstr ) implicit none type ( c_ptr ), intent ( in ) :: cp character ( len = :), allocatable , intent ( out ) :: fstr integer :: ilen !! string length ilen = strlen ( cp ) block !convert the C string to a Fortran string character ( kind = c_char , len = ilen + 1 ), pointer :: s call c_f_pointer ( cp , s ) fstr = s ( 1 : ilen ) nullify ( s ) end block end subroutine c_ptr_to_f_string","tags":"","url":"proc/c_ptr_to_f_string.html"},{"title":"f_string_to_c_ptr – fortran-astrodynamics-toolkit","text":"private  subroutine f_string_to_c_ptr(fstr, buffer) Convert a Fortran string to a c_ptr to a string.\n(the C string must already have been allocated to a fixed size) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fstr type(c_ptr), intent(inout) :: buffer a preallocated string buffer Calls proc~~f_string_to_c_ptr~~CallsGraph proc~f_string_to_c_ptr f_string_to_c_ptr interface~strlen strlen proc~f_string_to_c_ptr->interface~strlen s s proc~f_string_to_c_ptr->s Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~f_string_to_c_ptr~~CalledByGraph proc~f_string_to_c_ptr f_string_to_c_ptr proc~return_a_string return_a_string proc~return_a_string->proc~f_string_to_c_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine f_string_to_c_ptr ( fstr , buffer ) implicit none character ( len =* ), intent ( in ) :: fstr type ( c_ptr ), intent ( inout ) :: buffer !! a preallocated string buffer integer :: ilen !! string length of buffer ilen = strlen ( buffer ) block character ( kind = c_char , len = ilen + 1 ), pointer :: s call c_f_pointer ( buffer , s ) s ( 1 : min ( len ( fstr ), ilen )) = fstr ( 1 : min ( len ( fstr ), ilen )) buffer = c_loc ( s ) end block end subroutine f_string_to_c_ptr","tags":"","url":"proc/f_string_to_c_ptr.html"},{"title":"return_a_string – fortran-astrodynamics-toolkit","text":"private  subroutine return_a_string(ival, buffer) bind(c,name='return_a_string') Just a test of f_string_to_c_ptr . Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: ival type(c_ptr), intent(inout) :: buffer a preallocated string buffer Calls proc~~return_a_string~~CallsGraph proc~return_a_string return_a_string proc~f_string_to_c_ptr f_string_to_c_ptr proc~return_a_string->proc~f_string_to_c_ptr interface~strlen strlen proc~f_string_to_c_ptr->interface~strlen s s proc~f_string_to_c_ptr->s Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine return_a_string ( ival , buffer ) bind ( c , name = 'return_a_string' ) implicit none integer ( c_int ), intent ( in ), value :: ival type ( c_ptr ), intent ( inout ) :: buffer !! a preallocated string buffer call f_string_to_c_ptr ( repeat ( '*' , ival ), buffer ) end subroutine return_a_string","tags":"","url":"proc/return_a_string.html"},{"title":"strlen – fortran-astrodynamics-toolkit","text":"interface Called by interface~~strlen~~CalledByGraph interface~strlen strlen proc~c_ptr_to_f_string c_ptr_to_f_string proc~c_ptr_to_f_string->interface~strlen proc~f_string_to_c_ptr f_string_to_c_ptr proc~f_string_to_c_ptr->interface~strlen proc~initialize_geopotential_model initialize_geopotential_model proc~initialize_geopotential_model->proc~c_ptr_to_f_string proc~return_a_string return_a_string proc~return_a_string->proc~f_string_to_c_ptr Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. private  function strlen(str) result(isize) bind(C, name='strlen') Arguments Type Intent Optional Attributes Name type(c_ptr), value :: str Return Value integer(kind=c_int) Description C string length","tags":"","url":"interface/strlen.html"},{"title":"initialize – fortran-astrodynamics-toolkit","text":"private  subroutine initialize(me, n, f, report, g) Initialize the rk_class . Type Bound rk_class Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me integer, intent(in) :: n number of variables procedure( deriv_func ) :: f derivative function procedure( report_func ), optional :: report for reporting the steps procedure( event_func ), optional :: g for stopping at an event Calls proc~~initialize~~CallsGraph proc~initialize rk_class%initialize proc~destroy rk_class%destroy proc~initialize->proc~destroy Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~initialize~~CalledByGraph proc~initialize rk_class%initialize proc~compute_halo_monodromy_matrix compute_halo_monodromy_matrix proc~compute_halo_monodromy_matrix->proc~initialize proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~initialize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize ( me , n , f , report , g ) implicit none class ( rk_class ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of variables procedure ( deriv_func ) :: f !! derivative function procedure ( report_func ), optional :: report !! for reporting the steps procedure ( event_func ), optional :: g !! for stopping at an event call me % destroy () me % n = n me % f => f if ( present ( report )) me % report => report if ( present ( g )) me % g => g end subroutine initialize","tags":"","url":"proc/initialize.html"},{"title":"destroy – fortran-astrodynamics-toolkit","text":"private  subroutine destroy(me) Destructor for rk_class . Type Bound rk_class Arguments Type Intent Optional Attributes Name class( rk_class ), intent(out) :: me Called by proc~~destroy~~CalledByGraph proc~destroy rk_class%destroy proc~initialize rk_class%initialize proc~initialize->proc~destroy proc~compute_halo_monodromy_matrix compute_halo_monodromy_matrix proc~compute_halo_monodromy_matrix->proc~initialize proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~initialize Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy ( me ) implicit none class ( rk_class ), intent ( out ) :: me end subroutine destroy","tags":"","url":"proc/destroy.html"},{"title":"integrate – fortran-astrodynamics-toolkit","text":"private  subroutine integrate(me, t0, x0, h, tf, xf) Main integration routine for the rk_class . Type Bound rk_class Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tf final time real(kind=wp), intent(out), dimension(me%n) :: xf final state Calls proc~~integrate~~CallsGraph proc~integrate rk_class%integrate step step proc~integrate->step Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~integrate~~CalledByGraph proc~integrate rk_class%integrate proc~compute_halo_monodromy_matrix compute_halo_monodromy_matrix proc~compute_halo_monodromy_matrix->proc~integrate proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~integrate proc~rk_test rk_test proc~rk_test->proc~integrate Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine integrate ( me , t0 , x0 , h , tf , xf ) implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t0 !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x0 !! initial state real ( wp ), intent ( in ) :: h !! abs(time step) real ( wp ), intent ( in ) :: tf !! final time real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! final state real ( wp ) :: t , dt , t2 real ( wp ), dimension ( me % n ) :: x logical :: last , export if (. not . associated ( me % f )) error stop 'Error in integrate: f is not associated.' export = associated ( me % report ) if ( export ) call me % report ( t0 , x0 ) !first point if ( h == zero ) then xf = x0 else t = t0 x = x0 dt = sign ( h , tf - t0 ) !time step (correct sign) do t2 = t + dt last = (( dt >= zero . and . t2 >= tf ) . or . & !adjust last time step ( dt < zero . and . t2 <= tf )) ! if ( last ) dt = tf - t ! call me % step ( t , x , dt , xf ) if ( last ) exit if ( export ) call me % report ( t2 , xf ) !intermediate point x = xf t = t2 end do end if if ( export ) call me % report ( tf , xf ) !last point end subroutine integrate","tags":"","url":"proc/integrate.html"},{"title":"integrate_to_event – fortran-astrodynamics-toolkit","text":"private  subroutine integrate_to_event(me, t0, x0, h, tmax, tol, tf, xf, gf) Uses brent_module proc~~integrate_to_event~~UsesGraph proc~integrate_to_event rk_class%integrate_to_event module~brent_module brent_module proc~integrate_to_event->module~brent_module module~kind_module kind_module module~brent_module->module~kind_module module~numbers_module numbers_module module~brent_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Event-finding integration routine for the rk_class .\nIntegrates until g(t,x)=0, or until t=tf (whichever happens first). This is a work in progress. Type Bound rk_class Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tmax max final time if event not located real(kind=wp), intent(in) :: tol function tolerance for root finding real(kind=wp), intent(out) :: tf actual final time reached real(kind=wp), intent(out), dimension(me%n) :: xf final state (at tf) real(kind=wp), intent(out) :: gf g value at tf Calls proc~~integrate_to_event~~CallsGraph proc~integrate_to_event rk_class%integrate_to_event proc~set_function brent_class%set_function proc~integrate_to_event->proc~set_function proc~zeroin brent_class%zeroin proc~integrate_to_event->proc~zeroin step step proc~integrate_to_event->step Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~integrate_to_event~~CalledByGraph proc~integrate_to_event rk_class%integrate_to_event proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~integrate_to_event proc~rk_test rk_test proc~rk_test->proc~integrate_to_event Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine integrate_to_event ( me , t0 , x0 , h , tmax , tol , tf , xf , gf ) use brent_module implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t0 !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x0 !! initial state real ( wp ), intent ( in ) :: h !! abs(time step) real ( wp ), intent ( in ) :: tmax !! max final time if event not located real ( wp ), intent ( in ) :: tol !! function tolerance for root finding real ( wp ), intent ( out ) :: tf !! actual final time reached real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! final state (at tf) real ( wp ), intent ( out ) :: gf !! g value at tf !local variables: real ( wp ) :: t , dt , t2 , ga , gb , dt_root , dum real ( wp ), dimension ( me % n ) :: x , g_xf logical :: first , last , export procedure ( report_func ), pointer :: report type ( brent_class ) :: solver integer :: iflag if (. not . associated ( me % f )) error stop 'Error in integrate_to_event: f is not associated.' if (. not . associated ( me % g )) error stop 'Error in integrate_to_event: g is not associated.' if ( h == zero ) error stop 'Error in integrate_to_event: h must not be zero.' !If the points are being exported: export = associated ( me % report ) !first point: if ( export ) call me % report ( t0 , x0 ) if ( t0 == tmax ) then xf = x0 tf = t0 call me % g ( t0 , x0 , gf ) else first = . true . t = t0 x = x0 call me % g ( t0 , x0 , ga ) !evaluate event function dt = sign ( h , tmax - t0 ) !time step (correct sign) do t2 = t + dt last = (( dt >= zero . and . t2 >= tmax ) . or . & !adjust last time step ( dt < zero . and . t2 <= tmax )) ! if ( last ) then dt = tmax - t t2 = tmax end if call me % step ( t , x , dt , xf ) call me % g ( t2 , xf , gb ) !evaluate event function if ( first . and . abs ( ga ) <= tol ) then !we ignore a root at t0 after the first step if ( abs ( gb ) <= tol ) then !check this one since it could have landed on a root gf = gb tf = t2 exit else if ( last ) then !exiting without having found a root tf = t2 gf = gb exit end if if ( export ) call me % report ( t2 , xf ) !intermediate point x = xf t = t2 ga = gb end if elseif ( ga * gb <= zero ) then !there is a root somewhere on [t,t+dt] !find the root: call solver % set_function ( solver_func ) call solver % find_zero ( zero , dt , tol , dt_root , dum , iflag , ga , gb ) t2 = t + dt_root gf = solver_func ( solver , dt_root ) tf = t2 xf = g_xf !computed in the solver function exit else !no root yet, continue if ( last ) then !exiting without having found a root tf = t2 gf = gb exit end if if ( export ) call me % report ( t2 , xf ) !intermediate point x = xf t = t2 ga = gb end if if ( first ) first = . false . end do end if if ( export ) call me % report ( t2 , xf ) !last point contains function solver_func ( this , delt ) result ( g ) !! root solver function. The input is the dt offset from time t. implicit none class ( brent_class ), intent ( inout ) :: this real ( wp ), intent ( in ) :: delt !! from [0 to dt] real ( wp ) :: g !take a step from t to t+delt and evaluate g function: call me % step ( t , x , delt , g_xf ) call me % g ( t + delt , g_xf , g ) end function solver_func end subroutine integrate_to_event","tags":"","url":"proc/integrate_to_event.html"},{"title":"rk4 – fortran-astrodynamics-toolkit","text":"private  subroutine rk4(me, t, x, h, xf) Take one Runge Kutta 4 integration step: t -> t+h (x -> xf) Type Bound rk4_class Arguments Type Intent Optional Attributes Name class( rk4_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h Source Code subroutine rk4 ( me , t , x , h , xf ) implicit none class ( rk4_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state real ( wp ), intent ( in ) :: h !! time step real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! state at time `t+h` !local variables: real ( wp ), dimension ( me % n ) :: f1 , f2 , f3 , f4 real ( wp ) :: h2 !parameters: real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: six = 6.0_wp h2 = half * h call me % f ( t , x , f1 ) call me % f ( t + h2 , x + h2 * f1 , f2 ) call me % f ( t + h2 , x + h2 * f2 , f3 ) call me % f ( t + h , x + h * f3 , f4 ) xf = x + h * ( f1 + f2 + f2 + f3 + f3 + f4 ) / six end subroutine rk4","tags":"","url":"proc/rk4.html"},{"title":"rk8_10 – fortran-astrodynamics-toolkit","text":"private  subroutine rk8_10(me, t, x, h, xf) Take one Runge Kutta 8 integration step: t -> t+h (x -> xf) This is Formula (8-10) from Reference [1]. Reference E. B. Shanks, \" Higher Order Approximations of Runge-Kutta Type \",\n     NASA Technical Note, NASA TN D-2920, Sept. 1965. Type Bound rk8_10_class Arguments Type Intent Optional Attributes Name class( rk8_10_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h Source Code subroutine rk8_10 ( me , t , x , h , xf ) implicit none class ( rk8_10_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state real ( wp ), intent ( in ) :: h !! time step real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! state at time `t+h` !local variables: real ( wp ), dimension ( me % n ) :: f0 , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 !parameters: real ( wp ), parameter :: a1 = 4.0_wp / 2 7.0_wp real ( wp ), parameter :: a2 = 2.0_wp / 9.0_wp real ( wp ), parameter :: a3 = 1.0_wp / 3.0_wp real ( wp ), parameter :: a4 = 1.0_wp / 2.0_wp real ( wp ), parameter :: a5 = 2.0_wp / 3.0_wp real ( wp ), parameter :: a6 = 1.0_wp / 6.0_wp real ( wp ), parameter :: a8 = 5.0_wp / 6.0_wp real ( wp ), parameter :: c = 1.0_wp / 84 0.0_wp real ( wp ), parameter :: c0 = 4 1.0_wp real ( wp ), parameter :: c3 = 2 7.0_wp real ( wp ), parameter :: c4 = 27 2.0_wp real ( wp ), parameter :: c5 = 2 7.0_wp real ( wp ), parameter :: c6 = 21 6.0_wp real ( wp ), parameter :: c8 = 21 6.0_wp real ( wp ), parameter :: c9 = 4 1.0_wp real ( wp ), parameter :: aa1 = 4.0_wp / 2 7.0_wp real ( wp ), parameter :: aa2 = 1.0_wp / 1 8.0_wp real ( wp ), parameter :: aa3 = 1.0_wp / 1 2.0_wp real ( wp ), parameter :: aa4 = 1.0_wp / 8.0_wp real ( wp ), parameter :: aa5 = 1.0_wp / 5 4.0_wp real ( wp ), parameter :: aa6 = 1.0_wp / 432 0.0_wp real ( wp ), parameter :: aa7 = 1.0_wp / 2 0.0_wp real ( wp ), parameter :: aa8 = 1.0_wp / 28 8.0_wp real ( wp ), parameter :: aa9 = 1.0_wp / 82 0.0_wp real ( wp ), parameter :: b21 = 3.0_wp real ( wp ), parameter :: b32 = 3.0_wp real ( wp ), parameter :: b43 = 3.0_wp real ( wp ), parameter :: b50 = 1 3.0_wp real ( wp ), parameter :: b52 = - 2 7.0_wp real ( wp ), parameter :: b53 = 4 2.0_wp real ( wp ), parameter :: b54 = 8.0_wp real ( wp ), parameter :: b60 = 38 9.0_wp real ( wp ), parameter :: b62 = - 5 4.0_wp real ( wp ), parameter :: b63 = 96 6.0_wp real ( wp ), parameter :: b64 = - 82 4.0_wp real ( wp ), parameter :: b65 = 24 3.0_wp real ( wp ), parameter :: b70 = - 23 1.0_wp real ( wp ), parameter :: b72 = 8 1.0_wp real ( wp ), parameter :: b73 = - 116 4.0_wp real ( wp ), parameter :: b74 = 65 6.0_wp real ( wp ), parameter :: b75 = - 12 2.0_wp real ( wp ), parameter :: b76 = 80 0.0_wp real ( wp ), parameter :: b80 = - 12 7.0_wp real ( wp ), parameter :: b82 = 1 8.0_wp real ( wp ), parameter :: b83 = - 67 8.0_wp real ( wp ), parameter :: b84 = 45 6.0_wp real ( wp ), parameter :: b85 = - 9.0_wp real ( wp ), parameter :: b86 = 57 6.0_wp real ( wp ), parameter :: b87 = 4.0_wp real ( wp ), parameter :: b90 = 148 1.0_wp real ( wp ), parameter :: b92 = - 8 1.0_wp real ( wp ), parameter :: b93 = 710 4.0_wp real ( wp ), parameter :: b94 = - 337 6.0_wp real ( wp ), parameter :: b95 = 7 2.0_wp real ( wp ), parameter :: b96 = - 504 0.0_wp real ( wp ), parameter :: b97 = - 6 0.0_wp real ( wp ), parameter :: b98 = 72 0.0_wp call me % f ( t , x , f0 ) call me % f ( t + a1 * h , x + aa1 * h * f0 , f1 ) call me % f ( t + a2 * h , x + aa2 * h * ( f0 + b21 * f1 ), f2 ) call me % f ( t + a3 * h , x + aa3 * h * ( f0 + b32 * f2 ), f3 ) call me % f ( t + a4 * h , x + aa4 * h * ( f0 + b43 * f3 ), f4 ) call me % f ( t + a5 * h , x + aa5 * h * ( b50 * f0 + b52 * f2 + b53 * f3 + b54 * f4 ), f5 ) call me % f ( t + a6 * h , x + aa6 * h * ( b60 * f0 + b62 * f2 + b63 * f3 + b64 * f4 + b65 * f5 ), f6 ) call me % f ( t + h , x + aa7 * h * ( b70 * f0 + b72 * f2 + b73 * f3 + b74 * f4 + b75 * f5 + b76 * f6 ), f7 ) call me % f ( t + a8 * h , x + aa8 * h * ( b80 * f0 + b82 * f2 + b83 * f3 + b84 * f4 + b85 * f5 + b86 * f6 + b87 * f7 ), f8 ) call me % f ( t + h , x + aa9 * h * ( b90 * f0 + b92 * f2 + b93 * f3 + b94 * f4 + b95 * f5 + b96 * f6 + b97 * f7 + b98 * f8 ), f9 ) xf = x + h * c * ( c0 * f0 + c3 * f3 + c4 * f4 + c5 * f5 + c6 * f6 + c8 * f8 + c9 * f9 ) end subroutine rk8_10","tags":"","url":"proc/rk8_10.html"},{"title":"rk_test – fortran-astrodynamics-toolkit","text":"public  subroutine rk_test() Unit test of the rk_module .\nIntegrate a two-body orbit around the Earth. Arguments None Calls proc~~rk_test~~CallsGraph proc~rk_test rk_test proc~integrate rk_class%integrate proc~rk_test->proc~integrate proc~integrate_to_event rk_class%integrate_to_event proc~rk_test->proc~integrate_to_event step step proc~integrate->step proc~set_function brent_class%set_function proc~integrate_to_event->proc~set_function proc~zeroin brent_class%zeroin proc~integrate_to_event->proc~zeroin proc~integrate_to_event->step Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine rk_test () type , extends ( rk4_class ) :: spacecraft !! spacecraft propagation type. !! extends the [[rk4_class]] to include data used in the deriv routine real ( wp ) :: mu = zero !! central body gravitational parameter (km3/s2) integer :: fevals = 0 !! number of function evaluations logical :: first = . true . !! first point is being exported end type spacecraft integer , parameter :: n = 6 !! number of state variables real ( wp ), parameter :: tol = 1.0e-12_wp !! event location tolerance type ( spacecraft ) :: s , s2 real ( wp ) :: t0 , tf , x0 ( n ), dt , xf ( n ), x02 ( n ), gf , tf_actual write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' rk_test' write ( * , * ) '---------------' write ( * , * ) '' !*************************************************************************** !constructor (main body is Earth): s = spacecraft ( n = n , f = twobody , mu = 39860 0.436233_wp , report = twobody_report ) !initial conditions: x0 = [ 1000 0.0_wp , 1000 0.0_wp , 1000 0.0_wp ,& !initial state [r,v] (km,km/s) 1.0_wp , 2.0_wp , 3.0_wp ] t0 = zero !initial time (sec) dt = 1 0.0_wp !time step (sec) tf = 100 0.0_wp !final time (sec) s % fevals = 0 s % first = . true . call s % integrate ( t0 , x0 , dt , tf , xf ) !forward write ( * , * ) '' write ( * , '(A/,*(F15.6/))' ) 'Final state:' , xf s % fevals = 0 s % report => null () !disable reporting call s % integrate ( tf , xf , - dt , t0 , x02 ) !backwards write ( * , '(A/,*(E20.12/))' ) 'Error:' , x02 - x0 write ( * , '(A,I5)' ) 'Function evaluations:' , s % fevals write ( * , * ) '' !*************************************************************************** !event finding test: write ( * , * ) ' Event test - integrate until z = 12,000' s2 = spacecraft ( n = n , f = twobody , g = twobody_event , mu = 39860 0.436233_wp , report = twobody_report ) x0 = [ 1000 0.0_wp , 1000 0.0_wp , 1000 0.0_wp ,& !initial state [r,v] (km,km/s) 1.0_wp , 2.0_wp , 3.0_wp ] t0 = zero !initial time (sec) dt = 1 0.0_wp !time step (sec) tf = 100 0.0_wp !final time (sec) call s2 % integrate_to_event ( t0 , x0 , dt , tf , tol , tf_actual , xf , gf ) write ( * , * ) '' write ( * , '(A/,*(F15.6/))' ) 'Final time: ' , tf_actual write ( * , '(A/,*(F15.6/))' ) 'Final state:' , xf write ( * , '(A/,*(F15.6/))' ) 'Event func :' , gf contains !***************************************************************************************** !********************************************************* subroutine twobody ( me , t , x , xdot ) !! derivative routine for two-body orbit propagation implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension ( me % n ), intent ( in ) :: x real ( wp ), dimension ( me % n ), intent ( out ) :: xdot real ( wp ), dimension ( 3 ) :: r , v , a_grav real ( wp ) :: rmag select type ( me ) class is ( spacecraft ) r = x ( 1 : 3 ) v = x ( 4 : 6 ) rmag = norm2 ( r ) a_grav = - me % mu / rmag ** 3 * r !acceleration due to gravity xdot ( 1 : 3 ) = v xdot ( 4 : 6 ) = a_grav me % fevals = me % fevals + 1 end select end subroutine twobody !********************************************************* !********************************************************* subroutine twobody_report ( me , t , x ) !! report function - write time,state to console implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension ( me % n ), intent ( in ) :: x select type ( me ) class is ( spacecraft ) if ( me % first ) then !print header write ( * , * ) '' write ( * , '(*(A15,1X))' ) 'time (sec)' , 'x (km)' , 'y (km)' , 'z (km)' ,& 'vx (km/s)' , 'vy (km/s)' , 'vz (km/s)' me % first = . false . end if end select write ( * , '(*(F15.6,1X))' ) t , x end subroutine twobody_report !********************************************************* !********************************************************* subroutine twobody_event ( me , t , x , g ) !! event function (z = 12,000) implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension ( me % n ), intent ( in ) :: x real ( wp ), intent ( out ) :: g g = x ( 3 ) - 1200 0.0_wp end subroutine twobody_event !********************************************************* end subroutine rk_test","tags":"","url":"proc/rk_test.html"},{"title":"deriv_func – fortran-astrodynamics-toolkit","text":"interface private  subroutine deriv_func(me, t, x, xdot) Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t time real(kind=wp), intent(in), dimension(me%n) :: x state vector real(kind=wp), intent(out), dimension(me%n) :: xdot derivative of state vector Description derivative function","tags":"","url":"interface/deriv_func.html"},{"title":"event_func – fortran-astrodynamics-toolkit","text":"interface private  subroutine event_func(me, t, x, g) Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t time real(kind=wp), intent(in), dimension(me%n) :: x state vector real(kind=wp), intent(out) :: g g(t,x). The goal is to stop the integration when g=0. Description event function","tags":"","url":"interface/event_func.html"},{"title":"report_func – fortran-astrodynamics-toolkit","text":"interface private  subroutine report_func(me, t, x) Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t time real(kind=wp), intent(in), dimension(me%n) :: x state vector Description report function","tags":"","url":"interface/report_func.html"},{"title":"step_func – fortran-astrodynamics-toolkit","text":"interface private  subroutine step_func(me, t, x, h, xf) Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state vector real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf final state vector Description rk step function","tags":"","url":"interface/step_func.html"},{"title":"two_body_rotating_frame_constructor – fortran-astrodynamics-toolkit","text":"private pure function two_body_rotating_frame_constructor(primary_body, secondary_body, center, et, inertial) result(f) Constructor for a two_body_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: primary_body the primary body of\nthe frame type( celestial_body ), intent(in) :: secondary_body the secondary body used\nto construct the frame integer, intent(in) :: center the frame center (can\nbe primary_body , secondary_body , or barycenter ) real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] logical, intent(in), optional :: inertial if true, it's a quasi-inertial frame\n[default is false] Return Value type( two_body_rotating_frame ) Called by proc~~two_body_rotating_frame_constructor~~CalledByGraph proc~two_body_rotating_frame_constructor two_body_rotating_frame_constructor interface~two_body_rotating_frame two_body_rotating_frame interface~two_body_rotating_frame->proc~two_body_rotating_frame_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function two_body_rotating_frame_constructor (& primary_body , secondary_body , center , et , inertial ) result ( f ) implicit none type ( two_body_rotating_frame ) :: f type ( celestial_body ), intent ( in ) :: primary_body !! the primary body of !! the frame type ( celestial_body ), intent ( in ) :: secondary_body !! the secondary body used !! to construct the frame integer , intent ( in ) :: center !! the frame center (can !! be `primary_body`, !! `secondary_body`, or !! `barycenter`) real ( wp ), intent ( in ) :: et !! epoch at which the !! frame is defined [sec] logical , intent ( in ), optional :: inertial !! if true, it's a quasi-inertial frame !! [default is false] f % primary_body = primary_body f % secondary_body = secondary_body f % center = center f % et = et if ( present ( inertial )) f % inertial = inertial end function two_body_rotating_frame_constructor","tags":"","url":"proc/two_body_rotating_frame_constructor.html"},{"title":"two_body_rotating_pulsating_frame_constructor – fortran-astrodynamics-toolkit","text":"private pure function two_body_rotating_pulsating_frame_constructor(primary_body, secondary_body, center, scale, et) result(f) Constructor for a two_body_rotating_pulsating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: primary_body the primary body of\nthe frame type( celestial_body ), intent(in) :: secondary_body the secondary body used\nto construct the frame integer, intent(in) :: center the frame center (can\nbe primary_body , secondary_body , or barycenter ) real(kind=wp), intent(in) :: scale scale factor real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( two_body_rotating_pulsating_frame ) Called by proc~~two_body_rotating_pulsating_frame_constructor~~CalledByGraph proc~two_body_rotating_pulsating_frame_constructor two_body_rotating_pulsating_frame_constructor interface~two_body_rotating_pulsating_frame two_body_rotating_pulsating_frame interface~two_body_rotating_pulsating_frame->proc~two_body_rotating_pulsating_frame_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function two_body_rotating_pulsating_frame_constructor (& primary_body , secondary_body , center , scale , et ) result ( f ) implicit none type ( two_body_rotating_pulsating_frame ) :: f type ( celestial_body ), intent ( in ) :: primary_body !! the primary body of !! the frame type ( celestial_body ), intent ( in ) :: secondary_body !! the secondary body used !! to construct the frame integer , intent ( in ) :: center !! the frame center (can !! be `primary_body`, !! `secondary_body`, or !! `barycenter`) real ( wp ), intent ( in ) :: scale !! scale factor real ( wp ), intent ( in ) :: et !! epoch at which the !! frame is defined [sec] f % primary_body = primary_body f % secondary_body = secondary_body f % center = center f % scale = scale f % et = et end function two_body_rotating_pulsating_frame_constructor","tags":"","url":"proc/two_body_rotating_pulsating_frame_constructor.html"},{"title":"iau_earth_rotating_frame_constructor – fortran-astrodynamics-toolkit","text":"private pure function iau_earth_rotating_frame_constructor(b, et) result(f) Constructor for a iau_earth_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( iau_earth_rotating_frame ) Called by proc~~iau_earth_rotating_frame_constructor~~CalledByGraph proc~iau_earth_rotating_frame_constructor iau_earth_rotating_frame_constructor interface~iau_earth_rotating_frame iau_earth_rotating_frame interface~iau_earth_rotating_frame->proc~iau_earth_rotating_frame_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function iau_earth_rotating_frame_constructor ( b , et ) result ( f ) implicit none type ( iau_earth_rotating_frame ) :: f type ( celestial_body ), intent ( in ) :: b !! the central body real ( wp ), intent ( in ) :: et !! epoch at which the !! frame is defined [sec] f % primary_body = b f % et = et end function iau_earth_rotating_frame_constructor","tags":"","url":"proc/iau_earth_rotating_frame_constructor.html"},{"title":"iau_moon_rotating_frame_constructor – fortran-astrodynamics-toolkit","text":"private pure function iau_moon_rotating_frame_constructor(b, et) result(f) Constructor for a iau_moon_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( iau_earth_rotating_frame ) Called by proc~~iau_moon_rotating_frame_constructor~~CalledByGraph proc~iau_moon_rotating_frame_constructor iau_moon_rotating_frame_constructor interface~iau_moon_rotating_frame iau_moon_rotating_frame interface~iau_moon_rotating_frame->proc~iau_moon_rotating_frame_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function iau_moon_rotating_frame_constructor ( b , et ) result ( f ) implicit none type ( iau_earth_rotating_frame ) :: f type ( celestial_body ), intent ( in ) :: b !! the central body real ( wp ), intent ( in ) :: et !! epoch at which the !! frame is defined [sec] f % primary_body = b f % et = et end function iau_moon_rotating_frame_constructor","tags":"","url":"proc/iau_moon_rotating_frame_constructor.html"},{"title":"icrf_frame_constructor – fortran-astrodynamics-toolkit","text":"private pure function icrf_frame_constructor(b) result(f) Constructor for a icrf_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body Return Value type( icrf_frame ) Called by proc~~icrf_frame_constructor~~CalledByGraph proc~icrf_frame_constructor icrf_frame_constructor interface~icrf_frame icrf_frame interface~icrf_frame->proc~icrf_frame_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function icrf_frame_constructor ( b ) result ( f ) implicit none type ( icrf_frame ) :: f type ( celestial_body ), intent ( in ) :: b !! the central body f % primary_body = b end function icrf_frame_constructor","tags":"","url":"proc/icrf_frame_constructor.html"},{"title":"ecliptic_frame_constructor – fortran-astrodynamics-toolkit","text":"private pure function ecliptic_frame_constructor(b) result(f) Constructor for a ecliptic_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body Return Value type( ecliptic_frame ) Called by proc~~ecliptic_frame_constructor~~CalledByGraph proc~ecliptic_frame_constructor ecliptic_frame_constructor interface~ecliptic_frame ecliptic_frame interface~ecliptic_frame->proc~ecliptic_frame_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function ecliptic_frame_constructor ( b ) result ( f ) implicit none type ( ecliptic_frame ) :: f type ( celestial_body ), intent ( in ) :: b !! the central body f % primary_body = b end function ecliptic_frame_constructor","tags":"","url":"proc/ecliptic_frame_constructor.html"},{"title":"transform – fortran-astrodynamics-toolkit","text":"private  subroutine transform(from, rv, to, et, eph, rv_out, status_ok) Transform a Cartesian state from one reference frame to another at\na specified epoch. The from and to reference_frame s may each\nbe defined at a different epoch. The et ephemeris time is the time\nthe transformation is to be done, and accounts for the motion of the two\nframe centers from from%et and to%et to et . Type Bound reference_frame Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: from real(kind=wp), intent(in), dimension(6) :: rv class( reference_frame ), intent(inout) :: to real(kind=wp), intent(in) :: et the time of the transformation [sec] class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(out), dimension(6) :: rv_out logical, intent(out) :: status_ok Calls proc~~transform~~CallsGraph proc~transform reference_frame%transform get_c_cdot get_c_cdot proc~transform->get_c_cdot proc~rvcto_rvcfrom_icrf rvcto_rvcfrom_icrf proc~transform->proc~rvcto_rvcfrom_icrf get_rv get_rv proc~rvcto_rvcfrom_icrf->get_rv proc~from_primary_to_center two_body_rotating_frame%from_primary_to_center proc~rvcto_rvcfrom_icrf->proc~from_primary_to_center proc~from_primary_to_center->get_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~transform~~CalledByGraph proc~transform reference_frame%transform proc~from_j2000body_to_j2000ssb from_j2000body_to_j2000ssb proc~from_j2000body_to_j2000ssb->proc~transform proc~transformation_module_test transformation_module_test proc~transformation_module_test->proc~transform proc~get_sun_fraction get_sun_fraction proc~get_sun_fraction->proc~from_j2000body_to_j2000ssb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine transform ( from , rv , to , et , eph , rv_out , status_ok ) implicit none class ( reference_frame ), intent ( inout ) :: from real ( wp ), dimension ( 6 ), intent ( in ) :: rv class ( reference_frame ), intent ( inout ) :: to real ( wp ), intent ( in ) :: et !! the time of the transformation [sec] class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) real ( wp ), dimension ( 6 ), intent ( out ) :: rv_out logical , intent ( out ) :: status_ok ! local variables real ( wp ), dimension ( 3 , 3 ) :: c , cdot real ( wp ), dimension ( 3 , 3 ) :: rot1 , rotd1 real ( wp ), dimension ( 3 , 3 ) :: rot2 , rotd2 real ( wp ), dimension ( 3 ) :: rc21_out , vc21_out real ( wp ), dimension ( 3 ) :: rc21_icrf , vc21_icrf ! rotation matrix: input -> inertial call from % get_c_cdot ( eph = eph , to_icrf = . true ., c = rot1 , cdot = rotd1 , status_ok = status_ok ) if (. not . status_ok ) then write ( error_unit , '(A)' ) 'Error in transform: ' // & 'Could not compute rotation matrix from FROM frame to inertial.' rv_out = zero return end if ! rotation matrix: inertial -> output call to % get_c_cdot ( eph = eph , to_icrf = . false ., c = rot2 , cdot = rotd2 , status_ok = status_ok ) if (. not . status_ok ) then write ( error_unit , '(A)' ) 'Error in transform: ' // & 'Could not compute rotation matrix from inertial to TO frame.' rv_out = zero return end if ! rotation matrix: input -> output c = matmul ( rot2 , rot1 ) cdot = matmul ( rotd2 , rot1 ) + matmul ( rot2 , rotd1 ) ! get the state of the `from` frame center w.r.t. the `to` frame center, ! at the transformation time: call rvcto_rvcfrom_icrf ( from , to , eph , et , & rc21_icrf , vc21_icrf , status_ok ) if ( status_ok ) then ! to->from frame center state: inertial -> output frame rc21_out = matmul ( rot2 , rc21_icrf ) vc21_out = matmul ( rotd2 , rc21_icrf ) + matmul ( rot2 , vc21_icrf ) ! rotation + translation: rv_out ( 1 : 3 ) = matmul ( c , rv ( 1 : 3 )) + rc21_out rv_out ( 4 : 6 ) = matmul ( c , rv ( 4 : 6 )) + matmul ( cdot , rv ( 1 : 3 )) + vc21_out else !error rv_out = zero end if end subroutine transform","tags":"","url":"proc/transform.html"},{"title":"rvcto_rvcfrom_icrf – fortran-astrodynamics-toolkit","text":"private  subroutine rvcto_rvcfrom_icrf(from, to, eph, et, rc21, vc21, status_ok) Returns the state of the from frame center w.r.t. the to frame center,\nat the specified ephemeris time et . Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(in) :: from class( reference_frame ), intent(in) :: to class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(in) :: et ephemeris time [sec] real(kind=wp), intent(out), dimension(3) :: rc21 position of from frame center w.r.t. to frame center real(kind=wp), intent(out), dimension(3) :: vc21 velocity of from frame center w.r.t. to frame center logical, intent(out) :: status_ok true if there were no errors Calls proc~~rvcto_rvcfrom_icrf~~CallsGraph proc~rvcto_rvcfrom_icrf rvcto_rvcfrom_icrf get_rv get_rv proc~rvcto_rvcfrom_icrf->get_rv proc~from_primary_to_center two_body_rotating_frame%from_primary_to_center proc~rvcto_rvcfrom_icrf->proc~from_primary_to_center proc~from_primary_to_center->get_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~rvcto_rvcfrom_icrf~~CalledByGraph proc~rvcto_rvcfrom_icrf rvcto_rvcfrom_icrf proc~transform reference_frame%transform proc~transform->proc~rvcto_rvcfrom_icrf proc~from_j2000body_to_j2000ssb from_j2000body_to_j2000ssb proc~from_j2000body_to_j2000ssb->proc~transform proc~transformation_module_test transformation_module_test proc~transformation_module_test->proc~transform proc~get_sun_fraction get_sun_fraction proc~get_sun_fraction->proc~from_j2000body_to_j2000ssb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine rvcto_rvcfrom_icrf ( from , to , eph , et , rc21 , vc21 , status_ok ) !! Returns the state of the `from` frame center w.r.t. the `to` frame center, !! at the specified ephemeris time `et`. implicit none class ( reference_frame ), intent ( in ) :: from class ( reference_frame ), intent ( in ) :: to class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) real ( wp ), intent ( in ) :: et !! ephemeris time [sec] real ( wp ), dimension ( 3 ), intent ( out ) :: rc21 !! position of `from` frame center w.r.t. `to` frame center real ( wp ), dimension ( 3 ), intent ( out ) :: vc21 !! velocity of `from` frame center w.r.t. `to` frame center logical , intent ( out ) :: status_ok !! true if there were no errors ! local variables real ( wp ), dimension ( 6 ) :: rvc1 !! inertial state of `from` frame center w.r.t. `from` primary body real ( wp ), dimension ( 6 ) :: rvc2 !! inertial state of `to`   frame center w.r.t. `to`   primary body real ( wp ), dimension ( 6 ) :: rvb21 !! inertial state of `from` primary body w.r.t. `to`   primary body real ( wp ), dimension ( 6 ) :: rvc21 !! inertial state of `from` frame center w.r.t. `to`   frame center ! get TO primary body -> FROM primary body state [inertial] call eph % get_rv ( et , from % primary_body , to % primary_body , rvb21 , status_ok ) if ( status_ok ) then ! currently, only the two-body rotating frames may be ! centered somewhere other than the primary body. select type ( from ) class is ( two_body_rotating_frame ) call from % from_primary_to_center ( eph , et , rvc1 , status_ok ) class default rvc1 = zero end select if ( status_ok ) then select type ( to ) class is ( two_body_rotating_frame ) call to % from_primary_to_center ( eph , et , rvc2 , status_ok ) class default rvc2 = zero end select if ( status_ok ) then rvc21 = rvb21 + rvc1 - rvc2 rc21 = rvc21 ( 1 : 3 ) vc21 = rvc21 ( 4 : 6 ) return else write ( error_unit , '(A)' ) 'Error in rvcto_rvcfrom_icrf: ' // & 'Could not compute center of TO frame.' end if else write ( error_unit , '(A)' ) 'Error in rvcto_rvcfrom_icrf: ' // & 'Could not compute center of FROM frame.' end if else !error write ( error_unit , '(A)' ) 'Error in rvcto_rvcfrom_icrf: ' // & 'Could not compute translation.' end if ! we end up here if there was an error: rc21 = zero vc21 = zero end subroutine rvcto_rvcfrom_icrf","tags":"","url":"proc/rvcto_rvcfrom_icrf.html"},{"title":"from_primary_to_center – fortran-astrodynamics-toolkit","text":"private  subroutine from_primary_to_center(me, eph, et, rc, status_ok) returns the state of the frame center w.r.t. the frame primary body. Type Bound two_body_rotating_frame Arguments Type Intent Optional Attributes Name class( two_body_rotating_frame ), intent(in) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(in) :: et ephemeris time [sec] real(kind=wp), intent(out), dimension(6) :: rc state of frame center w.r.t. primary body [inertial] logical, intent(out) :: status_ok true if no errors. Calls proc~~from_primary_to_center~~CallsGraph proc~from_primary_to_center two_body_rotating_frame%from_primary_to_center get_rv get_rv proc~from_primary_to_center->get_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~from_primary_to_center~~CalledByGraph proc~from_primary_to_center two_body_rotating_frame%from_primary_to_center proc~rvcto_rvcfrom_icrf rvcto_rvcfrom_icrf proc~rvcto_rvcfrom_icrf->proc~from_primary_to_center proc~transform reference_frame%transform proc~transform->proc~rvcto_rvcfrom_icrf proc~from_j2000body_to_j2000ssb from_j2000body_to_j2000ssb proc~from_j2000body_to_j2000ssb->proc~transform proc~transformation_module_test transformation_module_test proc~transformation_module_test->proc~transform proc~get_sun_fraction get_sun_fraction proc~get_sun_fraction->proc~from_j2000body_to_j2000ssb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_primary_to_center ( me , eph , et , rc , status_ok ) !! returns the state of the frame center w.r.t. the frame primary body. implicit none class ( two_body_rotating_frame ), intent ( in ) :: me class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) real ( wp ), intent ( in ) :: et !! ephemeris time [sec] real ( wp ), dimension ( 6 ), intent ( out ) :: rc !! state of frame center w.r.t. primary body [inertial] logical , intent ( out ) :: status_ok !! true if no errors. real ( wp ) :: mu1 !! gravitational parameter of primary body real ( wp ) :: mu2 !! gravitational parameter of secondary body if ( me % center == center_at_primary_body ) then rc = zero else ! primary body -> secondary body state [inertial]: call eph % get_rv ( et , me % secondary_body , me % primary_body , rc , status_ok ) if ( status_ok ) then if ( me % center == center_at_barycenter ) then mu1 = me % primary_body % mu mu2 = me % secondary_body % mu rc = rc * ( mu2 / ( mu1 + mu2 ) ) elseif ( me % center == center_at_secondary_body ) then !frame center is secondary body (rc already computed) else error stop 'invalid rotating frame center selection.' end if else write ( error_unit , '(A)' ) 'Error in from_primary_to_center: ' // & 'Could not compute primary to secondary body state.' end if end if end subroutine from_primary_to_center","tags":"","url":"proc/from_primary_to_center.html"},{"title":"get_c_cdot_two_body_rotating – fortran-astrodynamics-toolkit","text":"private  subroutine get_c_cdot_two_body_rotating(me, eph, to_icrf, c, cdot, status_ok) rotation matrix for ROTATING <-> ICRF Type Bound two_body_rotating_frame Arguments Type Intent Optional Attributes Name class( two_body_rotating_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok Calls proc~~get_c_cdot_two_body_rotating~~CallsGraph proc~get_c_cdot_two_body_rotating two_body_rotating_frame%get_c_cdot_two_body_rotating get_rv get_rv proc~get_c_cdot_two_body_rotating->get_rv proc~cross cross proc~get_c_cdot_two_body_rotating->proc~cross proc~cross_matrix cross_matrix proc~get_c_cdot_two_body_rotating->proc~cross_matrix proc~unit unit proc~get_c_cdot_two_body_rotating->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_c_cdot_two_body_rotating~~CalledByGraph proc~get_c_cdot_two_body_rotating two_body_rotating_frame%get_c_cdot_two_body_rotating proc~get_c_cdot_two_body_rotating_pulsating two_body_rotating_pulsating_frame%get_c_cdot_two_body_rotating_pulsating proc~get_c_cdot_two_body_rotating_pulsating->proc~get_c_cdot_two_body_rotating Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_c_cdot_two_body_rotating ( me , eph , to_icrf , c , cdot , status_ok ) !! rotation matrix for ROTATING <-> ICRF implicit none class ( two_body_rotating_frame ), intent ( inout ) :: me class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) logical , intent ( in ) :: to_icrf real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot logical , intent ( out ) :: status_ok real ( wp ), dimension ( 3 ) :: r !! position of secondary body w.r.t. primary body [inertial frame] real ( wp ), dimension ( 3 ) :: v !! velocity of secondary body w.r.t. primary body [inertial frame] real ( wp ), dimension ( 3 ) :: h !! angular momentum vector real ( wp ), dimension ( 3 ) :: w !! angular velocity of frame logical :: need_cdot !! if we need to compute `cdot` real ( wp ), dimension ( 3 ) :: rhat !! `r` unit vector real ( wp ), dimension ( 3 ) :: hhat !! `h` unit vector need_cdot = present ( cdot ) ! get position & velocity of secondary body w.r.t. primary body, in the inertial frame call eph % get_rv ( me % et , me % secondary_body , me % primary_body , me % rv12 , status_ok ) if ( status_ok ) then r = me % rv12 ( 1 : 3 ) v = me % rv12 ( 4 : 6 ) h = cross ( r , v ) rhat = unit ( r ) hhat = unit ( h ) c ( 1 ,:) = rhat c ( 3 ,:) = hhat c ( 2 ,:) = cross ( hhat , rhat ) if ( need_cdot ) then if ( me % inertial ) then ! quasi inertial frame cdot = zero else w = h / dot_product ( r , r ) ! see: https://en.wikipedia.org/wiki/Angular_velocity cdot = - matmul ( c , cross_matrix ( w )) ! see: http://arxiv.org/pdf/1311.6010.pdf end if end if if ( to_icrf ) then c = transpose ( c ) if ( need_cdot ) cdot = transpose ( cdot ) end if else write ( error_unit , '(A)' ) 'Error in get_c_cdot_two_body_rotating: ' // & 'Could not compute rotation matrix.' c = zero if ( need_cdot ) cdot = zero end if end subroutine get_c_cdot_two_body_rotating","tags":"","url":"proc/get_c_cdot_two_body_rotating.html"},{"title":"get_c_cdot_two_body_rotating_pulsating – fortran-astrodynamics-toolkit","text":"private  subroutine get_c_cdot_two_body_rotating_pulsating(me, eph, to_icrf, c, cdot, status_ok) rotation matrix for ROTATING_PULSATING <-> ICRF Type Bound two_body_rotating_pulsating_frame Arguments Type Intent Optional Attributes Name class( two_body_rotating_pulsating_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok Calls proc~~get_c_cdot_two_body_rotating_pulsating~~CallsGraph proc~get_c_cdot_two_body_rotating_pulsating two_body_rotating_pulsating_frame%get_c_cdot_two_body_rotating_pulsating proc~get_c_cdot_two_body_rotating two_body_rotating_frame%get_c_cdot_two_body_rotating proc~get_c_cdot_two_body_rotating_pulsating->proc~get_c_cdot_two_body_rotating get_rv get_rv proc~get_c_cdot_two_body_rotating->get_rv proc~cross cross proc~get_c_cdot_two_body_rotating->proc~cross proc~cross_matrix cross_matrix proc~get_c_cdot_two_body_rotating->proc~cross_matrix proc~unit unit proc~get_c_cdot_two_body_rotating->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_c_cdot_two_body_rotating_pulsating ( me , eph , to_icrf , c , cdot , status_ok ) !! rotation matrix for ROTATING_PULSATING <-> ICRF implicit none class ( two_body_rotating_pulsating_frame ), intent ( inout ) :: me class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) logical , intent ( in ) :: to_icrf real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot logical , intent ( out ) :: status_ok ! local variables real ( wp ), dimension ( 3 , 3 ) :: cr , crdot real ( wp ), dimension ( 3 ) :: r12 , v12 real ( wp ) :: r12mag , factor logical :: need_cdot need_cdot = present ( cdot ) ! rotating frame transformation matrices: if ( need_cdot ) then call me % two_body_rotating_frame % get_c_cdot ( eph , to_icrf , cr , crdot , status_ok = status_ok ) else call me % two_body_rotating_frame % get_c_cdot ( eph , to_icrf , cr , status_ok = status_ok ) end if if ( status_ok ) then r12 = me % rv12 ( 1 : 3 ) ! was computed in get_c_cdot_two_body_rotating v12 = me % rv12 ( 4 : 6 ) r12mag = norm2 ( r12 ) if ( to_icrf ) then factor = r12mag / me % scale c = factor * cr if ( need_cdot ) cdot = factor * ( dot_product ( v12 , r12 ) * cr / ( r12mag ** 2 ) + crdot ) else factor = me % scale / r12mag c = factor * cr if ( need_cdot ) cdot = factor * ( - dot_product ( v12 , r12 ) * cr / ( r12mag ** 2 ) + crdot ) end if else !error write ( error_unit , '(A)' ) 'Error in get_c_cdot_two_body_rotating_pulsating: ' // & 'Could not compute rotation matrix.' c = zero if ( need_cdot ) cdot = zero end if end subroutine get_c_cdot_two_body_rotating_pulsating","tags":"","url":"proc/get_c_cdot_two_body_rotating_pulsating.html"},{"title":"get_c_cdot_icrf – fortran-astrodynamics-toolkit","text":"private  subroutine get_c_cdot_icrf(me, eph, to_icrf, c, cdot, status_ok) rotation matrix for ICRF <-> ICRF Type Bound icrf_frame Arguments Type Intent Optional Attributes Name class( icrf_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok Source Code subroutine get_c_cdot_icrf ( me , eph , to_icrf , c , cdot , status_ok ) !! rotation matrix for ICRF <-> ICRF implicit none class ( icrf_frame ), intent ( inout ) :: me class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) logical , intent ( in ) :: to_icrf real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot logical , intent ( out ) :: status_ok c = identity_3x3 if ( present ( cdot )) cdot = zero status_ok = . true . end subroutine get_c_cdot_icrf","tags":"","url":"proc/get_c_cdot_icrf.html"},{"title":"get_c_cdot_ecliptic – fortran-astrodynamics-toolkit","text":"private  subroutine get_c_cdot_ecliptic(me, eph, to_icrf, c, cdot, status_ok) Uses obliquity_module proc~~get_c_cdot_ecliptic~~UsesGraph proc~get_c_cdot_ecliptic ecliptic_frame%get_c_cdot_ecliptic module~obliquity_module obliquity_module proc~get_c_cdot_ecliptic->module~obliquity_module module~conversion_module conversion_module module~obliquity_module->module~conversion_module module~kind_module kind_module module~obliquity_module->module~kind_module module~conversion_module->module~kind_module module~numbers_module numbers_module module~conversion_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. rotation matrix for ICRF <-> Mean Ecliptic Type Bound ecliptic_frame Arguments Type Intent Optional Attributes Name class( ecliptic_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok Calls proc~~get_c_cdot_ecliptic~~CallsGraph proc~get_c_cdot_ecliptic ecliptic_frame%get_c_cdot_ecliptic proc~equatorial_to_mean_ecliptic_rotmat equatorial_to_mean_ecliptic_rotmat proc~get_c_cdot_ecliptic->proc~equatorial_to_mean_ecliptic_rotmat proc~mean_ecliptic_to_equatorial_rotmat mean_ecliptic_to_equatorial_rotmat proc~get_c_cdot_ecliptic->proc~mean_ecliptic_to_equatorial_rotmat proc~equatorial_to_mean_ecliptic_rotmat->proc~mean_ecliptic_to_equatorial_rotmat proc~mean_obliquity_of_ecliptic_iau1980 mean_obliquity_of_ecliptic_iau1980 proc~mean_ecliptic_to_equatorial_rotmat->proc~mean_obliquity_of_ecliptic_iau1980 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_c_cdot_ecliptic~~CalledByGraph proc~get_c_cdot_ecliptic ecliptic_frame%get_c_cdot_ecliptic proc~transformation_module_test transformation_module_test proc~transformation_module_test->proc~get_c_cdot_ecliptic Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_c_cdot_ecliptic ( me , eph , to_icrf , c , cdot , status_ok ) !! rotation matrix for ICRF <-> Mean Ecliptic use obliquity_module implicit none class ( ecliptic_frame ), intent ( inout ) :: me class ( ephemeris_class ), intent ( inout ) :: eph logical , intent ( in ) :: to_icrf real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot logical , intent ( out ) :: status_ok if ( to_icrf ) then c = mean_ecliptic_to_equatorial_rotmat () else c = equatorial_to_mean_ecliptic_rotmat () end if if ( present ( cdot )) cdot = zero status_ok = . true . end subroutine get_c_cdot_ecliptic","tags":"","url":"proc/get_c_cdot_ecliptic.html"},{"title":"get_c_cdot_iau_earth – fortran-astrodynamics-toolkit","text":"private  subroutine get_c_cdot_iau_earth(me, eph, to_icrf, c, cdot, status_ok) rotation matrix for IAU_EARTH <-> ICRF Type Bound iau_earth_rotating_frame Arguments Type Intent Optional Attributes Name class( iau_earth_rotating_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok Calls proc~~get_c_cdot_iau_earth~~CallsGraph proc~get_c_cdot_iau_earth iau_earth_rotating_frame%get_c_cdot_iau_earth proc~icrf_to_iau_earth icrf_to_iau_earth proc~get_c_cdot_iau_earth->proc~icrf_to_iau_earth proc~iau_rotation_matrix iau_rotation_matrix proc~icrf_to_iau_earth->proc~iau_rotation_matrix proc~rotation_matrix rotation_matrix proc~iau_rotation_matrix->proc~rotation_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_c_cdot_iau_earth ( me , eph , to_icrf , c , cdot , status_ok ) !! rotation matrix for IAU_EARTH <-> ICRF implicit none class ( iau_earth_rotating_frame ), intent ( inout ) :: me class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) logical , intent ( in ) :: to_icrf real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot logical , intent ( out ) :: status_ok c = icrf_to_iau_earth ( me % et ) !... don't have the cdot code yet... need to refactor iau code ... ! see also: ftp://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/tisbod.html !if (present(cdot)) cdot = error stop 'not yet supported' status_ok = . true . end subroutine get_c_cdot_iau_earth","tags":"","url":"proc/get_c_cdot_iau_earth.html"},{"title":"get_c_cdot_iau_moon – fortran-astrodynamics-toolkit","text":"private  subroutine get_c_cdot_iau_moon(me, eph, to_icrf, c, cdot, status_ok) rotation matrix for IAU_MOON <-> ICRF Type Bound iau_moon_rotating_frame Arguments Type Intent Optional Attributes Name class( iau_moon_rotating_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok Calls proc~~get_c_cdot_iau_moon~~CallsGraph proc~get_c_cdot_iau_moon iau_moon_rotating_frame%get_c_cdot_iau_moon proc~icrf_to_iau_moon icrf_to_iau_moon proc~get_c_cdot_iau_moon->proc~icrf_to_iau_moon proc~iau_rotation_matrix iau_rotation_matrix proc~icrf_to_iau_moon->proc~iau_rotation_matrix proc~rotation_matrix rotation_matrix proc~iau_rotation_matrix->proc~rotation_matrix Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_c_cdot_iau_moon ( me , eph , to_icrf , c , cdot , status_ok ) !! rotation matrix for IAU_MOON <-> ICRF implicit none class ( iau_moon_rotating_frame ), intent ( inout ) :: me class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) logical , intent ( in ) :: to_icrf real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot logical , intent ( out ) :: status_ok c = icrf_to_iau_moon ( me % et ) !... don't have the cdot code yet... need to refactor iau code ... ! see also: ftp://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/tisbod.html !if (present(cdot)) cdot = error stop 'not yet supported' status_ok = . true . end subroutine get_c_cdot_iau_moon","tags":"","url":"proc/get_c_cdot_iau_moon.html"},{"title":"transformation_module_test – fortran-astrodynamics-toolkit","text":"public  subroutine transformation_module_test() Uses jpl_ephemeris_module proc~~transformation_module_test~~UsesGraph proc~transformation_module_test transformation_module_test module~jpl_ephemeris_module jpl_ephemeris_module proc~transformation_module_test->module~jpl_ephemeris_module iso_fortran_env iso_fortran_env module~jpl_ephemeris_module->iso_fortran_env module~ephemeris_module ephemeris_module module~jpl_ephemeris_module->module~ephemeris_module module~kind_module kind_module module~jpl_ephemeris_module->module~kind_module module~ephemeris_module->module~kind_module module~celestial_body_module celestial_body_module module~ephemeris_module->module~celestial_body_module module~kind_module->iso_fortran_env module~celestial_body_module->module~kind_module module~base_class_module base_class_module module~celestial_body_module->module~base_class_module module~numbers_module numbers_module module~celestial_body_module->module~numbers_module module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Transformation units test Arguments None Calls proc~~transformation_module_test~~CallsGraph proc~transformation_module_test transformation_module_test proc~get_c_cdot_ecliptic ecliptic_frame%get_c_cdot_ecliptic proc~transformation_module_test->proc~get_c_cdot_ecliptic proc~initialize_ephemeris jpl_ephemeris%initialize_ephemeris proc~transformation_module_test->proc~initialize_ephemeris proc~transform reference_frame%transform proc~transformation_module_test->proc~transform proc~equatorial_to_mean_ecliptic_rotmat equatorial_to_mean_ecliptic_rotmat proc~get_c_cdot_ecliptic->proc~equatorial_to_mean_ecliptic_rotmat proc~mean_ecliptic_to_equatorial_rotmat mean_ecliptic_to_equatorial_rotmat proc~get_c_cdot_ecliptic->proc~mean_ecliptic_to_equatorial_rotmat get_c_cdot get_c_cdot proc~transform->get_c_cdot proc~rvcto_rvcfrom_icrf rvcto_rvcfrom_icrf proc~transform->proc~rvcto_rvcfrom_icrf proc~equatorial_to_mean_ecliptic_rotmat->proc~mean_ecliptic_to_equatorial_rotmat proc~mean_obliquity_of_ecliptic_iau1980 mean_obliquity_of_ecliptic_iau1980 proc~mean_ecliptic_to_equatorial_rotmat->proc~mean_obliquity_of_ecliptic_iau1980 get_rv get_rv proc~rvcto_rvcfrom_icrf->get_rv proc~from_primary_to_center two_body_rotating_frame%from_primary_to_center proc~rvcto_rvcfrom_icrf->proc~from_primary_to_center proc~from_primary_to_center->get_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine transformation_module_test () use jpl_ephemeris_module , only : jpl_ephemeris implicit none real ( wp ), dimension ( 6 ), parameter :: initial_state = [ 1000 0.0_wp ,& 0.0_wp ,& 0.0_wp ,& 1.0_wp ,& 2.0_wp ,& 3.0_wp ] !! km, km/s real ( wp ), parameter :: et = zero !! ephemeris time [sec] real ( wp ), parameter :: scale = 38440 0.0_wp !! scale factor [km] character ( len =* ), parameter :: ephemeris_file_421 = './eph/JPLEPH.421' !! JPL DE421 ephemeris file type ( icrf_frame ) :: from type ( two_body_rotating_pulsating_frame ) :: to type ( jpl_ephemeris ) :: eph421 logical :: status_ok real ( wp ), dimension ( 6 ) :: rv_out type ( ecliptic_frame ) :: ecliptic_f real ( wp ), dimension ( 3 , 3 ) :: c integer :: i !! counter write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' transformation_module_test' write ( * , * ) '---------------' write ( * , * ) '' !open the ephemeris: call eph421 % initialize ( filename = ephemeris_file_421 , status_ok = status_ok ) if (. not . status_ok ) error stop 'Error initializing DE421 ephemeris.' !initialize frames: !  [NOTE: need to make constructors for the frames] ! note: default is Earth-Moon-barycenter: from = icrf_frame ( et = et ) to = two_body_rotating_pulsating_frame ( et = et , scale = scale ) call from % transform ( initial_state , to , et , eph421 , rv_out , status_ok ) if (. not . status_ok ) error stop 'Error in state transformation.' !results: write ( * , * ) '' write ( * , '(A/,*(E30.16/))' ) 'initial state (J2000-Earth):' , initial_state write ( * , '(A/,*(E30.16/))' ) 'final state (Earth-Moon rotating, centered at barycenter, scale=384400):' , rv_out write ( * , * ) '' ! ecliptic frame: ecliptic_f = ecliptic_frame ( b = body_earth ) call ecliptic_f % get_c_cdot ( eph421 , to_icrf = . true ., c = c , status_ok = status_ok ) write ( * , * ) '' write ( * , * ) 'ecliptic to j2000:' do i = 1 , 3 write ( * , * ) c ( i ,:) end do ! from SPICE: ! rot = [1.0000000000000000E+00, 0.0000000000000000E+00, 0.0000000000000000E+00, !        0.0000000000000000E+00, 9.1748206206918181E-01, -3.9777715593191371E-01, !        0.0000000000000000E+00, 3.9777715593191371E-01, 9.1748206206918181E-01] ! ! from FAT: !        1.0000000000000000        0.0000000000000000        0.0000000000000000 !        0.0000000000000000       0.91748206206918181      -0.39777715593191371 !        0.0000000000000000       0.39777715593191371       0.91748206206918181 !close the ephemeris: call eph421 % close () end subroutine transformation_module_test","tags":"","url":"proc/transformation_module_test.html"},{"title":"two_body_rotating_frame – fortran-astrodynamics-toolkit","text":"public interface two_body_rotating_frame Calls interface~~two_body_rotating_frame~~CallsGraph interface~two_body_rotating_frame two_body_rotating_frame proc~two_body_rotating_frame_constructor two_body_rotating_frame_constructor interface~two_body_rotating_frame->proc~two_body_rotating_frame_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function two_body_rotating_frame_constructor (primary_body, secondary_body, center, et, inertial) result(f) Constructor for a two_body_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: primary_body the primary body of\nthe frame type( celestial_body ), intent(in) :: secondary_body the secondary body used\nto construct the frame integer, intent(in) :: center the frame center (can\nbe primary_body , secondary_body , or barycenter ) real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] logical, intent(in), optional :: inertial if true, it's a quasi-inertial frame\n[default is false] Return Value type( two_body_rotating_frame )","tags":"","url":"interface/two_body_rotating_frame.html"},{"title":"two_body_rotating_pulsating_frame – fortran-astrodynamics-toolkit","text":"public interface two_body_rotating_pulsating_frame Calls interface~~two_body_rotating_pulsating_frame~~CallsGraph interface~two_body_rotating_pulsating_frame two_body_rotating_pulsating_frame proc~two_body_rotating_pulsating_frame_constructor two_body_rotating_pulsating_frame_constructor interface~two_body_rotating_pulsating_frame->proc~two_body_rotating_pulsating_frame_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function two_body_rotating_pulsating_frame_constructor (primary_body, secondary_body, center, scale, et) result(f) Constructor for a two_body_rotating_pulsating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: primary_body the primary body of\nthe frame type( celestial_body ), intent(in) :: secondary_body the secondary body used\nto construct the frame integer, intent(in) :: center the frame center (can\nbe primary_body , secondary_body , or barycenter ) real(kind=wp), intent(in) :: scale scale factor real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( two_body_rotating_pulsating_frame )","tags":"","url":"interface/two_body_rotating_pulsating_frame.html"},{"title":"iau_earth_rotating_frame – fortran-astrodynamics-toolkit","text":"public interface iau_earth_rotating_frame Calls interface~~iau_earth_rotating_frame~~CallsGraph interface~iau_earth_rotating_frame iau_earth_rotating_frame proc~iau_earth_rotating_frame_constructor iau_earth_rotating_frame_constructor interface~iau_earth_rotating_frame->proc~iau_earth_rotating_frame_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function iau_earth_rotating_frame_constructor (b, et) result(f) Constructor for a iau_earth_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( iau_earth_rotating_frame )","tags":"","url":"interface/iau_earth_rotating_frame.html"},{"title":"iau_moon_rotating_frame – fortran-astrodynamics-toolkit","text":"public interface iau_moon_rotating_frame Calls interface~~iau_moon_rotating_frame~~CallsGraph interface~iau_moon_rotating_frame iau_moon_rotating_frame proc~iau_moon_rotating_frame_constructor iau_moon_rotating_frame_constructor interface~iau_moon_rotating_frame->proc~iau_moon_rotating_frame_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function iau_moon_rotating_frame_constructor (b, et) result(f) Constructor for a iau_moon_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( iau_earth_rotating_frame )","tags":"","url":"interface/iau_moon_rotating_frame.html"},{"title":"icrf_frame – fortran-astrodynamics-toolkit","text":"public interface icrf_frame Calls interface~~icrf_frame~~CallsGraph interface~icrf_frame icrf_frame proc~icrf_frame_constructor icrf_frame_constructor interface~icrf_frame->proc~icrf_frame_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function icrf_frame_constructor (b) result(f) Constructor for a icrf_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body Return Value type( icrf_frame )","tags":"","url":"interface/icrf_frame.html"},{"title":"ecliptic_frame – fortran-astrodynamics-toolkit","text":"public interface ecliptic_frame Calls interface~~ecliptic_frame~~CallsGraph interface~ecliptic_frame ecliptic_frame proc~ecliptic_frame_constructor ecliptic_frame_constructor interface~ecliptic_frame->proc~ecliptic_frame_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function ecliptic_frame_constructor (b) result(f) Constructor for a ecliptic_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body Return Value type( ecliptic_frame )","tags":"","url":"interface/ecliptic_frame.html"},{"title":"kepe – fortran-astrodynamics-toolkit","text":"private pure function kepe(e, m, ecc) Elliptic Kepler's equation Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: e eccentric anomaly real(kind=wp), intent(in) :: m mean anomaly real(kind=wp), intent(in) :: ecc eccentricity Return Value real(kind=wp) Source Code pure function kepe ( e , m , ecc ) implicit none real ( wp ), intent ( in ) :: e !! eccentric anomaly real ( wp ), intent ( in ) :: m !! mean anomaly real ( wp ), intent ( in ) :: ecc !! eccentricity real ( wp ) :: kepe kepe = e - ecc * sin ( e ) - m end function kepe","tags":"","url":"proc/kepe.html"},{"title":"d_kepe – fortran-astrodynamics-toolkit","text":"private pure function d_kepe(e, ecc) Derivative of kepe w.r.t. e Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: e eccentric anomaly real(kind=wp), intent(in) :: ecc eccentricity Return Value real(kind=wp) Source Code pure function d_kepe ( e , ecc ) implicit none real ( wp ), intent ( in ) :: e !! eccentric anomaly real ( wp ), intent ( in ) :: ecc !! eccentricity real ( wp ) :: d_kepe d_kepe = one - ecc * cos ( e ) end function d_kepe","tags":"","url":"proc/d_kepe.html"},{"title":"kepde – fortran-astrodynamics-toolkit","text":"private pure function kepde(de, dm, sigma0, sqrta, a, r) Elliptic Kepler's equation written in terms of the\neccentric anomaly difference.  See Battin, eqn 4.43. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: de eccentric anomaly difference real(kind=wp), intent(in) :: dm mean anomaly difference real(kind=wp), intent(in) :: sigma0 real(kind=wp), intent(in) :: sqrta real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: r Return Value real(kind=wp) Source Code pure function kepde ( de , dm , sigma0 , sqrta , a , r ) implicit none real ( wp ), intent ( in ) :: de !! eccentric anomaly difference real ( wp ), intent ( in ) :: dm !! mean anomaly difference real ( wp ), intent ( in ) :: sigma0 real ( wp ), intent ( in ) :: sqrta real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ) :: r real ( wp ) :: kepde kepde = - dm + de + sigma0 / sqrta * ( one - cos ( de )) - & ( one - r / a ) * sin ( de ) end function kepde","tags":"","url":"proc/kepde.html"},{"title":"d_kepde – fortran-astrodynamics-toolkit","text":"private pure function d_kepde(de, sigma0, sqrta, a, r) Derivative of kepde w.r.t de . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: de eccentric anomaly difference real(kind=wp), intent(in) :: sigma0 real(kind=wp), intent(in) :: sqrta real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: r Return Value real(kind=wp) Source Code pure function d_kepde ( de , sigma0 , sqrta , a , r ) implicit none real ( wp ), intent ( in ) :: de !! eccentric anomaly difference real ( wp ), intent ( in ) :: sigma0 real ( wp ), intent ( in ) :: sqrta real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ) :: r real ( wp ) :: d_kepde d_kepde = one + sigma0 / sqrta * sin ( de ) - ( one - r / a ) * cos ( de ) end function d_kepde","tags":"","url":"proc/d_kepde.html"},{"title":"kepdh – fortran-astrodynamics-toolkit","text":"private pure function kepdh(dh, dn, sigma0, sqrta, a, r) Battin, eqn. 4.64. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: dh hyperbolic anomaly difference real(kind=wp), intent(in) :: dn real(kind=wp), intent(in) :: sigma0 real(kind=wp), intent(in) :: sqrta real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: r Return Value real(kind=wp) Source Code pure function kepdh ( dh , dn , sigma0 , sqrta , a , r ) implicit none real ( wp ), intent ( in ) :: dh !! hyperbolic anomaly difference real ( wp ), intent ( in ) :: dn real ( wp ), intent ( in ) :: sigma0 real ( wp ), intent ( in ) :: sqrta real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ) :: r real ( wp ) :: kepdh kepdh = - dn - dh + sigma0 / sqrta * ( cosh ( dh ) - one ) + & ( one - r / a ) * sinh ( dh ) end function kepdh","tags":"","url":"proc/kepdh.html"},{"title":"d_kepdh – fortran-astrodynamics-toolkit","text":"private pure function d_kepdh(dh, sigma0, sqrta, a, r) Derivative of kepdh w.r.t dh . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: dh hyperbolic anomaly difference real(kind=wp), intent(in) :: sigma0 real(kind=wp), intent(in) :: sqrta real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: r Return Value real(kind=wp) Source Code pure function d_kepdh ( dh , sigma0 , sqrta , a , r ) implicit none real ( wp ), intent ( in ) :: dh !! hyperbolic anomaly difference real ( wp ), intent ( in ) :: sigma0 real ( wp ), intent ( in ) :: sqrta real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ) :: r real ( wp ) :: d_kepdh d_kepdh = - one + sigma0 / sqrta * sinh ( dh ) + ( one - r / a ) * cosh ( dh ) end function d_kepdh","tags":"","url":"proc/d_kepdh.html"},{"title":"barker – fortran-astrodynamics-toolkit","text":"private pure function barker(r1, r2, mu) Barker time of flight equation Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r1 real(kind=wp), intent(in), dimension(3) :: r2 real(kind=wp), intent(in) :: mu Return Value real(kind=wp) Source Code pure function barker ( r1 , r2 , mu ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r1 real ( wp ), dimension ( 3 ), intent ( in ) :: r2 real ( wp ), intent ( in ) :: mu real ( wp ) :: barker real ( wp ) :: x , r1mag , r2mag , r21mag , sigma , r1pr2mag real ( wp ), dimension ( 3 ) :: r21 r1mag = norm2 ( r1 ) r2mag = norm2 ( r2 ) r21 = r2 - r1 r21mag = norm2 ( r21 ) x = r1 ( 1 ) * r2 ( 2 ) - r1 ( 2 ) * r2 ( 1 ) sigma = sign ( one , x ) r1pr2mag = r1mag + r2mag barker = ( r1pr2mag + r21mag ) ** 1.5_wp - & sigma * ( r1pr2mag - r21mag ) ** 1.5_wp / ( six * sqrt ( mu )) end function barker","tags":"","url":"proc/barker.html"},{"title":"kepds – fortran-astrodynamics-toolkit","text":"private pure function kepds(ds, dt, r0, vr0, alpha, mu) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ds universal anomaly difference real(kind=wp), intent(in) :: dt real(kind=wp), intent(in) :: r0 real(kind=wp), intent(in) :: vr0 real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: mu Return Value real(kind=wp) Calls proc~~kepds~~CallsGraph proc~kepds kepds proc~stumpff_c stumpff_c proc~kepds->proc~stumpff_c proc~stumpff_s stumpff_s proc~kepds->proc~stumpff_s Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function kepds ( ds , dt , r0 , vr0 , alpha , mu ) implicit none real ( wp ), intent ( in ) :: ds !! universal anomaly difference real ( wp ), intent ( in ) :: dt real ( wp ), intent ( in ) :: r0 real ( wp ), intent ( in ) :: vr0 real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: mu real ( wp ) :: kepds real ( wp ) :: c , s , ads2 , ds2 ds2 = ds * ds ads2 = alpha * ds2 s = stumpff_s ( ads2 ) c = stumpff_c ( ads2 ) kepds = - sqrt ( mu ) * dt + r0 * vr0 * ds2 * c / sqrt ( mu ) + & ( one - alpha * r0 ) * ds2 * ds * s + r0 * ds end function kepds","tags":"","url":"proc/kepds.html"},{"title":"d_kepds – fortran-astrodynamics-toolkit","text":"private pure function d_kepds(ds, r0, vr0, alpha, mu) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ds real(kind=wp), intent(in) :: r0 real(kind=wp), intent(in) :: vr0 real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: mu Return Value real(kind=wp) Calls proc~~d_kepds~~CallsGraph proc~d_kepds d_kepds proc~stumpff_c stumpff_c proc~d_kepds->proc~stumpff_c proc~stumpff_s stumpff_s proc~d_kepds->proc~stumpff_s Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function d_kepds ( ds , r0 , vr0 , alpha , mu ) implicit none real ( wp ), intent ( in ) :: ds real ( wp ), intent ( in ) :: r0 real ( wp ), intent ( in ) :: vr0 real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: mu real ( wp ) :: d_kepds real ( wp ) :: c , s , ads2 , ds2 ds2 = ds * ds ads2 = alpha * ds2 s = stumpff_s ( ads2 ) c = stumpff_c ( ads2 ) d_kepds = r0 * vr0 / sqrt ( mu ) * ds * ( one - ads2 * s ) + & ( one - alpha * r0 ) * ds2 * c + r0 end function d_kepds","tags":"","url":"proc/d_kepds.html"},{"title":"stumpff_s – fortran-astrodynamics-toolkit","text":"private pure function stumpff_s(z) result(s) Stumpff function S(z) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: z Return Value real(kind=wp) Called by proc~~stumpff_s~~CalledByGraph proc~stumpff_s stumpff_s proc~d_kepds d_kepds proc~d_kepds->proc~stumpff_s proc~kepds kepds proc~kepds->proc~stumpff_s Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function stumpff_s ( z ) result ( s ) implicit none real ( wp ), intent ( in ) :: z real ( wp ) :: s if ( z > zero ) then s = ( sqrt ( z ) - sin ( sqrt ( z ))) / sqrt ( z ) ** 3 else if ( z < zero ) then s = ( sinh ( sqrt ( - z )) - sqrt ( - z )) / ( - z ) ** ( three / two ) else s = one / six end if end function stumpff_s","tags":"","url":"proc/stumpff_s.html"},{"title":"stumpff_c – fortran-astrodynamics-toolkit","text":"private pure function stumpff_c(z) result(c) Stumpff function C(z) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: z Return Value real(kind=wp) Called by proc~~stumpff_c~~CalledByGraph proc~stumpff_c stumpff_c proc~d_kepds d_kepds proc~d_kepds->proc~stumpff_c proc~kepds kepds proc~kepds->proc~stumpff_c Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function stumpff_c ( z ) result ( c ) implicit none real ( wp ), intent ( in ) :: z real ( wp ) :: c if ( z > zero ) then c = ( one - cos ( sqrt ( z ))) / z else if ( z < zero ) then c = ( cosh ( sqrt ( - z )) - one ) / ( - z ) else c = 0.5_wp end if end function stumpff_c","tags":"","url":"proc/stumpff_c.html"},{"title":"kepler_classical – fortran-astrodynamics-toolkit","text":"public  subroutine kepler_classical(x0, dt, mu, xf) Uses newton_module proc~~kepler_classical~~UsesGraph proc~kepler_classical kepler_classical module~newton_module newton_module proc~kepler_classical->module~newton_module module~kind_module kind_module module~newton_module->module~kind_module module~numbers_module numbers_module module~newton_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Classical Kepler propagator for elliptical and hyperbolic orbits.\n  Uses Lagrange formulations from Battin & Newton's method. See also Dario Izzo: pykep/src/core_functions/propagate_lagrangian.h Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: x0 initial position,velocity vector real(kind=wp), intent(in) :: dt propagation time real(kind=wp), intent(in) :: mu central body gravitational parameter real(kind=wp), intent(out), dimension(6) :: xf final position,velocity vector Calls proc~~kepler_classical~~CallsGraph proc~kepler_classical kepler_classical proc~newton newton proc~kepler_classical->proc~newton Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine kepler_classical ( x0 , dt , mu , xf ) use newton_module , only : newton implicit none real ( wp ), dimension ( 6 ), intent ( in ) :: x0 !! initial position,velocity vector real ( wp ), intent ( in ) :: dt !! propagation time real ( wp ), intent ( in ) :: mu !! central body gravitational parameter real ( wp ), dimension ( 6 ), intent ( out ) :: xf !! final position,velocity vector real ( wp ), dimension ( 3 ) :: r0 !! initial position vector real ( wp ), dimension ( 3 ) :: v0 !! initial velocity vector real ( wp ) :: de !! eccentric anomaly difference real ( wp ) :: dh !! hyperbolic anomaly difference integer :: iflag !! newton status flag real ( wp ) :: r , rmag , vmag , energy , a , sqrta , f ,& g , ft , gt , sigma0 , dm , dn , xs , fx , b , p , x , z , term real ( wp ), parameter :: parabolic_tol = 1.0e-12_wp !! zero tol for parabolic orbits (energy) real ( wp ), parameter :: ftol = 1.0e-12_wp !! function tol for root finding real ( wp ), parameter :: xtol = 1.0e-12_wp !! indep variable tol for root finding integer , parameter :: max_iter = 1000 !! maximum number of iterations in newton ! check trivial case: if ( dt == zero ) then xf = x0 return end if r0 = x0 ( 1 : 3 ) v0 = x0 ( 4 : 6 ) rmag = norm2 ( r0 ) vmag = norm2 ( v0 ) energy = ( vmag * vmag / two - mu / rmag ) sigma0 = dot_product ( r0 , v0 ) / sqrt ( mu ) ! if not parabolic, then compute semimajor axis if ( abs ( energy ) > parabolic_tol ) then a = - mu / two / energy end if if ( energy < - parabolic_tol ) then ! elliptical case sqrta = sqrt ( a ) dm = sqrt ( mu / a ** 3 ) * dt de = dm call newton ( de , kepde_ , d_kepde_ , ftol , xtol , max_iter , xs , fx , iflag ) if ( iflag < 0 ) then write ( error_unit , '(A)' ) 'Error in kepler_classical [elliptical]: newton did not converge' write ( * , * ) xs , fx , iflag end if de = xs r = a + ( rmag - a ) * cos ( de ) + sigma0 * sqrta * sin ( de ) ! eqn 4.42 ! lagrange coefficients (Battin eqn 4.41) f = one - a / rmag * ( one - cos ( de )) g = a * sigma0 / sqrt ( mu ) * ( one - cos ( de )) + rmag * sqrt ( a / mu ) * sin ( de ) ft = - sqrt ( mu * a ) / ( r * rmag ) * sin ( de ) gt = one - a / r * ( one - cos ( de )) else if ( energy > parabolic_tol ) then ! hyperbolic case sqrta = sqrt ( - a ) dn = sqrt ( - mu / a ** 3 ) * dt dh = sign ( one , dt ) ! todo: need a better initial guess call newton ( dh , kepdh_ , d_kepdh_ , ftol , xtol , max_iter , xs , fx , iflag ) if ( iflag < 0 ) then write ( error_unit , '(A)' ) 'Error in kepler_classical [hyperbola]: newton did not converge' write ( * , * ) xs , fx , iflag end if dh = xs r = a + ( rmag - a ) * cosh ( dh ) + sigma0 * sqrta * sinh ( dh ) ! lagrange coefficients (Battin eqn 4.62) f = one - a / rmag * ( one - cosh ( dh )) g = a * sigma0 / sqrt ( mu ) * ( one - cosh ( dh )) + rmag * sqrt ( - a / mu ) * sinh ( dh ) ft = - sqrt ( - mu * a ) / ( r * rmag ) * sinh ( dh ) gt = one - a / r * ( one - cosh ( dh )) else ! parbolic case ! See Battin Section 4.2 p = two * rmag - sigma0 ** 2 B = one / p ** 1.5_wp * ( sigma0 * ( rmag + p ) + three * sqrt ( mu ) * dt ) term = B + sqrt ( one + B * B ) z = ( term ) ** ( one / three ) - ( term ) ** ( - one / three ) ! Battin eqn 4.12 where z = tan(f/2) x = sqrt ( p ) * z - sigma0 r = rmag + sigma0 * x + one / two * x ** 2 f = one - x ** 2 / two / rmag g = x / two / sqrt ( mu ) * ( two * rmag + sigma0 * x ) ft = - sqrt ( mu ) * x / rmag / r gt = one - x ** 2 / two / r end if ! results: xf ( 1 : 3 ) = f * r0 + g * v0 xf ( 4 : 6 ) = ft * r0 + gt * v0 contains ! function wrappers for newtons method: subroutine kepde_ ( x , f ) implicit none real ( wp ), intent ( in ) :: x !! de real ( wp ), intent ( out ) :: f f = kepde ( x , dm , sigma0 , sqrta , a , rmag ) end subroutine kepde_ subroutine d_kepde_ ( x , f ) implicit none real ( wp ), intent ( in ) :: x !! de real ( wp ), intent ( out ) :: f f = d_kepde ( x , sigma0 , sqrta , a , rmag ) end subroutine d_kepde_ subroutine kepdh_ ( x , f ) implicit none real ( wp ), intent ( in ) :: x !! dh real ( wp ), intent ( out ) :: f f = kepdh ( x , dn , sigma0 , sqrta , a , rmag ) end subroutine kepdh_ subroutine d_kepdh_ ( x , f ) implicit none real ( wp ), intent ( in ) :: x !! dh real ( wp ), intent ( out ) :: f f = d_kepdh ( x , sigma0 , sqrta , a , rmag ) end subroutine d_kepdh_ end subroutine kepler_classical","tags":"","url":"proc/kepler_classical.html"},{"title":"kepler_shepperd – fortran-astrodynamics-toolkit","text":"public  subroutine kepler_shepperd(mu, rv1, dt, rv2, istat) Kepler propagation using Shepperd's method. Reference S.W. Shepperd, \"Universal Keplerian State Transition Matrix\".\n    Celestial Mechanics 35(1985) p. 129-144. Rody P.S. Oldenhuis, progress_orbitM Matlab function (BSD license).\n    http://www.mathworks.com/matlabcentral/fileexchange/26349-kepler-state-transition-matrix-mex C.D. Eagle, Orbital Mechanics with MATLAB, twobody2.m Matlab function (BSD license).\n    http://www.mathworks.com/matlabcentral/fileexchange/48723-matlab-functions-for-two-body-orbit-propagation Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter real(kind=wp), intent(in), dimension(6) :: rv1 initial position,velocity vector real(kind=wp), intent(in) :: dt time step real(kind=wp), intent(out), dimension(6) :: rv2 final position,velocity vector integer, intent(out), optional :: istat status flag (if not present, warnings are printed):\nLinear combination of : 0 : all is well -10 : failed to converge in time loop -100 : failed to converge in g loop Source Code subroutine kepler_shepperd ( mu , rv1 , dt , rv2 , istat ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter real ( wp ), dimension ( 6 ), intent ( in ) :: rv1 !! initial position,velocity vector real ( wp ), intent ( in ) :: dt !! time step real ( wp ), dimension ( 6 ), intent ( out ) :: rv2 !! final position,velocity vector integer , intent ( out ), optional :: istat !! status flag (if not present, warnings are printed): !! Linear combination of : !! !! `0` : all is well !! `-10` : failed to converge in time loop !! `-100` : failed to converge in `g` loop ! note: some of these could also be (optional) input: real ( wp ), parameter :: min_dt = epsilon ( one ) !! time step considered as zero (sec) integer , parameter :: max_iter = 1000 !! max iterations for time integer , parameter :: max_iter_g = 1000 !! max iterations for g real ( wp ), parameter :: ttol = 1.0e-8_wp !! tolerance for time (sec) real ( wp ), parameter :: gtol = 1.0e-12_wp !! tolerance for g real ( wp ), parameter :: zero_tol = epsilon ( one ) !! tolerance for beta=0 (parabola) logical , parameter :: use_halley = . true . !! use the Halley update !! rather than the original Newton real ( wp ), dimension ( 3 ) :: r1 !! initial position vector real ( wp ), dimension ( 3 ) :: v1 !! initial velocity vector real ( wp ) :: r1mag , nu0 , beta , p , deltau , u , t , deltat , bu , q ,& a , b , gprev , u0w2 , u1w2 , uu , u0 , u1 , u2 , u3 , r ,& ff , f , gg , g , umin , umax , du , abs_beta integer :: n , iter , k , d , l , iterg if ( present ( istat )) istat = 0 if ( abs ( dt ) <= min_dt ) then rv2 = rv1 else r1 = rv1 ( 1 : 3 ) v1 = rv1 ( 4 : 6 ) r1mag = norm2 ( r1 ) nu0 = dot_product ( r1 , v1 ) beta = two * mu / r1mag - dot_product ( v1 , v1 ) abs_beta = abs ( beta ) if ( abs_beta > zero_tol ) then umax = one / sqrt ( abs_beta ) else umax = huge ( one ) end if umin = - umax if ( beta > zero ) then p = twopi * mu * beta ** ( - three / two ) n = floor (( dt + p / two - two * nu0 / beta ) / p ) deltau = twopi * n * beta ** ( - five / two ) else deltau = zero end if u = zero t = zero iter = 0 deltat = dt - t do while ( abs ( deltat ) > ttol ) iter = iter + 1 bu = beta * u * u q = min ( 0.5_wp , bu / ( one + bu )) ! avoid q > 0.5 due to numerical issues a = one b = one g = one n = 0 k = - 9 d = 15 l = 3 gprev = huge ( one ) iterg = 0 do while ( abs ( g - gprev ) > gtol ) iterg = iterg + 1 k = - k l = l + 2 d = d + 4 * l n = n + ( 1 + k ) * l a = d / ( d - n * a * q ) b = ( a - one ) * b gprev = g g = g + b if ( iterg == max_iter_g ) then if ( present ( istat )) then istat = istat - 100 else write ( * , * ) 'Warning: kepler_shepperd failed to converge in g iteration' end if exit end if end do u0w2 = one - two * q u1w2 = two * ( one - q ) * u uu = 1 6.0_wp / 1 5.0_wp * u1w2 ** 5 * g + deltau u0 = two * u0w2 ** 2 - one u1 = two * u0w2 * u1w2 u2 = two * u1w2 ** 2 u3 = beta * uu + u1 * u2 / three r = r1mag * u0 + nu0 * u1 + mu * u2 t = r1mag * u1 + nu0 * u2 + mu * u3 deltat = dt - t if ( use_halley ) then ! Halley version from Oldenhuis routine du = deltat / (( one - q ) * ( four * r + deltat * beta * u )) else ! original Newton du = deltat / four / ( one - q ) / r end if ! this logic is from the Eagle routine if ( du < zero ) then umax = u u = u + du if ( u < umin ) u = ( umin + umax ) / two else umin = u u = u + du if ( u > umax ) u = ( umin + umax ) / two end if if ( iter == max_iter ) then if ( abs ( deltat ) > ttol ) then ! it still hasn't converged if ( present ( istat )) then istat = istat - 10 else write ( * , * ) 'Warning: kepler_shepperd failed to converge in time iteration' end if exit end if end if end do ff = one - mu / r1mag * u2 f = - mu * u1 / r / r1mag gg = r1mag * u1 + nu0 * u2 g = one - mu / r * u2 rv2 = [ r1 * ff + v1 * gg , r1 * f + v1 * g ] end if end subroutine kepler_shepperd","tags":"","url":"proc/kepler_shepperd.html"},{"title":"kepler_goodyear_stienon_klumpp – fortran-astrodynamics-toolkit","text":"public  subroutine kepler_goodyear_stienon_klumpp(rv0, tau, mu, accy, rvf) Kepler propagator based on the Goodyear code with\n  modifications by Stienon and Klumpp. See also W. H. Goodyear, \"Completely General Closed-Form Solution for Coordinates\n    and Partial Derivatives of the Two-Body Problem\", Astronomical Journal,\n    Vol. 70, No. 3, April 1965. pdf W. H. Goodyear, \"A General Method for the Computation of Cartesian\n    Coordinates and Partial Derivatives of the Two-Body Problem\",\n    NASA CR-522, Sep 1, 1966. pdf A. Klumpp, \"Performance Comparision of Lambert and Kepler Algorithms\",\n    JPL Interoffice Memorandum, 314.1-0426-ARK, Jan 2, 1991.\n   (See the KEPGSK Fortran 77 routine) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: rv0 state vector at reference\ntime T0 [km,km/s] real(kind=wp), intent(in) :: tau Time interval T-T0 [sec] real(kind=wp), intent(in) :: mu Central body gravitational\nconstant [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: accy Fractional accuracy required\n[0->0.1] real(kind=wp), intent(out), dimension(6) :: rvf state vector at solution time\nT [km,km/s] Source Code subroutine kepler_goodyear_stienon_klumpp ( rv0 , tau , mu , accy , rvf ) implicit none real ( wp ), dimension ( 6 ), intent ( in ) :: rv0 !! state vector at reference !! time T0 [km,km/s] real ( wp ), intent ( in ) :: tau !! Time interval T-T0 [sec] real ( wp ), intent ( in ) :: mu !! Central body gravitational !! constant [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: accy !! Fractional accuracy required !! [0->0.1] real ( wp ), dimension ( 6 ), intent ( out ) :: rvf !! state vector at solution time !! T [km,km/s] real ( wp ), parameter :: onethird = 1.0_wp / 3.0_wp !! 0.333333 in original code integer :: iloop !! loop counter defining number of iterations real ( wp ) :: r !! radius at solution time `T` real ( wp ) :: r0 !! radius at solution time `T0` integer :: i !! index integer :: j !! index integer :: m !! counter for normalizing lambda real ( wp ) :: psi !! independent variable in Kepler's equation real ( wp ) :: psin !! lower limit to `psi` real ( wp ) :: psip !! upper limit to `psi` real ( wp ) :: dlim !! tau/periapsis distance = abs(limit to `psi`) real ( wp ) :: dtau !! Kepler's equation residual real ( wp ) :: dtaun !! lower limit to `dtau` real ( wp ) :: dtaup !! upper limit to `dtau` real ( wp ) :: accrcy !! accuracy = midval(zero, `accy`, 0.1) real ( wp ) :: sig0 !! dot product: `r` with `v` real ( wp ) :: alpha !! twice the energy per unit mass real ( wp ) :: h2 !! square of angular momentum per unit mass real ( wp ) :: a !! reduced argument of `s_0`, `s_1`, etc. real ( wp ) :: ap !! actual argument of `s_0`, `s_1`, etc. real ( wp ) :: c0 !! c(n) is the nth Goodyear polynomial `s_n` !! divided by its leading term, so that !! !! * `c0 = s_0 = cosh(z)` !! * `c1 = s_1/psi = sinh(z)/z` !! * `c(n+2) = (n+1)(n+2)[c(n)-1]/z&#94;2` !! !! where `z = psi*sqrt(alpha)`. `ap=norm2(z)` real ( wp ) :: c1 real ( wp ) :: c2 real ( wp ) :: c3 real ( wp ) :: c4 real ( wp ) :: c5x3 real ( wp ) :: s1 !! `s_n` is the nth Goodyear !! polynomial, given by !! `s_n = psi&#94;n sim{z&#94;(2k)/(2k)!} k >=0 ` real ( wp ) :: s2 real ( wp ) :: s3 real ( wp ) :: g !! the G-function real ( wp ) :: gdm1 !! time derivative of the G-function minus one real ( wp ) :: fm1 !! the F-function minus one real ( wp ) :: fd !! time derivative of the F-function real ( wp ), dimension ( 4 ) :: c !! terms in F(psi) accrcy = min ( max ( zero , accy ), 0.1_wp ) r0 = dot_product ( rv0 ( 1 : 3 ), rv0 ( 1 : 3 )) ! r dot r sig0 = dot_product ( rv0 ( 1 : 3 ), rv0 ( 4 : 6 )) ! r dot v alpha = dot_product ( rv0 ( 4 : 6 ), rv0 ( 4 : 6 )) ! v dot v h2 = max ( r0 * alpha - sig0 * sig0 , zero ) r0 = sqrt ( r0 ) alpha = alpha - two * mu / r0 !compute initial limits for phi and dtau: c0 = sqrt ( max ( mu * mu + h2 * alpha , zero )) ! gm * eccentricity dlim = div ( 1.1_wp * tau * ( c0 + mu ), h2 ) ! tau/periapsis distance = max(a). ! Arbitrary factor 1.1 ensures ! psin <= psi <= psip ! when converged, despite ! numerical imprecision. if ( tau < zero ) then psin = dlim psip = zero dtaun = psin dtaup = - tau else psin = zero psip = dlim dtaun = - tau dtaup = psip end if !compute initial value of psi: psi = tau / r0 if ( alpha >= zero ) then c2 = one if ( tau < zero ) c2 = - one c3 = abs ( tau ) if ( alpha > zero ) then c0 = h2 * sqrt ( h2 ) / ( mu + c0 ) ** 2 if ( c3 > c0 ) then c1 = sqrt ( alpha ) psi = log ( two * alpha * c1 * c3 / ( r0 * alpha + c2 * c1 * sig0 + mu )) psi = max ( psi , one ) * c2 / c1 end if else !parabola c0 = r0 * sqrt ( six * r0 / mu ) if ( c3 > c0 ) psi = c2 * ( six * c3 / mu ) ** onethird end if end if ! begin loop for solving Kepler's equation: m = 0 iloop = 0 do iloop = iloop + 1 ! begin series summation: !compute argument a in reduced series obtained by factoring out psi's: a = alpha * psi * psi if ( abs ( a ) > one ) then !save a in ap and mod a if a exceeds unity in magnitude ap = a do m = m + 1 a = a * 0.25_wp if ( abs ( a ) <= one ) exit end do end if !sum series c5x3=3*s5/psi**5 and c4=s4/psi**4 c4 = one c5x3 = one do i = 9 , 3 , - 1 j = 2 * i c5x3 = one + a * c5x3 / ( j * ( j + 1 )) c4 = one + a * c4 / ( j * ( j - 1 )) end do c5x3 = c5x3 / 4 0.0_wp c4 = c4 / 2 4.0_wp !compute series c3=s3/psi**3,c2=s2/psi**2,c1=s1/psi,c0=rv0 c3 = ( 0.5_wp + a * c5x3 ) / three c2 = 0.5_wp + a * c4 c1 = one + a * c3 c0 = one + a * c2 if ( m > 0 ) then !demod series c0 and c1 if necessary with double angle formulas: do c1 = c1 * c0 c0 = two * c0 * c0 - one m = m - 1 if ( m <= 0 ) exit end do !compute c2,c3,c4,c5x3 from c0,c1,ap if demod required: c2 = ( c0 - one ) / ap c3 = ( c1 - one ) / ap c4 = ( c2 - 0.5_wp ) / ap c5x3 = ( three * c3 - 0.5_wp ) / ap end if !compute series s1,s2,s3 from c1,c2,c3: s1 = c1 * psi s2 = c2 * psi * psi s3 = c3 * psi * psi * psi ! compute slope r and residuals for kepler's equation: c ( 1 ) = r0 * s1 c ( 2 ) = sig0 * s2 c ( 3 ) = mu * s3 c ( 4 ) = tau g = c ( 4 ) - c ( 3 ) dtau = c ( 1 ) + c ( 2 ) - g r = abs ( r0 * c0 + ( sig0 * s1 + mu * s2 )) ! compute next psi: do !method = 0 if ( dtau < zero ) then psin = psi dtaun = dtau psi = psi - dtau / r if ( psi < psip ) exit ! < (not <=) to avoid false convergence else psip = psi dtaup = dtau psi = psi - dtau / r if ( psi > psin ) exit ! > (not >=) to avoid false convergence end if !reset psi within bounds psin and psip: !try incrementing bound with dtau nearest zero by the ratio 4*dtau/tau !--method = 1 if ( abs ( dtaun ) < abs ( dtaup )) psi = psin * ( one - div ( four * dtaun , tau )) if ( abs ( dtaup ) < abs ( dtaun )) psi = psip * ( one - div ( four * dtaup , tau )) if ( psi_in ( psi )) exit !try doubling bound closest to zero: !--method = 2 if ( tau > zero ) psi = psin + psin if ( tau < zero ) psi = psip + psip if ( psi_in ( psi )) exit !try interpolating between bounds: !--method = 3 psi = psin + ( psip - psin ) * div ( - dtaun , dtaup - dtaun ) if ( psi_in ( psi )) exit !try halving between bounds: !--method = 4 psi = psin + ( psip - psin ) * 0.5_wp exit end do ! test for convergence i = 1 do j = 2 , 4 if ( abs ( c ( j )) > abs ( c ( i ))) i = j end do if ( abs ( dtau ) > abs ( c ( i )) * accrcy . and . & psip - psin > abs ( psi ) * accrcy . and . & psi /= psin . and . psi /= psip ) then cycle else exit end if end do !compute remaining three of four functions: g, gdm1, fm1, fd gdm1 = - mu * s2 / r fm1 = - mu * s2 / r0 fd = - mu * s1 / r0 / r ! compute state at time T = T0 + TAU rvf ( 1 : 3 ) = rv0 ( 1 : 3 ) + fm1 * rv0 ( 1 : 3 ) + g * rv0 ( 4 : 6 ) ! terminal positions rvf ( 4 : 6 ) = rv0 ( 4 : 6 ) + fd * rv0 ( 1 : 3 ) + gdm1 * rv0 ( 4 : 6 ) ! terminal velocities contains !******************************************************************************* !*************************************************************************** !> !  Returns a nonoverflowing quotient pure function div ( num , den ) implicit none real ( wp ) :: div real ( wp ), intent ( in ) :: num real ( wp ), intent ( in ) :: den real ( wp ), parameter :: fsmall = 1.0e-38_wp !! small number above underflow limit real ( wp ), parameter :: flarge = 1.0e+38_wp !! large number below underflow limit div = num / ( sign ( one , den ) * max ( abs ( den ), abs ( num ) / flarge , fsmall ) ) end function div !*************************************************************************** !*************************************************************************** !> !  Returns true if `phi` is within and not on bounds pure function psi_in ( psi ) implicit none logical :: psi_in real ( wp ), intent ( in ) :: psi ! > & < (not >= & <=) to avoid false convergence psi_in = ( psi > psin . and . psi < psip ) end function psi_in !*************************************************************************** end subroutine kepler_goodyear_stienon_klumpp","tags":"","url":"proc/kepler_goodyear_stienon_klumpp.html"},{"title":"compute_crtpb_parameter – fortran-astrodynamics-toolkit","text":"public pure function compute_crtpb_parameter(mu1, mu2) result(mu) Compute , the normalized CRTBP parameter.\nIt is equal to . as long are they are both the same units. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu1 grav param for body 1 real(kind=wp), intent(in) :: mu2 grav param for body 2 Return Value real(kind=wp) CRTBP parameter Called by proc~~compute_crtpb_parameter~~CalledByGraph proc~compute_crtpb_parameter compute_crtpb_parameter proc~crtbp_test crtbp_test proc~crtbp_test->proc~compute_crtpb_parameter proc~halo_to_rv halo_to_rv proc~halo_to_rv->proc~compute_crtpb_parameter proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~compute_crtpb_parameter proc~halo_to_rv_diffcorr->proc~halo_to_rv proc~halo_orbit_test halo_orbit_test proc~halo_orbit_test->proc~halo_to_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function compute_crtpb_parameter ( mu1 , mu2 ) result ( mu ) implicit none real ( wp ), intent ( in ) :: mu1 !! grav param for body 1 [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: mu2 !! grav param for body 2 [km&#94;3/s&#94;2] real ( wp ) :: mu !! CRTBP parameter \\mu mu = mu2 / ( mu1 + mu2 ) end function compute_crtpb_parameter","tags":"","url":"proc/compute_crtpb_parameter.html"},{"title":"compute_jacobi_constant – fortran-astrodynamics-toolkit","text":"public pure function compute_jacobi_constant(mu, x) result(c) Compute the CRTBP Jacobi constant, given the state. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu CRTBP parameter (See compute_crtpb_parameter ) real(kind=wp), intent(in), dimension(6) :: x normalized state vector Return Value real(kind=wp) Jacobi constant Called by proc~~compute_jacobi_constant~~CalledByGraph proc~compute_jacobi_constant compute_jacobi_constant proc~crtbp_test crtbp_test proc~crtbp_test->proc~compute_jacobi_constant Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function compute_jacobi_constant ( mu , x ) result ( c ) implicit none real ( wp ), intent ( in ) :: mu !! CRTBP parameter (See [[compute_crtpb_parameter]]) real ( wp ), dimension ( 6 ), intent ( in ) :: x !! normalized state vector real ( wp ) :: c !! Jacobi constant !local variables: real , dimension ( 3 ) :: r , v , rb1 , rb2 real ( wp ) :: omm , r1 , r2 !extract variables from x vector: r = x ( 1 : 3 ) ! position v = x ( 4 : 6 ) ! velocity !other parameters: omm = one - mu rb1 = [ - mu , zero , zero ] ! location of body 1 rb2 = [ omm , zero , zero ] ! location of body 2 r1 = norm2 ( r - rb1 ) ! body1 -> sc distance r2 = norm2 ( r - rb2 ) ! body2 -> sc distance !compute Jacobi integral: ! [ See: http://cosweb1.fau.edu/~jmirelesjames/hw4Notes.pdf ] if ( r1 == zero . or . r2 == zero ) then c = huge ( one ) ! a large value else c = r ( 1 ) ** 2 + r ( 2 ) ** 2 + & two * omm / r1 + two * mu / r2 - & ( v ( 1 ) ** 2 + v ( 2 ) ** 2 + v ( 3 ) ** 2 ) end if end function compute_jacobi_constant","tags":"","url":"proc/compute_jacobi_constant.html"},{"title":"normalize_variables – fortran-astrodynamics-toolkit","text":"public  subroutine normalize_variables(mu1, mu2, d12, x, m, t, x_crtbp, m_crtbp, t_crtbp) Convert state in km, km/s units to normalized CRTBP state. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu1 grav. param. of body 1 real(kind=wp), intent(in) :: mu2 grav. param. of body 2 real(kind=wp), intent(in) :: d12 distance between body 1 and body 2 [km] real(kind=wp), intent(in), optional, dimension(6) :: x unnormalized state w.r.t. barycenter [km,km/s] real(kind=wp), intent(in), optional :: m unnormalized mass [kg] real(kind=wp), intent(in), optional :: t unnormalized time [sec] real(kind=wp), intent(out), optional, dimension(6) :: x_crtbp CRTBP normalized state real(kind=wp), intent(out), optional :: m_crtbp CRTBP normalized mass real(kind=wp), intent(out), optional :: t_crtbp CRTBP normalized time Source Code subroutine normalize_variables ( mu1 , mu2 , d12 , x , m , t , x_crtbp , m_crtbp , t_crtbp ) implicit none real ( wp ), intent ( in ) :: mu1 !! grav. param. of body 1  [\\mathrm{km}&#94;3/\\mathrm{s}&#94;2]  real ( wp ), intent ( in ) :: mu2 !! grav. param. of body 2  [\\mathrm{km}&#94;3/\\mathrm{s}&#94;2]  real ( wp ), intent ( in ) :: d12 !! distance between body 1 and body 2 [km] real ( wp ), dimension ( 6 ), intent ( in ), optional :: x !! unnormalized state w.r.t. barycenter [km,km/s] real ( wp ), intent ( in ), optional :: m !! unnormalized mass [kg] real ( wp ), intent ( in ), optional :: t !! unnormalized time [sec] real ( wp ), dimension ( 6 ), intent ( out ), optional :: x_crtbp !! CRTBP normalized state real ( wp ), intent ( out ), optional :: m_crtbp !! CRTBP normalized mass real ( wp ), intent ( out ), optional :: t_crtbp !! CRTBP normalized time real ( wp ) :: tp , n , tu , du , mu n = sqrt (( mu1 + mu2 ) / d12 ** 3 ) !mean motion (rad/sec) tu = one / n !time unit du = d12 !distance unit if ( present ( x ) . and . present ( x_crtbp )) then x_crtbp ( 1 : 3 ) = x ( 1 : 3 ) / du !scale distance x_crtbp ( 4 : 6 ) = x ( 4 : 6 ) / ( du / tu ) !scale velocity end if if ( present ( m ) . and . present ( m_crtbp )) then mu = ( mu1 + mu2 ) / universal_grav_constant !mass unit m_crtbp = m / mu !scale mass end if if ( present ( t ) . and . present ( t_crtbp )) t_crtbp = t / tu !scale time end subroutine normalize_variables","tags":"","url":"proc/normalize_variables.html"},{"title":"unnormalize_variables – fortran-astrodynamics-toolkit","text":"public  subroutine unnormalize_variables(mu1, mu2, d12, x_crtbp, m_crtbp, t_crtbp, x, m, t) Convert normalized CRTBP state to km, km/s units. Notes: See also: http://www.spaceatdia.org/uploads/mariano/ss1/2012SSLecture3.pdf m1 = one - mu   ! mass of body 1\n   m2 = mu         ! mass of body 2 x1 = -mu        ! location of body 1\n   x2 = one - mu   ! location of body 2 normalized mass     : 1 MU -> (m1 + m2) kg\n   normalized position : 1 DU -> d12 km\n   normalized time     : 1 TU -> 1/n sec\n                         (2pi TU -> 1 rev -> 2pi/n) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu1 grav. param. of body 1 real(kind=wp), intent(in) :: mu2 grav. param. of body 2 real(kind=wp), intent(in) :: d12 distance between body 1 and body 2 [km] real(kind=wp), intent(in), optional, dimension(6) :: x_crtbp CRTBP normalized state real(kind=wp), intent(in), optional :: m_crtbp CRTBP normalized mass real(kind=wp), intent(in), optional :: t_crtbp CRTBP normalized time real(kind=wp), intent(out), optional, dimension(6) :: x unnormalized state w.r.t. barycenter [km,km/s] real(kind=wp), intent(out), optional :: m unnormalized mass [kg] real(kind=wp), intent(out), optional :: t unnormalized time [sec] Source Code subroutine unnormalize_variables ( mu1 , mu2 , d12 , x_crtbp , m_crtbp , t_crtbp , x , m , t ) implicit none real ( wp ), intent ( in ) :: mu1 !! grav. param. of body 1  [\\mathrm{km}&#94;3/\\mathrm{s}&#94;2]  real ( wp ), intent ( in ) :: mu2 !! grav. param. of body 2  [\\mathrm{km}&#94;3/\\mathrm{s}&#94;2]  real ( wp ), intent ( in ) :: d12 !! distance between body 1 and body 2 [km] real ( wp ), dimension ( 6 ), intent ( in ), optional :: x_crtbp !! CRTBP normalized state real ( wp ), intent ( in ), optional :: m_crtbp !! CRTBP normalized mass real ( wp ), intent ( in ), optional :: t_crtbp !! CRTBP normalized time real ( wp ), dimension ( 6 ), intent ( out ), optional :: x !! unnormalized state w.r.t. barycenter [km,km/s] real ( wp ), intent ( out ), optional :: m !! unnormalized mass [kg] real ( wp ), intent ( out ), optional :: t !! unnormalized time [sec] real ( wp ) :: tp , n , tu , du , mu n = sqrt (( mu1 + mu2 ) / d12 ** 3 ) !mean motion (rad/sec) tu = one / n !time unit du = d12 !distance unit if ( present ( x ) . and . present ( x_crtbp )) then x ( 1 : 3 ) = x_crtbp ( 1 : 3 ) * du !unscale distance x ( 4 : 6 ) = x_crtbp ( 4 : 6 ) * ( du / tu ) !unscale velocity end if if ( present ( m ) . and . present ( m_crtbp )) then mu = ( mu1 + mu2 ) / universal_grav_constant !mass unit m = m_crtbp * mu !unscale mass end if if ( present ( t ) . and . present ( t_crtbp )) t = t_crtbp * tu !unscale time end subroutine unnormalize_variables","tags":"","url":"proc/unnormalize_variables.html"},{"title":"compute_libration_points – fortran-astrodynamics-toolkit","text":"public  subroutine compute_libration_points(mu, r1, r2, r3, r4, r5) Uses math_module proc~~compute_libration_points~~UsesGraph proc~compute_libration_points compute_libration_points module~math_module math_module proc~compute_libration_points->module~math_module module~kind_module kind_module module~math_module->module~kind_module module~numbers_module numbers_module module~math_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Compute the coordinates of the libration points (L1,L2,L3,L4,L5).\nL1-L3 are computed using Newton's method. L4-L5 are known analytically. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu CRTBP parameter real(kind=wp), intent(out), optional :: r1 L1 x coordinate real(kind=wp), intent(out), optional :: r2 L2 x coordinate real(kind=wp), intent(out), optional :: r3 L3 x coordinate real(kind=wp), intent(out), optional, dimension(2) :: r4 L4 [x,y] coordinates real(kind=wp), intent(out), optional, dimension(2) :: r5 L5 [x,y] coordinates Calls proc~~compute_libration_points~~CallsGraph proc~compute_libration_points compute_libration_points proc~cube_root cube_root proc~compute_libration_points->proc~cube_root Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_libration_points~~CalledByGraph proc~compute_libration_points compute_libration_points proc~compute_libration_points_v2 compute_libration_points_v2 proc~compute_libration_points_v2->proc~compute_libration_points proc~crtbp_test crtbp_test proc~crtbp_test->proc~compute_libration_points proc~crtbp_test->proc~compute_libration_points_v2 proc~halo_to_rv halo_to_rv proc~halo_to_rv->proc~compute_libration_points proc~halo_orbit_test halo_orbit_test proc~halo_orbit_test->proc~halo_to_rv proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~halo_to_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_libration_points ( mu , r1 , r2 , r3 , r4 , r5 ) use math_module , only : cube_root implicit none real ( wp ), intent ( in ) :: mu !! CRTBP parameter real ( wp ), intent ( out ), optional :: r1 !! L1 x coordinate real ( wp ), intent ( out ), optional :: r2 !! L2 x coordinate real ( wp ), intent ( out ), optional :: r3 !! L3 x coordinate real ( wp ), dimension ( 2 ), intent ( out ), optional :: r4 !! L4 [x,y] coordinates real ( wp ), dimension ( 2 ), intent ( out ), optional :: r5 !! L5 [x,y] coordinates integer :: i !! counter real ( wp ) :: f !! quintic function value (to be driven to zero) real ( wp ) :: fp !! derivative of quintic function real ( wp ) :: x !! indep. variable in the quintic functions integer , parameter :: maxiter = 100 !! maximum number of !! iterations for newton's method real ( wp ), parameter :: tol = 1.0e-12_wp !! convergence tolerance for !! newton's method !L1, L2, and L3 are solved using iterative Newton method: if ( present ( r1 )) then x = cube_root ( mu / ( 3.0_wp - 3.0_wp * mu )) !initial guess do i = 1 , maxiter f = x ** 5 - & ( 3.0_wp - mu ) * x ** 4 + & ( 3.0_wp - 2.0_wp * mu ) * x ** 3 - & mu * x ** 2 + & 2.0_wp * mu * x - & mu if ( abs ( f ) <= tol ) exit fp = 5.0_wp * x ** 4 - & 4.0_wp * x ** 3 * ( 3.0_wp - mu ) + & 3.0_wp * x ** 2 * ( 3.0_wp - 2.0_wp * mu ) - & 2.0_wp * x * mu + & 2.0_wp * mu x = x - f / fp end do r1 = 1.0_wp - x ! wrt primary body r1 = r1 - mu ! wrt barycenter end if if ( present ( r2 )) then x = cube_root ( mu / ( 3.0_wp - 3.0_wp * mu )) !initial guess do i = 1 , maxiter f = x ** 5 + & ( 3.0_wp - mu ) * x ** 4 + & ( 3.0_wp - 2.0_wp * mu ) * x ** 3 - & mu * x ** 2 - & 2.0_wp * mu * x - & mu if ( abs ( f ) <= tol ) exit fp = 5.0_wp * x ** 4 + & 4.0_wp * x ** 3 * ( 3.0_wp - mu ) + & 3.0_wp * x ** 2 * ( 3.0_wp - 2.0_wp * mu ) - & 2.0_wp * x * mu - & 2.0_wp * mu x = x - f / fp end do r2 = 1.0_wp + x ! wrt primary body r2 = r2 - mu ! wrt barycenter end if if ( present ( r3 )) then x = - ( 7.0_wp / 1 2.0_wp ) * mu !initial guess do i = 1 , maxiter f = x ** 5 + & ( 7.0_wp + mu ) * x ** 4 + & ( 1 9.0_wp + 6.0_wp * mu ) * x ** 3 + & ( 2 4.0_wp + 1 3.0_wp * mu ) * x ** 2 + & 2.0_wp * ( 6.0_wp + 7.0_wp * mu ) * x + & 7.0_wp * mu if ( abs ( f ) <= tol ) exit fp = 5.0_wp * x ** 4 + & 4.0_wp * x ** 3 * ( 7.0_wp + mu ) + & 3.0_wp * x ** 2 * ( 1 9.0_wp + 6.0_wp * mu ) + & 2.0_wp * x * ( 2 4.0_wp + 1 3.0_wp * mu ) + & 2.0_wp * ( 6.0_wp + 7.0_wp * mu ) x = x - f / fp end do r3 = - ( x + 1.0_wp ) ! wrt primary body r3 = r3 - mu ! wrt barycenter end if ! L4 and L5 are analytic: if ( present ( r4 )) r4 = [ 0.5_wp - mu , sqrt ( 3.0_wp ) / 2.0_wp ] if ( present ( r5 )) r5 = [ 0.5_wp - mu , - sqrt ( 3.0_wp ) / 2.0_wp ] end subroutine compute_libration_points","tags":"","url":"proc/compute_libration_points.html"},{"title":"compute_libration_points_v2 – fortran-astrodynamics-toolkit","text":"public  subroutine compute_libration_points_v2(mu, r1, r2, r3, r4, r5) Uses math_module proc~~compute_libration_points_v2~~UsesGraph proc~compute_libration_points_v2 compute_libration_points_v2 module~math_module math_module proc~compute_libration_points_v2->module~math_module module~kind_module kind_module module~math_module->module~kind_module module~numbers_module numbers_module module~math_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Compute the coordinates of the libration points (L1,L2,L3,L4,L5). This is just an alternate version of compute_libration_points . Reference J.S. Parker, R.L. Anderson, \"Low-Energy Lunar Trajectory Design\", 2014.\n   (Appendix A.5) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu CRTBP parameter real(kind=wp), intent(out), optional :: r1 L1 x coordinate real(kind=wp), intent(out), optional :: r2 L2 x coordinate real(kind=wp), intent(out), optional :: r3 L3 x coordinate real(kind=wp), intent(out), optional, dimension(2) :: r4 L4 [x,y] coordinates real(kind=wp), intent(out), optional, dimension(2) :: r5 L5 [x,y] coordinates Calls proc~~compute_libration_points_v2~~CallsGraph proc~compute_libration_points_v2 compute_libration_points_v2 proc~compute_libration_points compute_libration_points proc~compute_libration_points_v2->proc~compute_libration_points proc~cube_root cube_root proc~compute_libration_points_v2->proc~cube_root proc~compute_libration_points->proc~cube_root Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_libration_points_v2~~CalledByGraph proc~compute_libration_points_v2 compute_libration_points_v2 proc~crtbp_test crtbp_test proc~crtbp_test->proc~compute_libration_points_v2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_libration_points_v2 ( mu , r1 , r2 , r3 , r4 , r5 ) use math_module , only : cube_root implicit none real ( wp ), intent ( in ) :: mu !! CRTBP parameter real ( wp ), intent ( out ), optional :: r1 !! L1 x coordinate real ( wp ), intent ( out ), optional :: r2 !! L2 x coordinate real ( wp ), intent ( out ), optional :: r3 !! L3 x coordinate real ( wp ), dimension ( 2 ), intent ( out ), optional :: r4 !! L4 [x,y] coordinates real ( wp ), dimension ( 2 ), intent ( out ), optional :: r5 !! L5 [x,y] coordinates integer , parameter :: maxiter = 100 !! maximum number of iterations real ( wp ), parameter :: tol = 1.0e-12_wp !! convergence tolerance real ( wp ) :: gamma , gamma0 integer :: i !! counter if ( present ( r1 )) then gamma0 = cube_root ( mu * ( one - mu ) / three ) gamma = gamma0 + one do i = 1 , maxiter if ( abs ( gamma - gamma0 ) <= tol ) exit gamma0 = gamma gamma = cube_root (( mu * ( gamma0 - one ) ** 2 ) / ( three - two * mu - gamma0 * ( three - mu - gamma0 ))) end do r1 = one - mu - gamma end if if ( present ( r2 )) then gamma0 = cube_root ( mu * ( one - mu ) / three ) gamma = gamma0 + one do i = 1 , maxiter if ( abs ( gamma - gamma0 ) <= tol ) exit gamma0 = gamma gamma = cube_root (( mu * ( gamma0 + one ) ** 2 ) / ( three - two * mu + gamma0 * ( three - mu + gamma0 ))) end do r2 = one - mu + gamma end if if ( present ( r3 )) then gamma0 = cube_root ( mu * ( one - mu ) / three ) gamma = gamma0 + one do i = 1 , maxiter if ( abs ( gamma - gamma0 ) <= tol ) exit gamma0 = gamma gamma = cube_root (( one - mu ) * ( gamma0 + one ) ** 2 / ( one + two * mu + gamma0 * ( two + mu + gamma0 ))) end do r3 = - mu - gamma end if call compute_libration_points ( mu , r4 = r4 , r5 = r5 ) end subroutine compute_libration_points_v2","tags":"","url":"proc/compute_libration_points_v2.html"},{"title":"crtbp_derivs – fortran-astrodynamics-toolkit","text":"public  subroutine crtbp_derivs(mu, x, dx) CRTBP derivatives: state only. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu CRTBP parameter (See compute_crtpb_parameter ) real(kind=wp), intent(in), dimension(6) :: x normalized state real(kind=wp), intent(out), dimension(6) :: dx normalized state derivative Called by proc~~crtbp_derivs~~CalledByGraph proc~crtbp_derivs crtbp_derivs proc~crtbp_test crtbp_test proc~crtbp_test->proc~crtbp_derivs Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine crtbp_derivs ( mu , x , dx ) implicit none real ( wp ), intent ( in ) :: mu !! CRTBP parameter (See [[compute_crtpb_parameter]]) real ( wp ), dimension ( 6 ), intent ( in ) :: x !! normalized state [\\mathbf{r},\\mathbf{v}] real ( wp ), dimension ( 6 ), intent ( out ) :: dx !! normalized state derivative [\\dot{\\mathbf{r}},\\dot{\\mathbf{v}}] !local variables: real ( wp ), dimension ( 3 ) :: r1 , r2 , rb1 , rb2 , r , v , g real ( wp ) :: r13 , r23 , omm , c1 , c2 !extract variables from x vector: r = x ( 1 : 3 ) ! position v = x ( 4 : 6 ) ! velocity !other parameters: omm = one - mu rb1 = [ - mu , zero , zero ] ! location of body 1 rb2 = [ omm , zero , zero ] ! location of body 2 r1 = r - rb1 ! body1 -> sc vector r2 = r - rb2 ! body2 -> sc vector r13 = norm2 ( r1 ) ** 3 r23 = norm2 ( r2 ) ** 3 c1 = omm / r13 c2 = mu / r23 !normalized gravity from both bodies: g ( 1 ) = - c1 * ( r ( 1 ) + mu ) - c2 * ( r ( 1 ) - one + mu ) g ( 2 ) = - c1 * r ( 2 ) - c2 * r ( 2 ) g ( 3 ) = - c1 * r ( 3 ) - c2 * r ( 3 ) ! derivative of x: dx ( 1 : 3 ) = v ! rdot dx ( 4 ) = two * v ( 2 ) + r ( 1 ) + g ( 1 ) ! vdot dx ( 5 ) = - two * v ( 1 ) + r ( 2 ) + g ( 2 ) ! dx ( 6 ) = g ( 3 ) ! end subroutine crtbp_derivs","tags":"","url":"proc/crtbp_derivs.html"},{"title":"crtbp_derivs_with_stm – fortran-astrodynamics-toolkit","text":"public  subroutine crtbp_derivs_with_stm(mu, x, dx) CRTBP derivatives: state + state transition matrix. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu CRTBP parameter (See compute_crtpb_parameter ) real(kind=wp), intent(in), dimension(42) :: x normalized state and STM real(kind=wp), intent(out), dimension(42) :: dx normalized state and STM derivative Called by proc~~crtbp_derivs_with_stm~~CalledByGraph proc~crtbp_derivs_with_stm crtbp_derivs_with_stm proc~crtbp_test crtbp_test proc~crtbp_test->proc~crtbp_derivs_with_stm Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine crtbp_derivs_with_stm ( mu , x , dx ) implicit none real ( wp ), intent ( in ) :: mu !! CRTBP parameter (See [[compute_crtpb_parameter]]) real ( wp ), dimension ( 42 ), intent ( in ) :: x !! normalized state and STM [\\mathbf{r},\\mathbf{v},\\mathbf{\\Phi}] real ( wp ), dimension ( 42 ), intent ( out ) :: dx !! normalized state and STM derivative [\\dot{\\mathbf{r}},\\dot{\\mathbf{v}},\\dot{\\mathbf{\\Phi}}] !local variables: real , dimension ( 3 ) :: rb1 , rb2 , r , v , g real ( wp ), dimension ( 6 , 6 ) :: A , phi , phi_dot real ( wp ) :: r1 , r2 , r13 , r23 , r15 , r25 , omm , tmu , tomm , c1 , c2 real ( wp ) :: Uxx , Uxy , Uxz , Uyx , Uyy , Uyz , Uzx , Uzy , Uzz !extract variables from x vector: r = x ( 1 : 3 ) ! position v = x ( 4 : 6 ) ! velocity !other parameters: omm = one - mu rb1 = [ - mu , zero , zero ] ! location of body 1 rb2 = [ omm , zero , zero ] ! location of body 2 r1 = norm2 ( r - rb1 ) ! body1 -> sc distance r2 = norm2 ( r - rb2 ) ! body2 -> sc distance r13 = r1 ** 3 r23 = r2 ** 3 r15 = r1 ** 5 r25 = r2 ** 5 c1 = omm / r13 c2 = mu / r23 tmu = three * mu tomm = three * omm !normalized gravity from both bodies: g ( 1 ) = - c1 * ( r ( 1 ) + mu ) - c2 * ( r ( 1 ) - one + mu ) g ( 2 ) = - c1 * r ( 2 ) - c2 * r ( 2 ) g ( 3 ) = - c1 * r ( 3 ) - c2 * r ( 3 ) !STM terms: Uxx = one - c1 - c2 + tomm * ( r ( 1 ) + mu ) ** 2 / r15 + tmu * ( r ( 1 ) - one + mu ) ** 2 / r25 Uyy = one - c1 - c2 + tomm * r ( 2 ) ** 2 / r15 + tmu * r ( 2 ) ** 2 / r25 Uzz = c1 - c2 + tomm * r ( 3 ) ** 2 / r15 + tmu * r ( 3 ) ** 2 / r25 Uxy = tomm * ( r ( 1 ) + mu ) * r ( 2 ) / r15 + tmu * ( r ( 1 ) - one + mu ) * r ( 2 ) / r25 Uxz = tomm * ( r ( 1 ) + mu ) * r ( 3 ) / r15 + tmu * ( r ( 1 ) - one + mu ) * r ( 3 ) / r25 Uyz = tomm * r ( 2 ) * r ( 3 ) / r15 + tmu * r ( 2 ) * r ( 3 ) / r25 Uyx = Uxy Uzx = Uxz Uzy = Uyz !columns of A matrix: A (:, 1 ) = [ zero , zero , zero , Uxx , Uyx , Uzx ] A (:, 2 ) = [ zero , zero , zero , Uxy , Uyy , Uzy ] A (:, 3 ) = [ zero , zero , zero , Uxz , Uyz , Uzz ] A (:, 4 ) = [ one , zero , zero , zero , - two , zero ] A (:, 5 ) = [ zero , one , zero , two , zero , zero ] A (:, 6 ) = [ zero , zero , one , zero , zero , zero ] !unpack phi into matrix: phi = reshape ( x ( 7 : 42 ), shape = [ 6 , 6 ]) !derivative of phi matrix: phi_dot = matmul ( A , phi ) !derivative of x vector: dx ( 1 : 3 ) = v ! r_dot dx ( 4 ) = two * v ( 2 ) + r ( 1 ) + g ( 1 ) ! v_dot dx ( 5 ) = - two * v ( 1 ) + r ( 2 ) + g ( 2 ) ! dx ( 6 ) = g ( 3 ) ! dx ( 7 : 42 ) = pack ( phi_dot , mask = . true .) ! phi_dot end subroutine crtbp_derivs_with_stm","tags":"","url":"proc/crtbp_derivs_with_stm.html"},{"title":"crtbp_test – fortran-astrodynamics-toolkit","text":"public  subroutine crtbp_test() Uses celestial_body_module proc~~crtbp_test~~UsesGraph proc~crtbp_test crtbp_test module~celestial_body_module celestial_body_module proc~crtbp_test->module~celestial_body_module module~base_class_module base_class_module module~celestial_body_module->module~base_class_module module~kind_module kind_module module~celestial_body_module->module~kind_module module~numbers_module numbers_module module~celestial_body_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Unit tests for CRTBP routines. Arguments None Calls proc~~crtbp_test~~CallsGraph proc~crtbp_test crtbp_test proc~compute_crtpb_parameter compute_crtpb_parameter proc~crtbp_test->proc~compute_crtpb_parameter proc~compute_jacobi_constant compute_jacobi_constant proc~crtbp_test->proc~compute_jacobi_constant proc~compute_libration_points compute_libration_points proc~crtbp_test->proc~compute_libration_points proc~compute_libration_points_v2 compute_libration_points_v2 proc~crtbp_test->proc~compute_libration_points_v2 proc~crtbp_derivs crtbp_derivs proc~crtbp_test->proc~crtbp_derivs proc~crtbp_derivs_with_stm crtbp_derivs_with_stm proc~crtbp_test->proc~crtbp_derivs_with_stm proc~cube_root cube_root proc~compute_libration_points->proc~cube_root proc~compute_libration_points_v2->proc~compute_libration_points proc~compute_libration_points_v2->proc~cube_root Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine crtbp_test () use celestial_body_module implicit none real ( wp ), parameter :: mu_earth = body_earth % mu !!  \\mu_{Earth} ~ (\\mathrm{km}&#94;3/\\mathrm{s}&#94;2)  real ( wp ), parameter :: mu_moon = body_moon % mu !!  \\mu_{Moon}  ~ (\\mathrm{km}&#94;3/\\mathrm{s}&#94;2)  real ( wp ), parameter :: mu_sun = body_sun % mu !!  \\mu_{Sun}   ~ (\\mathrm{km}&#94;3/\\mathrm{s}&#94;2)  !< sample state (normalized) !< see: [Celestial Mechanics Notes Set 4: The Circular Restricted !< Three Body Problem](http://cosweb1.fau.edu/~jmirelesjames/hw4Notes.pdf), p.40. real ( wp ), dimension ( 6 ), parameter :: x = [ 0.30910452642073_wp , & 0.07738174525518_wp , & 0.0_wp , & - 0.72560796964234_wp , & 1.55464233412773_wp , & 0.0_wp ] integer :: i !! counter real ( wp ) :: mu !! CRTPB parameter real ( wp ) :: mu1 !! primary body mu real ( wp ) :: mu2 !! secondary body mu real ( wp ) :: c !! Jacobi constant real ( wp ), dimension ( 6 ) :: xd !! derivative vector: state real ( wp ), dimension ( 42 ) :: x_phi !! initial state + phi (identity) real ( wp ), dimension ( 42 ) :: x_phi_d !! derivative vector: state + phi real ( wp ), dimension ( 6 , 6 ) :: eye !! 6x6 identity matrix real ( wp ) :: r1 !! L1 x coordinate (normalized) real ( wp ) :: r2 !! L2 x coordinate (normalized) real ( wp ) :: r3 !! L3 x coordinate (normalized) real ( wp ), dimension ( 2 ) :: r4 !! L4 x coordinate (normalized) real ( wp ), dimension ( 2 ) :: r5 !! L5 x coordinate (normalized) !create an identity matrix for stm initial condition: eye = zero do i = 1 , 6 eye ( i , i ) = one end do x_phi = [ x , pack ( eye , mask = . true .)] write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' crtbp_test' write ( * , * ) '---------------' write ( * , * ) '' do i = 1 , 3 select case ( i ) case ( 1 ) mu1 = mu_earth mu2 = mu_moon case ( 2 ) mu1 = mu_earth mu2 = mu_earth case ( 3 ) mu1 = mu_earth + mu_moon / four mu2 = mu_earth end select write ( * , * ) '' mu = compute_crtpb_parameter ( mu1 , mu2 ) c = compute_jacobi_constant ( mu , x ) call crtbp_derivs ( mu , x , xd ) call crtbp_derivs_with_stm ( mu , x_phi , x_phi_d ) call compute_libration_points ( mu , r1 , r2 , r3 , r4 , r5 ) write ( * , '(A,1X,*(F30.16,1X))' ) 'mu:         ' , mu write ( * , '(A,1X,*(F30.16,1X))' ) 'L1 x:       ' , r1 write ( * , '(A,1X,*(F30.16,1X))' ) 'L2 x:       ' , r2 write ( * , '(A,1X,*(F30.16,1X))' ) 'L3 x:       ' , r3 write ( * , '(A,1X,*(F30.16,1X))' ) 'L4 x:       ' , r4 write ( * , '(A,1X,*(F30.16,1X))' ) 'L5 x:       ' , r5 write ( * , '(A,1X,*(F30.16,1X))' ) 'x:          ' , x write ( * , '(A,1X,*(F30.16,1X))' ) 'c:          ' , c write ( * , '(A,1X,*(F30.16,1X))' ) 'xd:         ' , xd write ( * , '(A,1X,*(F30.16,1X))' ) 'x+phi:      ' , x_phi write ( * , '(A,1X,*(F30.16,1X))' ) 'xd+phi_dot: ' , x_phi_d write ( * , * ) '' call compute_libration_points_v2 ( mu , r1 , r2 , r3 , r4 , r5 ) write ( * , * ) '' write ( * , * ) 'alternate formulation:' write ( * , '(A,1X,*(F30.16,1X))' ) 'L1 x:       ' , r1 write ( * , '(A,1X,*(F30.16,1X))' ) 'L2 x:       ' , r2 write ( * , '(A,1X,*(F30.16,1X))' ) 'L3 x:       ' , r3 write ( * , '(A,1X,*(F30.16,1X))' ) 'L4 x:       ' , r4 write ( * , '(A,1X,*(F30.16,1X))' ) 'L5 x:       ' , r5 write ( * , * ) '' end do end subroutine crtbp_test","tags":"","url":"proc/crtbp_test.html"},{"title":"ekepl – fortran-astrodynamics-toolkit","text":"public pure function ekepl(em, e1) Kepler's equation, em = ekepl - (1 - e1)*sin(ekepl) ,\nwith e1 in range 1 to 0 inclusive, solved accurately\n(based on ekepl3, but entering e1 , not e ) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: em real(kind=wp), intent(in) :: e1 Return Value real(kind=wp) Calls proc~~ekepl~~CallsGraph proc~ekepl ekepl proc~dcbsol dcbsol proc~ekepl->proc~dcbsol proc~emkep emkep proc~ekepl->proc~emkep proc~dcubrt dcubrt proc~dcbsol->proc~dcubrt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~ekepl~~CalledByGraph proc~ekepl ekepl proc~els2pv els2pv proc~els2pv->proc~ekepl proc~els3pv els3pv proc~els3pv->proc~els2pv proc~propagate propagate proc~propagate->proc~els3pv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function ekepl ( em , e1 ) implicit none real ( wp ) :: ekepl real ( wp ), intent ( in ) :: em real ( wp ), intent ( in ) :: e1 real ( wp ) :: emr , ee , e , w , fdd , fddd , f , fd , dee integer :: iter real ( wp ), parameter :: sw = 0.25_wp !range-reduce em to lie in range -pi to pi emr = mod ( em , twopi ) if ( emr < pineg ) emr = emr + twopi if ( emr > pi ) emr = emr - twopi ee = emr if ( ee /= zero ) then if ( ee < zero ) ee = - ee !(emr is range-reduced em & ee is absolute value of emr) !starter by first solving cubic equation e = one - e1 w = dcbsol ( e , two * e1 , three * ee ) !effectively interpolate in emr (absolute value) ee = ( ee * ee + ( pi - ee ) * w ) / pi if ( emr < zero ) ee = - ee !do two iterations of halley, each followed by newton do iter = 1 , 2 fdd = e * sin ( ee ) fddd = e * cos ( ee ) if ( ee * ee / six + e1 >= sw ) then f = ( ee - fdd ) - emr fd = one - fddd else f = emkep ( e1 , ee ) - emr fd = two * e * sin ( half * ee ) ** 2 + e1 end if dee = f * fd / ( half * f * fdd - fd * fd ) f = f + dee * ( fd + half * dee * ( fdd + athird * dee * fddd )) !to reduce the danger of underflow replace the last line by !    w = fd + half*dee*(fdd + athird*dee*fddd) fd = fd + dee * ( fdd + half * dee * fddd ) ee = ee + dee - f / fd !if replacing as above, then also replace the last line by !ee = ee - (f - dee*(fd - w))/fd end do end if !range-expand ekepl = ee + ( em - emr ) end function ekepl","tags":"","url":"proc/ekepl.html"},{"title":"ekepl1 – fortran-astrodynamics-toolkit","text":"public pure function ekepl1(em, e) Solve kepler's equation, em = ekepl - e*sin(ekepl) ,\nwith legendre-based starter and halley iterator\n(function has also been used under the name eafkep) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: em real(kind=wp), intent(in) :: e Return Value real(kind=wp) Source Code pure function ekepl1 ( em , e ) implicit none real ( wp ) :: ekepl1 real ( wp ), intent ( in ) :: em real ( wp ), intent ( in ) :: e real ( wp ) :: c , s , psi , xi , eta , fd , fdd , f real ( wp ), parameter :: testsq = 1.0e-8_wp c = e * cos ( em ) s = e * sin ( em ) psi = s / sqrt ( one - c - c + e * e ) do xi = cos ( psi ) eta = sin ( psi ) fd = ( one - c * xi ) + s * eta fdd = c * eta + s * xi f = psi - fdd psi = psi - f * fd / ( fd * fd - half * f * fdd ) if ( f * f < testsq ) exit end do ekepl1 = em + psi end function ekepl1","tags":"","url":"proc/ekepl1.html"},{"title":"ekepl2 – fortran-astrodynamics-toolkit","text":"public pure function ekepl2(em, e) Kepler's equation, em = ekepl - e*sin(ekepl) with\ne in range 0 to 1 inclusive, solved accurately Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: em real(kind=wp), intent(in) :: e Return Value real(kind=wp) Calls proc~~ekepl2~~CallsGraph proc~ekepl2 ekepl2 proc~emkepl emkepl proc~ekepl2->proc~emkepl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function ekepl2 ( em , e ) implicit none real ( wp ) :: ekepl2 real ( wp ), intent ( in ) :: em real ( wp ), intent ( in ) :: e real ( wp ) :: emr , ee , w , e1 , fdd , fddd , f , fd , dee logical :: l integer :: iter real ( wp ), parameter :: sw = 0.1_wp real ( wp ), parameter :: a = ( pi - one ) ** 2 / ( pi + two / three ) real ( wp ), parameter :: b = two * ( pi - asixth ) ** 2 / ( pi + two / three ) !range-reduce em to line in range -pi to pi emr = mod ( em , twopi ) if ( emr < pineg ) emr = emr + twopi if ( emr > pi ) emr = emr - twopi ee = emr if ( ee /= zero ) then if ( ee < zero ) ee = - ee !(emr is range-reduced em & ee is absolute value of emr) !started for e = 1 by cube root of bilinear function if ( ee < asixth ) then ee = ( six * ee ) ** athird else w = pi - ee ee = pi - a * w / ( b - w ) end if if ( emr < zero ) ee = - ee !interpolate for e ee = emr + ( ee - emr ) * e !do two iterations of halley, each followed by newton e1 = one - e l = ( e1 + ee * ee / six ) >= sw do iter = 1 , 2 fdd = e * sin ( ee ) fddd = e * cos ( ee ) if ( l ) then f = ( ee - fdd ) - emr fd = one - fddd else f = emkepl ( e , ee ) - emr fd = e1 + two * e * sin ( half * ee ) ** 2 end if dee = f * fd / ( half * f * fdd - fd * fd ) f = f + dee * ( fd + half * dee * ( fdd + athird * dee * fddd )) !to reduce the danger of underflow replace the last line by !w = fd + half*dee*(fdd + athird*dee*fddd) fd = fd + dee * ( fdd + half * dee * fddd ) ee = ee + dee - f / fd !if replacing as above, then also replace the last line by !ee = ee - (f - dee*(fd - w))/fd end do end if !range-expand ekepl2 = ee + ( em - emr ) end function ekepl2","tags":"","url":"proc/ekepl2.html"},{"title":"emkepl – fortran-astrodynamics-toolkit","text":"public pure function emkepl(e, ee) Accurate computation of ee - e*sin(ee) when (e, ee) is close to (1, 0) as then rounding worse not better Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: ee Return Value real(kind=wp) Called by proc~~emkepl~~CalledByGraph proc~emkepl emkepl proc~ekepl2 ekepl2 proc~ekepl2->proc~emkepl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function emkepl ( e , ee ) implicit none real ( wp ) :: emkepl real ( wp ), intent ( in ) :: e real ( wp ), intent ( in ) :: ee real ( wp ) :: x , ee2 , term , d , x0 x = ( one - e ) * sin ( ee ) ee2 = - ee * ee term = ee d = zero do d = d + two term = term * ee2 / ( d * ( d + one )) x0 = x x = x - term if ( x == x0 ) exit end do emkepl = x end function emkepl","tags":"","url":"proc/emkepl.html"},{"title":"emkep – fortran-astrodynamics-toolkit","text":"public pure function emkep(e1, ee) Similar to emkepl, except input is 1-e . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: e1 real(kind=wp), intent(in) :: ee Return Value real(kind=wp) Called by proc~~emkep~~CalledByGraph proc~emkep emkep proc~ekepl ekepl proc~ekepl->proc~emkep proc~pv2els pv2els proc~pv2els->proc~emkep proc~els2pv els2pv proc~els2pv->proc~ekepl proc~pv3els pv3els proc~pv3els->proc~pv2els proc~els3pv els3pv proc~els3pv->proc~els2pv proc~lambert_test lambert_test proc~lambert_test->proc~pv3els proc~propagate propagate proc~propagate->proc~pv3els proc~propagate->proc~els3pv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function emkep ( e1 , ee ) implicit none real ( wp ) :: emkep real ( wp ), intent ( in ) :: e1 real ( wp ), intent ( in ) :: ee real ( wp ) :: x , ee2 , term , d , x0 x = e1 * sin ( ee ) ee2 = - ee * ee term = ee d = zero do d = d + two term = term * ee2 / ( d * ( d + one )) x0 = x x = x - term if ( x == x0 ) exit end do emkep = x end function emkep","tags":"","url":"proc/emkep.html"},{"title":"shkepl – fortran-astrodynamics-toolkit","text":"public pure function shkepl(el, g1) Equation el = shkepl + (g1 - 1)*asinh(shkepl) ,\nwith g1 in range 0 to 1 inclusive, solved accurately. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: el real(kind=wp), intent(in) :: g1 Return Value real(kind=wp) Calls proc~~shkepl~~CallsGraph proc~shkepl shkepl proc~dcubrt dcubrt proc~shkepl->proc~dcubrt proc~shmkep shmkep proc~shkepl->proc~shmkep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~shkepl~~CalledByGraph proc~shkepl shkepl proc~els2pv els2pv proc~els2pv->proc~shkepl proc~els3pv els3pv proc~els3pv->proc~els2pv proc~propagate propagate proc~propagate->proc~els3pv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function shkepl ( el , g1 ) implicit none real ( wp ) :: shkepl real ( wp ), intent ( in ) :: el real ( wp ), intent ( in ) :: g1 real ( wp ) :: s , g , cl , al , w , s0 , s1 , s2 , s3 , fdd , fddd , f , fd , ds , stemp integer :: iter real ( wp ), parameter :: sw = half s = el if ( el /= zero ) then !started based on lagrange's theorem g = one - g1 cl = sqrt ( one + el ** 2 ) al = asinh ( el ) w = g ** 2 * al / cl ** 3 s = one - g / cl s = el + g * al / dcubrt ( s ** 3 + w * el * ( 1.5_wp - g / 0.75_wp )) !two iterations (at most) of halley-then-newton process do iter = 1 , 2 s0 = s * s s1 = s0 + one s2 = sqrt ( s1 ) s3 = s1 * s2 fdd = g * s / s3 fddd = g * ( one - two * s0 ) / ( s1 * s3 ) if ( asixth * s0 + g1 >= sw ) then f = ( s - g * asinh ( s )) - el fd = one - g / s2 else f = shmkep ( g1 , s ) - el fd = ( s0 / ( s2 + one ) + g1 ) / s2 end if ds = f * fd / ( half * f * fdd - fd * fd ) stemp = s + ds if ( stemp == s ) exit f = f + ds * ( fd + half * ds * ( fdd + athird * ds * fddd )) fd = fd + ds * ( fdd + half * ds * fddd ) s = stemp - f / fd end do end if shkepl = s end function shkepl","tags":"","url":"proc/shkepl.html"},{"title":"shmkep – fortran-astrodynamics-toolkit","text":"public pure function shmkep(g1, s) Accurate computation of s - (1 - g1)*asinh(s) when (g1, s) is close to (0, 0) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: g1 real(kind=wp), intent(in) :: s Return Value real(kind=wp) Called by proc~~shmkep~~CalledByGraph proc~shmkep shmkep proc~pv2els pv2els proc~pv2els->proc~shmkep proc~shkepl shkepl proc~shkepl->proc~shmkep proc~els2pv els2pv proc~els2pv->proc~shkepl proc~pv3els pv3els proc~pv3els->proc~pv2els proc~els3pv els3pv proc~els3pv->proc~els2pv proc~lambert_test lambert_test proc~lambert_test->proc~pv3els proc~propagate propagate proc~propagate->proc~pv3els proc~propagate->proc~els3pv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function shmkep ( g1 , s ) implicit none real ( wp ) :: shmkep real ( wp ), intent ( in ) :: g1 real ( wp ), intent ( in ) :: s real ( wp ) :: g , t , tsq , x , term , twoi1 , x0 g = one - g1 t = s / ( one + sqrt ( one + s * s )) tsq = t * t x = s * ( g1 + g * tsq ) term = two * g * t twoi1 = one do twoi1 = twoi1 + two term = term * tsq x0 = x x = x - term / twoi1 if ( x == x0 ) exit end do shmkep = x end function shmkep","tags":"","url":"proc/shmkep.html"},{"title":"dcbsol – fortran-astrodynamics-toolkit","text":"private pure function dcbsol(a, b, c) result(x) Solution to a*x**3 + 3*b*x - 2c = 0 , where a and b**3 + a*c**2 are both non-negative\n(zero generated, in lieu of infinity, if a = b = 0 ) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b real(kind=wp), intent(in) :: c Return Value real(kind=wp) Calls proc~~dcbsol~~CallsGraph proc~dcbsol dcbsol proc~dcubrt dcubrt proc~dcbsol->proc~dcubrt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~dcbsol~~CalledByGraph proc~dcbsol dcbsol proc~ekepl ekepl proc~ekepl->proc~dcbsol proc~els2pv els2pv proc~els2pv->proc~dcbsol proc~els2pv->proc~ekepl proc~els3pv els3pv proc~els3pv->proc~els2pv proc~propagate propagate proc~propagate->proc~els3pv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function dcbsol ( a , b , c ) result ( x ) implicit none real ( wp ) :: x real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ) :: b real ( wp ), intent ( in ) :: c real ( wp ) :: bsq , d if ( a == zero . and . b == zero . or . c == zero ) then x = zero else bsq = b * b d = sqrt ( a ) * abs ( c ) d = dcubrt ( d + sqrt ( b * bsq + d * d )) ** 2 x = two * c / ( d + b + bsq / d ) end if end function dcbsol","tags":"","url":"proc/dcbsol.html"},{"title":"dcubrt – fortran-astrodynamics-toolkit","text":"private pure function dcubrt(x) result(c) Cube root computed accurately, by incorporating\none Newton-Raphson iteration. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Called by proc~~dcubrt~~CalledByGraph proc~dcubrt dcubrt proc~dcbsol dcbsol proc~dcbsol->proc~dcubrt proc~shkepl shkepl proc~shkepl->proc~dcubrt proc~ekepl ekepl proc~ekepl->proc~dcbsol proc~els2pv els2pv proc~els2pv->proc~dcbsol proc~els2pv->proc~shkepl proc~els2pv->proc~ekepl proc~els3pv els3pv proc~els3pv->proc~els2pv proc~propagate propagate proc~propagate->proc~els3pv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function dcubrt ( x ) result ( c ) implicit none real ( wp ) :: c real ( wp ), intent ( in ) :: x real ( wp ) :: y if ( x == zero ) then c = zero else y = abs ( x ) c = y ** athird c = c - athird * ( c - y / c ** 2 ) c = sign ( c , x ) end if end function dcubrt","tags":"","url":"proc/dcubrt.html"},{"title":"propagate – fortran-astrodynamics-toolkit","text":"public pure subroutine propagate(mu, rv0, dt, rvf) Basic two-body propagator using the Gooding universal element routines. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu grav. parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(6) :: rv0 initial state [km, km/s] real(kind=wp), intent(in) :: dt time step [sec] real(kind=wp), intent(out), dimension(6) :: rvf final state [km, km/s] Calls proc~~propagate~~CallsGraph proc~propagate propagate proc~els3pv els3pv proc~propagate->proc~els3pv proc~pv3els pv3els proc~propagate->proc~pv3els proc~els2pv els2pv proc~els3pv->proc~els2pv proc~pv2els pv2els proc~pv3els->proc~pv2els proc~dcbsol dcbsol proc~els2pv->proc~dcbsol proc~ekepl ekepl proc~els2pv->proc~ekepl proc~shkepl shkepl proc~els2pv->proc~shkepl proc~emkep emkep proc~pv2els->proc~emkep proc~shmkep shmkep proc~pv2els->proc~shmkep proc~dcubrt dcubrt proc~dcbsol->proc~dcubrt proc~ekepl->proc~dcbsol proc~ekepl->proc~emkep proc~shkepl->proc~shmkep proc~shkepl->proc~dcubrt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine propagate ( mu , rv0 , dt , rvf ) implicit none real ( wp ), intent ( in ) :: mu !! grav. parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 6 ), intent ( in ) :: rv0 !! initial state [km, km/s] real ( wp ), intent ( in ) :: dt !! time step [sec] real ( wp ), dimension ( 6 ), intent ( out ) :: rvf !! final state [km, km/s] real ( wp ), dimension ( 6 ) :: e !convert to elements, increment time, ! then convert back to cartesian: call pv3els ( mu , rv0 , e ) e ( 6 ) = e ( 6 ) + dt call els3pv ( mu , e , rvf ) end subroutine propagate","tags":"","url":"proc/propagate.html"},{"title":"els2pv – fortran-astrodynamics-toolkit","text":"private pure subroutine els2pv(gm, al, q, om, tau, r, u, vr, vt) Algorithm for two-dimensional conversion\nfrom orbital elements to position and velocity. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: gm grav. parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: al alpha [km&#94;2/s&#94;2] real(kind=wp), intent(in) :: q periapsis distance [km] real(kind=wp), intent(in) :: om argument of periapsis relative to assumed reference direction [rad] real(kind=wp), intent(in) :: tau time from periapsis [sec] real(kind=wp), intent(out) :: r radial distance [km] real(kind=wp), intent(out) :: u angle from reference direction [rad] real(kind=wp), intent(out) :: vr radial velocity [km/2] real(kind=wp), intent(out) :: vt transverse velocity >=0 [km/s] Calls proc~~els2pv~~CallsGraph proc~els2pv els2pv proc~dcbsol dcbsol proc~els2pv->proc~dcbsol proc~ekepl ekepl proc~els2pv->proc~ekepl proc~shkepl shkepl proc~els2pv->proc~shkepl proc~dcubrt dcubrt proc~dcbsol->proc~dcubrt proc~ekepl->proc~dcbsol proc~emkep emkep proc~ekepl->proc~emkep proc~shkepl->proc~dcubrt proc~shmkep shmkep proc~shkepl->proc~shmkep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~els2pv~~CalledByGraph proc~els2pv els2pv proc~els3pv els3pv proc~els3pv->proc~els2pv proc~propagate propagate proc~propagate->proc~els3pv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine els2pv ( gm , al , q , om , tau , r , u , vr , vt ) implicit none real ( wp ), intent ( in ) :: gm !! grav. parameter [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: al !! alpha [km&#94;2/s&#94;2] real ( wp ), intent ( in ) :: q !! periapsis distance [km] real ( wp ), intent ( in ) :: om !! argument of periapsis relative to assumed reference direction [rad] real ( wp ), intent ( in ) :: tau !! time from periapsis [sec] real ( wp ), intent ( out ) :: r !! radial distance [km] real ( wp ), intent ( out ) :: u !! angle from reference direction [rad] real ( wp ), intent ( out ) :: vr !! radial velocity [km/2] real ( wp ), intent ( out ) :: vt !! transverse velocity >=0 [km/s] real ( wp ) :: d , h , v , e1 , e , ep1 , alp , rtal , em , ee2 , s2 , c2 , emv , s , c if ( al == zero ) then !(parabola - gm cannot be zero) d = dcbsol ( half / gm , q , 1.5_wp * gm * tau ) r = q + half * d * d / gm h = sqrt ( two * gm * q ) v = two * atan2 ( d , h ) else !(ellipse or hyperbola) e1 = al * q e = gm - e1 ep1 = gm + e h = sqrt ( q * ep1 ) alp = abs ( al ) rtal = sqrt ( alp ) !(last 6 items could be saved if repeating gm, al & q) em = tau * alp * rtal if ( al > zero ) then !(ellipse - gm cannot be zero) ! make sure e1 argument to ekepl is between [0,1] ee2 = half * ekepl ( em / gm , max ( zero , min ( one , e1 / gm ))) s2 = sin ( ee2 ) c2 = cos ( ee2 ) r = q + two * e * s2 * s2 / al d = two * e * s2 * c2 / rtal v = two * atan2 ( ep1 * s2 , h * rtal * c2 ) emv = em / gm - v v = v + fourpi * sign ( real ( int ( abs ( emv / fourpi ) + half ), wp ), emv ) else !(hyperbola) s = shkepl ( em / e , - e1 / e ) s2 = s * s c = sqrt ( one + s2 ) s2 = s2 / ( c + one ) r = q - e * s2 / al d = e * s / rtal v = atan2 ( s * h * rtal , - gm * s2 - e1 ) end if end if !(all orbits) u = om + v vr = d / r vt = h / r end subroutine els2pv","tags":"","url":"proc/els2pv.html"},{"title":"els3pv – fortran-astrodynamics-toolkit","text":"public pure subroutine els3pv(gm, e, pv) Algorithm for three-dimensional conversion\nfrom orbital elements to position and velocity Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: gm grav. parameter [km&#94;3/sec&#94;2] real(kind=wp), intent(in), dimension(6) :: e [al, q, ei, bom, om, tau] real(kind=wp), intent(out), dimension(6) :: pv [x, y, z, xdot, ydot, zdot] Calls proc~~els3pv~~CallsGraph proc~els3pv els3pv proc~els2pv els2pv proc~els3pv->proc~els2pv proc~dcbsol dcbsol proc~els2pv->proc~dcbsol proc~ekepl ekepl proc~els2pv->proc~ekepl proc~shkepl shkepl proc~els2pv->proc~shkepl proc~dcubrt dcubrt proc~dcbsol->proc~dcubrt proc~ekepl->proc~dcbsol proc~emkep emkep proc~ekepl->proc~emkep proc~shkepl->proc~dcubrt proc~shmkep shmkep proc~shkepl->proc~shmkep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~els3pv~~CalledByGraph proc~els3pv els3pv proc~propagate propagate proc~propagate->proc~els3pv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine els3pv ( gm , e , pv ) implicit none real ( wp ), intent ( in ) :: gm !! grav. parameter [km&#94;3/sec&#94;2] real ( wp ), dimension ( 6 ), intent ( in ) :: e !! [al, q, ei, bom, om, tau] real ( wp ), dimension ( 6 ), intent ( out ) :: pv !! [x, y, z, xdot, ydot, zdot] real ( wp ) :: x , y , z , xdot , ydot , zdot , al , q , ei , bom , om , tau real ( wp ) :: r , u , vr , vt , c , s , x1 , x2 , y1 , y2 if ( all ( e == zero )) then pv = zero else al = e ( 1 ) q = e ( 2 ) ei = e ( 3 ) bom = e ( 4 ) om = e ( 5 ) tau = e ( 6 ) call els2pv ( gm , al , q , om , tau , r , u , vr , vt ) c = cos ( u ) s = sin ( u ) x1 = r * c y1 = r * s x2 = vr * c - vt * s y2 = vr * s + vt * c c = cos ( ei ) s = sin ( ei ) z = y1 * s y1 = y1 * c zdot = y2 * s y2 = y2 * c c = cos ( bom ) s = sin ( bom ) x = x1 * c - y1 * s y = x1 * s + y1 * c xdot = x2 * c - y2 * s ydot = x2 * s + y2 * c pv ( 1 ) = x pv ( 2 ) = y pv ( 3 ) = z pv ( 4 ) = xdot pv ( 5 ) = ydot pv ( 6 ) = zdot end if end subroutine els3pv","tags":"","url":"proc/els3pv.html"},{"title":"pv2els – fortran-astrodynamics-toolkit","text":"private pure subroutine pv2els(gm, r, u, vr, vt, al, q, om, tau) Algorithm for two-dimensional conversion\nfrom position and velocity to orbital elements. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: gm grav. parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: r radial distance [km] real(kind=wp), intent(in) :: u angle from assumed reference direction [rad] real(kind=wp), intent(in) :: vr radial velocity [km/2] real(kind=wp), intent(in) :: vt transverse velocity >=0 [km/s] real(kind=wp), intent(out) :: al alpha: gm/a [km&#94;2/s&#94;2] real(kind=wp), intent(out) :: q periapsis distance [km] real(kind=wp), intent(out) :: om argument of periapsis relative to reference direction [rad] real(kind=wp), intent(out) :: tau time from periapsis [sec] Calls proc~~pv2els~~CallsGraph proc~pv2els pv2els proc~emkep emkep proc~pv2els->proc~emkep proc~shmkep shmkep proc~pv2els->proc~shmkep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~pv2els~~CalledByGraph proc~pv2els pv2els proc~pv3els pv3els proc~pv3els->proc~pv2els proc~lambert_test lambert_test proc~lambert_test->proc~pv3els proc~propagate propagate proc~propagate->proc~pv3els Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine pv2els ( gm , r , u , vr , vt , al , q , om , tau ) implicit none real ( wp ), intent ( in ) :: gm !! grav. parameter [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: r !! radial distance [km] real ( wp ), intent ( in ) :: u !! angle from assumed reference direction [rad] real ( wp ), intent ( in ) :: vr !! radial velocity [km/2] real ( wp ), intent ( in ) :: vt !! transverse velocity >=0 [km/s] real ( wp ), intent ( out ) :: al !! alpha: gm/a [km&#94;2/s&#94;2] real ( wp ), intent ( out ) :: q !! periapsis distance [km] real ( wp ), intent ( out ) :: om !! argument of periapsis relative to reference direction [rad] real ( wp ), intent ( out ) :: tau !! time from periapsis [sec] real ( wp ) :: esq1 , es , eses , ec , ecec , esq , e , v , e1 real ( wp ) :: eh , em , ecesq , en , adj , vsq , rtal , d , h , p , alp real ( wp ), parameter :: sw = 0.25_wp logical , parameter :: l = . false . !(all orbits) vsq = vr * vr + vt * vt al = two * gm / r - vsq alp = abs ( al ) rtal = sqrt ( alp ) d = r * vr h = r * vt p = h * h esq1 = p * al es = d * rtal eses = es * es ec = r * vsq - gm ecec = ec * ec if ( al > zero ) then !(one esq formula superior for the ellipse) esq = ecec + eses else !(different formula superior for the hyperbola) esq = gm * gm - esq1 end if e = sqrt ( esq ) q = p / ( gm + e ) if ( al == zero ) then !(parabola) tau = d * ( two * q + r ) / ( three * gm ) v = two * atan2 ( vr , vt ) else if ( e == zero ) then !(circle) tau = zero v = zero else !(ellipse or hyperbola) e1 = al * q if ( al > zero ) then !(ellipse) eh = atan2 ( es , ec ) if ( gm * eh * eh / six + e1 >= gm * sw ) then !(general case) em = gm * eh - es ecesq = gm * ec - esq else !(for e1 & eh both near zero) em = gm * emkep ( e1 / gm , eh ) ecesq = ( esq1 * ecec - esq * eses ) / ( esq + gm * ec ) end if else !(hyperbola) eh = asinh ( es / e ) if ( gm * eh * eh / six - e1 >= gm * sw ) then !(general case) em = es - gm * eh ecesq = esq - gm * ec else !(for e1 & eh both near zero) em = e * shmkep ( - e1 / e , es / e ) ecesq = - ( esq1 * ecec + esq * eses ) / ( esq + gm * ec ) end if end if !(ellipse or hyperbola still) en = alp * rtal tau = em / en v = atan2 ( es * h * rtal , ecesq ) end if !(all orbits) om = u - v ! !  note: the following is never executed... set l=true and test... ! if ( l . and . al > zero ) then !(for ellipse, adjust revolutions if required (using l)) adj = twopi * sign ( real ( int ( abs ( om / twopi ) + half ), wp ), om ) om = om - adj tau = tau + adj / en end if end subroutine pv2els","tags":"","url":"proc/pv2els.html"},{"title":"pv3els – fortran-astrodynamics-toolkit","text":"public pure subroutine pv3els(gm, pv, e) Algorithm for three-dimensional conversion\nfrom position and velocity to orbital elements. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: gm grav. parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(6) :: pv [x, y, z, xdot, ydot, zdot] real(kind=wp), intent(out), dimension(6) :: e [al, q, ei, bom, om, tau] Calls proc~~pv3els~~CallsGraph proc~pv3els pv3els proc~pv2els pv2els proc~pv3els->proc~pv2els proc~emkep emkep proc~pv2els->proc~emkep proc~shmkep shmkep proc~pv2els->proc~shmkep Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~pv3els~~CalledByGraph proc~pv3els pv3els proc~lambert_test lambert_test proc~lambert_test->proc~pv3els proc~propagate propagate proc~propagate->proc~pv3els Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine pv3els ( gm , pv , e ) implicit none real ( wp ), intent ( in ) :: gm !! grav. parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 6 ), intent ( in ) :: pv !! [x, y, z, xdot, ydot, zdot] real ( wp ), dimension ( 6 ), intent ( out ) :: e !! [al, q, ei, bom, om, tau] real ( wp ) :: x , y , z , xdot , ydot , zdot , al , q , ei , bom , om , tau , xsqysq ,& rsq , r , vr , hx , hy , hz , hsq , u , vt , bx , by , bz , w , h if ( all ( pv == zero )) then e = zero else x = pv ( 1 ) y = pv ( 2 ) z = pv ( 3 ) xdot = pv ( 4 ) ydot = pv ( 5 ) zdot = pv ( 6 ) xsqysq = x * x + y * y rsq = xsqysq + z * z r = sqrt ( rsq ) vr = ( x * xdot + y * ydot + z * zdot ) / r hx = y * zdot - z * ydot hy = z * xdot - x * zdot hz = x * ydot - y * xdot hsq = hx * hx + hy * hy + hz * hz if ( hsq == zero ) then !(rectilinear orbit) ei = halfpi if ( xsqysq == zero ) then !(axial orbit) bom = zero else !(general rectilinear orbit) bom = atan2 ( y , x ) end if u = atan2 ( z , sqrt ( xsqysq )) vt = zero else !(non-degenerate orbit) bx = hy * z - hz * y by = hz * x - hx * z bz = hx * y - hy * x hx = y * bz - z * by hy = z * bx - x * bz hz = x * by - y * bx w = hx * hx + hy * hy h = sqrt ( w + hz * hz ) ei = atan2 ( sqrt ( w ), hz ) if ( w == zero ) then !(orbit in reference plane) bom = zero u = atan2 ( y * sign ( one , hz ), x ) else !(general orbit) bom = atan2 ( hx , - hy ) u = atan2 ( h * z , rsq * bz ) end if vt = h / ( r * rsq ) end if call pv2els ( gm , r , u , vr , vt , al , q , om , tau ) e ( 1 ) = al e ( 2 ) = q e ( 3 ) = ei e ( 4 ) = bom e ( 5 ) = om e ( 6 ) = tau end if end subroutine pv3els","tags":"","url":"proc/pv3els.html"},{"title":"solar_radiation_pressure – fortran-astrodynamics-toolkit","text":"public  function solar_radiation_pressure(area, cr, r_sc_sun, sunfrac) result(srp) Compute the solar radiation pressure force vector on a spacecraft. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: area cross-sectional area of spacecraft [m&#94;2] real(kind=wp), intent(in) :: cr coefficient of reflectivity real(kind=wp), intent(in), dimension(3) :: r_sc_sun vector from spacecraft to sun [km] real(kind=wp), intent(in) :: sunfrac sun fraction [0=total eclipse, 1=no eclipse] Return Value real(kind=wp), dimension(3) solar radiation pressure force vector [N] Source Code function solar_radiation_pressure ( area , cr , r_sc_sun , sunfrac ) result ( srp ) real ( wp ), intent ( in ) :: area !! cross-sectional area of spacecraft [m&#94;2] real ( wp ), intent ( in ) :: cr !! coefficient of reflectivity real ( wp ), dimension ( 3 ), intent ( in ) :: r_sc_sun !! vector from spacecraft to sun [km] real ( wp ), intent ( in ) :: sunfrac !! sun fraction [0=total eclipse, 1=no eclipse] real ( wp ), dimension ( 3 ) :: srp !! solar radiation pressure force vector [N] real ( wp ) :: mag !! srp magnitude real ( wp ) :: r_mag !! magnitude of `r_sc_sun` if ( sunfrac == zero ) then srp = zero else r_mag = norm2 ( r_sc_sun ) * km2m ! (m) mag = sunfrac * cr * solar_luminosity * area / ( c_light * km2m * fourpi * r_mag ** 2 ) srp = - mag * r_sc_sun * km2m / r_mag ! (N) end if end function solar_radiation_pressure","tags":"","url":"proc/solar_radiation_pressure.html"},{"title":"get_sun_fraction – fortran-astrodynamics-toolkit","text":"public  function get_sun_fraction(b, rad_body, rad_sun, eph, et, rv, model, rbubble, use_geometric, info) result(phi) Compute the \"sun fraction\" using the selected shadow model. Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b eclipsing body real(kind=wp), intent(in) :: rad_body radius of the eclipsing body [km] real(kind=wp), intent(in) :: rad_sun radius of the Sun [km] class( ephemeris_class ), intent(inout) :: eph the ephemeris to use for sun and ssb (if necessary) real(kind=wp), intent(in) :: et observer ephemeris time (sec) real(kind=wp), intent(in), dimension(6) :: rv state of the spacecraft (j2000-body frame) integer, intent(in) :: model algorithm to use: 1: circular cubic shadow model 2-4: solar fraction model real(kind=wp), intent(in) :: rbubble eclipse bubble [km]. see the reference.\nif rbubble=0, then no bubble is used.\nonly used if model=1 logical, intent(in), optional :: use_geometric if true, use geometric positions\n(no light time or stellar aberration correction)\ndefault = false character(len=:), intent(out), optional, allocatable :: info info string Return Value real(kind=wp) solar fraction returned: if model=1 , circular cubic sun frac value: >0 no eclipse <0 eclipse =0 on the eclipse line if model=2 , true solar fraction value [0=total eclipse, 1=no eclipse],\n   with model of umbra/penumbra/antumbra (Wertz, 1978) if model=3 , alternate version of solar fraction (Montenbruck and Gill) if model=4 , alternate version of solar fraction (nyxspace) Calls proc~~get_sun_fraction~~CallsGraph proc~get_sun_fraction get_sun_fraction get_r get_r proc~get_sun_fraction->get_r proc~apparent_position apparent_position proc~get_sun_fraction->proc~apparent_position proc~cubic_shadow_model cubic_shadow_model proc~get_sun_fraction->proc~cubic_shadow_model proc~from_j2000body_to_j2000ssb from_j2000body_to_j2000ssb proc~get_sun_fraction->proc~from_j2000body_to_j2000ssb proc~solar_fraction solar_fraction proc~get_sun_fraction->proc~solar_fraction proc~solar_fraction_alt solar_fraction_alt proc~get_sun_fraction->proc~solar_fraction_alt proc~solar_fraction_alt2 solar_fraction_alt2 proc~get_sun_fraction->proc~solar_fraction_alt2 proc~apparent_position->get_r proc~axis_angle_rotation axis_angle_rotation proc~apparent_position->proc~axis_angle_rotation proc~cross cross proc~apparent_position->proc~cross proc~unit unit proc~apparent_position->proc~unit acosd acosd proc~cubic_shadow_model->acosd asind asind proc~cubic_shadow_model->asind proc~cubic_shadow_model->proc~unit proc~wrap_angle wrap_angle proc~cubic_shadow_model->proc~wrap_angle proc~transform reference_frame%transform proc~from_j2000body_to_j2000ssb->proc~transform proc~solar_fraction->proc~unit proc~solar_fraction_alt->proc~unit proc~solar_fraction_alt2->proc~unit proc~axis_angle_rotation->proc~cross proc~axis_angle_rotation->proc~unit get_c_cdot get_c_cdot proc~transform->get_c_cdot proc~rvcto_rvcfrom_icrf rvcto_rvcfrom_icrf proc~transform->proc~rvcto_rvcfrom_icrf get_rv get_rv proc~rvcto_rvcfrom_icrf->get_rv proc~from_primary_to_center two_body_rotating_frame%from_primary_to_center proc~rvcto_rvcfrom_icrf->proc~from_primary_to_center proc~from_primary_to_center->get_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function get_sun_fraction ( b , rad_body , rad_sun , eph , et , rv , model , rbubble , use_geometric , info ) result ( phi ) type ( celestial_body ), intent ( in ) :: b !! eclipsing body real ( wp ), intent ( in ) :: rad_body !! radius of the eclipsing body [km] real ( wp ), intent ( in ) :: rad_sun !! radius of the Sun [km] class ( ephemeris_class ), intent ( inout ) :: eph !! the ephemeris to use for sun and ssb (if necessary) real ( wp ), intent ( in ) :: et !! observer ephemeris time (sec) real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! state of the spacecraft (j2000-body frame) integer , intent ( in ) :: model !! algorithm to use: !! !!  * 1: circular cubic shadow model !!  * 2-4: solar fraction model real ( wp ), intent ( in ) :: rbubble !! eclipse bubble [km]. see the reference. !! if rbubble=0, then no bubble is used. !! only used if model=1 logical , intent ( in ), optional :: use_geometric !! if true, use geometric positions !! (no light time or stellar aberration correction) !! default = false character ( len = :), allocatable , intent ( out ), optional :: info !! info string real ( wp ) :: phi !! solar fraction returned: !! !!  * if `model=1`, circular cubic sun frac value: !!     * `>0` no eclipse !!     * `<0` eclipse !!     * `=0` on the eclipse line !!  * if `model=2`, true solar fraction value [0=total eclipse, 1=no eclipse], !!    with model of umbra/penumbra/antumbra (Wertz, 1978) !!  * if `model=3`, alternate version of solar fraction (Montenbruck and Gill) !!  * if `model=4`, alternate version of solar fraction (nyxspace) logical :: status_ok !! true if no problems real ( wp ), dimension ( 3 ) :: r_sun !! apparent state of the sun (j2000-ssb frame) real ( wp ), dimension ( 3 ) :: r_body !! apparent state of the eclipsing body (j2000-ssb frame) real ( wp ), dimension ( 6 ) :: rv_ssb !! state of the spacecraft !! (j2000-ssb frame) logical :: use_apparent if ( present ( use_geometric )) then use_apparent = . not . use_geometric else use_apparent = . true . end if if ( use_apparent ) then ! apparent position of sun and body wrt to the spacecraft call from_j2000body_to_j2000ssb ( b , eph , et , rv , rv_ssb ) ! state of spacecraft in j2000-ssb call apparent_position ( eph , body_sun , et , rv_ssb , r_sun , status_ok ) ! apparent position of sun in j2000 if (. not . status_ok ) error stop 'error getting apparent sun position' call apparent_position ( eph , b , et , rv_ssb , r_body , status_ok ) ! apparent position of body in j2000 if (. not . status_ok ) error stop 'error getting apparent body position' else ! use geometric positions r_body = - rv ( 1 : 3 ) ! geometric position of body wrt spacecraft in j2000 call eph % get_r ( et , body_sun , b , r_sun , status_ok ) ! geometric position of sun wrt body in j2000 if (. not . status_ok ) error stop 'error getting geometric sun position' r_sun = r_body + r_sun ! geometric position of sun wrt spacecraft in j2000 end if ! compute sun fraction value select case ( model ) case ( 1 ); call cubic_shadow_model ( r_sun , rad_sun , r_body , rad_body , phi , rbubble ) case ( 2 ); call solar_fraction ( r_sun , rad_sun , r_body , rad_body , phi , info ) case ( 3 ); call solar_fraction_alt ( r_sun , rad_sun , r_body , rad_body , phi , info ) case ( 4 ); call solar_fraction_alt2 ( r_sun , rad_sun , r_body , rad_body , phi ) case default error stop 'invalid sun fraction model' end select end function get_sun_fraction","tags":"","url":"proc/get_sun_fraction.html"},{"title":"solar_fraction – fortran-astrodynamics-toolkit","text":"public  subroutine solar_fraction(d_s, rs, d_p, rp, fraction, info) Compute the solar fraction visible due to an eclipse by another body. Reference J. Wertz, \"Spacecraft Attitude Determination and Control\", 1978.\n    See Chapter 3 and Appendix A. Note that the implementation here corrects\n    a typo in this reference, and also protects for a division by zero. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: d_s vector from the spacecraft to the Sun real(kind=wp), intent(in) :: rs radius of the Sun real(kind=wp), intent(in), dimension(3) :: d_p vector from the spacecraft to the planet real(kind=wp), intent(in) :: rp radius of the planet real(kind=wp), intent(out) :: fraction fraction of the Sun visible [0=total eclipse, 1=no eclipse] character(len=:), intent(out), optional, allocatable :: info info string Calls proc~~solar_fraction~~CallsGraph proc~solar_fraction solar_fraction proc~unit unit proc~solar_fraction->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~solar_fraction~~CalledByGraph proc~solar_fraction solar_fraction proc~get_sun_fraction get_sun_fraction proc~get_sun_fraction->proc~solar_fraction proc~lighting_module_test lighting_module_test proc~lighting_module_test->proc~solar_fraction Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine solar_fraction ( d_s , rs , d_p , rp , fraction , info ) real ( wp ), dimension ( 3 ), intent ( in ) :: d_s !! vector from the spacecraft to the Sun real ( wp ), intent ( in ) :: rs !! radius of the Sun real ( wp ), dimension ( 3 ), intent ( in ) :: d_p !! vector from the spacecraft to the planet real ( wp ), intent ( in ) :: rp !! radius of the planet real ( wp ), intent ( out ) :: fraction !! fraction of the Sun visible [0=total eclipse, 1=no eclipse] character ( len = :), allocatable , intent ( out ), optional :: info !! info string real ( wp ) :: s !! distance from the planet to the Sun real ( wp ) :: c !! distance from the center of the planet to the apex of the shadow cone real ( wp ) :: rho_c !! angular radius of the shadow cone real ( wp ) :: rho_s !! angular radius of the Sun real ( wp ) :: rho_p !! angular radius of the planet real ( wp ) :: theta !! angular separation of the sun and planet as viewed by the spacecraft real ( wp ) :: ds !! distance from the spacecraft to the Sun real ( wp ) :: dp !! distance from the spacecraft to the planet real ( wp ) :: drho !! difference in angular radii of the planet and Sun real ( wp ) :: crp , crs , srp , srs , cth , sth , t1 , t2 , t3 , delr !! temp variables if ( rp <= zero ) then ! no eclipse possible if the planet has no radius if ( present ( info )) info = 'no eclipse: planet radius <= 0' fraction = one return end if ds = norm2 ( d_s ) dp = norm2 ( d_p ) if ( ds <= rs ) then ! inside the Sun if ( present ( info )) info = 'inside Sun' fraction = one return else if ( dp <= rp ) then ! inside the planet if ( present ( info )) info = 'inside Planet' fraction = zero return end if s = norm2 ( d_s - d_p ) delr = rs - rp if ( delr == zero ) then ! special case when the bodies are the same size, ! to avoid division by zero c = huge ( 1.0_wp ) else c = ( rp * s ) / delr end if rho_c = asin ( delr / s ) ! appx = asin(rs/s) rho_s = asin ( rs / ds ) rho_p = asin ( rp / dp ) theta = acos ( dot_product ( unit ( d_s ), unit ( d_p ))) drho = rho_p - rho_s crp = cos ( rho_p ) crs = cos ( rho_s ) srp = sin ( rho_p ) srs = sin ( rho_s ) cth = cos ( theta ) sth = sin ( theta ) if ( ( ds > s ) . and . ( rho_p + rho_s > theta ) . and . ( theta > abs ( drho )) ) then ! partial eclipse if ( present ( info )) info = 'penumbra' t1 = pi - crs * acos ( ( crp - crs * cth ) / ( srs * sth ) ) t2 = - crp * acos ( ( crs - crp * cth ) / ( srp * sth ) ) t3 = - acos ( ( cth - crs * crp ) / ( srs * srp ) ) fraction = one - ( t1 + t2 + t3 ) / ( pi * ( one - crs )) else if ( ( s < ds ) . and . ( ds - s < c ) . and . ( drho > theta ) ) then ! total eclipse if ( present ( info )) info = 'umbra' fraction = zero else if ( ( c < ds - s ) . and . ( drho < theta ) ) then ! JW : typo in original reference ! annular eclipse if ( present ( info )) info = 'antumbra' fraction = one - ( one - crp ) / ( one - crs ) else ! no eclipse if ( present ( info )) info = 'full sun' fraction = one end if end subroutine solar_fraction","tags":"","url":"proc/solar_fraction.html"},{"title":"from_j2000body_to_j2000ssb – fortran-astrodynamics-toolkit","text":"public  subroutine from_j2000body_to_j2000ssb(b, eph, et, rv, rv_ssb) convert from a j2000-body frame to a j2000-ssb frame. Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b eclipsing body class( ephemeris_class ), intent(inout) :: eph the ephemeris to use for body and ssb real(kind=wp), intent(in) :: et ephemeris time (sec) real(kind=wp), intent(in), dimension(6) :: rv j2000-body state (km, km/s) real(kind=wp), intent(out), dimension(6) :: rv_ssb j2000-ssb state (km, km/s) Calls proc~~from_j2000body_to_j2000ssb~~CallsGraph proc~from_j2000body_to_j2000ssb from_j2000body_to_j2000ssb proc~transform reference_frame%transform proc~from_j2000body_to_j2000ssb->proc~transform get_c_cdot get_c_cdot proc~transform->get_c_cdot proc~rvcto_rvcfrom_icrf rvcto_rvcfrom_icrf proc~transform->proc~rvcto_rvcfrom_icrf get_rv get_rv proc~rvcto_rvcfrom_icrf->get_rv proc~from_primary_to_center two_body_rotating_frame%from_primary_to_center proc~rvcto_rvcfrom_icrf->proc~from_primary_to_center proc~from_primary_to_center->get_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~from_j2000body_to_j2000ssb~~CalledByGraph proc~from_j2000body_to_j2000ssb from_j2000body_to_j2000ssb proc~get_sun_fraction get_sun_fraction proc~get_sun_fraction->proc~from_j2000body_to_j2000ssb Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_j2000body_to_j2000ssb ( b , eph , et , rv , rv_ssb ) type ( celestial_body ), intent ( in ) :: b !! eclipsing body class ( ephemeris_class ), intent ( inout ) :: eph !! the ephemeris to use for body and ssb real ( wp ), intent ( in ) :: et !! ephemeris time (sec) real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! j2000-body state (km, km/s) real ( wp ), dimension ( 6 ), intent ( out ) :: rv_ssb !! j2000-ssb state (km, km/s) type ( icrf_frame ) :: f1 , f2 logical :: status_ok f1 = icrf_frame ( b = b ) f2 = icrf_frame ( b = body_ssb ) call f1 % transform ( rv , f2 , et , eph , rv_ssb , status_ok ) ! from f1 to f2 if (. not . status_ok ) error stop 'transformation error in from_j2000body_to_j2000ssb' end subroutine from_j2000body_to_j2000ssb","tags":"","url":"proc/from_j2000body_to_j2000ssb.html"},{"title":"apparent_position – fortran-astrodynamics-toolkit","text":"public  subroutine apparent_position(eph, b_target, et, rv_obs_ssb, r_target, status_ok) Return the position of a target body relative to an observer,\ncorrected for light time and stellar aberration. see the SPICELIB routine spkapo (with 'lt+s') Arguments Type Intent Optional Attributes Name class( ephemeris_class ), intent(inout) :: eph the ephemeris type( celestial_body ), intent(in) :: b_target target body real(kind=wp), intent(in) :: et observer ephemeris time (sec) real(kind=wp), intent(in), dimension(6) :: rv_obs_ssb state of the observer\n(j2000 frame w.r.t. solar system barycenter) real(kind=wp), intent(out), dimension(3) :: r_target apparant state of the target (j2000 frame)\nCorrected for one-way light time and stellar aberration logical, intent(out) :: status_ok true if no problems Calls proc~~apparent_position~~CallsGraph proc~apparent_position apparent_position get_r get_r proc~apparent_position->get_r proc~axis_angle_rotation axis_angle_rotation proc~apparent_position->proc~axis_angle_rotation proc~cross cross proc~apparent_position->proc~cross proc~unit unit proc~apparent_position->proc~unit proc~axis_angle_rotation->proc~cross proc~axis_angle_rotation->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~apparent_position~~CalledByGraph proc~apparent_position apparent_position proc~get_sun_fraction get_sun_fraction proc~get_sun_fraction->proc~apparent_position Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine apparent_position ( eph , b_target , et , rv_obs_ssb , r_target , status_ok ) class ( ephemeris_class ), intent ( inout ) :: eph !! the ephemeris type ( celestial_body ), intent ( in ) :: b_target !! target body real ( wp ), dimension ( 6 ), intent ( in ) :: rv_obs_ssb !! state of the observer !! (j2000 frame w.r.t. solar system barycenter) real ( wp ), intent ( in ) :: et !! observer ephemeris time (sec) real ( wp ), dimension ( 3 ), intent ( out ) :: r_target !! apparant state of the target (j2000 frame) !! Corrected for one-way light time and stellar aberration logical , intent ( out ) :: status_ok !! true if no problems real ( wp ), dimension ( 3 ) :: r_targ_ssb !! target body r wrt. ssb real ( wp ) :: lt !! one-way light time [sec] ! Find the geometric position of the target body with respect to the ! solar system barycenter. Subtract the position of the observer ! to get the relative position. Use this to compute the one-way ! light time. call eph % get_r ( et , b_target , body_ssb , r_targ_ssb , status_ok ) if (. not . status_ok ) return r_targ_ssb = r_targ_ssb - rv_obs_ssb ( 1 : 3 ) ! relative pos of target lt = norm2 ( r_targ_ssb ) / c_light ! light time ! To correct for light time, find the position of the target body ! at the current epoch minus the one-way light time. Note that ! the observer remains where he is. call eph % get_r ( et - lt , b_target , body_ssb , r_targ_ssb , status_ok ) if (. not . status_ok ) return r_targ_ssb = r_targ_ssb - rv_obs_ssb ( 1 : 3 ) ! At this point, r_targ_ssb contains the geometric or light-time ! corrected position of the target relative to the observer ! stellar aberration correction r_target = stellar_aberration ( r_targ_ssb , rv_obs_ssb ( 4 : 6 )) contains function stellar_aberration ( pobj , vobs ) result ( appobj ) !!  Correct the apparent position of an object for stellar aberration. !!  see SPICELIB routine `STELAB` real ( wp ), dimension ( 3 ), intent ( in ) :: pobj real ( wp ), dimension ( 3 ), intent ( in ) :: vobs real ( wp ), dimension ( 3 ) :: appobj real ( wp ), dimension ( 3 ) :: u , vbyc , h real ( wp ) :: lensqr , sinphi , phi real ( wp ), parameter :: zero_tol = epsilon ( 1.0_wp ) !! tolerance for zero u = unit ( pobj ) vbyc = vobs / c_light lensqr = dot_product ( vbyc , vbyc ) if ( lensqr >= 1.0_wp ) error stop 'velocity > speed of light' h = cross ( u , vbyc ) sinphi = norm2 ( h ) if ( abs ( sinphi ) > zero_tol ) then ! if (sinphi /= 0) ! rotate the position of the object by phi ! radians about h to obtain the apparent position. phi = asin ( sinphi ) call axis_angle_rotation ( pobj , h , phi , appobj ) else ! observer is moving along the line of sight to the object, ! and no correction is required appobj = pobj end if end function stellar_aberration end subroutine apparent_position","tags":"","url":"proc/apparent_position.html"},{"title":"cubic_shadow_model – fortran-astrodynamics-toolkit","text":"public  subroutine cubic_shadow_model(rsun, radsun, rplanet, radplanet, sunfrac, rbubble) The \"circular cubic\" shadow model. Reference J. Williams, et. al, \"A new eclipse algorithm for use in\n    spacecraft trajectory optimization\", 2023, AAS 23-243 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: rsun apparent position vector of sun wrt spacecraft [km] real(kind=wp), intent(in) :: radsun radius of sun [km] real(kind=wp), intent(in), dimension(3) :: rplanet apparent position vector of eclipsing body wrt spacecraft [km] real(kind=wp), intent(in) :: radplanet radius of the eclipsing body [km] real(kind=wp), intent(out) :: sunfrac value of the function (>0 no eclipse,\n<0 eclipse, =0 on the shadow line) real(kind=wp), intent(in), optional :: rbubble eclipse bubble radius. if present, then sunfrac is\nthe value along an arc length of rbubble in the direction of the max eclipse line. Calls proc~~cubic_shadow_model~~CallsGraph proc~cubic_shadow_model cubic_shadow_model acosd acosd proc~cubic_shadow_model->acosd asind asind proc~cubic_shadow_model->asind proc~unit unit proc~cubic_shadow_model->proc~unit proc~wrap_angle wrap_angle proc~cubic_shadow_model->proc~wrap_angle Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~cubic_shadow_model~~CalledByGraph proc~cubic_shadow_model cubic_shadow_model proc~get_sun_fraction get_sun_fraction proc~get_sun_fraction->proc~cubic_shadow_model Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine cubic_shadow_model ( rsun , radsun , rplanet , radplanet , sunfrac , rbubble ) real ( wp ), dimension ( 3 ), intent ( in ) :: rsun !! apparent position vector of sun wrt spacecraft [km] real ( wp ), intent ( in ) :: radsun !! radius of sun [km] real ( wp ), dimension ( 3 ), intent ( in ) :: rplanet !! apparent position vector of eclipsing body wrt spacecraft [km] real ( wp ), intent ( in ) :: radplanet !! radius of the eclipsing body [km] real ( wp ), intent ( out ) :: sunfrac !! value of the function (>0 no eclipse, !! <0 eclipse, =0 on the shadow line) real ( wp ), intent ( in ), optional :: rbubble !! eclipse bubble radius. if present, then `sunfrac` is !! the value along an arc length of `rbubble` !! in the direction of the max eclipse line. real ( wp ), dimension ( 3 ) :: r !! radius vector from eclipsing body to spacecraft real ( wp ), dimension ( 3 ) :: rsb !! radius vector from the sun to the eclipsing body real ( wp ) :: tmp !! temp value real ( wp ) :: alpha !! [deg] real ( wp ) :: alpha0 !! [deg] real ( wp ) :: sin_alpha0 !! `sin(alpha0)` real ( wp ) :: rsbmag !! magnitude of radius vector from the sun to the eclipsing body real ( wp ) :: rmag !! magnitude of `r` logical :: compute_bubble !! use the `rbubble` inputs to adjust `alpha` compute_bubble = present ( rbubble ) if ( compute_bubble ) compute_bubble = rbubble > zero r = - rplanet rmag = norm2 ( r ) if ( rmag < radplanet ) then ! if inside the body, just return value from the surface r = radplanet * unit ( r ) rmag = radplanet end if rsb = rplanet - rsun alpha = safe_acosd ( dot_product ( unit ( r ), unit ( rsb ))) if ( compute_bubble ) alpha = rad2deg * abs ( wrap_angle ( alpha * deg2rad - abs ( rbubble ) / rmag )) rsbmag = norm2 ( rsb ) tmp = ( radsun + radplanet ) / rsbmag sin_alpha0 = ( one / rmag ) * ( radplanet * sqrt (( one / tmp ) ** 2 - one ) + sqrt ( rmag ** 2 - radplanet ** 2 )) * tmp alpha0 = safe_asind ( sin_alpha0 ) sunfrac = ( alpha ** 2 / ( alpha0 ** 2 - alpha0 ** 3 / 27 0.0_wp )) * ( one - alpha / 27 0.0_wp ) - one contains pure real ( wp ) function safe_asind ( x ) !! `asind` with range checking real ( wp ), intent ( in ) :: x safe_asind = asind ( min ( one , max ( - one , x ))) end function safe_asind pure real ( wp ) function safe_acosd ( x ) !! `acosd` with range checking real ( wp ), intent ( in ) :: x safe_acosd = acosd ( min ( one , max ( - one , x ))) end function safe_acosd end subroutine cubic_shadow_model","tags":"","url":"proc/cubic_shadow_model.html"},{"title":"solar_fraction_alt – fortran-astrodynamics-toolkit","text":"public  subroutine solar_fraction_alt(d_s, rs, d_p, rp, percentsun, info) Another eclipse model, using circular area assumptions. References Montenbruck and Gill, \"Satellite Orbits\". The GMAT routine ShadowState::FindShadowState . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: d_s vector from the spacecraft to the Sun real(kind=wp), intent(in) :: rs radius of the Sun real(kind=wp), intent(in), dimension(3) :: d_p vector from the spacecraft to the planet real(kind=wp), intent(in) :: rp radius of the planet real(kind=wp), intent(out) :: percentsun fraction of the Sun visible [0=total eclipse, 1=no eclipse] character(len=:), intent(out), optional, allocatable :: info info string Calls proc~~solar_fraction_alt~~CallsGraph proc~solar_fraction_alt solar_fraction_alt proc~unit unit proc~solar_fraction_alt->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~solar_fraction_alt~~CalledByGraph proc~solar_fraction_alt solar_fraction_alt proc~get_sun_fraction get_sun_fraction proc~get_sun_fraction->proc~solar_fraction_alt proc~lighting_module_test lighting_module_test proc~lighting_module_test->proc~solar_fraction_alt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine solar_fraction_alt ( d_s , rs , d_p , rp , percentsun , info ) real ( wp ), dimension ( 3 ), intent ( in ) :: d_s !! vector from the spacecraft to the Sun real ( wp ), intent ( in ) :: rs !! radius of the Sun real ( wp ), dimension ( 3 ), intent ( in ) :: d_p !! vector from the spacecraft to the planet real ( wp ), intent ( in ) :: rp !! radius of the planet real ( wp ), intent ( out ) :: percentsun !! fraction of the Sun visible [0=total eclipse, 1=no eclipse] character ( len = :), allocatable , intent ( out ), optional :: info !! info string real ( wp ), dimension ( 3 ) :: unitsun , d_s_hat , d_p_hat real ( wp ) :: rho_s , rho_p , theta , rdotsun , d_s_mag , d_p_mag , c , a2 , b2 , x , y , area !              [sc] !            /     \\ !        d_s       d_p !      /              \\ !  [sun] ---------- [body] unitsun = unit ( d_s - d_p ) ! body to sun unit vector rdotsun = dot_product ( - d_p , unitsun ) if ( rdotsun > zero ) then ! sunny side of central body is always fully lit ! [the assumption here is the sun is always bigger than the body?] if ( present ( info )) info = 'full sun' percentsun = one else d_s_mag = norm2 ( d_s ) d_p_mag = norm2 ( d_p ) if ( rs >= d_s_mag ) then ! inside the Sun if ( present ( info )) info = 'inside Sun' percentsun = one else if ( rp >= d_p_mag ) then ! inside the planet if ( present ( info )) info = 'inside Planet' percentsun = zero else rho_s = asin ( rs / d_s_mag ) rho_p = asin ( rp / d_p_mag ) d_p_hat = unit ( d_p ) d_s_hat = unit ( d_s ) theta = acos ( dot_product ( d_p_hat , d_s_hat )) ! apparant distance from sun to body if ( rho_s + rho_p <= theta ) then ! full sunlight if ( present ( info )) info = 'full sunlight' percentsun = one else if ( theta <= rho_p - rho_s ) then ! umbra if ( present ( info )) info = 'umbra' percentsun = zero else if ( ( abs ( rho_s - rho_p ) < theta ) . and . ( theta < rho_s + rho_p ) ) then ! penumbra if ( present ( info )) info = 'penumbra' ! see montenbruck and gill, eq. 3.87-3.94 c = acos ( dot_product ( d_p_hat , d_s_hat )) a2 = rho_s * rho_s b2 = rho_p * rho_p x = ( c * c + a2 - b2 ) / ( two * c ) y = sqrt ( a2 - x * x ) area = a2 * acos ( x / rho_s ) + b2 * acos (( c - x ) / rho_p ) - c * y percentsun = one - area / ( pi * a2 ) else ! antumbra if ( present ( info )) info = 'antumbra' percentsun = one - rho_p * rho_p / ( rho_s * rho_s ) end if end if end if end subroutine solar_fraction_alt","tags":"","url":"proc/solar_fraction_alt.html"},{"title":"solar_fraction_alt2 – fortran-astrodynamics-toolkit","text":"public  subroutine solar_fraction_alt2(r_l, Rl, r_e, Re, percentsun, info) Another eclipse model, using circular area assumptions,\n  coded up based on the nixspace documentation.\n  The results are very similar to solar_fraction_alt . References https://nyxspace.com/nyxspace/MathSpec/celestial/eclipse/#nomenclature Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r_l vector from the spacecraft to the Sun real(kind=wp), intent(in) :: Rl radius of the Sun real(kind=wp), intent(in), dimension(3) :: r_e vector from the spacecraft to the planet real(kind=wp), intent(in) :: Re radius of the planet real(kind=wp), intent(out) :: percentsun fraction of the Sun visible [0=total eclipse, 1=no eclipse] character(len=:), intent(out), optional, allocatable :: info info string Calls proc~~solar_fraction_alt2~~CallsGraph proc~solar_fraction_alt2 solar_fraction_alt2 proc~unit unit proc~solar_fraction_alt2->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~solar_fraction_alt2~~CalledByGraph proc~solar_fraction_alt2 solar_fraction_alt2 proc~get_sun_fraction get_sun_fraction proc~get_sun_fraction->proc~solar_fraction_alt2 proc~lighting_module_test lighting_module_test proc~lighting_module_test->proc~solar_fraction_alt2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine solar_fraction_alt2 ( r_l , Rl , r_e , Re , percentsun , info ) real ( wp ), dimension ( 3 ), intent ( in ) :: r_l !! vector from the spacecraft to the Sun real ( wp ), intent ( in ) :: Rl !! radius of the Sun real ( wp ), dimension ( 3 ), intent ( in ) :: r_e !! vector from the spacecraft to the planet real ( wp ), intent ( in ) :: Re !! radius of the planet real ( wp ), intent ( out ) :: percentsun !! fraction of the Sun visible [0=total eclipse, 1=no eclipse] character ( len = :), allocatable , intent ( out ), optional :: info !! info string real ( wp ) :: rlp , rep , dp , r_l_mag , r_e_mag , & d1 , d2 , dp2 , rlp2 , rep2 , At , Astar ! this check isn't mentioned in the reference, but needed ! for sc -- sun -- body case if ( dot_product ( - r_e , unit ( r_l - r_e )) > zero ) then ! sunny side of body is always fully lit ! [the assumption here is the sun is always bigger than the body?] if ( present ( info )) info = 'full sun' percentsun = one return end if r_l_mag = norm2 ( r_l ) r_e_mag = norm2 ( r_e ) ! these checks also aren't in the writeup: if ( Rl >= r_l_mag ) then ! inside the Sun if ( present ( info )) info = 'inside Sun' percentsun = one ; return else if ( Re >= r_e_mag ) then ! inside the planet if ( present ( info )) info = 'inside Planet' percentsun = zero ; return end if rlp = asin ( Rl / r_l_mag ) rep = asin ( Re / r_e_mag ) dp = acos ( dot_product ( r_l , r_e ) / ( r_l_mag * r_e_mag )) ! modified this check: !if (dp-rlp<rep) then  ! original if ( rlp + rep <= dp ) then ! corrected if ( present ( info )) info = 'full sun' percentsun = one ! full sun else if ( rep >= dp + rlp ) then if ( present ( info )) info = 'umbra' percentsun = zero ! umbra else if ( rlp - rep >= dp . or . dp >= rlp + rep ) then ! antumbra if ( present ( info )) info = 'antumbra' percentsun = one - rep * rep / ( rlp * rlp ) else ! penumbra if ( present ( info )) info = 'penumbra' dp2 = dp * dp rlp2 = rlp * rlp rep2 = rep * rep d1 = ( dp2 - rlp2 + rep2 ) / ( two * dp ) d2 = ( dp2 + rlp2 - rep2 ) / ( two * dp ) At = A ( rep , rep2 , d1 ) + A ( rlp , rlp2 , d2 ) Astar = pi * rlp2 percentsun = ( Astar - At ) / Astar end if contains pure real ( wp ) function A ( r , r2 , d ) real ( wp ), intent ( in ) :: r , r2 , d A = r2 * acos ( d / r ) - d * sqrt ( r2 - d * d ) end function A end subroutine solar_fraction_alt2","tags":"","url":"proc/solar_fraction_alt2.html"},{"title":"lighting_module_test – fortran-astrodynamics-toolkit","text":"public  subroutine lighting_module_test() Unit tests for the listing module. Arguments None Calls proc~~lighting_module_test~~CallsGraph proc~lighting_module_test lighting_module_test proc~solar_fraction solar_fraction proc~lighting_module_test->proc~solar_fraction proc~solar_fraction_alt solar_fraction_alt proc~lighting_module_test->proc~solar_fraction_alt proc~solar_fraction_alt2 solar_fraction_alt2 proc~lighting_module_test->proc~solar_fraction_alt2 proc~unit unit proc~solar_fraction->proc~unit proc~solar_fraction_alt->proc~unit proc~solar_fraction_alt2->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine lighting_module_test () real ( wp ) :: rs , rp real ( wp ), dimension ( 3 ) :: d_s , d_p rs = 1.0_wp ! sun radius rp = 1.0_wp ! planet radius ! sun -- body -- sc  -> 0.0 d_s = [ - 10 0.0_wp , 0.0_wp , 0.0_wp ] d_p = [ - 1 0.0_wp , 0.0_wp , 0.0_wp ] call go () ! sc -- sun -- body  -> 1.0 d_s = [ 1 0.0_wp , 0.0_wp , 0.0_wp ] d_p = [ 10 0.0_wp , 0.0_wp , 0.0_wp ] call go () ! sc -- body -- sun  -> 0.0 d_s = [ 10 0.0_wp , 0.0_wp , 0.0_wp ] d_p = [ 1 0.0_wp , 0.0_wp , 0.0_wp ] call go () ! sc -- body -- sun  -> penumbra d_s = [ 10 0.0_wp , 0.0_wp , 0.0_wp ] d_p = [ 1 0.0_wp , 1.0_wp , 0.0_wp ] call go () ! body -- sc -- sun d_s = [ - 10 0.0_wp , 0.0_wp , 0.0_wp ] d_p = [ 10 0.0_wp , 0.0_wp , 0.0_wp ] call go () !.................................... ! sc -- body -- sun  -> antumbra rs = 10 0.0_wp d_s = [ 2000 0.0_wp , 0.0_wp , 0.0_wp ] d_p = [ 40 0.0_wp , 0.0_wp , 0.0_wp ] call go () rs = 10 0.0_wp ! umbra d_s = [ 2000 0.0_wp , 0.0_wp , 0.0_wp ] d_p = [ 10 0.0_wp , 0.0_wp , 0.0_wp ] call go () ! realistic sun/earth case: !  sun -- earth -- sc rs = 69600 0.0_wp rp = 637 8.0_wp d_s = [ - 14959787 0.7_wp , 0.0_wp , 0.0_wp ] d_p = [ - 677 8.0_wp , 640 0.0_wp , 0.0_wp ] call go () ! ! an edge case, a very small sun very close to the body on x-axis, ! ! sc on y-axis very close to body    .. i don't think any properly handle this .. .double check... ! rs = 0.0001_wp ! sun radius ! rp = 10.0_wp ! planet radius ! d_p = [0.0001_wp, -rp-0.01_wp, 0.0_wp] ! d_s = d_p + [-rp-0.01_wp, 0.0_wp, 0.0_wp] ! call go() contains subroutine go () real ( wp ) :: phi1 , phi2 , phi3 character ( len = :), allocatable :: info1 , info2 , info3 print * , '----------------------------------' write ( * , * ) '' call solar_fraction ( d_s , rs , d_p , rp , phi1 , info1 ) call solar_fraction_alt ( d_s , rs , d_p , rp , phi2 , info2 ) call solar_fraction_alt2 ( d_s , rs , d_p , rp , phi3 , info3 ) write ( * , * ) 'phi1 = ' , phi1 , info1 write ( * , * ) 'phi2 = ' , phi2 , info2 write ( * , * ) 'phi3 = ' , phi3 , info3 write ( * , * ) 'diff 1= ' , abs ( phi1 - phi2 ) ! spherical vs circular write ( * , * ) 'diff 2= ' , abs ( phi2 - phi3 ) ! two circular models if ( abs ( phi1 - phi2 ) > 1.0e-4_wp ) error stop 'WARNING: large difference between models' print * , '' end subroutine go end subroutine lighting_module_test","tags":"","url":"proc/lighting_module_test.html"},{"title":"spice_id_to_old_id – fortran-astrodynamics-toolkit","text":"private pure function spice_id_to_old_id(spice_id) result(old_id) Convert the NAIF SPICE ID code to the old one used by the JPL ephemeris.\nReturns 0 if the body was not found. Arguments Type Intent Optional Attributes Name integer, intent(in) :: spice_id the ID code used by SPICE Return Value integer the ID code used by this module (old JPL ephemeris code) Called by proc~~spice_id_to_old_id~~CalledByGraph proc~spice_id_to_old_id spice_id_to_old_id proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~get_r_from_jpl_ephemeris->proc~spice_id_to_old_id proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~get_rv_from_jpl_ephemeris->proc~spice_id_to_old_id proc~ephemeris_test ephemeris_test proc~ephemeris_test->proc~get_r_from_jpl_ephemeris proc~ephemeris_test->proc~get_rv_from_jpl_ephemeris Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function spice_id_to_old_id ( spice_id ) result ( old_id ) implicit none integer , intent ( in ) :: spice_id !! the ID code used by SPICE integer :: old_id !! the ID code used by this module (old JPL ephemeris code) integer :: i !! counter !> !  The index of this array is the old ID code. The value is the new code. !  See: [NAIF Integer ID codes](http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/req/naif_ids.html) integer , parameter , dimension ( 13 ) :: new_ids = & [ 199 ,& ! mercury 299 ,& ! venus 399 ,& ! earth 499 ,& ! mars 599 ,& ! jupiter 699 ,& ! saturn 799 ,& ! uranus 899 ,& ! neptune 999 ,& ! pluto 301 ,& ! moon 10 , & ! sun 0 , & ! solar-system barycenter 3 ] ! earth-moon barycenter !just a simple search of the list: ! [small enough that bisection search probably not worth it] do i = 1 , size ( new_ids ) if ( new_ids ( i ) == spice_id ) then old_id = i return end if end do !not found: old_id = 0 end function spice_id_to_old_id","tags":"","url":"proc/spice_id_to_old_id.html"},{"title":"get_rv_from_jpl_ephemeris – fortran-astrodynamics-toolkit","text":"private  subroutine get_rv_from_jpl_ephemeris(me, et, targ, obs, rv, status_ok) Uses conversion_module time_module celestial_body_module numbers_module proc~~get_rv_from_jpl_ephemeris~~UsesGraph proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris module~celestial_body_module celestial_body_module proc~get_rv_from_jpl_ephemeris->module~celestial_body_module module~conversion_module conversion_module proc~get_rv_from_jpl_ephemeris->module~conversion_module module~numbers_module numbers_module proc~get_rv_from_jpl_ephemeris->module~numbers_module module~time_module time_module proc~get_rv_from_jpl_ephemeris->module~time_module module~celestial_body_module->module~numbers_module module~base_class_module base_class_module module~celestial_body_module->module~base_class_module module~kind_module kind_module module~celestial_body_module->module~kind_module module~conversion_module->module~numbers_module module~conversion_module->module~kind_module module~numbers_module->module~kind_module module~time_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interface for the ephemeris_module . Type Bound jpl_ephemeris Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=fat_wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=fat_wp), intent(out), dimension(6) :: rv state of targ w.r.t. obs [km,km/s] in ICRF frame logical, intent(out) :: status_ok true if there were no problems Calls proc~~get_rv_from_jpl_ephemeris~~CallsGraph proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~et_to_jd et_to_jd proc~get_rv_from_jpl_ephemeris->proc~et_to_jd proc~get_state jpl_ephemeris%get_state proc~get_rv_from_jpl_ephemeris->proc~get_state proc~spice_id_to_old_id spice_id_to_old_id proc~get_rv_from_jpl_ephemeris->proc~spice_id_to_old_id proc~state jpl_ephemeris%state proc~get_state->proc~state proc~interp jpl_ephemeris%interp proc~state->proc~interp proc~split split proc~state->proc~split Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_rv_from_jpl_ephemeris~~CalledByGraph proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~ephemeris_test ephemeris_test proc~ephemeris_test->proc~get_rv_from_jpl_ephemeris Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_rv_from_jpl_ephemeris ( me , et , targ , obs , rv , status_ok ) use time_module , only : et_to_jd use conversion_module , only : day2sec use celestial_body_module , only : celestial_body use numbers_module , only : zero implicit none class ( jpl_ephemeris ), intent ( inout ) :: me real ( fat_wp ), intent ( in ) :: et !! ephemeris time [sec] type ( celestial_body ), intent ( in ) :: targ !! target body type ( celestial_body ), intent ( in ) :: obs !! observer body real ( fat_wp ), dimension ( 6 ), intent ( out ) :: rv !! state of targ w.r.t. obs [km,km/s] in ICRF frame logical , intent ( out ) :: status_ok !! true if there were no problems real ( wp ) :: jd !! julian date for input to [[get_state]]. integer :: ntarg !! id code for target body integer :: ncent !! id code for observer body real ( wp ), dimension ( 6 ) :: rv_ !! in case `wp /= fat_wp` we need a copy if ( targ == obs ) then !don't bother if target and observer are the same body rv = zero status_ok = . true . else !convert to expected inputs: jd = et_to_jd ( et ) ntarg = spice_id_to_old_id ( targ % id ) ncent = spice_id_to_old_id ( obs % id ) if ( ntarg > 0 . and . ncent > 0 ) then call me % get_state ( jd , ntarg , ncent , rv_ , status_ok ) rv = rv_ if ( status_ok ) then if (. not . me % km ) then !we must return in units of km/s !so, convert from AU, AU/day to km, km/s rv = rv * me % au rv ( 4 : 6 ) = rv ( 4 : 6 ) / day2sec end if else write ( error_unit , '(A)' ) 'Error in get_rv_from_jpl_ephemeris: ' // & 'Error calling ephemeris.' end if else write ( error_unit , '(A)' ) 'Error in get_rv_from_jpl_ephemeris: ' // & 'No ephemeris for this body.' status_ok = . false . end if end if end subroutine get_rv_from_jpl_ephemeris","tags":"","url":"proc/get_rv_from_jpl_ephemeris.html"},{"title":"get_r_from_jpl_ephemeris – fortran-astrodynamics-toolkit","text":"private  subroutine get_r_from_jpl_ephemeris(me, et, targ, obs, r, status_ok) Uses conversion_module time_module celestial_body_module numbers_module proc~~get_r_from_jpl_ephemeris~~UsesGraph proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris module~celestial_body_module celestial_body_module proc~get_r_from_jpl_ephemeris->module~celestial_body_module module~conversion_module conversion_module proc~get_r_from_jpl_ephemeris->module~conversion_module module~numbers_module numbers_module proc~get_r_from_jpl_ephemeris->module~numbers_module module~time_module time_module proc~get_r_from_jpl_ephemeris->module~time_module module~celestial_body_module->module~numbers_module module~base_class_module base_class_module module~celestial_body_module->module~base_class_module module~kind_module kind_module module~celestial_body_module->module~kind_module module~conversion_module->module~numbers_module module~conversion_module->module~kind_module module~numbers_module->module~kind_module module~time_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interface for the ephemeris_module . Type Bound jpl_ephemeris Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=fat_wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=fat_wp), intent(out), dimension(3) :: r position of targ w.r.t. obs [km] in ICRF frame logical, intent(out) :: status_ok true if there were no problems Calls proc~~get_r_from_jpl_ephemeris~~CallsGraph proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~et_to_jd et_to_jd proc~get_r_from_jpl_ephemeris->proc~et_to_jd proc~get_state jpl_ephemeris%get_state proc~get_r_from_jpl_ephemeris->proc~get_state proc~spice_id_to_old_id spice_id_to_old_id proc~get_r_from_jpl_ephemeris->proc~spice_id_to_old_id proc~state jpl_ephemeris%state proc~get_state->proc~state proc~interp jpl_ephemeris%interp proc~state->proc~interp proc~split split proc~state->proc~split Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_r_from_jpl_ephemeris~~CalledByGraph proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~ephemeris_test ephemeris_test proc~ephemeris_test->proc~get_r_from_jpl_ephemeris Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_r_from_jpl_ephemeris ( me , et , targ , obs , r , status_ok ) use time_module , only : et_to_jd use conversion_module , only : day2sec use celestial_body_module , only : celestial_body use numbers_module , only : zero implicit none class ( jpl_ephemeris ), intent ( inout ) :: me real ( fat_wp ), intent ( in ) :: et !! ephemeris time [sec] type ( celestial_body ), intent ( in ) :: targ !! target body type ( celestial_body ), intent ( in ) :: obs !! observer body real ( fat_wp ), dimension ( 3 ), intent ( out ) :: r !! position of targ w.r.t. obs [km] in ICRF frame logical , intent ( out ) :: status_ok !! true if there were no problems real ( wp ) :: jd !! julian date for input to [[get_state]]. integer :: ntarg !! id code for target body integer :: ncent !! id code for observer body real ( wp ), dimension ( 6 ) :: rv_ !! in case `wp /= fat_wp` we need a copy if ( targ == obs ) then !don't bother if target and observer are the same body r = zero status_ok = . true . else !convert to expected inputs: jd = et_to_jd ( et ) ntarg = spice_id_to_old_id ( targ % id ) ncent = spice_id_to_old_id ( obs % id ) if ( ntarg > 0 . and . ncent > 0 ) then call me % get_state ( jd , ntarg , ncent , rv_ , status_ok , pos_only = . true .) ! only return position r = rv_ ( 1 : 3 ) if ( status_ok ) then if (. not . me % km ) then !we must return in units of km !so, convert from AU to km r = r * me % au end if else write ( error_unit , '(A)' ) 'Error in get_r_from_jpl_ephemeris: ' // & 'Error calling ephemeris.' end if else write ( error_unit , '(A)' ) 'Error in get_r_from_jpl_ephemeris: ' // & 'No ephemeris for this body.' status_ok = . false . end if end if end subroutine get_r_from_jpl_ephemeris","tags":"","url":"proc/get_r_from_jpl_ephemeris.html"},{"title":"get_state – fortran-astrodynamics-toolkit","text":"private  subroutine get_state(me, jd, ntarg, ncent, rrd, status_ok, pos_only) This subroutine reads the JPL planetary ephemeris\n  and gives the position and velocity of the point ntarg with respect to ncent . Notes The numbering convention for ntarg and ncent is: 1 = mercury 8 = neptune 2 = venus 9 = pluto 3 = earth 10 = moon 4 = mars 11 = sun 5 = jupiter 12 = solar - sys tem barycenter 6 = saturn 13 = earth - moon barycenter 7 = uranus 14 = nutations ( longitude and obliq ) 15 = librations , if on eph file (if nutations are wanted, set ntarg = 14.\n  for librations, set ntarg = 15. set ncent=0.) Type Bound jpl_ephemeris Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: jd d.p. Julian ephemeris date at which interpolation is wanted. integer, intent(in) :: ntarg integer number of 'target' point. integer, intent(in) :: ncent integer number of 'center' point. real(kind=wp), intent(out), dimension(6) :: rrd output 6-word d.p. array containing position and velocity\nof point ntarg relative to ncent .\nthe units are AU and AU/day (or km and km/sec if me%km=.true. ).\nFor librations the units are radians and radians\nper day. In the case of nutations the first four words of rrd will be set to nutations and rates, having units of\nradians and radians/day. logical, intent(out) :: status_ok true if there were no problems logical, intent(in), optional :: pos_only if .true. only the position components are returned, not the velocity. [doesn't work yet] Calls proc~~get_state~~CallsGraph proc~get_state jpl_ephemeris%get_state proc~state jpl_ephemeris%state proc~get_state->proc~state proc~interp jpl_ephemeris%interp proc~state->proc~interp proc~split split proc~state->proc~split Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~get_state~~CalledByGraph proc~get_state jpl_ephemeris%get_state proc~ephemeris_test ephemeris_test proc~ephemeris_test->proc~get_state proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~ephemeris_test->proc~get_r_from_jpl_ephemeris proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~ephemeris_test->proc~get_rv_from_jpl_ephemeris proc~get_r_from_jpl_ephemeris->proc~get_state proc~get_rv_from_jpl_ephemeris->proc~get_state Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_state ( me , jd , ntarg , ncent , rrd , status_ok , pos_only ) implicit none class ( jpl_ephemeris ), intent ( inout ) :: me real ( wp ), intent ( in ) :: jd !! d.p. Julian ephemeris date at which interpolation is wanted. integer , intent ( in ) :: ntarg !! integer number of 'target' point. integer , intent ( in ) :: ncent !! integer number of 'center' point. real ( wp ), dimension ( 6 ), intent ( out ) :: rrd !! output 6-word d.p. array containing position and velocity !! of point `ntarg` relative to `ncent`. !! the units are AU and AU/day (or km and km/sec if `me%km=.true.`). !! For librations the units are radians and radians !! per day. In the case of nutations the first four words of !! `rrd` will be set to nutations and rates, having units of !! radians and radians/day. logical , intent ( out ) :: status_ok !! true if there were no problems logical , intent ( in ), optional :: pos_only !! if .true. only the position components are returned, not the velocity. [doesn't work yet] real ( wp ), dimension ( 2 ) :: et2 real ( wp ), dimension ( 6 , 13 ) :: pv real ( wp ), dimension ( 6 , 11 ) :: pvst real ( wp ), dimension ( 4 ) :: pnut integer , dimension ( 12 ) :: list integer :: i , j , k logical :: bsave logical :: full_state !! if .true. then we return the full state, otherwise only the position integer :: ilist !! for the `list` array status_ok = . false . if ( present ( pos_only )) then full_state = . not . pos_only else full_state = . true . end if ! if (.not. full_state) then !     ilist = 1   ! only return the position ! else !     ilist = 2   ! return position and velocity ! end if ilist = 2 ! note: setting to 1 doesn't seem to work. need to figure out why. ! for now, will always interpolate the full state. if ( me % initialized ) then ! initialize et2 for 'state' and set up component count et2 ( 1 ) = jd et2 ( 2 ) = 0.0_wp list = 0 rrd = 0.0_wp if ( ntarg /= ncent ) then select case ( ntarg ) case ( 14 ) !nutation if ( me % ipt ( 2 , 12 ) > 0 ) then !me%ipt(35) list ( 11 ) = 2 call me % state ( et2 , list , pvst , pnut , status_ok ) if (. not . status_ok ) then write ( error_unit , '(A)' ) 'error interpolating nutations in get_state.' return end if rrd ( 1 : 4 ) = pnut ( 1 : 4 ) rrd ( 5 ) = 0.0_wp rrd ( 6 ) = 0.0_wp return else rrd ( 1 : 4 ) = 0.0_wp write ( error_unit , '(A)' ) 'error in get_state: the ephemeris file does not contain nutations.' return endif case ( 15 ) !librations if ( me % ipt ( 2 , 13 ) > 0 ) then !me%ipt(38) list ( 12 ) = 2 call me % state ( et2 , list , pvst , pnut , status_ok ) if (. not . status_ok ) then write ( error_unit , '(A)' ) 'error interpolating librations in get_state.' return end if rrd = pvst (:, 11 ) return else write ( error_unit , '(A)' ) 'error in get_state: the ephemeris file does not contain librations.' return endif case default ! force barycentric output by 'state' bsave = me % bary me % bary = . true . ! set up proper entries in 'list' array for state call do i = 1 , 2 if ( i == 1 ) then k = ntarg else k = ncent end if if ( k <= 10 ) list ( k ) = ilist ! can we set all these to 1 for position only? doesn't seem to work? if ( k == 10 ) list ( 3 ) = ilist if ( k == 3 ) list ( 10 ) = ilist if ( k == 13 ) list ( 3 ) = ilist enddo ! make call to state call me % state ( et2 , list , pvst , pnut , status_ok ) if (. not . status_ok ) then write ( error_unit , '(A)' ) 'error interpolating state in get_state.' return end if do i = 1 , 10 do j = 1 , 6 pv ( j , i ) = pvst ( j , i ) end do enddo if ( ntarg == 11 . or . ncent == 11 ) pv (:, 11 ) = me % pvsun if ( ntarg == 12 . or . ncent == 12 ) pv (:, 12 ) = 0.0_wp if ( ntarg == 13 . or . ncent == 13 ) pv (:, 13 ) = pvst (:, 3 ) if ( ntarg * ncent == 30 . and . ntarg + ncent == 13 ) then pv (:, 3 ) = 0.0_wp else if ( list ( 3 ) == 2 ) pv (:, 3 ) = pvst (:, 3 ) - pvst (:, 10 ) / ( 1.0_wp + me % emrat ) if ( list ( 10 ) == 2 ) pv (:, 10 ) = pv (:, 3 ) + pvst (:, 10 ) end if rrd = pv (:, ntarg ) - pv (:, ncent ) me % bary = bsave end select end if status_ok = . true . else write ( error_unit , '(A)' ) 'error in get_state: the ephemeris is not initialized.' end if end subroutine get_state","tags":"","url":"proc/get_state.html"},{"title":"interp – fortran-astrodynamics-toolkit","text":"private  subroutine interp(me, buf, t, ncf, ncm, na, ifl, pv) this subroutine differentiates and interpolates a\nset of chebyshev coefficients to give position and velocity. Type Bound jpl_ephemeris Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=wp), dimension(ncf,ncm,*) :: buf 1st location of array of d.p. chebyshev coefficients of position real(kind=wp), intent(in), dimension(2) :: t integer, intent(in) :: ncf of coefficients per component integer, intent(in) :: ncm of components per set of coefficients integer, intent(in) :: na of sets of coefficients in full array (i.e., # of sub-intervals in full interval) integer, intent(in) :: ifl integer flag\n= 1 for positions only\n= 2 for pos and vel real(kind=wp), dimension(ncm,*) :: pv interpolated quantities requested.  dimension\nexpected is pv(ncm,ifl), dp. Called by proc~~interp~~CalledByGraph proc~interp jpl_ephemeris%interp proc~state jpl_ephemeris%state proc~state->proc~interp proc~get_state jpl_ephemeris%get_state proc~get_state->proc~state proc~ephemeris_test ephemeris_test proc~ephemeris_test->proc~get_state proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~ephemeris_test->proc~get_r_from_jpl_ephemeris proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~ephemeris_test->proc~get_rv_from_jpl_ephemeris proc~get_r_from_jpl_ephemeris->proc~get_state proc~get_rv_from_jpl_ephemeris->proc~get_state Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine interp ( me , buf , t , ncf , ncm , na , ifl , pv ) implicit none class ( jpl_ephemeris ), intent ( inout ) :: me integer , intent ( in ) :: ncf !! # of coefficients per component integer , intent ( in ) :: ncm !! # of components per set of coefficients real ( wp ), dimension ( ncf , ncm , * ) :: buf !! 1st location of array of d.p. chebyshev coefficients of position real ( wp ), dimension ( 2 ), intent ( in ) :: t integer , intent ( in ) :: na !! # of sets of coefficients in full array !! (i.e., # of sub-intervals in full interval) integer , intent ( in ) :: ifl !! integer flag !! = 1 for positions only !! = 2 for pos and vel real ( wp ), dimension ( ncm , * ) :: pv !! interpolated quantities requested.  dimension !! expected is pv(ncm,ifl), dp. real ( wp ) :: dna , dt1 , temp , vfac , tc integer :: l , i , j ! entry point. get correct sub-interval number for this set ! of coefficients and then get normalized chebyshev time ! within that subinterval. dna = dble ( na ) dt1 = int ( t ( 1 )) temp = dna * t ( 1 ) l = int ( temp - dt1 ) + 1 ! tc is the normalized chebyshev time (-1 <= tc <= 1) tc = 2.0_wp * ( mod ( temp , 1.0_wp ) + dt1 ) - 1.0_wp ! check to see whether chebyshev time has changed, ! and compute new polynomial values if it has. ! (the element pc(2) is the value of t1(tc) and hence ! contains the value of tc on the previous call.) if ( tc /= me % pc ( 2 )) then me % np = 2 me % nv = 3 me % pc ( 2 ) = tc me % twot = tc + tc endif ! be sure that at least 'ncf' polynomials have been evaluated ! and are stored in the array 'pc'. if ( me % np < ncf ) then do i = me % np + 1 , ncf me % pc ( i ) = me % twot * me % pc ( i - 1 ) - me % pc ( i - 2 ) end do me % np = ncf endif ! interpolate to get position for each component do i = 1 , ncm pv ( i , 1 ) = 0.0_wp do j = ncf , 1 , - 1 pv ( i , 1 ) = pv ( i , 1 ) + me % pc ( j ) * buf ( j , i , l ) end do end do if ( ifl <= 1 ) return ! if velocity interpolation is wanted, be sure enough ! derivative polynomials have been generated and stored. vfac = ( dna + dna ) / t ( 2 ) me % vc ( 3 ) = me % twot + me % twot if ( me % nv < ncf ) then do i = me % nv + 1 , ncf me % vc ( i ) = me % twot * me % vc ( i - 1 ) + me % pc ( i - 1 ) + me % pc ( i - 1 ) - me % vc ( i - 2 ) end do me % nv = ncf endif ! interpolate to get velocity for each component do i = 1 , ncm pv ( i , 2 ) = 0.0_wp do j = ncf , 2 , - 1 pv ( i , 2 ) = pv ( i , 2 ) + me % vc ( j ) * buf ( j , i , l ) end do pv ( i , 2 ) = pv ( i , 2 ) * vfac end do end subroutine interp","tags":"","url":"proc/interp.html"},{"title":"split – fortran-astrodynamics-toolkit","text":"private  subroutine split(tt, fr) this subroutine breaks a d.p. number into a d.p. integer\nand a d.p. fractional part. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: tt d.p. input number real(kind=wp), intent(out), dimension(2) :: fr d.p. 2-word output array.\nfr(1) contains integer part\nfr(2) contains fractional part\nfor negative input numbers, fr(1) contains the next\nmore negative integer; fr(2) contains a positive fraction. Called by proc~~split~~CalledByGraph proc~split split proc~state jpl_ephemeris%state proc~state->proc~split proc~get_state jpl_ephemeris%get_state proc~get_state->proc~state proc~ephemeris_test ephemeris_test proc~ephemeris_test->proc~get_state proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~ephemeris_test->proc~get_r_from_jpl_ephemeris proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~ephemeris_test->proc~get_rv_from_jpl_ephemeris proc~get_r_from_jpl_ephemeris->proc~get_state proc~get_rv_from_jpl_ephemeris->proc~get_state Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine split ( tt , fr ) implicit none real ( wp ), intent ( in ) :: tt !! d.p. input number real ( wp ), dimension ( 2 ), intent ( out ) :: fr !! d.p. 2-word output array. !! fr(1) contains integer part !! fr(2) contains fractional part !! for negative input numbers, fr(1) contains the next !! more negative integer; fr(2) contains a positive fraction. ! get integer and fractional parts fr ( 1 ) = int ( tt ) fr ( 2 ) = tt - fr ( 1 ) if ( tt >= 0.0_wp . or . fr ( 2 ) == 0.0_wp ) return ! make adjustments for negative input number fr ( 1 ) = fr ( 1 ) - 1.0_wp fr ( 2 ) = fr ( 2 ) + 1.0_wp end subroutine split","tags":"","url":"proc/split.html"},{"title":"initialize_ephemeris – fortran-astrodynamics-toolkit","text":"private  subroutine initialize_ephemeris(me, filename, ksize, km, bary, status_ok) Initialize the ephemeris.\n  This routine may be called to load a different ephemeris file.\n  Otherwise, it is called on the first call to get_state, and loads\n  the file specified in the module header. Note Based on code formerly in state . Type Bound jpl_ephemeris Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me character(len=*), intent(in) :: filename ephemeris file name integer, intent(in), optional :: ksize corresponding ksize logical, intent(in), optional :: km defining physical units of the output states. km = .true. : km and km/sec [default], km = .false. : au and au/day. logical, intent(in), optional :: bary logical flag defining output center.\nonly the 9 planets are affected. bary = .true. : center is solar-system barycenter, bary = .false. : center is sun [default]. logical, intent(out) :: status_ok true if there were not problems. Called by proc~~initialize_ephemeris~~CalledByGraph proc~initialize_ephemeris jpl_ephemeris%initialize_ephemeris proc~ephemeris_test ephemeris_test proc~ephemeris_test->proc~initialize_ephemeris proc~transformation_module_test transformation_module_test proc~transformation_module_test->proc~initialize_ephemeris Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize_ephemeris ( me , filename , ksize , km , bary , status_ok ) implicit none class ( jpl_ephemeris ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: filename !! ephemeris file name integer , intent ( in ), optional :: ksize !! corresponding `ksize` logical , intent ( in ), optional :: km !! defining physical units of the output states. !! `km = .true.`  : km and km/sec [default], !! `km = .false.` : au and au/day. logical , intent ( in ), optional :: bary !! logical flag defining output center. !! only the 9 planets are affected. !! `bary = .true.`  : center is solar-system barycenter, !! `bary = .false.` : center is sun [default]. logical , intent ( out ) :: status_ok !! true if there were not problems. !local variables: integer :: irecsz , istat , i , j , k , l !just in case it was already open: call me % close () ! clears everything in the class !ephemeris file name: me % namfil = trim ( filename ) !optional inputs: if ( present ( ksize )) me % ksize = ksize if ( present ( km )) me % km = km if ( present ( bary )) me % bary = bary irecsz = nrecl * me % ksize me % ncoeffs = me % ksize / 2 open ( newunit = me % nrfile , & file = me % namfil , & access = 'DIRECT' , & form = 'UNFORMATTED' , & action = 'READ' , & !JW added recl = irecsz , & iostat = istat , & status = 'OLD' ) !write(*,*) \"istat=\",istat status_ok = ( istat == 0 ) !if there were no problems opening the file if ( status_ok ) then read ( me % nrfile , rec = 1 , iostat = istat ) & me % ttl ,( me % cnam ( k ), k = 1 , oldmax ), me % ss , me % ncon , me % au , me % emrat ,& (( me % ipt ( i , j ), i = 1 , 3 ), j = 1 , 12 ), me % numde ,( me % ipt ( i , 13 ), i = 1 , 3 ), & ( me % cnam ( l ), l = oldmax + 1 , me % ncon ) if ( istat == 0 ) then if ( me % ncon <= oldmax ) then read ( me % nrfile , rec = 2 , iostat = istat ) ( me % cval ( i ), i = 1 , oldmax ) else read ( me % nrfile , rec = 2 , iostat = istat ) ( me % cval ( i ), i = 1 , me % ncon ) endif if ( istat == 0 ) then me % nrl = 0 me % initialized = . true . end if end if ! check if the reads went OK: status_ok = me % initialized if ( status_ok ) then !initialize some of the class variables: ! [note: this was formerly done in the interp routine] me % pc ( 1 ) = 1.0_wp me % vc ( 2 ) = 1.0_wp else write ( error_unit , '(A)' ) 'Error reading ephemeris file: ' // trim ( me % namfil ) end if else write ( error_unit , '(A)' ) 'Error opening ephemeris file: ' // trim ( me % namfil ) end if end subroutine initialize_ephemeris","tags":"","url":"proc/initialize_ephemeris.html"},{"title":"close_ephemeris – fortran-astrodynamics-toolkit","text":"private  subroutine close_ephemeris(me) Close the ephemeris. Type Bound jpl_ephemeris Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me Source Code subroutine close_ephemeris ( me ) implicit none class ( jpl_ephemeris ), intent ( inout ) :: me logical :: is_open integer :: istat if ( me % initialized ) then !close the file: inquire ( unit = me % nrfile , opened = is_open , iostat = istat ) if ( is_open ) close ( unit = me % nrfile , iostat = istat ) !initialize all class variables to defaults: call clear ( me ) end if contains subroutine clear ( eph ) !! clear all the variables in the [[jpl_ephemeris]] class. implicit none class ( jpl_ephemeris ), intent ( out ) :: eph end subroutine clear end subroutine close_ephemeris","tags":"","url":"proc/close_ephemeris.html"},{"title":"state – fortran-astrodynamics-toolkit","text":"private  subroutine state(me, et2, list, pv, pnut, status_ok) This subroutine reads and interpolates the JPL planetary ephemeris file. Type Bound jpl_ephemeris Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=wp), intent(in), dimension(2) :: et2 2-word Julian ephemeris epoch at which interpolation\nis wanted.  any combination of et2(1)+et2(2) which falls\nwithin the time span on the file is a permissible epoch. a. for ease in programming, the user may put the\n   entire epoch in et2(1) and set et2(2)=0 . b. for maximum interpolation accuracy, set et2(1) =\n   the most recent midnight at or before interpolation\n   epoch and set et2(2) = fractional part of a day\n   elapsed between et2(1) and epoch. c. as an alternative, it may prove convenient to set et2(1) = some fixed epoch, such as start of integration,\n   and et2(2) = elapsed interval between then and epoch. integer, intent(in), dimension(12) :: list 12-word integer array specifying what interpolation\nis wanted for each of the bodies on the file. list(i) = 0 : no interpolation for body i, list(i) = 1 : position only, list(i) = 2 : position and velocity. The designation of the astronomical bodies by i is: i = 1 : mercury, i = 2 : venus, i = 3 : earth-moon barycenter, i = 4 : mars, i = 5 : jupiter, i = 6 : saturn, i = 7 : uranus, i = 8 : neptune, i = 9 : pluto, i =10 : geocentric moon, i =11 : nutations in longitude and obliquity, i =12 : lunar librations (if on file). real(kind=wp), intent(out), dimension(6,11) :: pv dp 6 x 11 array that will contain requested interpolated\nquantities (other than nutation, stored in pnut ).\nthe body specified by list(i) will have its\nstate in the array starting at pv(1,i) .\n(on any given call, only those words in pv which are\naffected by the first 10 list entries, and by list(12) if librations are on the file, are set.\nthe rest of the pv array is untouched.)\nthe order of components starting in pv(1,i) is: x , y , z , dx , dy , dz . All output vectors are referenced to the earth mean\nequator and equinox of J2000 if the DE number is 200 or\ngreater; of B1950 if the DE number is less than 200. The moon state is always geocentric; the other nine states\nare either heliocentric or solar-system barycentric,\ndepending on the setting of the bary variable in the class. Lunar librations, if on file, are put into pv(k,11) if list(12) is 1 or 2 . real(kind=wp), intent(out), dimension(4) :: pnut dp 4-word array that will contain nutations and rates,\ndepending on the setting of list(11) .  the order of\nquantities in pnut is: d psi (nutation in longitude), d epsilon (nutation in obliquity), d psi dot , d epsilon dot . logical, intent(out) :: status_ok true if there were no problems Calls proc~~state~~CallsGraph proc~state jpl_ephemeris%state proc~interp jpl_ephemeris%interp proc~state->proc~interp proc~split split proc~state->proc~split Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~state~~CalledByGraph proc~state jpl_ephemeris%state proc~get_state jpl_ephemeris%get_state proc~get_state->proc~state proc~ephemeris_test ephemeris_test proc~ephemeris_test->proc~get_state proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~ephemeris_test->proc~get_r_from_jpl_ephemeris proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~ephemeris_test->proc~get_rv_from_jpl_ephemeris proc~get_r_from_jpl_ephemeris->proc~get_state proc~get_rv_from_jpl_ephemeris->proc~get_state Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine state ( me , et2 , list , pv , pnut , status_ok ) implicit none class ( jpl_ephemeris ), intent ( inout ) :: me real ( wp ), dimension ( 2 ), intent ( in ) :: et2 !! 2-word Julian ephemeris epoch at which interpolation !! is wanted.  any combination of `et2(1)+et2(2)` which falls !! within the time span on the file is a permissible epoch. !! !! ***a.*** for ease in programming, the user may put the !!    entire epoch in `et2(1)` and set `et2(2)=0`. !! ***b.*** for maximum interpolation accuracy, set `et2(1)` = !!    the most recent midnight at or before interpolation !!    epoch and set `et2(2)` = fractional part of a day !!    elapsed between `et2(1)` and epoch. !! ***c.*** as an alternative, it may prove convenient to set !!    `et2(1)` = some fixed epoch, such as start of integration, !!    and `et2(2)` = elapsed interval between then and epoch. integer , dimension ( 12 ), intent ( in ) :: list !! 12-word integer array specifying what interpolation !! is wanted for each of the bodies on the file. !!    ***list(i) = 0*** : no interpolation for body i, !!    ***list(i) = 1*** : position only, !!    ***list(i) = 2*** : position and velocity. !! !! The designation of the astronomical bodies by i is: !!    ***i = 1*** : mercury, !!    ***i = 2*** : venus, !!    ***i = 3*** : earth-moon barycenter, !!    ***i = 4*** : mars, !!    ***i = 5*** : jupiter, !!    ***i = 6*** : saturn, !!    ***i = 7*** : uranus, !!    ***i = 8*** : neptune, !!    ***i = 9*** : pluto, !!    ***i =10*** : geocentric moon, !!    ***i =11*** : nutations in longitude and obliquity, !!    ***i =12*** : lunar librations (if on file). real ( wp ), dimension ( 6 , 11 ), intent ( out ) :: pv !! dp 6 x 11 array that will contain requested interpolated !! quantities (other than nutation, stored in `pnut`). !! the body specified by `list(i)` will have its !! state in the array starting at `pv(1,i)`. !! (on any given call, only those words in `pv` which are !! affected by the first 10 `list` entries, and by `list(12)` !! if librations are on the file, are set. !! the rest of the `pv` array is untouched.) !! the order of components starting in `pv(1,i)` is: !! `x`,`y`,`z`,`dx`,`dy`,`dz`. !! !! All output vectors are referenced to the earth mean !! equator and equinox of J2000 if the DE number is 200 or !! greater; of B1950 if the DE number is less than 200. !! !! The moon state is always geocentric; the other nine states !! are either heliocentric or solar-system barycentric, !! depending on the setting of the `bary` variable in the class. !! !! Lunar librations, if on file, are put into `pv(k,11)` if !! `list(12)` is `1` or `2`. real ( wp ), dimension ( 4 ), intent ( out ) :: pnut !! dp 4-word array that will contain nutations and rates, !! depending on the setting of `list(11)`.  the order of !! quantities in `pnut` is: !! !! * `d psi`  (nutation in longitude), !! * `d epsilon` (nutation in obliquity), !! * `d psi dot`, !! * `d epsilon dot`. logical , intent ( out ) :: status_ok !! true if there were no problems real ( wp ), dimension ( 2 ) :: t real ( wp ), dimension ( 4 ) :: pjd real ( wp ) :: aufac , s , tmp1 , tmp2 integer :: istat , i , j , k , nr status_ok = . true . s = et2 ( 1 ) - 0.5_wp call split ( s , pjd ( 1 : 2 )) call split ( et2 ( 2 ), pjd ( 3 : 4 )) pjd ( 1 ) = pjd ( 1 ) + pjd ( 3 ) + 0.5_wp pjd ( 2 ) = pjd ( 2 ) + pjd ( 4 ) call split ( pjd ( 2 ), pjd ( 3 : 4 )) pjd ( 1 ) = pjd ( 1 ) + pjd ( 3 ) ! error return for epoch out of range if ( pjd ( 1 ) + pjd ( 4 ) < me % ss ( 1 ) . or . pjd ( 1 ) + pjd ( 4 ) > me % ss ( 2 )) then write ( error_unit , '(A,F12.2,A,2F22.2)' ) & 'Error: requested jed,' ,& et2 ( 1 ) + et2 ( 2 ),& ' not within ephemeris limits,' ,& me % ss ( 1 ), me % ss ( 2 ) status_ok = . false . return end if ! calculate record # and relative time in interval nr = int (( pjd ( 1 ) - me % ss ( 1 )) / me % ss ( 3 )) + 3 if ( pjd ( 1 ) == me % ss ( 2 )) nr = nr - 1 tmp1 = dble ( nr - 3 ) * me % ss ( 3 ) + me % ss ( 1 ) tmp2 = pjd ( 1 ) - tmp1 t ( 1 ) = ( tmp2 + pjd ( 4 )) / me % ss ( 3 ) ! read correct record if not in core if ( nr /= me % nrl ) then me % nrl = nr read ( me % nrfile , rec = nr , iostat = istat ) ( me % buf ( k ), k = 1 , me % ncoeffs ) if ( istat /= 0 ) then write ( error_unit , '(2F12.2,A80)' ) et2 , 'Error return in state' status_ok = . false . return end if endif if ( me % km ) then t ( 2 ) = me % ss ( 3 ) * 8640 0.0_wp aufac = 1.0_wp else t ( 2 ) = me % ss ( 3 ) aufac = 1.0_wp / me % au endif ! interpolate ssbary sun call me % interp ( me % buf ( me % ipt ( 1 , 11 )), t , me % ipt ( 2 , 11 ), 3 , me % ipt ( 3 , 11 ), 2 , me % pvsun ) me % pvsun = me % pvsun * aufac ! check and interpolate whichever bodies are requested do i = 1 , 10 if ( list ( i ) == 0 ) cycle call me % interp ( me % buf ( me % ipt ( 1 , i )), t , me % ipt ( 2 , i ), 3 , me % ipt ( 3 , i ), list ( i ), pv ( 1 , i )) do j = 1 , 6 if ( i <= 9 . and . . not . me % bary ) then pv ( j , i ) = pv ( j , i ) * aufac - me % pvsun ( j ) else pv ( j , i ) = pv ( j , i ) * aufac endif enddo end do ! do nutations if requested (and if on file) if ( list ( 11 ) > 0 . and . me % ipt ( 2 , 12 ) > 0 ) & call me % interp ( me % buf ( me % ipt ( 1 , 12 )), t , me % ipt ( 2 , 12 ), 2 , me % ipt ( 3 , 12 ), list ( 11 ), pnut ) ! get librations if requested (and if on file) if ( list ( 12 ) > 0 . and . me % ipt ( 2 , 13 ) > 0 ) & call me % interp ( me % buf ( me % ipt ( 1 , 13 )), t , me % ipt ( 2 , 13 ), 3 , me % ipt ( 3 , 13 ), list ( 12 ), pv ( 1 , 11 )) end subroutine state","tags":"","url":"proc/state.html"},{"title":"get_constants – fortran-astrodynamics-toolkit","text":"private  subroutine get_constants(me, nam, val, sss, n) Obtain the constants from the ephemeris file. Type Bound jpl_ephemeris Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me character(len=6), intent(out), dimension(:) :: nam array of constant names real(kind=wp), intent(out), dimension(:) :: val array of values of constants real(kind=wp), intent(out), dimension(3) :: sss jd start, jd stop, step of ephemeris integer, intent(out) :: n number of entries in nam and val arrays Called by proc~~get_constants~~CalledByGraph proc~get_constants jpl_ephemeris%get_constants proc~ephemeris_test ephemeris_test proc~ephemeris_test->proc~get_constants Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine get_constants ( me , nam , val , sss , n ) implicit none class ( jpl_ephemeris ), intent ( inout ) :: me character ( len = 6 ), dimension (:), intent ( out ) :: nam !! array of constant names real ( wp ), dimension (:), intent ( out ) :: val !! array of values of constants real ( wp ), dimension ( 3 ), intent ( out ) :: sss !! jd start, jd stop, step of ephemeris integer , intent ( out ) :: n !! number of entries in `nam` and `val` arrays integer :: i if ( me % initialized ) then n = me % ncon sss = me % ss do i = 1 , n nam ( i ) = me % cnam ( i ) val ( i ) = me % cval ( i ) enddo else write ( error_unit , '(A)' ) 'error in get_constants: the ephemeris is not initialized.' end if end subroutine get_constants","tags":"","url":"proc/get_constants.html"},{"title":"ephemeris_test – fortran-astrodynamics-toolkit","text":"public  subroutine ephemeris_test() Uses time_module celestial_body_module proc~~ephemeris_test~~UsesGraph proc~ephemeris_test ephemeris_test module~celestial_body_module celestial_body_module proc~ephemeris_test->module~celestial_body_module module~time_module time_module proc~ephemeris_test->module~time_module module~base_class_module base_class_module module~celestial_body_module->module~base_class_module module~kind_module kind_module module~celestial_body_module->module~kind_module module~numbers_module numbers_module module~celestial_body_module->module~numbers_module module~time_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Ephemeris test routine. Ephemeris files This routine requires the DE405 and DE421 JPL binary ephemeris files\n  to be present in the ./eph directory.\n  These can be built by using the instructions here . See also get_third_party.sh script in the repo. Arguments None Calls proc~~ephemeris_test~~CallsGraph proc~ephemeris_test ephemeris_test proc~get_constants jpl_ephemeris%get_constants proc~ephemeris_test->proc~get_constants proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~ephemeris_test->proc~get_r_from_jpl_ephemeris proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~ephemeris_test->proc~get_rv_from_jpl_ephemeris proc~get_state jpl_ephemeris%get_state proc~ephemeris_test->proc~get_state proc~initialize_ephemeris jpl_ephemeris%initialize_ephemeris proc~ephemeris_test->proc~initialize_ephemeris proc~jd_to_et jd_to_et proc~ephemeris_test->proc~jd_to_et proc~get_r_from_jpl_ephemeris->proc~get_state proc~et_to_jd et_to_jd proc~get_r_from_jpl_ephemeris->proc~et_to_jd proc~spice_id_to_old_id spice_id_to_old_id proc~get_r_from_jpl_ephemeris->proc~spice_id_to_old_id proc~get_rv_from_jpl_ephemeris->proc~get_state proc~get_rv_from_jpl_ephemeris->proc~et_to_jd proc~get_rv_from_jpl_ephemeris->proc~spice_id_to_old_id proc~state jpl_ephemeris%state proc~get_state->proc~state proc~interp jpl_ephemeris%interp proc~state->proc~interp proc~split split proc~state->proc~split Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine ephemeris_test () use time_module , only : jd_to_et use celestial_body_module , fat_wp => wp implicit none ! note: the low-level functions use real64 variables. character ( len = 6 ), dimension ( nmax ) :: nams real ( wp ), dimension ( 6 ) :: diffrv real ( wp ), dimension ( 3 ) :: ss real ( wp ), dimension ( nmax ) :: vals integer :: nvs , ntarg , nctr , i , j type ( jpl_ephemeris ) :: eph405 , eph421 logical :: status_ok_405 , status_ok_421 real ( wp ) :: jd_64 , rv_64 ( 6 ), rv1_64 ( 6 ), rv2_64 ( 6 ) real ( fat_wp ) :: et real ( fat_wp ), dimension ( 3 ) :: r real ( fat_wp ), dimension ( 6 ) :: rv , rv1 , rv2 real ( fat_wp ) :: jd character ( len =* ), parameter :: ephemeris_file_405 = './eph/JPLEPH.405' !! JPL DE405 ephemeris file character ( len =* ), parameter :: ephemeris_file_421 = './eph/JPLEPH.421' !! JPL DE421 ephemeris file write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' ephemeris_test' write ( * , * ) '---------------' write ( * , * ) '' !initialize: call eph405 % initialize ( filename = ephemeris_file_405 , status_ok = status_ok_405 ) call eph421 % initialize ( filename = ephemeris_file_421 , status_ok = status_ok_421 ) if ( status_ok_405 ) then !get some constants from the file: call eph405 % get_constants ( nams , vals , ss , nvs ) write ( * , '(A)' ) '' write ( * , '(A)' ) 'Ephemeris initialized' write ( * , '(A,1X,F15.3,1X,A,1X,F15.3)' ) 'JD range: ' , ss ( 1 ), 'to ' , ss ( 2 ) write ( * , '(A)' ) '' do i = 1 , nvs write ( * , '(A,1X,D25.16)' ) nams ( i ), vals ( i ) end do jd = 245153 6.5_wp ! julian date et = jd_to_et ( jd ) ! ephemeris time if ( jd < ss ( 1 ) . or . jd > ss ( 2 )) then write ( * , '(A)' ) '' write ( * , * ) 'error: jed out of bounds.' write ( * , * ) 'jed   = ' , jd write ( * , * ) 'ss(1) = ' , ss ( 1 ) write ( * , * ) 'ss(2) = ' , ss ( 2 ) else !test DE405: do j = 1 , 2 if ( j == 1 ) then ntarg = 3 !earth nctr = 11 !sun else ntarg = 10 !moon nctr = 3 !earth end if write ( * , * ) '' write ( * , * ) 'DE405' write ( * , * ) 'state of \"' // trim ( list_of_bodies ( ntarg )) // & '\" wrt \"' // trim ( list_of_bodies ( nctr )) // '\"' do i = 1 , 10 jd_64 = jd call eph405 % get_state ( jd_64 , ntarg , nctr , rv_64 , status_ok_405 ) rv = rv_64 write ( * , '(F15.2,1X,*(E25.16,1X))' ) jd , norm2 ( rv ( 1 : 3 )), rv jd = jd + 1 0.0_wp end do end do end if else write ( * , * ) 'Error opening DE405 ephemeris file' end if if ( status_ok_405 . and . status_ok_421 ) then !compare DE405 with DE421 do j = 1 , 2 if ( j == 1 ) then ntarg = 3 !earth nctr = 11 !sun else ntarg = 10 !moon nctr = 3 !earth end if write ( * , * ) '' write ( * , * ) 'DE421 - DE405 Difference' write ( * , * ) 'state of \"' // trim ( list_of_bodies ( ntarg )) // & '\" wrt \"' // trim ( list_of_bodies ( nctr )) // '\"' do i = 1 , 10 jd_64 = jd call eph405 % get_state ( jd_64 , ntarg , nctr , rv1_64 , status_ok_405 ) rv1 = rv1_64 jd_64 = jd call eph421 % get_state ( jd_64 , ntarg , nctr , rv2_64 , status_ok_421 ) rv2 = rv2_64 diffrv = rv2 - rv1 write ( * , '(F15.2,1X,*(E25.16,1X))' ) jd , norm2 ( diffrv ( 1 : 3 )), norm2 ( diffrv ( 4 : 6 )) jd = jd + 1 0.0_wp end do end do ! compare get_rv with get_r call eph405 % get_rv ( et , body_earth , body_moon , rv , status_ok_405 ) call eph405 % get_r ( et , body_earth , body_moon , r , status_ok_405 ) write ( * , * ) '' write ( * , * ) 'r - rv(1:3) = ' , r - rv ( 1 : 3 ) if (. not . all ( r - rv ( 1 : 3 ) == zero )) error stop 'error in ephemeris' write ( * , * ) '' else write ( * , * ) 'Error opening DE421 ephemeris file' end if !cleanup: call eph405 % close () call eph421 % close () end subroutine ephemeris_test","tags":"","url":"proc/ephemeris_test.html"},{"title":"et_to_jd – fortran-astrodynamics-toolkit","text":"public pure function et_to_jd(et) result(jd) Uses conversion_module proc~~et_to_jd~~UsesGraph proc~et_to_jd et_to_jd module~conversion_module conversion_module proc~et_to_jd->module~conversion_module module~kind_module kind_module module~conversion_module->module~kind_module module~numbers_module numbers_module module~conversion_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Convert ephemeris time (seconds from J2000 epoch) to Julian date. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: et ephemeris time [sec from J2000 epoch] Return Value real(kind=wp) Julian date [days] Called by proc~~et_to_jd~~CalledByGraph proc~et_to_jd et_to_jd proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~get_r_from_jpl_ephemeris->proc~et_to_jd proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~get_rv_from_jpl_ephemeris->proc~et_to_jd proc~standish_module_test standish_module_test proc~standish_module_test->proc~et_to_jd proc~standish_rv_func standish_ephemeris%standish_rv_func proc~standish_module_test->proc~standish_rv_func proc~standish_rv_func->proc~et_to_jd proc~ephemeris_test ephemeris_test proc~ephemeris_test->proc~get_r_from_jpl_ephemeris proc~ephemeris_test->proc~get_rv_from_jpl_ephemeris proc~standish_r_func standish_ephemeris%standish_r_func proc~standish_r_func->proc~standish_rv_func Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function et_to_jd ( et ) result ( jd ) use conversion_module , only : sec2day implicit none real ( wp ), intent ( in ) :: et !! ephemeris time [sec from J2000 epoch] real ( wp ) :: jd !! Julian date [days] jd = jd_j2000 + et * sec2day end function et_to_jd","tags":"","url":"proc/et_to_jd.html"},{"title":"jd_to_et – fortran-astrodynamics-toolkit","text":"public pure function jd_to_et(jd) result(et) Uses conversion_module proc~~jd_to_et~~UsesGraph proc~jd_to_et jd_to_et module~conversion_module conversion_module proc~jd_to_et->module~conversion_module module~kind_module kind_module module~conversion_module->module~kind_module module~numbers_module numbers_module module~conversion_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Convert Julian date to ephemeris time (seconds from J2000 epoch). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: jd Julian date [days] Return Value real(kind=wp) ephemeris time [sec from J2000 epoch] Called by proc~~jd_to_et~~CalledByGraph proc~jd_to_et jd_to_et proc~ephemeris_test ephemeris_test proc~ephemeris_test->proc~jd_to_et proc~time_module_test time_module_test proc~time_module_test->proc~jd_to_et Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function jd_to_et ( jd ) result ( et ) use conversion_module , only : day2sec implicit none real ( wp ), intent ( in ) :: jd !! Julian date [days] real ( wp ) :: et !! ephemeris time [sec from J2000 epoch] et = ( jd - jd_j2000 ) * day2sec end function jd_to_et","tags":"","url":"proc/jd_to_et.html"},{"title":"jd_to_mjd – fortran-astrodynamics-toolkit","text":"public pure function jd_to_mjd(jd) result(mjd) Converts Julian date to Modified Julian date. Reference USNO Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: jd julian date Return Value real(kind=wp) modified julian date Source Code pure function jd_to_mjd ( jd ) result ( mjd ) implicit none real ( wp ) :: mjd !! modified julian date real ( wp ), intent ( in ) :: jd !! julian date mjd = jd - 240000 0.5_wp end function jd_to_mjd","tags":"","url":"proc/jd_to_mjd.html"},{"title":"mjd_to_jd – fortran-astrodynamics-toolkit","text":"public pure function mjd_to_jd(mjd) result(jd) Converts Modified Julian date to Julian date. Reference USNO Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mjd modified julian date Return Value real(kind=wp) julian date Source Code pure function mjd_to_jd ( mjd ) result ( jd ) implicit none real ( wp ) :: jd !! julian date real ( wp ), intent ( in ) :: mjd !! modified julian date jd = mjd + 240000 0.5_wp end function mjd_to_jd","tags":"","url":"proc/mjd_to_jd.html"},{"title":"julian_day – fortran-astrodynamics-toolkit","text":"public pure function julian_day(y, m, d) Returns the Julian day number (i.e., the Julian date at Greenwich noon)\n  on the specified YEAR, MONTH, and DAY. Valid for any Gregorian calendar date producing a\n  Julian date greater than zero. Reference USNO Arguments Type Intent Optional Attributes Name integer, intent(in) :: y year (YYYY) integer, intent(in) :: m month (MM) integer, intent(in) :: d day (DD) Return Value integer Called by proc~~julian_day~~CalledByGraph proc~julian_day julian_day proc~julian_date_realsec julian_date_realsec proc~julian_date_realsec->proc~julian_day interface~julian_date julian_date interface~julian_date->proc~julian_date_realsec proc~julian_date_intsec julian_date_intsec interface~julian_date->proc~julian_date_intsec proc~julian_date_intsec->proc~julian_date_realsec proc~time_module_test time_module_test proc~time_module_test->interface~julian_date Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure integer function julian_day ( y , m , d ) implicit none integer , intent ( in ) :: y !! year (YYYY) integer , intent ( in ) :: m !! month (MM) integer , intent ( in ) :: d !! day (DD) julian_day = d - 32075 + 1461 * ( y + 4800 + ( m - 14 ) / 12 ) / 4 + 367 * & ( m - 2 - ( m - 14 ) / 12 * 12 ) / 12 - 3 * (( y + 4900 + ( m - 14 ) / 12 ) / 100 ) / 4 end function julian_day","tags":"","url":"proc/julian_day.html"},{"title":"julian_date_intsec – fortran-astrodynamics-toolkit","text":"private pure function julian_date_intsec(y, m, d, hour, minute, second) result(julian_date) Returns the Julian date for the specified YEAR, MONTH, DAY, HR, MIN, SEC. Valid for any Gregorian calendar date producing a\n  Julian date greater than zero. History JW : 10/4/2017 : moved main code to julian_date_realsec routine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: y integer, intent(in) :: m integer, intent(in) :: d integer, intent(in) :: hour integer, intent(in) :: minute integer, intent(in) :: second Return Value real(kind=wp) Calls proc~~julian_date_intsec~~CallsGraph proc~julian_date_intsec julian_date_intsec proc~julian_date_realsec julian_date_realsec proc~julian_date_intsec->proc~julian_date_realsec proc~julian_day julian_day proc~julian_date_realsec->proc~julian_day Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~julian_date_intsec~~CalledByGraph proc~julian_date_intsec julian_date_intsec interface~julian_date julian_date interface~julian_date->proc~julian_date_intsec proc~time_module_test time_module_test proc~time_module_test->interface~julian_date Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function julian_date_intsec ( y , m , d , hour , minute , second ) result ( julian_date ) implicit none real ( wp ) :: julian_date integer , intent ( in ) :: y integer , intent ( in ) :: m integer , intent ( in ) :: d integer , intent ( in ) :: hour integer , intent ( in ) :: minute integer , intent ( in ) :: second ! call the other routine: julian_date = julian_date_realsec ( y , m , d , hour , minute , real ( second , wp )) end function julian_date_intsec","tags":"","url":"proc/julian_date_intsec.html"},{"title":"julian_date_realsec – fortran-astrodynamics-toolkit","text":"private pure function julian_date_realsec(y, m, d, hour, minute, second) result(julian_date) Returns the Julian date for the specified YEAR, MONTH, DAY, HR, MIN, SEC. Valid for any Gregorian calendar date producing a\n  Julian date greater than zero. History JW : 10/4/2017 : made second a real value & renamed routine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: y integer, intent(in) :: m integer, intent(in) :: d integer, intent(in) :: hour integer, intent(in) :: minute real(kind=wp), intent(in) :: second Return Value real(kind=wp) Calls proc~~julian_date_realsec~~CallsGraph proc~julian_date_realsec julian_date_realsec proc~julian_day julian_day proc~julian_date_realsec->proc~julian_day Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~julian_date_realsec~~CalledByGraph proc~julian_date_realsec julian_date_realsec interface~julian_date julian_date interface~julian_date->proc~julian_date_realsec proc~julian_date_intsec julian_date_intsec interface~julian_date->proc~julian_date_intsec proc~julian_date_intsec->proc~julian_date_realsec proc~time_module_test time_module_test proc~time_module_test->interface~julian_date Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function julian_date_realsec ( y , m , d , hour , minute , second ) result ( julian_date ) implicit none real ( wp ) :: julian_date integer , intent ( in ) :: y integer , intent ( in ) :: m integer , intent ( in ) :: d integer , intent ( in ) :: hour integer , intent ( in ) :: minute real ( wp ), intent ( in ) :: second integer :: julian_day_number julian_day_number = julian_day ( y , m , d ) julian_date = real ( julian_day_number , wp ) + & ( hour - 1 2.0_wp ) / 2 4.0_wp + & minute / 144 0.0_wp + & second / 8640 0.0_wp end function julian_date_realsec","tags":"","url":"proc/julian_date_realsec.html"},{"title":"is_leap_year – fortran-astrodynamics-toolkit","text":"public pure function is_leap_year(y) Return true if the specified year is a leap year. Arguments Type Intent Optional Attributes Name integer, intent(in) :: y year Return Value logical Called by proc~~is_leap_year~~CalledByGraph proc~is_leap_year is_leap_year proc~calendar_date_to_et calendar_date_to_et proc~calendar_date_to_et->proc~is_leap_year proc~time_module_test time_module_test proc~time_module_test->proc~calendar_date_to_et Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure logical function is_leap_year ( y ) integer , intent ( in ) :: y !! year is_leap_year = ( mod ( y , 4 ) == 0 . and . ( mod ( y , 100 ) /= 0 . or . mod ( y , 400 ) == 0 )) end function is_leap_year","tags":"","url":"proc/is_leap_year.html"},{"title":"calendar_date_to_et – fortran-astrodynamics-toolkit","text":"public  function calendar_date_to_et(year, month, day, hour, minute, second) result(et) Uses conversion_module proc~~calendar_date_to_et~~UsesGraph proc~calendar_date_to_et calendar_date_to_et module~conversion_module conversion_module proc~calendar_date_to_et->module~conversion_module module~kind_module kind_module module~conversion_module->module~kind_module module~numbers_module numbers_module module~conversion_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Directly converts a calendar date to seconds since the J2000 epoch. Arguments Type Intent Optional Attributes Name integer, intent(in) :: year integer, intent(in) :: month integer, intent(in) :: day integer, intent(in) :: hour integer, intent(in) :: minute real(kind=wp), intent(in) :: second Return Value real(kind=wp) Calls proc~~calendar_date_to_et~~CallsGraph proc~calendar_date_to_et calendar_date_to_et proc~is_leap_year is_leap_year proc~calendar_date_to_et->proc~is_leap_year Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calendar_date_to_et~~CalledByGraph proc~calendar_date_to_et calendar_date_to_et proc~time_module_test time_module_test proc~time_module_test->proc~calendar_date_to_et Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function calendar_date_to_et ( year , month , day , hour , minute , second ) result ( et ) use conversion_module , only : hr2sec , min2sec , day2sec integer , intent ( in ) :: year , month , day , hour , minute real ( wp ), intent ( in ) :: second real ( wp ) :: et ! Constants for the J2000 epoch: January 1, 2000, 12:00:00 integer , parameter :: j2000_year = 2000 integer , parameter :: j2000_month = 1 integer , parameter :: j2000_day = 1 integer , parameter :: j2000_hour = 12 integer , parameter :: j2000_minute = 0 real ( wp ), parameter :: j2000_second = 0.0_wp ! Days in each month (non-leap year) integer , dimension ( 12 ), parameter :: days_in_month = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] integer :: y , m integer :: total_days ! first do time of day: et = real ( hour - j2000_hour , wp ) * hr2sec + & real ( minute - j2000_minute , wp ) * min2sec + & ( second - j2000_second ) ! now, calculate the total number of days from J2000 to the given date total_days = 0 do y = j2000_year , year - 1 total_days = total_days + 365 + merge ( 1 , 0 , is_leap_year ( y )) end do do m = 1 , month - 1 if ( m == 2 ) then total_days = total_days + days_in_month ( m ) + merge ( 1 , 0 , is_leap_year ( year )) else total_days = total_days + days_in_month ( m ) end if end do ! add days: et = et + real ( total_days + ( day - j2000_day ), wp ) * day2sec end function calendar_date_to_et","tags":"","url":"proc/calendar_date_to_et.html"},{"title":"calendar_date_realsec – fortran-astrodynamics-toolkit","text":"private pure subroutine calendar_date_realsec(julian_date, year, month, day, hrs, min, sec) Returns the year, month, day, hr, min, sec for the specified Julian date. See also https://aa.usno.navy.mil/faq/JD_formula.html http://www.davidgsimpson.com/software/jd2greg_f90.txt Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: julian_date julian date integer, intent(out) :: year integer, intent(out) :: month integer, intent(out) :: day integer, intent(out) :: hrs integer, intent(out) :: min real(kind=wp), intent(out) :: sec Called by proc~~calendar_date_realsec~~CalledByGraph proc~calendar_date_realsec calendar_date_realsec interface~julian_date_to_calendar_date julian_date_to_calendar_date interface~julian_date_to_calendar_date->proc~calendar_date_realsec proc~time_module_test time_module_test proc~time_module_test->proc~calendar_date_realsec Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine calendar_date_realsec ( julian_date , year , month , day , hrs , min , sec ) implicit none real ( wp ), intent ( in ) :: julian_date !! julian date integer , intent ( out ) :: year integer , intent ( out ) :: month integer , intent ( out ) :: day integer , intent ( out ) :: hrs integer , intent ( out ) :: min real ( wp ), intent ( out ) :: sec integer :: i , j , k , l , n , jd real ( wp ) :: frac_day jd = int ( julian_date ) l = jd + 68569 n = 4 * l / 146097 l = l - ( 146097 * n + 3 ) / 4 i = 4000 * ( l + 1 ) / 1461001 l = l - 1461 * i / 4 + 31 j = 80 * l / 2447 k = l - 2447 * j / 80 l = j / 11 j = j + 2 - 12 * l i = 100 * ( n - 49 ) + i + l year = i month = j day = k frac_day = julian_date - real ( jd , wp ) + 0.5_wp hrs = int ( frac_day * 2 4.0_wp ) min = int (( frac_day - hrs / 2 4.0_wp ) * 144 0.0_wp ) sec = ( frac_day - hrs / 2 4.0_wp - min / 144 0.0_wp ) * 8640 0.0_wp if ( sec == 6 0.0_wp ) then sec = 0.0_wp min = min + 1 end if if ( min == 60 ) then min = 0 hrs = hrs + 1 end if end subroutine calendar_date_realsec","tags":"","url":"proc/calendar_date_realsec.html"},{"title":"time_module_test – fortran-astrodynamics-toolkit","text":"public  subroutine time_module_test() Test routine for the Julian date routines. Arguments None Calls proc~~time_module_test~~CallsGraph proc~time_module_test time_module_test interface~julian_date julian_date proc~time_module_test->interface~julian_date proc~calendar_date_realsec calendar_date_realsec proc~time_module_test->proc~calendar_date_realsec proc~calendar_date_to_et calendar_date_to_et proc~time_module_test->proc~calendar_date_to_et proc~jd_to_et jd_to_et proc~time_module_test->proc~jd_to_et proc~julian_date_intsec julian_date_intsec interface~julian_date->proc~julian_date_intsec proc~julian_date_realsec julian_date_realsec interface~julian_date->proc~julian_date_realsec proc~is_leap_year is_leap_year proc~calendar_date_to_et->proc~is_leap_year proc~julian_date_intsec->proc~julian_date_realsec proc~julian_day julian_day proc~julian_date_realsec->proc~julian_day Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine time_module_test () implicit none real ( wp ) :: jd , sec integer :: year , month , day , hrs , min real ( wp ) :: et1 , et2 write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' time_module_test' write ( * , * ) '---------------' write ( * , * ) '' ! JD = 2451545.0 jd = julian_date ( 2000 , 1 , 1 , 12 , 0 , 0 ) call calendar_date_realsec ( jd , year , month , day , hrs , min , sec ) write ( * , * ) 'jd    ' , jd write ( * , * ) 'year  ' , year write ( * , * ) 'month ' , month write ( * , * ) 'day   ' , day write ( * , * ) 'hrs   ' , hrs write ( * , * ) 'min   ' , min write ( * , * ) 'sec   ' , sec if ( year /= 2000 ) error stop 'error: incorrect year' if ( month /= 1 ) error stop 'error: incorrect month' if ( day /= 1 ) error stop 'error: incorrect day' if ( hrs /= 12 ) error stop 'error: incorrect hrs' if ( min /= 0 ) error stop 'error: incorrect min' if ( sec /= 0.0_wp ) error stop 'error: incorrect sec' ! compare two ways to convert calendar date to ephemeris time: ! et1 should be more accurate since it doesn't go through jd write ( * , * ) '' et1 = calendar_date_to_et ( 2026 , 3 , 4 , 8 , 9 , 1 0.12345678_wp ) et2 = jd_to_et ( julian_date ( 2026 , 3 , 4 , 8 , 9 , 1 0.12345678_wp )) write ( * , * ) 'et1   ' , et1 write ( * , * ) 'et2   ' , et2 write ( * , * ) 'et diff: ' , abs ( et1 - et2 ) write ( * , * ) '' write ( * , * ) 'PASSED' end subroutine time_module_test","tags":"","url":"proc/time_module_test.html"},{"title":"julian_date – fortran-astrodynamics-toolkit","text":"public interface julian_date calendar date to julian date Calls interface~~julian_date~~CallsGraph interface~julian_date julian_date proc~julian_date_intsec julian_date_intsec interface~julian_date->proc~julian_date_intsec proc~julian_date_realsec julian_date_realsec interface~julian_date->proc~julian_date_realsec proc~julian_date_intsec->proc~julian_date_realsec proc~julian_day julian_day proc~julian_date_realsec->proc~julian_day Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~julian_date~~CalledByGraph interface~julian_date julian_date proc~time_module_test time_module_test proc~time_module_test->interface~julian_date Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure function julian_date_realsec (y, m, d, hour, minute, second) result(julian_date) Author Jacob Williams Date 1/21/2015 Returns the Julian date for the specified YEAR, MONTH, DAY, HR, MIN, SEC. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: y integer, intent(in) :: m integer, intent(in) :: d integer, intent(in) :: hour integer, intent(in) :: minute real(kind=wp), intent(in) :: second Return Value real(kind=wp) private pure function julian_date_intsec (y, m, d, hour, minute, second) result(julian_date) Author Jacob Williams Date 1/21/2015 Returns the Julian date for the specified YEAR, MONTH, DAY, HR, MIN, SEC. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: y integer, intent(in) :: m integer, intent(in) :: d integer, intent(in) :: hour integer, intent(in) :: minute integer, intent(in) :: second Return Value real(kind=wp)","tags":"","url":"interface/julian_date.html"},{"title":"julian_date_to_calendar_date – fortran-astrodynamics-toolkit","text":"public interface julian_date_to_calendar_date Calls interface~~julian_date_to_calendar_date~~CallsGraph interface~julian_date_to_calendar_date julian_date_to_calendar_date proc~calendar_date_realsec calendar_date_realsec interface~julian_date_to_calendar_date->proc~calendar_date_realsec Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private pure subroutine calendar_date_realsec (julian_date, year, month, day, hrs, min, sec) Author Jacob Williams Returns the year, month, day, hr, min, sec for the specified Julian date. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: julian_date julian date integer, intent(out) :: year integer, intent(out) :: month integer, intent(out) :: day integer, intent(out) :: hrs integer, intent(out) :: min real(kind=wp), intent(out) :: sec","tags":"","url":"interface/julian_date_to_calendar_date.html"},{"title":"cw_equations – fortran-astrodynamics-toolkit","text":"public  function cw_equations(x0, dt, n) result(x) Clohessy-Wiltshire equations for relative motion. These apply to an RSW frame centered at the target spacecraft. References The Clohessy Wiltshire Model Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: x0 initial state [r,v] of chaser (at t0) [km, km/s] real(kind=wp), intent(in) :: dt elapsed time from t0 [sec] real(kind=wp), intent(in) :: n mean motion of target orbit ( sqrt(mu/a**3) ) [1/sec] Return Value real(kind=wp), dimension(6) final state [r,v] of chaser [km, km/s] Called by proc~~cw_equations~~CalledByGraph proc~cw_equations cw_equations proc~cw_propagator cw_propagator proc~cw_propagator->proc~cw_equations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function cw_equations ( x0 , dt , n ) result ( x ) implicit none real ( wp ), dimension ( 6 ), intent ( in ) :: x0 !! initial state [r,v] of chaser (at t0) [km, km/s] real ( wp ), intent ( in ) :: dt !! elapsed time from t0 [sec] real ( wp ), intent ( in ) :: n !! mean motion of target orbit (`sqrt(mu/a**3)`) [1/sec] real ( wp ), dimension ( 6 ) :: x !! final state [r,v] of chaser [km, km/s] real ( wp ) :: nt , cnt , snt if ( dt == zero ) then x = x0 else if ( n == zero ) then error stop 'Error: Target orbit mean motion must be non-zero.' else nt = n * dt cnt = cos ( nt ) snt = sin ( nt ) x ( 1 ) = ( four - three * cnt ) * x0 ( 1 ) + ( snt / n ) * x0 ( 4 ) + ( two / n ) * ( one - cnt ) * x0 ( 5 ) x ( 2 ) = six * ( snt - nt ) * x0 ( 1 ) + x0 ( 2 ) - ( two / n ) * ( one - cnt ) * x0 ( 4 ) + one / n * ( four * snt - three * nt ) * x0 ( 5 ) x ( 3 ) = cnt * x0 ( 3 ) + ( snt / n ) * x0 ( 6 ) x ( 4 ) = three * n * snt * x0 ( 1 ) + cnt * x0 ( 4 ) + two * snt * x0 ( 5 ) x ( 5 ) = - ( six * n * ( one - cnt )) * x0 ( 1 ) - two * snt * x0 ( 4 ) + ( four * cnt - three ) * x0 ( 5 ) x ( 6 ) = - n * snt * x0 ( 3 ) + cnt * x0 ( 6 ) end if end if end function cw_equations","tags":"","url":"proc/cw_equations.html"},{"title":"cw_propagator – fortran-astrodynamics-toolkit","text":"public  subroutine cw_propagator(t0, x0, h, n, tf, xf, report) Clohessy-Wiltshire propagation routine. See also rk_module Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t0 initialize time [sec] real(kind=wp), intent(in), dimension(6) :: x0 initial state in RST coordinates [km,km/s] real(kind=wp), intent(in) :: h abs(time step) [sec] real(kind=wp), intent(in) :: n mean motion of target orbit ( sqrt(mu/a**3) ) [1/sec] real(kind=wp), intent(in) :: tf final time [sec] real(kind=wp), intent(out), dimension(6) :: xf final state in RST coordinates [km,km/s] procedure( report_func ), optional :: report to report each point Calls proc~~cw_propagator~~CallsGraph proc~cw_propagator cw_propagator proc~cw_equations cw_equations proc~cw_propagator->proc~cw_equations Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine cw_propagator ( t0 , x0 , h , n , tf , xf , report ) implicit none real ( wp ), intent ( in ) :: t0 !! initialize time [sec] real ( wp ), dimension ( 6 ), intent ( in ) :: x0 !! initial state in RST coordinates [km,km/s] real ( wp ), intent ( in ) :: h !! abs(time step) [sec] real ( wp ), intent ( in ) :: n !! mean motion of target orbit (`sqrt(mu/a**3)`) [1/sec] real ( wp ), intent ( in ) :: tf !! final time [sec] real ( wp ), dimension ( 6 ), intent ( out ) :: xf !! final state in RST coordinates [km,km/s] procedure ( report_func ), optional :: report !! to report each point real ( wp ) :: t , dt , t2 real ( wp ), dimension ( 6 ) :: x logical :: last , export export = present ( report ) if ( export ) call report ( t0 , x0 ) !first point if ( h == zero ) then xf = x0 else t = t0 x = x0 dt = sign ( h , tf - t0 ) !time step  (correct sign) do t2 = t + dt last = (( dt >= zero . and . t2 >= tf ) . or . & !adjust last time step ( dt < zero . and . t2 <= tf )) ! if ( last ) dt = tf - t ! xf = cw_equations ( x , dt , n ) ! propagate if ( last ) exit if ( export ) call report ( t2 , xf ) !intermediate point x = xf t = t2 end do end if if ( export ) call report ( tf , xf ) !last point end subroutine cw_propagator","tags":"","url":"proc/cw_propagator.html"},{"title":"from_ijk_to_frame_rv – fortran-astrodynamics-toolkit","text":"private  subroutine from_ijk_to_frame_rv(mu, from_ijk_to_frame, rt_ijk, vt_ijk, r_ijk, v_ijk, dr_frame, dv_frame) Transform a position (and optionally velocity) vector from IJK to a specified relative frame. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] procedure( frame_transform_func ) :: from_ijk_to_frame function to compute the transformation matrices real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: v_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), dimension(3) :: dr_frame Chaser frame position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_frame Chaser frame position vector relative to target [km] Called by proc~~from_ijk_to_frame_rv~~CalledByGraph proc~from_ijk_to_frame_rv from_ijk_to_frame_rv proc~from_ijk_to_lvlh_rv from_ijk_to_lvlh_rv proc~from_ijk_to_lvlh_rv->proc~from_ijk_to_frame_rv proc~from_ijk_to_rsw_rv from_ijk_to_rsw_rv proc~from_ijk_to_rsw_rv->proc~from_ijk_to_frame_rv proc~from_ijk_to_vuw_rv from_ijk_to_vuw_rv proc~from_ijk_to_vuw_rv->proc~from_ijk_to_frame_rv interface~from_ijk_to_lvlh from_ijk_to_lvlh interface~from_ijk_to_lvlh->proc~from_ijk_to_lvlh_rv interface~from_ijk_to_rsw from_ijk_to_rsw interface~from_ijk_to_rsw->proc~from_ijk_to_rsw_rv interface~from_ijk_to_vuw from_ijk_to_vuw interface~from_ijk_to_vuw->proc~from_ijk_to_vuw_rv proc~from_lvlh_to_ijk_mat from_lvlh_to_ijk_mat proc~from_lvlh_to_ijk_mat->interface~from_ijk_to_lvlh proc~from_rsw_to_ijk_mat from_rsw_to_ijk_mat proc~from_rsw_to_ijk_mat->interface~from_ijk_to_rsw proc~from_vuw_to_ijk_mat from_vuw_to_ijk_mat proc~from_vuw_to_ijk_mat->interface~from_ijk_to_vuw proc~relative_motion_test relative_motion_test proc~relative_motion_test->interface~from_ijk_to_lvlh proc~relative_motion_test->interface~from_ijk_to_rsw interface~from_lvlh_to_ijk from_lvlh_to_ijk interface~from_lvlh_to_ijk->proc~from_lvlh_to_ijk_mat interface~from_rsw_to_ijk from_rsw_to_ijk interface~from_rsw_to_ijk->proc~from_rsw_to_ijk_mat interface~from_vuw_to_ijk from_vuw_to_ijk interface~from_vuw_to_ijk->proc~from_vuw_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_ijk_to_frame_rv ( mu , from_ijk_to_frame , rt_ijk , vt_ijk , r_ijk , v_ijk , dr_frame , dv_frame ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] procedure ( frame_transform_func ) :: from_ijk_to_frame !! function to compute the transformation matrices real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ) :: dr_frame !! Chaser frame position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: dv_frame !! Chaser frame position vector relative to target [km] real ( wp ), dimension ( 3 , 3 ) :: c real ( wp ), dimension ( 3 , 3 ) :: cdot real ( wp ), dimension ( 3 ) :: dr_ijk , dv_ijk !IJK state of chaser relative to target: dr_ijk = r_ijk - rt_ijk ! [target + delta = chaser] if ( present ( dv_frame )) then dv_ijk = v_ijk - vt_ijk ! [target + delta = chaser] call from_ijk_to_frame ( mu , rt_ijk , vt_ijk , c = c , cdot = cdot ) dr_frame = matmul ( c , dr_ijk ) dv_frame = matmul ( cdot , dr_ijk ) + matmul ( c , dv_ijk ) else call from_ijk_to_frame ( mu , r_ijk , v_ijk , c = c ) dr_frame = matmul ( c , dr_ijk ) end if end subroutine from_ijk_to_frame_rv","tags":"","url":"proc/from_ijk_to_frame_rv.html"},{"title":"from_frame_to_ijk_rv – fortran-astrodynamics-toolkit","text":"private  subroutine from_frame_to_ijk_rv(mu, from_frame_to_ijk, rt_ijk, vt_ijk, dr_frame, dv_frame, r_ijk, v_ijk) Transform a position (and optionally velocity) vector from a specified relative frame to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] procedure( frame_transform_func ) :: from_frame_to_ijk function to compute the transformation matrices real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: dr_frame Chaser frame position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_frame Chaser frame position vector relative to target [km] real(kind=wp), intent(out), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), optional, dimension(3) :: v_ijk Chaser IJK absolute position vector [km] Called by proc~~from_frame_to_ijk_rv~~CalledByGraph proc~from_frame_to_ijk_rv from_frame_to_ijk_rv proc~from_lvlh_to_ijk_rv from_lvlh_to_ijk_rv proc~from_lvlh_to_ijk_rv->proc~from_frame_to_ijk_rv proc~from_rsw_to_ijk_rv from_rsw_to_ijk_rv proc~from_rsw_to_ijk_rv->proc~from_frame_to_ijk_rv proc~from_vuw_to_ijk_rv from_vuw_to_ijk_rv proc~from_vuw_to_ijk_rv->proc~from_frame_to_ijk_rv interface~from_lvlh_to_ijk from_lvlh_to_ijk interface~from_lvlh_to_ijk->proc~from_lvlh_to_ijk_rv interface~from_rsw_to_ijk from_rsw_to_ijk interface~from_rsw_to_ijk->proc~from_rsw_to_ijk_rv interface~from_vuw_to_ijk from_vuw_to_ijk interface~from_vuw_to_ijk->proc~from_vuw_to_ijk_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_frame_to_ijk_rv ( mu , from_frame_to_ijk , rt_ijk , vt_ijk , dr_frame , dv_frame , r_ijk , v_ijk ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] procedure ( frame_transform_func ) :: from_frame_to_ijk !! function to compute the transformation matrices real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dr_frame !! Chaser frame position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dv_frame !! Chaser frame position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: v_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 , 3 ) :: c real ( wp ), dimension ( 3 , 3 ) :: cdot if ( present ( v_ijk )) then call from_frame_to_ijk ( mu , rt_ijk , vt_ijk , c = c , cdot = cdot ) !chaser = target + delta: r_ijk = rt_ijk + matmul ( c , dr_frame ) v_ijk = vt_ijk + matmul ( cdot , dr_frame ) + matmul ( c , dv_frame ) else call from_frame_to_ijk ( mu , rt_ijk , vt_ijk , c = c ) r_ijk = rt_ijk + matmul ( c , dr_frame ) end if end subroutine from_frame_to_ijk_rv","tags":"","url":"proc/from_frame_to_ijk_rv.html"},{"title":"from_ijk_to_lvlh_mat – fortran-astrodynamics-toolkit","text":"private  subroutine from_ijk_to_lvlh_mat(mu, r, v, a, c, cdot) Uses vector_module proc~~from_ijk_to_lvlh_mat~~UsesGraph proc~from_ijk_to_lvlh_mat from_ijk_to_lvlh_mat module~vector_module vector_module proc~from_ijk_to_lvlh_mat->module~vector_module module~kind_module kind_module module~vector_module->module~kind_module module~numbers_module numbers_module module~vector_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Compute the transformation matrices to convert IJK to LVLH. See also LVLH Transformations Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix Calls proc~~from_ijk_to_lvlh_mat~~CallsGraph proc~from_ijk_to_lvlh_mat from_ijk_to_lvlh_mat proc~cross cross proc~from_ijk_to_lvlh_mat->proc~cross proc~uhat_dot uhat_dot proc~from_ijk_to_lvlh_mat->proc~uhat_dot proc~unit unit proc~from_ijk_to_lvlh_mat->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~from_ijk_to_lvlh_mat~~CalledByGraph proc~from_ijk_to_lvlh_mat from_ijk_to_lvlh_mat interface~from_ijk_to_lvlh from_ijk_to_lvlh interface~from_ijk_to_lvlh->proc~from_ijk_to_lvlh_mat proc~from_lvlh_to_ijk_mat from_lvlh_to_ijk_mat proc~from_lvlh_to_ijk_mat->interface~from_ijk_to_lvlh proc~relative_motion_test relative_motion_test proc~relative_motion_test->interface~from_ijk_to_lvlh interface~from_lvlh_to_ijk from_lvlh_to_ijk interface~from_lvlh_to_ijk->proc~from_lvlh_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_ijk_to_lvlh_mat ( mu , r , v , a , c , cdot ) use vector_module , only : unit , cross , uhat_dot implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector of target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector of target [km/s] real ( wp ), dimension ( 3 ), intent ( in ), optional :: a !! acceleration vector of target [km/s&#94;2] !! (if not present, then a torque-free force model is assumed) real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c !! C transformation matrix real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot !! CDOT transformation matrix real ( wp ), dimension ( 3 ) :: ex_hat , ex_hat_dot real ( wp ), dimension ( 3 ) :: ey_hat , ey_hat_dot real ( wp ), dimension ( 3 ) :: ez_hat , ez_hat_dot real ( wp ), dimension ( 3 ) :: h , h_hat , h_dot h = cross ( r , v ) h_hat = unit ( h ) ez_hat = - unit ( r ) ey_hat = - h_hat ex_hat = cross ( ey_hat , ez_hat ) c ( 1 ,:) = ex_hat c ( 2 ,:) = ey_hat c ( 3 ,:) = ez_hat if ( present ( cdot )) then ez_hat_dot = - uhat_dot ( r , v ) if ( present ( a )) then h_dot = cross ( r , a ) ey_hat_dot = - uhat_dot ( h , h_dot ) ex_hat_dot = cross ( ey_hat_dot , ez_hat ) + cross ( ey_hat , ez_hat_dot ) else !assume no external torque ey_hat_dot = zero ex_hat_dot = cross ( ey_hat , ez_hat_dot ) end if cdot ( 1 ,:) = ex_hat_dot cdot ( 2 ,:) = ey_hat_dot cdot ( 3 ,:) = ez_hat_dot end if end subroutine from_ijk_to_lvlh_mat","tags":"","url":"proc/from_ijk_to_lvlh_mat.html"},{"title":"from_ijk_to_lvlh_rv – fortran-astrodynamics-toolkit","text":"private  subroutine from_ijk_to_lvlh_rv(mu, rt_ijk, vt_ijk, r_ijk, v_ijk, dr_lvlh, dv_lvlh) Transform a position (and optionally velocity) vector from IJK to LVLH. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: v_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km] Calls proc~~from_ijk_to_lvlh_rv~~CallsGraph proc~from_ijk_to_lvlh_rv from_ijk_to_lvlh_rv proc~from_ijk_to_frame_rv from_ijk_to_frame_rv proc~from_ijk_to_lvlh_rv->proc~from_ijk_to_frame_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~from_ijk_to_lvlh_rv~~CalledByGraph proc~from_ijk_to_lvlh_rv from_ijk_to_lvlh_rv interface~from_ijk_to_lvlh from_ijk_to_lvlh interface~from_ijk_to_lvlh->proc~from_ijk_to_lvlh_rv proc~from_lvlh_to_ijk_mat from_lvlh_to_ijk_mat proc~from_lvlh_to_ijk_mat->interface~from_ijk_to_lvlh proc~relative_motion_test relative_motion_test proc~relative_motion_test->interface~from_ijk_to_lvlh interface~from_lvlh_to_ijk from_lvlh_to_ijk interface~from_lvlh_to_ijk->proc~from_lvlh_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_ijk_to_lvlh_rv ( mu , rt_ijk , vt_ijk , r_ijk , v_ijk , dr_lvlh , dv_lvlh ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ) :: dr_lvlh !! Chaser LVLH position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: dv_lvlh !! Chaser LVLH position vector relative to target [km] call from_ijk_to_frame_rv ( mu , from_ijk_to_lvlh_mat , rt_ijk , vt_ijk , r_ijk , v_ijk , dr_lvlh , dv_lvlh ) end subroutine from_ijk_to_lvlh_rv","tags":"","url":"proc/from_ijk_to_lvlh_rv.html"},{"title":"from_lvlh_to_ijk_mat – fortran-astrodynamics-toolkit","text":"private  subroutine from_lvlh_to_ijk_mat(mu, r, v, a, c, cdot) Uses vector_module proc~~from_lvlh_to_ijk_mat~~UsesGraph proc~from_lvlh_to_ijk_mat from_lvlh_to_ijk_mat module~vector_module vector_module proc~from_lvlh_to_ijk_mat->module~vector_module module~kind_module kind_module module~vector_module->module~kind_module module~numbers_module numbers_module module~vector_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Compute the transformation matrices to convert LVLH to IJK. See also LVLH Transformations Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix Calls proc~~from_lvlh_to_ijk_mat~~CallsGraph proc~from_lvlh_to_ijk_mat from_lvlh_to_ijk_mat interface~from_ijk_to_lvlh from_ijk_to_lvlh proc~from_lvlh_to_ijk_mat->interface~from_ijk_to_lvlh proc~from_ijk_to_lvlh_mat from_ijk_to_lvlh_mat interface~from_ijk_to_lvlh->proc~from_ijk_to_lvlh_mat proc~from_ijk_to_lvlh_rv from_ijk_to_lvlh_rv interface~from_ijk_to_lvlh->proc~from_ijk_to_lvlh_rv proc~cross cross proc~from_ijk_to_lvlh_mat->proc~cross proc~uhat_dot uhat_dot proc~from_ijk_to_lvlh_mat->proc~uhat_dot proc~unit unit proc~from_ijk_to_lvlh_mat->proc~unit proc~from_ijk_to_frame_rv from_ijk_to_frame_rv proc~from_ijk_to_lvlh_rv->proc~from_ijk_to_frame_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~from_lvlh_to_ijk_mat~~CalledByGraph proc~from_lvlh_to_ijk_mat from_lvlh_to_ijk_mat interface~from_lvlh_to_ijk from_lvlh_to_ijk interface~from_lvlh_to_ijk->proc~from_lvlh_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_lvlh_to_ijk_mat ( mu , r , v , a , c , cdot ) use vector_module , only : unit , cross implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector of target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector of target [km/s] real ( wp ), dimension ( 3 ), intent ( in ), optional :: a !! acceleration vector of target [km/s&#94;2] !! (if not present, then a torque-free force model is assumed) real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c !! C transformation matrix real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot !! CDOT transformation matrix call from_ijk_to_lvlh ( mu , r , v , a , c , cdot ) c = transpose ( c ) if ( present ( cdot )) cdot = transpose ( cdot ) end subroutine from_lvlh_to_ijk_mat","tags":"","url":"proc/from_lvlh_to_ijk_mat.html"},{"title":"from_lvlh_to_ijk_rv – fortran-astrodynamics-toolkit","text":"private  subroutine from_lvlh_to_ijk_rv(mu, rt_ijk, vt_ijk, dr_lvlh, dv_lvlh, r_ijk, v_ijk) Transform a position (and optionally velocity) vector from LVLH to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), optional, dimension(3) :: v_ijk Chaser IJK absolute position vector [km] Calls proc~~from_lvlh_to_ijk_rv~~CallsGraph proc~from_lvlh_to_ijk_rv from_lvlh_to_ijk_rv proc~from_frame_to_ijk_rv from_frame_to_ijk_rv proc~from_lvlh_to_ijk_rv->proc~from_frame_to_ijk_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~from_lvlh_to_ijk_rv~~CalledByGraph proc~from_lvlh_to_ijk_rv from_lvlh_to_ijk_rv interface~from_lvlh_to_ijk from_lvlh_to_ijk interface~from_lvlh_to_ijk->proc~from_lvlh_to_ijk_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_lvlh_to_ijk_rv ( mu , rt_ijk , vt_ijk , dr_lvlh , dv_lvlh , r_ijk , v_ijk ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dr_lvlh !! Chaser LVLH position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dv_lvlh !! Chaser LVLH position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: v_ijk !! Chaser IJK absolute position vector [km] call from_frame_to_ijk_rv ( mu , from_lvlh_to_ijk_mat , rt_ijk , vt_ijk , dr_lvlh , dv_lvlh , r_ijk , v_ijk ) end subroutine from_lvlh_to_ijk_rv","tags":"","url":"proc/from_lvlh_to_ijk_rv.html"},{"title":"from_ijk_to_vuw_mat – fortran-astrodynamics-toolkit","text":"private  subroutine from_ijk_to_vuw_mat(mu, r, v, a, c, cdot) Uses vector_module proc~~from_ijk_to_vuw_mat~~UsesGraph proc~from_ijk_to_vuw_mat from_ijk_to_vuw_mat module~vector_module vector_module proc~from_ijk_to_vuw_mat->module~vector_module module~kind_module kind_module module~vector_module->module~kind_module module~numbers_module numbers_module module~vector_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Compute the transformation matrices to convert IJK to vuw. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2]\nthis is used here to assume instantaneous conic motion if a is not present. real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix Calls proc~~from_ijk_to_vuw_mat~~CallsGraph proc~from_ijk_to_vuw_mat from_ijk_to_vuw_mat proc~cross cross proc~from_ijk_to_vuw_mat->proc~cross proc~uhat_dot uhat_dot proc~from_ijk_to_vuw_mat->proc~uhat_dot proc~unit unit proc~from_ijk_to_vuw_mat->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~from_ijk_to_vuw_mat~~CalledByGraph proc~from_ijk_to_vuw_mat from_ijk_to_vuw_mat interface~from_ijk_to_vuw from_ijk_to_vuw interface~from_ijk_to_vuw->proc~from_ijk_to_vuw_mat proc~from_vuw_to_ijk_mat from_vuw_to_ijk_mat proc~from_vuw_to_ijk_mat->interface~from_ijk_to_vuw interface~from_vuw_to_ijk from_vuw_to_ijk interface~from_vuw_to_ijk->proc~from_vuw_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_ijk_to_vuw_mat ( mu , r , v , a , c , cdot ) use vector_module , only : unit , cross , uhat_dot implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] !! this is used here to assume instantaneous conic motion if `a` is not present. real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector of target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector of target [km/s] real ( wp ), dimension ( 3 ), intent ( in ), optional :: a !! acceleration vector of target [km/s&#94;2] !! (if not present, then a torque-free force model is assumed) real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c !! C transformation matrix real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot !! CDOT transformation matrix real ( wp ), dimension ( 3 ) :: ex_hat , ex_hat_dot real ( wp ), dimension ( 3 ) :: ey_hat , ey_hat_dot real ( wp ), dimension ( 3 ) :: ez_hat , ez_hat_dot real ( wp ), dimension ( 3 ) :: h , h_hat , h_dot , v_hat , a_conic real ( wp ) :: rmag !! position vector magniude h = cross ( r , v ) h_hat = unit ( h ) v_hat = unit ( v ) ex_hat = v_hat ez_hat = h_hat ey_hat = cross ( ez_hat , ex_hat ) c ( 1 ,:) = ex_hat c ( 2 ,:) = ey_hat c ( 3 ,:) = ez_hat if ( present ( cdot )) then if ( present ( a )) then ex_hat_dot = uhat_dot ( v , a ) h_dot = cross ( r , a ) else rmag = norm2 ( r ) ! is this as simple as we can make this? ! here we assume instantaneous conic motion a_conic = - mu / rmag ** 3 * r ! accceleration for conic motion ex_hat_dot = uhat_dot ( v , a_conic ) h_dot = zero end if ez_hat_dot = uhat_dot ( h , h_dot ) ey_hat_dot = cross ( ez_hat_dot , ex_hat ) + cross ( ez_hat , ex_hat_dot ) cdot ( 1 ,:) = ex_hat_dot cdot ( 2 ,:) = ey_hat_dot cdot ( 3 ,:) = ez_hat_dot end if end subroutine from_ijk_to_vuw_mat","tags":"","url":"proc/from_ijk_to_vuw_mat.html"},{"title":"from_ijk_to_vuw_rv – fortran-astrodynamics-toolkit","text":"private  subroutine from_ijk_to_vuw_rv(mu, rt_ijk, vt_ijk, r_ijk, v_ijk, dr_vuw, dv_vuw) Transform a position (and optionally velocity) vector from IJK to VUW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: v_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), dimension(3) :: dr_vuw Chaser vuw position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_vuw Chaser vuw position vector relative to target [km] Calls proc~~from_ijk_to_vuw_rv~~CallsGraph proc~from_ijk_to_vuw_rv from_ijk_to_vuw_rv proc~from_ijk_to_frame_rv from_ijk_to_frame_rv proc~from_ijk_to_vuw_rv->proc~from_ijk_to_frame_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~from_ijk_to_vuw_rv~~CalledByGraph proc~from_ijk_to_vuw_rv from_ijk_to_vuw_rv interface~from_ijk_to_vuw from_ijk_to_vuw interface~from_ijk_to_vuw->proc~from_ijk_to_vuw_rv proc~from_vuw_to_ijk_mat from_vuw_to_ijk_mat proc~from_vuw_to_ijk_mat->interface~from_ijk_to_vuw interface~from_vuw_to_ijk from_vuw_to_ijk interface~from_vuw_to_ijk->proc~from_vuw_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_ijk_to_vuw_rv ( mu , rt_ijk , vt_ijk , r_ijk , v_ijk , dr_vuw , dv_vuw ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ) :: dr_vuw !! Chaser vuw position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: dv_vuw !! Chaser vuw position vector relative to target [km] call from_ijk_to_frame_rv ( mu , from_ijk_to_vuw_mat , rt_ijk , vt_ijk , r_ijk , v_ijk , dr_vuw , dv_vuw ) end subroutine from_ijk_to_vuw_rv","tags":"","url":"proc/from_ijk_to_vuw_rv.html"},{"title":"from_vuw_to_ijk_mat – fortran-astrodynamics-toolkit","text":"private  subroutine from_vuw_to_ijk_mat(mu, r, v, a, c, cdot) Uses vector_module proc~~from_vuw_to_ijk_mat~~UsesGraph proc~from_vuw_to_ijk_mat from_vuw_to_ijk_mat module~vector_module vector_module proc~from_vuw_to_ijk_mat->module~vector_module module~kind_module kind_module module~vector_module->module~kind_module module~numbers_module numbers_module module~vector_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Compute the transformation matrices to convert VUW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix Calls proc~~from_vuw_to_ijk_mat~~CallsGraph proc~from_vuw_to_ijk_mat from_vuw_to_ijk_mat interface~from_ijk_to_vuw from_ijk_to_vuw proc~from_vuw_to_ijk_mat->interface~from_ijk_to_vuw proc~from_ijk_to_vuw_mat from_ijk_to_vuw_mat interface~from_ijk_to_vuw->proc~from_ijk_to_vuw_mat proc~from_ijk_to_vuw_rv from_ijk_to_vuw_rv interface~from_ijk_to_vuw->proc~from_ijk_to_vuw_rv proc~cross cross proc~from_ijk_to_vuw_mat->proc~cross proc~uhat_dot uhat_dot proc~from_ijk_to_vuw_mat->proc~uhat_dot proc~unit unit proc~from_ijk_to_vuw_mat->proc~unit proc~from_ijk_to_frame_rv from_ijk_to_frame_rv proc~from_ijk_to_vuw_rv->proc~from_ijk_to_frame_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~from_vuw_to_ijk_mat~~CalledByGraph proc~from_vuw_to_ijk_mat from_vuw_to_ijk_mat interface~from_vuw_to_ijk from_vuw_to_ijk interface~from_vuw_to_ijk->proc~from_vuw_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_vuw_to_ijk_mat ( mu , r , v , a , c , cdot ) use vector_module , only : unit , cross implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector of target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector of target [km/s] real ( wp ), dimension ( 3 ), intent ( in ), optional :: a !! acceleration vector of target [km/s&#94;2] !! (if not present, then a torque-free force model is assumed) real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c !! C transformation matrix real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot !! CDOT transformation matrix call from_ijk_to_vuw ( mu , r , v , a , c , cdot ) c = transpose ( c ) if ( present ( cdot )) cdot = transpose ( cdot ) end subroutine from_vuw_to_ijk_mat","tags":"","url":"proc/from_vuw_to_ijk_mat.html"},{"title":"from_vuw_to_ijk_rv – fortran-astrodynamics-toolkit","text":"private  subroutine from_vuw_to_ijk_rv(mu, rt_ijk, vt_ijk, dr_vuw, dv_vuw, r_ijk, v_ijk) Transform a position (and optionally velocity) vector from VUW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: dr_vuw Chaser vuw position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_vuw Chaser vuw position vector relative to target [km] real(kind=wp), intent(out), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), optional, dimension(3) :: v_ijk Chaser IJK absolute position vector [km] Calls proc~~from_vuw_to_ijk_rv~~CallsGraph proc~from_vuw_to_ijk_rv from_vuw_to_ijk_rv proc~from_frame_to_ijk_rv from_frame_to_ijk_rv proc~from_vuw_to_ijk_rv->proc~from_frame_to_ijk_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~from_vuw_to_ijk_rv~~CalledByGraph proc~from_vuw_to_ijk_rv from_vuw_to_ijk_rv interface~from_vuw_to_ijk from_vuw_to_ijk interface~from_vuw_to_ijk->proc~from_vuw_to_ijk_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_vuw_to_ijk_rv ( mu , rt_ijk , vt_ijk , dr_vuw , dv_vuw , r_ijk , v_ijk ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dr_vuw !! Chaser vuw position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dv_vuw !! Chaser vuw position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: v_ijk !! Chaser IJK absolute position vector [km] call from_frame_to_ijk_rv ( mu , from_vuw_to_ijk_mat , rt_ijk , vt_ijk , dr_vuw , dv_vuw , r_ijk , v_ijk ) end subroutine from_vuw_to_ijk_rv","tags":"","url":"proc/from_vuw_to_ijk_rv.html"},{"title":"from_ijk_to_rsw_mat – fortran-astrodynamics-toolkit","text":"private  subroutine from_ijk_to_rsw_mat(mu, r, v, a, c, cdot) Uses vector_module proc~~from_ijk_to_rsw_mat~~UsesGraph proc~from_ijk_to_rsw_mat from_ijk_to_rsw_mat module~vector_module vector_module proc~from_ijk_to_rsw_mat->module~vector_module module~kind_module kind_module module~vector_module->module~kind_module module~numbers_module numbers_module module~vector_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Compute the transformation matrices to convert IJK to RSW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix Calls proc~~from_ijk_to_rsw_mat~~CallsGraph proc~from_ijk_to_rsw_mat from_ijk_to_rsw_mat proc~cross cross proc~from_ijk_to_rsw_mat->proc~cross proc~uhat_dot uhat_dot proc~from_ijk_to_rsw_mat->proc~uhat_dot proc~unit unit proc~from_ijk_to_rsw_mat->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~from_ijk_to_rsw_mat~~CalledByGraph proc~from_ijk_to_rsw_mat from_ijk_to_rsw_mat interface~from_ijk_to_rsw from_ijk_to_rsw interface~from_ijk_to_rsw->proc~from_ijk_to_rsw_mat proc~from_rsw_to_ijk_mat from_rsw_to_ijk_mat proc~from_rsw_to_ijk_mat->interface~from_ijk_to_rsw proc~relative_motion_test relative_motion_test proc~relative_motion_test->interface~from_ijk_to_rsw interface~from_rsw_to_ijk from_rsw_to_ijk interface~from_rsw_to_ijk->proc~from_rsw_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_ijk_to_rsw_mat ( mu , r , v , a , c , cdot ) use vector_module , only : unit , cross , uhat_dot implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector of target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector of target [km/s] real ( wp ), dimension ( 3 ), intent ( in ), optional :: a !! acceleration vector of target [km/s&#94;2] !! (if not present, then a torque-free force model is assumed) real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c !! C transformation matrix real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot !! CDOT transformation matrix real ( wp ), dimension ( 3 ) :: ex_hat , ex_hat_dot real ( wp ), dimension ( 3 ) :: ey_hat , ey_hat_dot real ( wp ), dimension ( 3 ) :: ez_hat , ez_hat_dot real ( wp ), dimension ( 3 ) :: h , h_hat , h_dot h = cross ( r , v ) h_hat = unit ( h ) ex_hat = unit ( r ) ez_hat = h_hat ey_hat = cross ( ez_hat , ex_hat ) c ( 1 ,:) = ex_hat c ( 2 ,:) = ey_hat c ( 3 ,:) = ez_hat if ( present ( cdot )) then ex_hat_dot = uhat_dot ( r , v ) if ( present ( a )) then h_dot = cross ( r , a ) ez_hat_dot = uhat_dot ( h , h_dot ) ey_hat_dot = cross ( ez_hat_dot , ex_hat ) + cross ( ez_hat , ex_hat_dot ) else !assume no external torque ez_hat_dot = zero ey_hat_dot = cross ( ez_hat , ex_hat_dot ) end if cdot ( 1 ,:) = ex_hat_dot cdot ( 2 ,:) = ey_hat_dot cdot ( 3 ,:) = ez_hat_dot end if end subroutine from_ijk_to_rsw_mat","tags":"","url":"proc/from_ijk_to_rsw_mat.html"},{"title":"from_ijk_to_rsw_rv – fortran-astrodynamics-toolkit","text":"private  subroutine from_ijk_to_rsw_rv(mu, rt_ijk, vt_ijk, r_ijk, v_ijk, dr_rsw, dv_rsw) Transform a position (and optionally velocity) vector from IJK to RSW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: v_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), dimension(3) :: dr_rsw Chaser RSW position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_rsw Chaser RSW position vector relative to target [km] Calls proc~~from_ijk_to_rsw_rv~~CallsGraph proc~from_ijk_to_rsw_rv from_ijk_to_rsw_rv proc~from_ijk_to_frame_rv from_ijk_to_frame_rv proc~from_ijk_to_rsw_rv->proc~from_ijk_to_frame_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~from_ijk_to_rsw_rv~~CalledByGraph proc~from_ijk_to_rsw_rv from_ijk_to_rsw_rv interface~from_ijk_to_rsw from_ijk_to_rsw interface~from_ijk_to_rsw->proc~from_ijk_to_rsw_rv proc~from_rsw_to_ijk_mat from_rsw_to_ijk_mat proc~from_rsw_to_ijk_mat->interface~from_ijk_to_rsw proc~relative_motion_test relative_motion_test proc~relative_motion_test->interface~from_ijk_to_rsw interface~from_rsw_to_ijk from_rsw_to_ijk interface~from_rsw_to_ijk->proc~from_rsw_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_ijk_to_rsw_rv ( mu , rt_ijk , vt_ijk , r_ijk , v_ijk , dr_rsw , dv_rsw ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ) :: dr_rsw !! Chaser RSW position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: dv_rsw !! Chaser RSW position vector relative to target [km] call from_ijk_to_frame_rv ( mu , from_ijk_to_rsw_mat , rt_ijk , vt_ijk , r_ijk , v_ijk , dr_rsw , dv_rsw ) end subroutine from_ijk_to_rsw_rv","tags":"","url":"proc/from_ijk_to_rsw_rv.html"},{"title":"from_rsw_to_ijk_mat – fortran-astrodynamics-toolkit","text":"private  subroutine from_rsw_to_ijk_mat(mu, r, v, a, c, cdot) Uses vector_module proc~~from_rsw_to_ijk_mat~~UsesGraph proc~from_rsw_to_ijk_mat from_rsw_to_ijk_mat module~vector_module vector_module proc~from_rsw_to_ijk_mat->module~vector_module module~kind_module kind_module module~vector_module->module~kind_module module~numbers_module numbers_module module~vector_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Compute the transformation matrices to convert RSW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix Calls proc~~from_rsw_to_ijk_mat~~CallsGraph proc~from_rsw_to_ijk_mat from_rsw_to_ijk_mat interface~from_ijk_to_rsw from_ijk_to_rsw proc~from_rsw_to_ijk_mat->interface~from_ijk_to_rsw proc~from_ijk_to_rsw_mat from_ijk_to_rsw_mat interface~from_ijk_to_rsw->proc~from_ijk_to_rsw_mat proc~from_ijk_to_rsw_rv from_ijk_to_rsw_rv interface~from_ijk_to_rsw->proc~from_ijk_to_rsw_rv proc~cross cross proc~from_ijk_to_rsw_mat->proc~cross proc~uhat_dot uhat_dot proc~from_ijk_to_rsw_mat->proc~uhat_dot proc~unit unit proc~from_ijk_to_rsw_mat->proc~unit proc~from_ijk_to_frame_rv from_ijk_to_frame_rv proc~from_ijk_to_rsw_rv->proc~from_ijk_to_frame_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~from_rsw_to_ijk_mat~~CalledByGraph proc~from_rsw_to_ijk_mat from_rsw_to_ijk_mat interface~from_rsw_to_ijk from_rsw_to_ijk interface~from_rsw_to_ijk->proc~from_rsw_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_rsw_to_ijk_mat ( mu , r , v , a , c , cdot ) use vector_module , only : unit , cross implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector of target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector of target [km/s] real ( wp ), dimension ( 3 ), intent ( in ), optional :: a !! acceleration vector of target [km/s&#94;2] !! (if not present, then a torque-free force model is assumed) real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c !! C transformation matrix real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot !! CDOT transformation matrix call from_ijk_to_rsw ( mu , r , v , a , c , cdot ) c = transpose ( c ) if ( present ( cdot )) cdot = transpose ( cdot ) end subroutine from_rsw_to_ijk_mat","tags":"","url":"proc/from_rsw_to_ijk_mat.html"},{"title":"from_rsw_to_ijk_rv – fortran-astrodynamics-toolkit","text":"private  subroutine from_rsw_to_ijk_rv(mu, rt_ijk, vt_ijk, dr_rsw, dv_rsw, r_ijk, v_ijk) Transform a position (and optionally velocity) vector from RSW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: dr_rsw Chaser RSW position vector [km] real(kind=wp), intent(in), dimension(3) :: dv_rsw Chaser RSW velocity vector [km/s] real(kind=wp), intent(out), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), optional, dimension(3) :: v_ijk Chaser IJK absolute velocity vector [km/s] Calls proc~~from_rsw_to_ijk_rv~~CallsGraph proc~from_rsw_to_ijk_rv from_rsw_to_ijk_rv proc~from_frame_to_ijk_rv from_frame_to_ijk_rv proc~from_rsw_to_ijk_rv->proc~from_frame_to_ijk_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~from_rsw_to_ijk_rv~~CalledByGraph proc~from_rsw_to_ijk_rv from_rsw_to_ijk_rv interface~from_rsw_to_ijk from_rsw_to_ijk interface~from_rsw_to_ijk->proc~from_rsw_to_ijk_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_rsw_to_ijk_rv ( mu , rt_ijk , vt_ijk , dr_rsw , dv_rsw , r_ijk , v_ijk ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dr_rsw !! Chaser RSW position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dv_rsw !! Chaser RSW velocity vector [km/s] real ( wp ), dimension ( 3 ), intent ( out ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: v_ijk !! Chaser IJK absolute velocity vector [km/s] call from_frame_to_ijk_rv ( mu , from_rsw_to_ijk_mat , rt_ijk , vt_ijk , dr_rsw , dv_rsw , r_ijk , v_ijk ) end subroutine from_rsw_to_ijk_rv","tags":"","url":"proc/from_rsw_to_ijk_rv.html"},{"title":"from_rsw_to_lvlh_rv – fortran-astrodynamics-toolkit","text":"private  subroutine from_rsw_to_lvlh_rv(dr_rsw, dv_rsw, dr_lvlh, dv_lvlh) Transform a position (and optionally velocity) vector from RSW to LVLH. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: dr_rsw Chaser RSW position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_rsw Chaser RSW velocity vector relative to target [km/s] real(kind=wp), intent(out), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km] Called by proc~~from_rsw_to_lvlh_rv~~CalledByGraph proc~from_rsw_to_lvlh_rv from_rsw_to_lvlh_rv interface~from_rsw_to_lvlh from_rsw_to_lvlh interface~from_rsw_to_lvlh->proc~from_rsw_to_lvlh_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_rsw_to_lvlh_rv ( dr_rsw , dv_rsw , dr_lvlh , dv_lvlh ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: dr_rsw !! Chaser RSW position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dv_rsw !! Chaser RSW velocity vector relative to target [km/s] real ( wp ), dimension ( 3 ), intent ( out ) :: dr_lvlh !! Chaser LVLH position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: dv_lvlh !! Chaser LVLH position vector relative to target [km] dr_lvlh ( 1 ) = dr_rsw ( 2 ) dr_lvlh ( 2 ) = - dr_rsw ( 3 ) dr_lvlh ( 3 ) = - dr_rsw ( 1 ) if ( present ( dv_lvlh )) then dv_lvlh ( 1 ) = dv_rsw ( 2 ) dv_lvlh ( 2 ) = - dv_rsw ( 3 ) dv_lvlh ( 3 ) = - dv_rsw ( 1 ) end if end subroutine from_rsw_to_lvlh_rv","tags":"","url":"proc/from_rsw_to_lvlh_rv.html"},{"title":"from_lvlh_to_rsw_rv – fortran-astrodynamics-toolkit","text":"private  subroutine from_lvlh_to_rsw_rv(dr_lvlh, dv_lvlh, dr_rsw, dv_rsw) Transform a position (and optionally velocity) vector from LVLH to RSW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), dimension(3) :: dr_rsw Chaser RSW position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_rsw Chaser RSW velocity vector relative to target [km/s] Called by proc~~from_lvlh_to_rsw_rv~~CalledByGraph proc~from_lvlh_to_rsw_rv from_lvlh_to_rsw_rv interface~from_lvlh_to_rsw from_lvlh_to_rsw interface~from_lvlh_to_rsw->proc~from_lvlh_to_rsw_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine from_lvlh_to_rsw_rv ( dr_lvlh , dv_lvlh , dr_rsw , dv_rsw ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: dr_lvlh !! Chaser LVLH position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dv_lvlh !! Chaser LVLH position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ) :: dr_rsw !! Chaser RSW position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: dv_rsw !! Chaser RSW velocity vector relative to target [km/s] dr_rsw ( 2 ) = dr_lvlh ( 1 ) dr_rsw ( 3 ) = - dr_lvlh ( 2 ) dr_rsw ( 1 ) = - dr_lvlh ( 3 ) if ( present ( dv_rsw )) then dv_rsw ( 2 ) = dv_lvlh ( 1 ) dv_rsw ( 3 ) = - dv_lvlh ( 2 ) dv_rsw ( 1 ) = - dv_lvlh ( 3 ) end if end subroutine from_lvlh_to_rsw_rv","tags":"","url":"proc/from_lvlh_to_rsw_rv.html"},{"title":"relative_motion_test – fortran-astrodynamics-toolkit","text":"public  subroutine relative_motion_test() Unit tests for the relative_motion_module . Arguments None Calls proc~~relative_motion_test~~CallsGraph proc~relative_motion_test relative_motion_test interface~from_ijk_to_lvlh from_ijk_to_lvlh proc~relative_motion_test->interface~from_ijk_to_lvlh interface~from_ijk_to_rsw from_ijk_to_rsw proc~relative_motion_test->interface~from_ijk_to_rsw proc~from_ijk_to_lvlh_mat from_ijk_to_lvlh_mat interface~from_ijk_to_lvlh->proc~from_ijk_to_lvlh_mat proc~from_ijk_to_lvlh_rv from_ijk_to_lvlh_rv interface~from_ijk_to_lvlh->proc~from_ijk_to_lvlh_rv proc~from_ijk_to_rsw_mat from_ijk_to_rsw_mat interface~from_ijk_to_rsw->proc~from_ijk_to_rsw_mat proc~from_ijk_to_rsw_rv from_ijk_to_rsw_rv interface~from_ijk_to_rsw->proc~from_ijk_to_rsw_rv proc~cross cross proc~from_ijk_to_lvlh_mat->proc~cross proc~uhat_dot uhat_dot proc~from_ijk_to_lvlh_mat->proc~uhat_dot proc~unit unit proc~from_ijk_to_lvlh_mat->proc~unit proc~from_ijk_to_frame_rv from_ijk_to_frame_rv proc~from_ijk_to_lvlh_rv->proc~from_ijk_to_frame_rv proc~from_ijk_to_rsw_mat->proc~cross proc~from_ijk_to_rsw_mat->proc~uhat_dot proc~from_ijk_to_rsw_mat->proc~unit proc~from_ijk_to_rsw_rv->proc~from_ijk_to_frame_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine relative_motion_test () implicit none real ( wp ), dimension ( 6 ), parameter :: target_eci_state = [ - 230167 2.24489839_wp , & - 537107 6.10250925_wp , & - 342114 6.71530212_wp , & 613 3.8624555516_wp , & 30 6.265184163608_wp , & - 459 7.13439017524_wp ] real ( wp ), dimension ( 6 ), parameter :: chaser_eci_state = [ - 225521 3.51862763_wp , & - 536655 3.94133467_wp , & - 345387 1.15040494_wp , & 615 6.89588163809_wp , & 35 6.79933181917_wp , & - 456 5.88915429063_wp ] real ( wp ), dimension ( 3 ) :: r_12_I , r1_I , r2_I real ( wp ), dimension ( 3 ) :: v_12_I , v1_I , v2_I real ( wp ), dimension ( 3 ) :: r_12_R , v_12_R real ( wp ), dimension ( 3 , 3 ) :: c , cdot real ( wp ), parameter :: mu = 39860 0.4418_wp ! gravitational parameter [km&#94;3/s&#94;2] write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' relative_motion_test' write ( * , * ) '---------------' write ( * , * ) '' r1_I = target_eci_state ( 1 : 3 ) v1_I = target_eci_state ( 4 : 6 ) r2_I = chaser_eci_state ( 1 : 3 ) v2_I = chaser_eci_state ( 4 : 6 ) r_12_I = r2_I - r1_I v_12_I = v2_I - v1_I call from_ijk_to_lvlh ( mu , r1_I , v1_I , c = c , cdot = cdot ) r_12_R = matmul ( c , r_12_I ) v_12_R = matmul ( cdot , r_12_I ) + matmul ( c , v_12_I ) write ( * , '(A,*(D30.16,1X))' ) 'r_12_LVLH : ' , r_12_R write ( * , '(A,*(D30.16,1X))' ) 'v_12_LVLH : ' , v_12_R write ( * , * ) '' call from_ijk_to_rsw ( mu , r1_I , v1_I , c = c , cdot = cdot ) r_12_R = matmul ( c , r_12_I ) v_12_R = matmul ( cdot , r_12_I ) + matmul ( c , v_12_I ) write ( * , '(A,*(D30.16,1X))' ) 'r_12_RSW : ' , r_12_R write ( * , '(A,*(D30.16,1X))' ) 'v_12_RSW : ' , v_12_R write ( * , * ) '' end subroutine relative_motion_test","tags":"","url":"proc/relative_motion_test.html"},{"title":"from_ijk_to_lvlh – fortran-astrodynamics-toolkit","text":"public interface from_ijk_to_lvlh Conversion from IJK to LVLH Calls interface~~from_ijk_to_lvlh~~CallsGraph interface~from_ijk_to_lvlh from_ijk_to_lvlh proc~from_ijk_to_lvlh_mat from_ijk_to_lvlh_mat interface~from_ijk_to_lvlh->proc~from_ijk_to_lvlh_mat proc~from_ijk_to_lvlh_rv from_ijk_to_lvlh_rv interface~from_ijk_to_lvlh->proc~from_ijk_to_lvlh_rv proc~cross cross proc~from_ijk_to_lvlh_mat->proc~cross proc~uhat_dot uhat_dot proc~from_ijk_to_lvlh_mat->proc~uhat_dot proc~unit unit proc~from_ijk_to_lvlh_mat->proc~unit proc~from_ijk_to_frame_rv from_ijk_to_frame_rv proc~from_ijk_to_lvlh_rv->proc~from_ijk_to_frame_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~from_ijk_to_lvlh~~CalledByGraph interface~from_ijk_to_lvlh from_ijk_to_lvlh proc~from_lvlh_to_ijk_mat from_lvlh_to_ijk_mat proc~from_lvlh_to_ijk_mat->interface~from_ijk_to_lvlh proc~relative_motion_test relative_motion_test proc~relative_motion_test->interface~from_ijk_to_lvlh interface~from_lvlh_to_ijk from_lvlh_to_ijk interface~from_lvlh_to_ijk->proc~from_lvlh_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine from_ijk_to_lvlh_mat (mu, r, v, a, c, cdot) Author Jacob Williams Date 4/19/2014 Compute the transformation matrices to convert IJK to LVLH. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_ijk_to_lvlh_rv (mu, rt_ijk, vt_ijk, r_ijk, v_ijk, dr_lvlh, dv_lvlh) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from IJK to LVLH. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: v_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km]","tags":"","url":"interface/from_ijk_to_lvlh.html"},{"title":"from_lvlh_to_ijk – fortran-astrodynamics-toolkit","text":"public interface from_lvlh_to_ijk Conversion from LVLH to IJK Calls interface~~from_lvlh_to_ijk~~CallsGraph interface~from_lvlh_to_ijk from_lvlh_to_ijk proc~from_lvlh_to_ijk_mat from_lvlh_to_ijk_mat interface~from_lvlh_to_ijk->proc~from_lvlh_to_ijk_mat proc~from_lvlh_to_ijk_rv from_lvlh_to_ijk_rv interface~from_lvlh_to_ijk->proc~from_lvlh_to_ijk_rv interface~from_ijk_to_lvlh from_ijk_to_lvlh proc~from_lvlh_to_ijk_mat->interface~from_ijk_to_lvlh proc~from_frame_to_ijk_rv from_frame_to_ijk_rv proc~from_lvlh_to_ijk_rv->proc~from_frame_to_ijk_rv proc~from_ijk_to_lvlh_mat from_ijk_to_lvlh_mat interface~from_ijk_to_lvlh->proc~from_ijk_to_lvlh_mat proc~from_ijk_to_lvlh_rv from_ijk_to_lvlh_rv interface~from_ijk_to_lvlh->proc~from_ijk_to_lvlh_rv proc~cross cross proc~from_ijk_to_lvlh_mat->proc~cross proc~uhat_dot uhat_dot proc~from_ijk_to_lvlh_mat->proc~uhat_dot proc~unit unit proc~from_ijk_to_lvlh_mat->proc~unit proc~from_ijk_to_frame_rv from_ijk_to_frame_rv proc~from_ijk_to_lvlh_rv->proc~from_ijk_to_frame_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine from_lvlh_to_ijk_mat (mu, r, v, a, c, cdot) Author Jacob Williams Date 4/19/2014 Compute the transformation matrices to convert LVLH to IJK. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_lvlh_to_ijk_rv (mu, rt_ijk, vt_ijk, dr_lvlh, dv_lvlh, r_ijk, v_ijk) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from LVLH to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), optional, dimension(3) :: v_ijk Chaser IJK absolute position vector [km]","tags":"","url":"interface/from_lvlh_to_ijk.html"},{"title":"from_ijk_to_rsw – fortran-astrodynamics-toolkit","text":"public interface from_ijk_to_rsw Conversion from IJK to RSW Calls interface~~from_ijk_to_rsw~~CallsGraph interface~from_ijk_to_rsw from_ijk_to_rsw proc~from_ijk_to_rsw_mat from_ijk_to_rsw_mat interface~from_ijk_to_rsw->proc~from_ijk_to_rsw_mat proc~from_ijk_to_rsw_rv from_ijk_to_rsw_rv interface~from_ijk_to_rsw->proc~from_ijk_to_rsw_rv proc~cross cross proc~from_ijk_to_rsw_mat->proc~cross proc~uhat_dot uhat_dot proc~from_ijk_to_rsw_mat->proc~uhat_dot proc~unit unit proc~from_ijk_to_rsw_mat->proc~unit proc~from_ijk_to_frame_rv from_ijk_to_frame_rv proc~from_ijk_to_rsw_rv->proc~from_ijk_to_frame_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~from_ijk_to_rsw~~CalledByGraph interface~from_ijk_to_rsw from_ijk_to_rsw proc~from_rsw_to_ijk_mat from_rsw_to_ijk_mat proc~from_rsw_to_ijk_mat->interface~from_ijk_to_rsw proc~relative_motion_test relative_motion_test proc~relative_motion_test->interface~from_ijk_to_rsw interface~from_rsw_to_ijk from_rsw_to_ijk interface~from_rsw_to_ijk->proc~from_rsw_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine from_ijk_to_rsw_mat (mu, r, v, a, c, cdot) Author Jacob Williams Date 4/19/2014 Compute the transformation matrices to convert IJK to RSW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_ijk_to_rsw_rv (mu, rt_ijk, vt_ijk, r_ijk, v_ijk, dr_rsw, dv_rsw) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from IJK to RSW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: v_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), dimension(3) :: dr_rsw Chaser RSW position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_rsw Chaser RSW position vector relative to target [km]","tags":"","url":"interface/from_ijk_to_rsw.html"},{"title":"from_rsw_to_ijk – fortran-astrodynamics-toolkit","text":"public interface from_rsw_to_ijk Conversion from RSW to IJK Calls interface~~from_rsw_to_ijk~~CallsGraph interface~from_rsw_to_ijk from_rsw_to_ijk proc~from_rsw_to_ijk_mat from_rsw_to_ijk_mat interface~from_rsw_to_ijk->proc~from_rsw_to_ijk_mat proc~from_rsw_to_ijk_rv from_rsw_to_ijk_rv interface~from_rsw_to_ijk->proc~from_rsw_to_ijk_rv interface~from_ijk_to_rsw from_ijk_to_rsw proc~from_rsw_to_ijk_mat->interface~from_ijk_to_rsw proc~from_frame_to_ijk_rv from_frame_to_ijk_rv proc~from_rsw_to_ijk_rv->proc~from_frame_to_ijk_rv proc~from_ijk_to_rsw_mat from_ijk_to_rsw_mat interface~from_ijk_to_rsw->proc~from_ijk_to_rsw_mat proc~from_ijk_to_rsw_rv from_ijk_to_rsw_rv interface~from_ijk_to_rsw->proc~from_ijk_to_rsw_rv proc~cross cross proc~from_ijk_to_rsw_mat->proc~cross proc~uhat_dot uhat_dot proc~from_ijk_to_rsw_mat->proc~uhat_dot proc~unit unit proc~from_ijk_to_rsw_mat->proc~unit proc~from_ijk_to_frame_rv from_ijk_to_frame_rv proc~from_ijk_to_rsw_rv->proc~from_ijk_to_frame_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine from_rsw_to_ijk_mat (mu, r, v, a, c, cdot) Author Jacob Williams Date 4/19/2014 Compute the transformation matrices to convert RSW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_rsw_to_ijk_rv (mu, rt_ijk, vt_ijk, dr_rsw, dv_rsw, r_ijk, v_ijk) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from RSW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: dr_rsw Chaser RSW position vector [km] real(kind=wp), intent(in), dimension(3) :: dv_rsw Chaser RSW velocity vector [km/s] real(kind=wp), intent(out), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), optional, dimension(3) :: v_ijk Chaser IJK absolute velocity vector [km/s]","tags":"","url":"interface/from_rsw_to_ijk.html"},{"title":"from_lvlh_to_rsw – fortran-astrodynamics-toolkit","text":"public interface from_lvlh_to_rsw Conversion from LVLH to RSW Calls interface~~from_lvlh_to_rsw~~CallsGraph interface~from_lvlh_to_rsw from_lvlh_to_rsw proc~from_lvlh_to_rsw_rv from_lvlh_to_rsw_rv interface~from_lvlh_to_rsw->proc~from_lvlh_to_rsw_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine from_lvlh_to_rsw_rv (dr_lvlh, dv_lvlh, dr_rsw, dv_rsw) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from LVLH to RSW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), dimension(3) :: dr_rsw Chaser RSW position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_rsw Chaser RSW velocity vector relative to target [km/s]","tags":"","url":"interface/from_lvlh_to_rsw.html"},{"title":"from_rsw_to_lvlh – fortran-astrodynamics-toolkit","text":"public interface from_rsw_to_lvlh Conversion from RSW to LVLH Calls interface~~from_rsw_to_lvlh~~CallsGraph interface~from_rsw_to_lvlh from_rsw_to_lvlh proc~from_rsw_to_lvlh_rv from_rsw_to_lvlh_rv interface~from_rsw_to_lvlh->proc~from_rsw_to_lvlh_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine from_rsw_to_lvlh_rv (dr_rsw, dv_rsw, dr_lvlh, dv_lvlh) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from RSW to LVLH. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: dr_rsw Chaser RSW position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_rsw Chaser RSW velocity vector relative to target [km/s] real(kind=wp), intent(out), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km]","tags":"","url":"interface/from_rsw_to_lvlh.html"},{"title":"from_ijk_to_vuw – fortran-astrodynamics-toolkit","text":"public interface from_ijk_to_vuw Conversion from IJK to vuw Calls interface~~from_ijk_to_vuw~~CallsGraph interface~from_ijk_to_vuw from_ijk_to_vuw proc~from_ijk_to_vuw_mat from_ijk_to_vuw_mat interface~from_ijk_to_vuw->proc~from_ijk_to_vuw_mat proc~from_ijk_to_vuw_rv from_ijk_to_vuw_rv interface~from_ijk_to_vuw->proc~from_ijk_to_vuw_rv proc~cross cross proc~from_ijk_to_vuw_mat->proc~cross proc~uhat_dot uhat_dot proc~from_ijk_to_vuw_mat->proc~uhat_dot proc~unit unit proc~from_ijk_to_vuw_mat->proc~unit proc~from_ijk_to_frame_rv from_ijk_to_frame_rv proc~from_ijk_to_vuw_rv->proc~from_ijk_to_frame_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by interface~~from_ijk_to_vuw~~CalledByGraph interface~from_ijk_to_vuw from_ijk_to_vuw proc~from_vuw_to_ijk_mat from_vuw_to_ijk_mat proc~from_vuw_to_ijk_mat->interface~from_ijk_to_vuw interface~from_vuw_to_ijk from_vuw_to_ijk interface~from_vuw_to_ijk->proc~from_vuw_to_ijk_mat Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine from_ijk_to_vuw_mat (mu, r, v, a, c, cdot) Compute the transformation matrices to convert IJK to vuw. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2]\nthis is used here to assume instantaneous conic motion if a is not present. real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_ijk_to_vuw_rv (mu, rt_ijk, vt_ijk, r_ijk, v_ijk, dr_vuw, dv_vuw) Transform a position (and optionally velocity) vector from IJK to VUW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: v_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), dimension(3) :: dr_vuw Chaser vuw position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_vuw Chaser vuw position vector relative to target [km]","tags":"","url":"interface/from_ijk_to_vuw.html"},{"title":"from_vuw_to_ijk – fortran-astrodynamics-toolkit","text":"public interface from_vuw_to_ijk Conversion from vuw to IJK Calls interface~~from_vuw_to_ijk~~CallsGraph interface~from_vuw_to_ijk from_vuw_to_ijk proc~from_vuw_to_ijk_mat from_vuw_to_ijk_mat interface~from_vuw_to_ijk->proc~from_vuw_to_ijk_mat proc~from_vuw_to_ijk_rv from_vuw_to_ijk_rv interface~from_vuw_to_ijk->proc~from_vuw_to_ijk_rv interface~from_ijk_to_vuw from_ijk_to_vuw proc~from_vuw_to_ijk_mat->interface~from_ijk_to_vuw proc~from_frame_to_ijk_rv from_frame_to_ijk_rv proc~from_vuw_to_ijk_rv->proc~from_frame_to_ijk_rv proc~from_ijk_to_vuw_mat from_ijk_to_vuw_mat interface~from_ijk_to_vuw->proc~from_ijk_to_vuw_mat proc~from_ijk_to_vuw_rv from_ijk_to_vuw_rv interface~from_ijk_to_vuw->proc~from_ijk_to_vuw_rv proc~cross cross proc~from_ijk_to_vuw_mat->proc~cross proc~uhat_dot uhat_dot proc~from_ijk_to_vuw_mat->proc~uhat_dot proc~unit unit proc~from_ijk_to_vuw_mat->proc~unit proc~from_ijk_to_frame_rv from_ijk_to_frame_rv proc~from_ijk_to_vuw_rv->proc~from_ijk_to_frame_rv Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Module Procedures private  subroutine from_vuw_to_ijk_mat (mu, r, v, a, c, cdot) Compute the transformation matrices to convert VUW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_vuw_to_ijk_rv (mu, rt_ijk, vt_ijk, dr_vuw, dv_vuw, r_ijk, v_ijk) Transform a position (and optionally velocity) vector from VUW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: dr_vuw Chaser vuw position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_vuw Chaser vuw position vector relative to target [km] real(kind=wp), intent(out), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), optional, dimension(3) :: v_ijk Chaser IJK absolute position vector [km]","tags":"","url":"interface/from_vuw_to_ijk.html"},{"title":"fmin – fortran-astrodynamics-toolkit","text":"private  function fmin(me, ax, bx, tol) result(xmin) An approximation x to the point where f attains a minimum on\n  the interval (ax,bx) is determined. the method used is a combination of golden section search and\n  successive parabolic interpolation. convergence is never much slower\n  than that for a fibonacci search. if f has a continuous second\n  derivative which is positive at the minimum (which is not at ax or\n  bx), then convergence is superlinear, and usually of the order of\n  about 1.324. the function f is never evaluated at two points closer together\n  than eps abs(fmin) + (tol/3), where eps is approximately the square\n  root of the relative machine precision. if f is a unimodal\n  function and the computed values of f are always unimodal when\n  separated by at least eps abs(x) + (tol/3), then fmin approximates\n  the abcissa of the global minimum of f on the interval ax,bx with\n  an error less than 3 eps abs(fmin) + tol. if f is not unimodal,\n  then fmin may approximate a local, but perhaps non-global, minimum to\n  the same accuracy. this function subprogram is a slightly modified version of the\n  algol 60 procedure localmin given in richard brent, algorithms for\n  minimization without derivatives, prentice - hall, inc. (1973). See also [1] http://www.netlib.org/fmm/fmin.f Type Bound brent_class Arguments Type Intent Optional Attributes Name class( brent_class ), intent(inout) :: me real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp), intent(in) :: tol desired length of the interval of\nuncertainty of the final result (>=0) Return Value real(kind=wp) abcissa approximating the point where\nf attains a minimum Called by proc~~fmin~~CalledByGraph proc~fmin brent_class%fmin proc~brent_test brent_test proc~brent_test->proc~fmin Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function fmin ( me , ax , bx , tol ) result ( xmin ) implicit none class ( brent_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( in ) :: tol !! desired length of the interval of !! uncertainty of the final result (>=0) real ( wp ) :: xmin !! abcissa approximating the point where !! f attains a minimum real ( wp ) :: a , b , d , e , xm , p , q , r , tol1 , tol2 , u , v , w real ( wp ) :: fu , fv , fw , fx , x real ( wp ) :: abs , sqrt , sign real ( wp ), parameter :: c = ( three - sqrt ( five )) / two !! squared inverse of golden ratio real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: eps = sqrt ( epsilon ( one )) ! initialization a = ax b = bx v = a + c * ( b - a ) w = v x = v e = zero fx = me % f ( x ) fv = fx fw = fx do !  main loop starts here xm = half * ( a + b ) tol1 = eps * abs ( x ) + tol / three tol2 = two * tol1 !  check stopping criterion if ( abs ( x - xm ) <= ( tol2 - half * ( b - a ))) exit ! is golden-section necessary if ( abs ( e ) <= tol1 ) then !  a golden-section step if ( x >= xm ) then e = a - x else e = b - x end if d = c * e else !  fit parabola r = ( x - w ) * ( fx - fv ) q = ( x - v ) * ( fx - fw ) p = ( x - v ) * q - ( x - w ) * r q = two * ( q - r ) if ( q > zero ) p = - p q = abs ( q ) r = e e = d !  is parabola acceptable if (( abs ( p ) >= abs ( half * q * r )) . or . ( p <= q * ( a - x )) . or . ( p >= q * ( b - x ))) then !  a golden-section step if ( x >= xm ) then e = a - x else e = b - x end if d = c * e else !  a parabolic interpolation step d = p / q u = x + d !  f must not be evaluated too close to ax or bx if ((( u - a ) < tol2 ) . or . (( b - u ) < tol2 )) d = sign ( tol1 , xm - x ) end if end if !  f must not be evaluated too close to x if ( abs ( d ) >= tol1 ) then u = x + d else u = x + sign ( tol1 , d ) end if fu = me % f ( u ) !  update a, b, v, w, and x if ( fu <= fx ) then if ( u >= x ) a = x if ( u < x ) b = x v = w fv = fw w = x fw = fx x = u fx = fu else if ( u < x ) a = u if ( u >= x ) b = u if ( fu <= fw . or . w == x ) then v = w fv = fw w = u fw = fu else if ( fu <= fv . or . v == x . or . v == w ) then v = u fv = fu end if end if end do !  end of main loop xmin = x end function fmin","tags":"","url":"proc/fmin.html"},{"title":"set_function – fortran-astrodynamics-toolkit","text":"private  subroutine set_function(me, f) Set the function to be minimized. Type Bound brent_class Arguments Type Intent Optional Attributes Name class( brent_class ), intent(inout) :: me procedure( func ) :: f Called by proc~~set_function~~CalledByGraph proc~set_function brent_class%set_function proc~brent_test brent_test proc~brent_test->proc~set_function proc~integrate_to_event rk_class%integrate_to_event proc~integrate_to_event->proc~set_function proc~integrate_to_event~2 rk_variable_step_class%integrate_to_event proc~integrate_to_event~2->proc~set_function proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~integrate_to_event proc~rk_test rk_test proc~rk_test->proc~integrate_to_event proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->proc~integrate_to_event~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine set_function ( me , f ) implicit none class ( brent_class ), intent ( inout ) :: me procedure ( func ) :: f me % f => f end subroutine set_function","tags":"","url":"proc/set_function.html"},{"title":"zeroin – fortran-astrodynamics-toolkit","text":"private  subroutine zeroin(me, ax, bx, tol, xzero, fzero, iflag, fax, fbx) Uses iso_fortran_env proc~~zeroin~~UsesGraph proc~zeroin brent_class%zeroin iso_fortran_env iso_fortran_env proc~zeroin->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Find a zero of the function in the given interval to within a tolerance ,\n  where is the relative machine precision defined as\n  the smallest representable number such that . It is assumed that and have opposite signs. References R. P. Brent, \" An algorithm with guaranteed convergence for\n    finding a zero of a function \",\n    The Computer Journal, Vol 14, No. 4., 1971. R. P. Brent, \" Algorithms for minimization without derivatives \",\n    Prentice-Hall, Inc., 1973. See also zeroin.f from Netlib Type Bound brent_class Arguments Type Intent Optional Attributes Name class( brent_class ), intent(inout) :: me real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp), intent(in) :: tol desired length of the interval of uncertainty of the final result (>=0) real(kind=wp), intent(out) :: xzero abscissa approximating a zero of f in the interval ax , bx real(kind=wp), intent(out) :: fzero value of f at the root ( f(xzero) ) integer, intent(out) :: iflag status flag ( -1 =error, 0 =root found) real(kind=wp), intent(in), optional :: fax if f(ax) is already known, it can be input here real(kind=wp), intent(in), optional :: fbx if f(ax) is already known, it can be input here Called by proc~~zeroin~~CalledByGraph proc~zeroin brent_class%zeroin proc~brent_test brent_test proc~brent_test->proc~zeroin proc~integrate_to_event rk_class%integrate_to_event proc~integrate_to_event->proc~zeroin proc~integrate_to_event~2 rk_variable_step_class%integrate_to_event proc~integrate_to_event~2->proc~zeroin proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->proc~integrate_to_event proc~rk_test rk_test proc~rk_test->proc~integrate_to_event proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->proc~integrate_to_event~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine zeroin ( me , ax , bx , tol , xzero , fzero , iflag , fax , fbx ) use iso_fortran_env , only : error_unit implicit none class ( brent_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( in ) :: tol !! desired length of the interval of uncertainty of the final result (>=0) real ( wp ), intent ( out ) :: xzero !! abscissa approximating a zero of `f` in the interval `ax`,`bx` real ( wp ), intent ( out ) :: fzero !! value of `f` at the root (`f(xzero)`) integer , intent ( out ) :: iflag !! status flag (`-1`=error, `0`=root found) real ( wp ), intent ( in ), optional :: fax !! if `f(ax)` is already known, it can be input here real ( wp ), intent ( in ), optional :: fbx !! if `f(ax)` is already known, it can be input here real ( wp ), parameter :: eps = epsilon ( one ) !! original code had d1mach(4) real ( wp ) :: a , b , c , d , e , fa , fb , fc , tol1 , xm , p , q , r , s tol1 = eps + one a = ax b = bx if ( present ( fax )) then fa = fax else fa = me % f ( a ) end if if ( present ( fbx )) then fb = fbx else fb = me % f ( b ) end if !check trivial cases first: if ( fa == zero ) then iflag = 0 xzero = a fzero = fa elseif ( fb == zero ) then iflag = 0 xzero = b fzero = fb elseif ( fa * ( fb / abs ( fb )) < zero ) then ! check that f(ax) and f(bx) have different signs c = a fc = fa d = b - a e = d do if ( abs ( fc ) < abs ( fb )) then a = b b = c c = a fa = fb fb = fc fc = fa end if tol1 = two * eps * abs ( b ) + 0.5_wp * tol xm = 0.5_wp * ( c - b ) if (( abs ( xm ) <= tol1 ). or .( fb == zero )) exit ! see if a bisection is forced if (( abs ( e ) >= tol1 ). and .( abs ( fa ) > abs ( fb ))) then s = fb / fa if ( a /= c ) then ! inverse quadratic interpolation q = fa / fc r = fb / fc p = s * ( two * xm * q * ( q - r ) - ( b - a ) * ( r - one )) q = ( q - one ) * ( r - one ) * ( s - one ) else ! linear interpolation p = two * xm * s q = one - s end if if ( p <= zero ) then p =- p else q =- q end if s = e e = d if ((( two * p ) >= ( three * xm * q - abs ( tol1 * q ))) . or . & ( p >= abs ( 0.5_wp * s * q ))) then d = xm e = d else d = p / q end if else d = xm e = d end if a = b fa = fb if ( abs ( d ) <= tol1 ) then if ( xm <= zero ) then b = b - tol1 else b = b + tol1 end if else b = b + d end if fb = me % f ( b ) if (( fb * ( fc / abs ( fc ))) > zero ) then c = a fc = fa d = b - a e = d end if end do iflag = 0 xzero = b fzero = fb else iflag = - 1 write ( error_unit , '(A)' )& 'Error in zeroin: f(ax) and f(bx) do not have different signs.' end if end subroutine zeroin","tags":"","url":"proc/zeroin.html"},{"title":"brent_test – fortran-astrodynamics-toolkit","text":"public  subroutine brent_test() Test of the fmin and zeroin functions. Arguments None Calls proc~~brent_test~~CallsGraph proc~brent_test brent_test proc~fmin brent_class%fmin proc~brent_test->proc~fmin proc~set_function brent_class%set_function proc~brent_test->proc~set_function proc~zeroin brent_class%zeroin proc~brent_test->proc~zeroin Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine brent_test () implicit none real ( wp ) :: r , fzero integer :: iflag real ( wp ), parameter :: ax = zero real ( wp ), parameter :: bx = two * pi real ( wp ), parameter :: tol = 1.0e-6_wp type , extends ( brent_class ) :: myfunc_type integer :: i = 0 !! function counter end type myfunc_type type ( myfunc_type ) :: myfunc write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' brent_test' write ( * , * ) '---------------' write ( * , * ) '' call myfunc % set_function ( sin_func ) !set the function !call fmin: ! [the minimum is at 270 deg] myfunc % i = 0 r = myfunc % minimize ( ax , bx , tol ) write ( * , * ) 'minimum of sin(x) at: ' , r * 18 0.0_wp / pi , ' deg' write ( * , * ) 'number of function calls: ' , myfunc % i !call zeroin: ! [the root is at pi] myfunc % i = 0 call myfunc % find_zero ( ax + 0.0001_wp , bx / two + 0.0002 , tol , r , fzero , iflag ) write ( * , * ) 'root of sin(x) at: ' , r * 18 0.0_wp / pi , ' deg' write ( * , * ) 'number of function calls: ' , myfunc % i contains function sin_func ( me , x ) result ( f ) !! Example function to minimize: sin(x) implicit none class ( brent_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ) :: f f = sin ( x ) select type ( me ) class is ( myfunc_type ) me % i = me % i + 1 !number of function calls end select end function sin_func end subroutine brent_test","tags":"","url":"proc/brent_test.html"},{"title":"base_class_equal – fortran-astrodynamics-toolkit","text":"public pure elemental function base_class_equal(b1, b2) result(is_equal) == operator for base_class variables.\nTo be equal, they must be the same type and have the same ID . Type Bound base_class Arguments Type Intent Optional Attributes Name class( base_class ), intent(in) :: b1 class( base_class ), intent(in) :: b2 Return Value logical Source Code pure elemental function base_class_equal ( b1 , b2 ) result ( is_equal ) implicit none class ( base_class ), intent ( in ) :: b1 class ( base_class ), intent ( in ) :: b2 logical :: is_equal is_equal = same_type_as ( b1 , b2 ) . and . ( b1 % id == b2 % id ) end function base_class_equal","tags":"","url":"proc/base_class_equal.html"},{"title":"base_class_not_equal – fortran-astrodynamics-toolkit","text":"public pure elemental function base_class_not_equal(b1, b2) result(not_equal) /= operator for base_class variables.\nTo be equal, they must be the same type and have the same ID . Type Bound base_class Arguments Type Intent Optional Attributes Name class( base_class ), intent(in) :: b1 class( base_class ), intent(in) :: b2 Return Value logical Source Code pure elemental function base_class_not_equal ( b1 , b2 ) result ( not_equal ) implicit none class ( base_class ), intent ( in ) :: b1 class ( base_class ), intent ( in ) :: b2 logical :: not_equal not_equal = . not . ( b1 % id == b2 % id ) end function base_class_not_equal","tags":"","url":"proc/base_class_not_equal.html"},{"title":"great_circle_distance – fortran-astrodynamics-toolkit","text":"public pure function great_circle_distance(r, long1, lat1, long2, lat2) result(d) Great circle distance on a spherical body, using the Vincenty algorithm. References T. Vincenty, \" Direct and Inverse Solutions of Geodesics on the Ellipsoid\n    with Application of Nested Equations \",\n    Survey Review XXII. 176, April 1975. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r radius of the body [km] real(kind=wp), intent(in) :: long1 longitude of first site [rad] real(kind=wp), intent(in) :: lat1 latitude of the first site [rad] real(kind=wp), intent(in) :: long2 longitude of the second site [rad] real(kind=wp), intent(in) :: lat2 latitude of the second site [rad] Return Value real(kind=wp) great circle distance from 1 to 2 [km] Source Code pure function great_circle_distance ( r , long1 , lat1 , long2 , lat2 ) result ( d ) implicit none real ( wp ) :: d !! great circle distance from 1 to 2 [km] real ( wp ), intent ( in ) :: r !! radius of the body [km] real ( wp ), intent ( in ) :: long1 !! longitude of first site [rad] real ( wp ), intent ( in ) :: lat1 !! latitude of the first site [rad] real ( wp ), intent ( in ) :: long2 !! longitude of the second site [rad] real ( wp ), intent ( in ) :: lat2 !! latitude of the second site [rad] real ( wp ) :: c1 , s1 , c2 , s2 , dlon , clon , slon !Compute aux variables: c1 = cos ( lat1 ) s1 = sin ( lat1 ) c2 = cos ( lat2 ) s2 = sin ( lat2 ) dlon = long1 - long2 clon = cos ( dlon ) slon = sin ( dlon ) d = r * atan2 ( sqrt (( c2 * slon ) ** 2 + ( c1 * s2 - s1 * c2 * clon ) ** 2 ), ( s1 * s2 + c1 * c2 * clon ) ) end function great_circle_distance","tags":"","url":"proc/great_circle_distance.html"},{"title":"geocentric_radius – fortran-astrodynamics-toolkit","text":"public pure function geocentric_radius(a, b, lat) result(r) The distance from the center of a celestial body (e.g., the Earth) to a point\n  on the spheroid surface at a specified geodetic latitude. Reference Geocentric radius Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a equatorial radius (km) real(kind=wp), intent(in) :: b polar radius of point (km) real(kind=wp), intent(in) :: lat geodetic latitude of point (rad) Return Value real(kind=wp) distance from center of body to point (km) Source Code pure function geocentric_radius ( a , b , lat ) result ( r ) implicit none real ( wp ), intent ( in ) :: a !! equatorial radius (km) real ( wp ), intent ( in ) :: b !! polar radius of point (km) real ( wp ), intent ( in ) :: lat !! geodetic latitude of point (rad) real ( wp ) :: r !! distance from center of body to point (km) !local variables: real ( wp ) :: num , den , cl2 , sl2 , a2 , b2 if ( a == zero . and . b == zero ) then r = zero else cl2 = cos ( lat ) ** 2 sl2 = sin ( lat ) ** 2 a2 = a * a b2 = b * b num = cl2 * a2 ** 2 + sl2 * b2 ** 2 den = cl2 * a2 + sl2 * b2 r = sqrt ( num / den ) end if end function geocentric_radius","tags":"","url":"proc/geocentric_radius.html"},{"title":"solve_polynomial – fortran-astrodynamics-toolkit","text":"private pure function solve_polynomial(B, x0, error) result(x) Numerical solution to polynomial equation using Newton-Raphson method Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(0:6) :: B Polynomial B = B(6) x&#94;6 + B(5) x&#94;5 + ... + B(0) real(kind=wp), intent(in) :: x0 Initial point real(kind=wp), intent(in) :: error Maximum error Return Value real(kind=wp) root found after applying Newton-Raphson method to B The function returns the value when the correction\nis smaller than error. Called by proc~~solve_polynomial~~CalledByGraph proc~solve_polynomial solve_polynomial proc~cartesianintogeodetici CartesianIntoGeodeticI proc~cartesianintogeodetici->proc~solve_polynomial proc~cartesianintogeodeticii CartesianIntoGeodeticII proc~cartesianintogeodeticii->proc~solve_polynomial Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function solve_polynomial ( B , x0 , error ) result ( x ) real ( wp ), dimension ( 0 : 6 ), intent ( in ) :: B !! Polynomial `B = B(6) x&#94;6 + B(5) x&#94;5 + ... + B(0)` real ( wp ), intent ( in ) :: x0 !! Initial point real ( wp ), intent ( in ) :: error !! Maximum error real ( wp ) :: x !! root found after applying Newton-Raphson method to `B` !! The function returns the value when the correction !! is smaller than error. real ( wp ) :: f , fp , corr integer :: i , j !! counter integer , parameter :: maxiter = 100 !! maximum number of iterations x = x0 do i = 1 , maxiter f = B ( 6 ) do j = 5 , 0 , - 1 if ( j == 5 ) then fp = f else fp = x * fp + f end if f = x * f + B ( j ) end do if ( fp == zero ) exit ! singular point corr = f / fp x = x - corr if ( abs ( corr ) <= error ) exit end do end function solve_polynomial","tags":"","url":"proc/solve_polynomial.html"},{"title":"heikkinen – fortran-astrodynamics-toolkit","text":"public pure subroutine heikkinen(rvec, a, b, h, lon, lat) Heikkinen routine for cartesian to geodetic transformation References M. Heikkinen, \"Geschlossene formeln zur berechnung raumlicher\n     geodatischer koordinaten aus rechtwinkligen Koordinaten\".\n     Z. Ermess., 107 (1982), 207-211 (in German). E. D. Kaplan, \"Understanding GPS: Principles and Applications\",\n     Artech House, 1996. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: rvec position vector [km] real(kind=wp), intent(in) :: a geoid semimajor axis [km] real(kind=wp), intent(in) :: b geoid semiminor axis [km] real(kind=wp), intent(out) :: h geodetic altitude [km] real(kind=wp), intent(out) :: lon longitude [rad] real(kind=wp), intent(out) :: lat geodetic latitude [rad] Source Code pure subroutine heikkinen ( rvec , a , b , h , lon , lat ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: rvec !! position vector [km] real ( wp ), intent ( in ) :: a !! geoid semimajor axis [km] real ( wp ), intent ( in ) :: b !! geoid semiminor axis [km] real ( wp ), intent ( out ) :: h !! geodetic altitude [km] real ( wp ), intent ( out ) :: lon !! longitude [rad] real ( wp ), intent ( out ) :: lat !! geodetic latitude [rad] real ( wp ) :: f , e_2 , ep , r , e2 , ff , g , c , s , pp , q , r0 , u , v , z0 , x , y , z , z2 , r2 , tmp , a2 , b2 x = rvec ( 1 ) y = rvec ( 2 ) z = rvec ( 3 ) a2 = a * a b2 = b * b f = ( a - b ) / a e_2 = ( 2.0_wp * f - f * f ) ep = sqrt ( a2 / b2 - 1.0_wp ) z2 = z * z r = sqrt ( x ** 2 + y ** 2 ) r2 = r * r e2 = a2 - b2 ff = 5 4.0_wp * b2 * z2 g = r2 + ( 1.0_wp - e_2 ) * z2 - e_2 * e2 c = e_2 ** 2 * ff * r2 / g ** 3 s = ( 1.0_wp + c + sqrt ( c ** 2 + 2.0_wp * c )) ** ( 1.0_wp / 3.0_wp ) pp = ff / ( 3.0_wp * ( s + 1.0_wp / s + 1.0_wp ) ** 2 * g ** 2 ) q = sqrt ( 1.0_wp + 2.0_wp * e_2 ** 2 * pp ) r0 = - pp * e_2 * r / ( 1.0_wp + q ) + & sqrt ( max ( 0.0_wp , 1.0_wp / 2.0_wp * a2 * ( 1.0_wp + 1.0_wp / q ) - & ( pp * ( 1.0_wp - e_2 ) * z2 ) / ( q * ( 1.0_wp + q )) - & 1.0_wp / 2.0_wp * pp * r2 ) ) u = sqrt ( ( r - e_2 * r0 ) ** 2 + z2 ) v = sqrt ( ( r - e_2 * r0 ) ** 2 + ( 1.0_wp - e_2 ) * z2 ) z0 = b ** 2 * z / ( a * v ) h = u * ( 1.0_wp - b2 / ( a * v ) ) lat = atan2 ( ( z + ep ** 2 * z0 ), r ) lon = atan2 ( y , x ) end subroutine heikkinen","tags":"","url":"proc/heikkinen.html"},{"title":"olson – fortran-astrodynamics-toolkit","text":"public pure subroutine olson(rvec, a, b, h, long, lat) Olson routine for cartesian to geodetic transformation. References Olson, D. K., Converting Earth-Centered, Earth-Fixed Coordinates to\n     Geodetic Coordinates, IEEE Transactions on Aerospace and Electronic\n     Systems, 32 (1996) 473-476. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: rvec position vector [km] real(kind=wp), intent(in) :: a geoid semimajor axis [km] real(kind=wp), intent(in) :: b geoid semiminor axis [km] real(kind=wp), intent(out) :: h geodetic altitude [km] real(kind=wp), intent(out) :: long longitude [rad] real(kind=wp), intent(out) :: lat geodetic latitude [rad] Source Code pure subroutine olson ( rvec , a , b , h , long , lat ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: rvec !!position vector [km] real ( wp ), intent ( in ) :: a !!geoid semimajor axis [km] real ( wp ), intent ( in ) :: b !!geoid semiminor axis [km] real ( wp ), intent ( out ) :: h !!geodetic altitude [km] real ( wp ), intent ( out ) :: long !!longitude [rad] real ( wp ), intent ( out ) :: lat !!geodetic latitude [rad] real ( wp ) :: f , x , y , z , e2 , a1 , a2 , a3 , a4 , a5 , a6 , w , zp ,& w2 , r2 , r , s2 , c2 , u , v , s , ss , c , g , rg , rf , m , p , z2 x = rvec ( 1 ) y = rvec ( 2 ) z = rvec ( 3 ) f = ( a - b ) / a e2 = f * ( 2.0_wp - f ) a1 = a * e2 a2 = a1 * a1 a3 = a1 * e2 / 2.0_wp a4 = 2.5_wp * a2 a5 = a1 + a3 a6 = 1.0_wp - e2 zp = abs ( z ) w2 = x * x + y * y w = sqrt ( w2 ) z2 = z * z r2 = z2 + w2 r = sqrt ( r2 ) if ( r < 10 0.0_wp ) then lat = 0.0_wp long = 0.0_wp h = - 1.0e7_wp else s2 = z2 / r2 c2 = w2 / r2 u = a2 / r v = a3 - a4 / r if ( c2 > 0.3_wp ) then s = ( zp / r ) * ( 1.0_wp + c2 * ( a1 + u + s2 * v ) / r ) lat = asin ( s ) ss = s * s c = sqrt ( 1.0_wp - ss ) else c = ( w / r ) * ( 1.0_wp - s2 * ( a5 - u - c2 * v ) / r ) lat = acos ( c ) ss = 1.0_wp - c * c s = sqrt ( ss ) end if g = 1.0_wp - e2 * ss rg = a / sqrt ( g ) rf = a6 * rg u = w - rg * c v = zp - rf * s f = c * u + s * v m = c * v - s * u p = m / ( rf / g + f ) lat = lat + p if ( z < 0.0_wp ) lat = - lat h = f + m * p / 2.0_wp long = atan2 ( y , x ) end if end subroutine olson","tags":"","url":"proc/olson.html"},{"title":"direct – fortran-astrodynamics-toolkit","text":"public  subroutine direct(a, f, glat1, glon1, faz, s, glat2, glon2, baz) Solve the \"direct\" geodetic problem: given the latitude and longitude of one\n  point and the azimuth and distance to a second point, determine the latitude\n  and longitude of that second point.  The solution is obtained using the\n  algorithm by Vincenty. References T. Vincenty, \" Direct and Inverse Solutions of Geodesics on the\n     Ellipsoid with Application of Nested Equations \",\n     Survey Review XXII. 176, April 1975. PC Software Download - INVERSE and FORWARD ,\n     National Geodetic Survey. Version 3.0 (November, 2012). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a semimajor axis of ellipsoid [m] real(kind=wp), intent(in) :: f flattening of ellipsoid [-] real(kind=wp), intent(in) :: glat1 latitude of 1 [rad] real(kind=wp), intent(in) :: glon1 longitude of 1 [rad] real(kind=wp), intent(in) :: faz forward azimuth 1->2 [rad] real(kind=wp), intent(in) :: s distance from 1->2 [m] real(kind=wp), intent(out) :: glat2 latitude of 2 [rad] real(kind=wp), intent(out) :: glon2 longitude of 2 [rad] real(kind=wp), intent(out) :: baz back azimuth 2->1 [rad] Called by proc~~direct~~CalledByGraph proc~direct direct proc~direct_inverse_test direct_inverse_test proc~direct_inverse_test->proc~direct Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine direct ( a , f , glat1 , glon1 , faz , s , glat2 , glon2 , baz ) implicit none real ( wp ), intent ( in ) :: a !! semimajor axis of ellipsoid [m] real ( wp ), intent ( in ) :: f !! flattening of ellipsoid [-] real ( wp ), intent ( in ) :: glat1 !! latitude of 1 [rad] real ( wp ), intent ( in ) :: glon1 !! longitude of 1 [rad] real ( wp ), intent ( in ) :: faz !! forward azimuth 1->2 [rad] real ( wp ), intent ( in ) :: s !! distance from 1->2 [m] real ( wp ), intent ( out ) :: glat2 !! latitude of 2 [rad] real ( wp ), intent ( out ) :: glon2 !! longitude of 2 [rad] real ( wp ), intent ( out ) :: baz !! back azimuth 2->1 [rad] real ( wp ) :: r , tu , sf , cf , cu , su , sa , c2a , x , c , d , y , sy , cy , cz , e real ( wp ), parameter :: eps = 0.5e-13_wp r = 1.0_wp - f tu = r * sin ( glat1 ) / cos ( glat1 ) sf = sin ( faz ) cf = cos ( faz ) if ( cf /= 0.0_wp ) then baz = atan2 ( tu , cf ) * 2.0_wp else baz = 0.0_wp end if cu = 1.0_wp / sqrt ( tu * tu + 1.0_wp ) su = tu * cu sa = cu * sf c2a = - sa * sa + 1.0_wp x = sqrt (( 1.0_wp / r / r - 1.0_wp ) * c2a + 1.0_wp ) + 1.0_wp x = ( x - 2.0_wp ) / x c = 1.0_wp - x c = ( x * x / 4.0_wp + 1.0_wp ) / c d = ( 0.375_wp * x * x - 1.0_wp ) * x tu = s / r / a / c y = tu do sy = sin ( y ) cy = cos ( y ) cz = cos ( baz + y ) e = cz * cz * 2.0_wp - 1.0_wp c = y x = e * cy y = e + e - 1.0_wp y = ((( sy * sy * 4.0_wp - 3.0_wp ) * y * cz * d / 6.0_wp + x ) * d / 4.0_wp - cz ) * sy * d + tu if ( abs ( y - c ) <= eps ) exit end do baz = cu * cy * cf - su * sy c = r * sqrt ( sa * sa + baz * baz ) d = su * cy + cu * sy * cf glat2 = atan2 ( d , c ) c = cu * cy - su * sy * cf x = atan2 ( sy * sf , c ) c = (( - 3.0_wp * c2a + 4.0_wp ) * f + 4.0_wp ) * c2a * f / 1 6.0_wp d = (( e * cy * c + cz ) * sy * c + y ) * sa glon2 = glon1 + x - ( 1.0_wp - c ) * d * f baz = atan2 ( sa , baz ) + pi end subroutine direct","tags":"","url":"proc/direct.html"},{"title":"geodetic_to_cartesian – fortran-astrodynamics-toolkit","text":"public  subroutine geodetic_to_cartesian(a, b, glat, lon, h, r) Geodetic latitude, longitude, and height to Cartesian position vector. References E. D. Kaplan, \"Understanding GPS: Principles and Applications\",\n     Artech House, 1996. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a geoid semimajor axis [km] real(kind=wp), intent(in) :: b geoid semiminor axis [km] real(kind=wp), intent(in) :: glat geodetic latitude [rad] real(kind=wp), intent(in) :: lon longitude [rad] real(kind=wp), intent(in) :: h geodetic altitude [km] real(kind=wp), intent(out), dimension(3) :: r Cartesian position vector [x,y,z] Source Code subroutine geodetic_to_cartesian ( a , b , glat , lon , h , r ) implicit none real ( wp ), intent ( in ) :: a !! geoid semimajor axis [km] real ( wp ), intent ( in ) :: b !! geoid semiminor axis [km] real ( wp ), intent ( in ) :: glat !! geodetic latitude [rad] real ( wp ), intent ( in ) :: lon !! longitude [rad] real ( wp ), intent ( in ) :: h !! geodetic altitude [km] real ( wp ), dimension ( 3 ), intent ( out ) :: r !! Cartesian position vector [x,y,z] real ( wp ) :: e2 , slat , clat , slon , clon , tlat , ome2 , d , q , aod slat = sin ( glat ) clat = cos ( glat ) tlat = tan ( glat ) slon = sin ( lon ) clon = cos ( lon ) e2 = 1.0_wp - ( b * b ) / ( a * a ) ome2 = 1.0_wp - e2 d = sqrt ( 1.0_wp + ome2 * tlat * tlat ) q = sqrt ( 1.0_wp - e2 * slat * slat ) aod = a / d r ( 1 ) = aod * clon + h * clon * clat r ( 2 ) = aod * slon + h * slon * clat r ( 3 ) = a * ome2 * slat / q + h * slat end subroutine geodetic_to_cartesian","tags":"","url":"proc/geodetic_to_cartesian.html"},{"title":"inverse – fortran-astrodynamics-toolkit","text":"public  subroutine inverse(a, rf, b1, l1, b2, l2, faz, baz, s, it, sig, lam, kind) INVERSE computes the geodetic azimuth and distance between two points,\n  given their geographic positions. Version for long-line and antipodal cases.\n  Latitudes may be 90 degrees exactly. Reference T. Vincenty, \" Direct and Inverse Solutions of Geodesics on the Ellipsoid\n    with Application of Nested Equations \",\n    Survey Review XXII. 176, April 1975. inverse.for Version 3.0 (November, 2012). History Original programmed by thaddeus vincenty, 1975, 1976 Removed back side solution option, debugged, revised -- 2011may01 -- dgm\n    this version of code is interim -- antipodal boundary needs work Jacob Williams, 1/25/2016 : refactored into modern Fortran. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a Equatorial semimajor axis real(kind=wp), intent(in) :: rf reciprocal flattening (1/f) real(kind=wp), intent(in) :: b1 latitude of point 1 (rad, positive north) real(kind=wp), intent(in) :: l1 longitude of point 1 (rad, positive east) real(kind=wp), intent(in) :: b2 latitude of point 2 (rad, positive north) real(kind=wp), intent(in) :: l2 longitude of point 2 (rad, positive east) real(kind=wp), intent(out) :: faz Forward azimuth (rad, clockwise from north) real(kind=wp), intent(out) :: baz Back azimuth (rad, clockwise from north) real(kind=wp), intent(out) :: s Ellipsoidal distance integer, intent(out) :: it iteration count real(kind=wp), intent(out) :: sig spherical distance on auxiliary sphere real(kind=wp), intent(out) :: lam longitude difference on auxiliary sphere integer, intent(out) :: kind solution flag: kind=1, long-line; kind=2, antipodal Called by proc~~inverse~~CalledByGraph proc~inverse inverse proc~direct_inverse_test direct_inverse_test proc~direct_inverse_test->proc~inverse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine inverse ( a , rf , b1 , l1 , b2 , l2 , faz , baz , s , it , sig , lam , kind ) implicit none real ( wp ), intent ( in ) :: a !! Equatorial semimajor axis real ( wp ), intent ( in ) :: rf !! reciprocal flattening (1/f) real ( wp ), intent ( in ) :: b1 !! latitude of point 1 (rad, positive north) real ( wp ), intent ( in ) :: l1 !! longitude of point 1 (rad, positive east) real ( wp ), intent ( in ) :: b2 !! latitude of point 2 (rad, positive north) real ( wp ), intent ( in ) :: l2 !! longitude of point 2 (rad, positive east) real ( wp ), intent ( out ) :: faz !! Forward azimuth (rad, clockwise from north) real ( wp ), intent ( out ) :: baz !! Back azimuth (rad, clockwise from north) real ( wp ), intent ( out ) :: s !! Ellipsoidal distance integer , intent ( out ) :: it !! iteration count real ( wp ), intent ( out ) :: sig !! spherical distance on auxiliary sphere real ( wp ), intent ( out ) :: lam !! longitude difference on auxiliary sphere integer , intent ( out ) :: kind !! solution flag: kind=1, long-line; kind=2, antipodal real ( wp ) :: beta1 , beta2 , biga , bigb , bige , bigf , boa , c , cosal2 , coslam ,& cossig , costm , costm2 , cosu1 , cosu2 , d , dsig , ep2 , l , prev ,& sinal , sinlam , sinsig , sinu1 , sinu2 , tem1 , tem2 , temp , test , z real ( wp ), parameter :: tol = 1.0e-14_wp !! convergence tolerance real ( wp ), parameter :: eps = 1.0e-15_wp !! tolerance for zero boa = 1.0_wp - 1.0_wp / rf ! b/a beta1 = atan ( boa * tan ( b1 )) ! better reduced latitude sinu1 = sin ( beta1 ) cosu1 = cos ( beta1 ) beta2 = atan ( boa * tan ( b2 )) ! better reduced latitude sinu2 = sin ( beta2 ) cosu2 = cos ( beta2 ) l = l2 - l1 ! longitude difference [-pi,pi] if ( l > pi ) l = l - twopi if ( l <- pi ) l = l + twopi prev = l test = l it = 0 kind = 1 lam = l longline : do ! long-line loop (kind=1) sinlam = sin ( lam ) coslam = cos ( lam ) temp = cosu1 * sinu2 - sinu1 * cosu2 * coslam sinsig = sqrt (( cosu2 * sinlam ) ** 2 + temp ** 2 ) cossig = sinu1 * sinu2 + cosu1 * cosu2 * coslam sig = atan2 ( sinsig , cossig ) if ( abs ( sinsig ) < eps ) then sinal = cosu1 * cosu2 * sinlam / sign ( eps , sinsig ) else sinal = cosu1 * cosu2 * sinlam / sinsig endif cosal2 = - sinal ** 2 + 1.0_wp if ( abs ( cosal2 ) < eps ) then costm = - 2.0_wp * ( sinu1 * sinu2 / sign ( eps , cosal2 )) + cossig else costm = - 2.0_wp * ( sinu1 * sinu2 / cosal2 ) + cossig endif costm2 = costm * costm c = (( - 3.0_wp * cosal2 + 4.0_wp ) / rf + 4.0_wp ) * cosal2 / rf / 1 6.0_wp antipodal : do ! antipodal loop (kind=2) it = it + 1 d = ((( 2.0_wp * costm2 - 1.0_wp ) * cossig * c + costm ) * sinsig * c + sig ) * ( 1.0_wp - c ) / rf if ( kind == 1 ) then lam = l + d * sinal if ( abs ( lam - test ) >= tol ) then if ( abs ( lam ) > pi ) then kind = 2 lam = pi if ( l < 0.0_wp ) lam = - lam sinal = 0.0_wp cosal2 = 1.0_wp test = 2.0_wp prev = test sig = pi - abs ( atan ( sinu1 / cosu1 ) + atan ( sinu2 / cosu2 )) sinsig = sin ( sig ) cossig = cos ( sig ) c = (( - 3.0_wp * cosal2 + 4.0_wp ) / rf + 4.0_wp ) * cosal2 / rf / 1 6.0_wp if ( abs ( sinal - prev ) < tol ) exit longline if ( abs ( cosal2 ) < eps ) then costm = - 2.0_wp * ( sinu1 * sinu2 / sign ( eps , cosal2 )) + cossig else costm = - 2.0_wp * ( sinu1 * sinu2 / cosal2 ) + cossig endif costm2 = costm * costm cycle antipodal endif if ( (( lam - test ) * ( test - prev )) < 0.0_wp . and . it > 5 ) & lam = ( 2.0_wp * lam + 3.0_wp * test + prev ) / 6.0_wp ! refined converge. prev = test test = lam cycle longline endif else sinal = ( lam - l ) / d if ( (( sinal - test ) * ( test - prev )) < 0.0_wp . and . it > 5 ) & sinal = ( 2.0_wp * sinal + 3.0_wp * test + prev ) / 6.0_wp ! refined converge. prev = test test = sinal cosal2 = - sinal ** 2 + 1.0_wp sinlam = sinal * sinsig / ( cosu1 * cosu2 ) coslam = - sqrt ( abs ( - sinlam ** 2 + 1.0_wp )) lam = atan2 ( sinlam , coslam ) temp = cosu1 * sinu2 - sinu1 * cosu2 * coslam sinsig = sqrt (( cosu2 * sinlam ) ** 2 + temp ** 2 ) cossig = sinu1 * sinu2 + cosu1 * cosu2 * coslam sig = atan2 ( sinsig , cossig ) c = (( - 3.0_wp * cosal2 + 4.0_wp ) / rf + 4.0_wp ) * cosal2 / rf / 1 6.0_wp if ( abs ( sinal - prev ) >= tol ) then if ( abs ( cosal2 ) < eps ) then costm = - 2.0_wp * ( sinu1 * sinu2 / sign ( eps , cosal2 )) + cossig else costm = - 2.0_wp * ( sinu1 * sinu2 / cosal2 ) + cossig endif costm2 = costm * costm cycle antipodal endif endif exit longline !finished end do antipodal end do longline ! convergence if ( kind == 2 ) then ! antipodal faz = sinal / cosu1 baz = sqrt ( - faz ** 2 + 1.0_wp ) if ( temp < 0.0_wp ) baz = - baz faz = atan2 ( faz , baz ) tem1 = - sinal tem2 = sinu1 * sinsig - cosu1 * cossig * baz baz = atan2 ( tem1 , tem2 ) else ! long-line tem1 = cosu2 * sinlam tem2 = cosu1 * sinu2 - sinu1 * cosu2 * coslam faz = atan2 ( tem1 , tem2 ) tem1 = - cosu1 * sinlam tem2 = sinu1 * cosu2 - cosu1 * sinu2 * coslam baz = atan2 ( tem1 , tem2 ) endif if ( faz < 0.0_wp ) faz = faz + twopi if ( baz < 0.0_wp ) baz = baz + twopi ! helmert 1880 from vincenty \"geodetic inverse solution between antipodal points\" ep2 = 1.0_wp / ( boa * boa ) - 1.0_wp bige = sqrt ( 1.0_wp + ep2 * cosal2 ) bigf = ( bige - 1.0_wp ) / ( bige + 1.0_wp ) biga = ( 1.0_wp + bigf * bigf / 4.0_wp ) / ( 1.0_wp - bigf ) bigb = bigf * ( 1.0_wp - 0.375_wp * bigf * bigf ) z = bigb / 6.0_wp * costm * ( - 3.0_wp + 4.0_wp * sinsig ** 2 ) * ( - 3.0_wp + 4.0_wp * costm2 ) dsig = bigb * sinsig * ( costm + bigb / 4.0_wp * ( cossig * ( - 1.0_wp + 2.0_wp * costm2 ) - z )) s = ( boa * a ) * biga * ( sig - dsig ) end subroutine inverse","tags":"","url":"proc/inverse.html"},{"title":"geodetic_to_cartesian_triaxial – fortran-astrodynamics-toolkit","text":"public  subroutine geodetic_to_cartesian_triaxial(ax, ay, b, phi, lambda, h, r) Function computes the Cartesian coordinates given the\n  geodetic latitude (phi), longitude (lambda) and\n  height (h) of a point related to an ellipsoid\n  defined by its three semiaxes ax, ay and b History Jacob Williams, 10/29/2022 : Fortran verison of this algorithm,\n    based on the Matlab (v1.0 01/03/2019) code. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ax semiaxes (0 < b <= ay <= ax) real(kind=wp), intent(in) :: ay semiaxes (0 < b <= ay <= ax) real(kind=wp), intent(in) :: b semiaxes (0 < b <= ay <= ax) real(kind=wp), intent(in) :: phi geodetic latitude (radians) real(kind=wp), intent(in) :: lambda geodetic longitude (radians) real(kind=wp), intent(in) :: h geodetic height real(kind=wp), intent(out), dimension(3) :: r Cartesian position vector [x,y,z] Source Code subroutine geodetic_to_cartesian_triaxial ( ax , ay , b , phi , lambda , h , r ) real ( wp ), intent ( in ) :: ax !! semiaxes (0 < b <= ay <= ax) real ( wp ), intent ( in ) :: ay !! semiaxes (0 < b <= ay <= ax) real ( wp ), intent ( in ) :: b !! semiaxes (0 < b <= ay <= ax) real ( wp ), intent ( in ) :: phi !! geodetic latitude (radians) real ( wp ), intent ( in ) :: lambda !! geodetic longitude (radians) real ( wp ), intent ( in ) :: h !! geodetic height real ( wp ), dimension ( 3 ), intent ( out ) :: r !! Cartesian position vector [x,y,z] real ( wp ) :: ee2 , ex2 , N , cp , sp , cl , sl cp = cos ( phi ) sp = sin ( phi ) cl = cos ( lambda ) sl = sin ( lambda ) ee2 = ( ax * ax - ay * ay ) / ( ax * ax ) ex2 = ( ax * ax - b * b ) / ( ax * ax ) N = ax / sqrt ( one - ex2 * sp * sp - ee2 * cp * cp * sl * sl ) r = [( N + h ) * cp * cl , & ( N * ( one - ee2 ) + h ) * cp * sl , & ( N * ( one - ex2 ) + h ) * sp ] end subroutine geodetic_to_cartesian_triaxial","tags":"","url":"proc/geodetic_to_cartesian_triaxial.html"},{"title":"geodetic_to_cartesian_triaxial_2 – fortran-astrodynamics-toolkit","text":"public pure subroutine geodetic_to_cartesian_triaxial_2(a, b, c, lat, long, h, r) Geodetic to Cartesian for Triaxial Ellipsoid. References S. Bektas, \"Geodetic Computations on Triaxial Ellipsoid\",\n    International Journal of Mining Science (IJMS),\n    Volume 1, Issue 1, June 2015, p 25-34 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: b ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: c ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: lat latitude (rad) real(kind=wp), intent(in) :: long longitude (rad) real(kind=wp), intent(in) :: h altitude real(kind=wp), intent(out), dimension(3) :: r Cartesian coordinates (x,y,z) Called by proc~~geodetic_to_cartesian_triaxial_2~~CalledByGraph proc~geodetic_to_cartesian_triaxial_2 geodetic_to_cartesian_triaxial_2 proc~xyz2philambda xyz2philambda proc~xyz2philambda->proc~geodetic_to_cartesian_triaxial_2 proc~cartesian_to_geodetic_triaxial cartesian_to_geodetic_triaxial proc~cartesian_to_geodetic_triaxial->proc~xyz2philambda Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine geodetic_to_cartesian_triaxial_2 ( a , b , c , lat , long , h , r ) implicit none real ( wp ), intent ( in ) :: a !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: b !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: c !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: lat !! latitude (rad) real ( wp ), intent ( in ) :: long !! longitude (rad) real ( wp ), intent ( in ) :: h !! altitude real ( wp ), dimension ( 3 ), intent ( out ) :: r !! Cartesian coordinates (x,y,z) real ( wp ) :: ex2 , ee2 , v , a2 , clat , slat , clon , slon , omee2 , omex2 a2 = a * a ex2 = ( a2 - c ** 2 ) / a2 ee2 = ( a2 - b ** 2 ) / a2 clat = cos ( lat ) slat = sin ( lat ) clon = cos ( long ) slon = sin ( long ) omee2 = 1.0_wp - ee2 omex2 = 1.0_wp - ex2 v = a / sqrt ( 1.0_wp - ex2 * slat ** 2 - ee2 * clat ** 2 * slon ** 2 ) r = [( v + h ) * clon * clat , & ( v * omee2 + h ) * slon * clat , & ( v * omex2 + h ) * slat ] end subroutine geodetic_to_cartesian_triaxial_2","tags":"","url":"proc/geodetic_to_cartesian_triaxial_2.html"},{"title":"cartesian_to_geodetic_triaxial – fortran-astrodynamics-toolkit","text":"public  subroutine cartesian_to_geodetic_triaxial(ax, ay, b, r, tol, phi, lambda, h) Function computes the geodetic latitude (phi), longitude (lambda) and\n  height (h) of a point related to an ellipsoid\n  defined by its three semiaxes ax, ay and b (0 < b <= ay <= ax)\n  given Cartesian coordinates Xi, Yi, Zi and tolerance (tol).\n  Latitude and longitude are returned in radians. Reference G. Panou and R. Korakitis, \"Cartesian to geodetic coordinates conversion\n    on an ellipsoid using the bisection method\".\n    Journal of Geodesy volume 96, Article number: 66 (2022). (link) C++ code MATLAB code History Jacob Williams, 10/29/2022 : Fortran verison of this algorithm. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ax semiaxes (0 < b <= ay <= ax) real(kind=wp), intent(in) :: ay semiaxes (0 < b <= ay <= ax) real(kind=wp), intent(in) :: b semiaxes (0 < b <= ay <= ax) real(kind=wp), intent(in), dimension(3) :: r Cartesian coordinates (x,y,z) real(kind=wp), intent(in) :: tol tolerance (may be set to zero) real(kind=wp), intent(out) :: phi geodetic latitude (radians) real(kind=wp), intent(out) :: lambda geodetic longitude (radians) real(kind=wp), intent(out) :: h geodetic height Calls proc~~cartesian_to_geodetic_triaxial~~CallsGraph proc~cartesian_to_geodetic_triaxial cartesian_to_geodetic_triaxial proc~bisection_special_2 bisection_special_2 proc~cartesian_to_geodetic_triaxial->proc~bisection_special_2 proc~bisection_special_3 bisection_special_3 proc~cartesian_to_geodetic_triaxial->proc~bisection_special_3 proc~philambda_quadrant philambda_quadrant proc~cartesian_to_geodetic_triaxial->proc~philambda_quadrant proc~xyz2fl xyz2fl proc~cartesian_to_geodetic_triaxial->proc~xyz2fl proc~xyz2philambda xyz2philambda proc~cartesian_to_geodetic_triaxial->proc~xyz2philambda proc~geodetic_to_cartesian_triaxial_2 geodetic_to_cartesian_triaxial_2 proc~xyz2philambda->proc~geodetic_to_cartesian_triaxial_2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine cartesian_to_geodetic_triaxial ( ax , ay , b , r , tol , phi , lambda , h ) real ( wp ), intent ( in ) :: ax !! semiaxes (0 < b <= ay <= ax) real ( wp ), intent ( in ) :: ay !! semiaxes (0 < b <= ay <= ax) real ( wp ), intent ( in ) :: b !! semiaxes (0 < b <= ay <= ax) real ( wp ), dimension ( 3 ), intent ( in ) :: r !! Cartesian coordinates (x,y,z) real ( wp ), intent ( in ) :: tol !! tolerance (may be set to zero) real ( wp ), intent ( out ) :: phi !! geodetic latitude (radians) real ( wp ), intent ( out ) :: lambda !! geodetic longitude (radians) real ( wp ), intent ( out ) :: h !! geodetic height real ( wp ) :: kx , ky , cx , cy , cz , XX , YY , ZZ , x , y , z , Xo , Yo , Zo , m , Mm , axax , ayay , b2 integer :: n if ( ax < ay . or . ay < b ) error stop 'error in cartesian_to_geodetic_triaxial: invalid ax,ay,b' axax = ax * ax ayay = ay * ay b2 = b * b kx = ( axax - b2 ) / ax ky = ( ayay - b2 ) / ay cx = ( axax ) / ( b2 ) cy = ( ayay ) / ( b2 ) cz = ( axax ) / ( ayay ) XX = abs ( r ( 1 )) YY = abs ( r ( 2 )) ZZ = abs ( r ( 3 )) ! Compute geodetic latitude/longitude if ( ZZ == zero ) then if ( XX == zero . and . YY == zero ) then x = zero y = zero z = b else if ( ky * XX * ky * XX + kx * YY * kx * YY < kx * ky * kx * ky ) then x = ax * XX / kx y = ay * YY / ky z = b * sqrt ( one - (( x * x ) / ( axax )) - (( y * y ) / ( ayay ))) else if ( XX == zero ) then x = zero y = ay z = zero else if ( YY == zero ) then x = ax y = zero z = zero else Xo = XX / ax Yo = YY / ay call bisection_special_2 ( cz , Xo , Yo , tol , n , m , Mm ) x = cz * XX / ( cz + m ) y = YY / ( one + m ) z = zero end if else if ( XX == zero . and . YY == zero ) then x = zero y = zero z = b else Xo = XX / ax Yo = YY / ay Zo = ZZ / b call bisection_special_3 ( cx , cy , Xo , Yo , Zo , tol , n , m , Mm ) x = cx * XX / ( cx + m ) y = cy * YY / ( cy + m ) if ( m < zero . and . ky * XX * ky * XX + kx * YY * kx * YY < kx * ky * kx * ky ) then z = b * sqrt ( one - (( x * x ) / ( axax )) - (( y * y ) / ( ayay ))) else z = ZZ / ( one + m ) end if end if end if call xyz2fl ( ax , ay , b , x , y , z , phi , lambda ) ! analytic method used for initial guess call xyz2philambda ( ax , ay , b , x , y , z , phi , lambda ) ! iterative method call philambda_quadrant ( r ( 1 ), r ( 2 ), r ( 3 ), phi , lambda ) ! Compute geodetic height h = norm2 ([ XX - x , YY - y , ZZ - z ]) if (( XX + YY + ZZ ) < ( x + y + z )) h = - h end subroutine cartesian_to_geodetic_triaxial","tags":"","url":"proc/cartesian_to_geodetic_triaxial.html"},{"title":"bisection_special_2 – fortran-astrodynamics-toolkit","text":"private  subroutine bisection_special_2(cz, Xo, Yo, tol, n, m, Gm) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: cz real(kind=wp), intent(in) :: Xo real(kind=wp), intent(in) :: Yo real(kind=wp), intent(in) :: tol integer, intent(out) :: n real(kind=wp), intent(out) :: m real(kind=wp), intent(out) :: Gm Called by proc~~bisection_special_2~~CalledByGraph proc~bisection_special_2 bisection_special_2 proc~cartesian_to_geodetic_triaxial cartesian_to_geodetic_triaxial proc~cartesian_to_geodetic_triaxial->proc~bisection_special_2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine bisection_special_2 ( cz , Xo , Yo , tol , n , m , Gm ) real ( wp ), intent ( in ) :: cz , Xo , Yo , tol integer , intent ( out ) :: n real ( wp ), intent ( out ) :: m , Gm real ( wp ) :: d1 , Gd1 , d2 , d , MM d1 = - one + Yo Gd1 = ( cz * Xo * cz * Xo ) / (( cz + d1 ) * ( cz + d1 )) d2 = - one + sqrt ( cz * Xo * cz * Xo + Yo * Yo ) d = ( d2 - d1 ) / two n = 0 m = - two do while ( d > tol ) n = n + 1 MM = m m = d1 + d Gm = (( cz * Xo * cz * Xo ) / (( cz + m ) * ( cz + m ))) + (( Yo * Yo ) / (( one + m ) ** 2 )) - one if ( MM == m + tol . or . Gm == zero ) return if ( sign ( one , Gm ) == sign ( one , Gd1 )) then d1 = m Gd1 = Gm else d2 = m end if d = ( d2 - d1 ) / two end do n = n + 1 m = d1 + d Gm = (( cz * Xo * cz * Xo ) / (( cz + m ) * ( cz + m ))) + (( Yo * Yo ) / (( one + m ) ** 2 )) - one end subroutine bisection_special_2","tags":"","url":"proc/bisection_special_2.html"},{"title":"bisection_special_3 – fortran-astrodynamics-toolkit","text":"private  subroutine bisection_special_3(cx, cy, Xo, Yo, Zo, tol, n, m, Hm) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: cx real(kind=wp), intent(in) :: cy real(kind=wp), intent(in) :: Xo real(kind=wp), intent(in) :: Yo real(kind=wp), intent(in) :: Zo real(kind=wp), intent(in) :: tol integer, intent(out) :: n real(kind=wp), intent(out) :: m real(kind=wp), intent(out) :: Hm Called by proc~~bisection_special_3~~CalledByGraph proc~bisection_special_3 bisection_special_3 proc~cartesian_to_geodetic_triaxial cartesian_to_geodetic_triaxial proc~cartesian_to_geodetic_triaxial->proc~bisection_special_3 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine bisection_special_3 ( cx , cy , Xo , Yo , Zo , tol , n , m , Hm ) real ( wp ), intent ( in ) :: cx , cy , Xo , Yo , Zo , tol integer , intent ( out ) :: n real ( wp ), intent ( out ) :: m , Hm real ( wp ) :: d1 , Hd1 , d2 , d , MM d1 = - one + Zo Hd1 = (( cx * Xo * cx * Xo ) / (( cx + d1 ) * ( cx + d1 ))) + (( cy * Yo * cy * Yo ) / (( cy + d1 ) * ( cy + d1 ))) d2 = - one + sqrt ( cx * Xo * cx * Xo + cy * Yo * cy * Yo + Zo * Zo ) d = ( d2 - d1 ) / two n = 0 m = - two do while ( d > tol ) n = n + 1 MM = m m = d1 + d Hm = (( cx * Xo * cx * Xo ) / (( cx + m ) * ( cx + m ))) + (( cy * Yo * cy * Yo ) / & (( cy + m ) * ( cy + m ))) + (( Zo * Zo ) / (( one + m ) ** 2 )) - one if ( MM == m + tol . or . Hm == zero ) return if ( sign ( one , Hm ) == sign ( one , Hd1 )) then d1 = m Hd1 = Hm else d2 = m end if d = ( d2 - d1 ) / two end do n = n + 1 m = d1 + d Hm = (( cx * Xo * cx * Xo ) / (( cx + m ) * ( cx + m ))) + (( cy * Yo * cy * Yo ) / & (( cy + m ) * ( cy + m ))) + (( Zo * Zo ) / (( one + m ) ** 2 )) - one end subroutine bisection_special_3","tags":"","url":"proc/bisection_special_3.html"},{"title":"philambda_quadrant – fortran-astrodynamics-toolkit","text":"private  subroutine philambda_quadrant(x, y, z, phi, lambda) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(inout) :: phi real(kind=wp), intent(inout) :: lambda Called by proc~~philambda_quadrant~~CalledByGraph proc~philambda_quadrant philambda_quadrant proc~cartesian_to_geodetic_triaxial cartesian_to_geodetic_triaxial proc~cartesian_to_geodetic_triaxial->proc~philambda_quadrant proc~cartesianintogeodetici CartesianIntoGeodeticI proc~cartesianintogeodetici->proc~philambda_quadrant proc~cartesianintogeodeticii CartesianIntoGeodeticII proc~cartesianintogeodeticii->proc~philambda_quadrant Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine philambda_quadrant ( x , y , z , phi , lambda ) real ( wp ), intent ( in ) :: x , y , z real ( wp ), intent ( inout ) :: phi , lambda if ( z < zero ) then phi = - phi end if if ( x >= zero ) then if ( y >= zero ) then lambda = lambda else lambda = - lambda end if else if ( y >= zero ) then lambda = pi - lambda else lambda = lambda - pi end if end if end subroutine philambda_quadrant","tags":"","url":"proc/philambda_quadrant.html"},{"title":"xyz2philambda – fortran-astrodynamics-toolkit","text":"private  subroutine xyz2philambda(ax, ay, b, x, y, z, phi, lambda) Determination of the geodetic latitude and longitude Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ax real(kind=wp), intent(in) :: ay real(kind=wp), intent(in) :: b real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(inout) :: phi input is initial guess, output is refined values real(kind=wp), intent(inout) :: lambda input is initial guess, output is refined values Calls proc~~xyz2philambda~~CallsGraph proc~xyz2philambda xyz2philambda proc~geodetic_to_cartesian_triaxial_2 geodetic_to_cartesian_triaxial_2 proc~xyz2philambda->proc~geodetic_to_cartesian_triaxial_2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~xyz2philambda~~CalledByGraph proc~xyz2philambda xyz2philambda proc~cartesian_to_geodetic_triaxial cartesian_to_geodetic_triaxial proc~cartesian_to_geodetic_triaxial->proc~xyz2philambda Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine xyz2philambda ( ax , ay , b , x , y , z , phi , lambda ) real ( wp ), intent ( in ) :: ax , ay , b , x , y , z real ( wp ), intent ( inout ) :: phi , lambda !! input is initial guess, output is refined values real ( wp ) :: ee2 , ex2 , Sphi , Cphi , Slambda , Clambda ,& Den , NN , onemee2 , onemex2 , dndphi , dxdphi ,& dydphi , dzdphi , dndlam , dxdlam , dydlam , dzdlam integer :: n real ( wp ), dimension ( 3 , 2 ) :: J real ( wp ), dimension ( 2 , 3 ) :: Jt !! transpose of J real ( wp ), dimension ( 3 , 1 ) :: dl real ( wp ), dimension ( 2 , 2 ) :: Nmat , Ninv real ( wp ), dimension ( 2 , 1 ) :: dx real ( wp ), dimension ( 3 ) :: r0 ! real(wp) :: s0, SS0 ! real(wp),dimension(3,1) :: UU ! real(wp),dimension(1,1) :: tmp integer , parameter :: maxiter = 100 !! maximum number of iterations real ( wp ), parameter :: stop_tol = ten * epsilon ( one ) !! stopping tol for corrections ee2 = ( ax * ax - ay * ay ) / ( ax * ax ) ! eqn. 5 ex2 = ( ax * ax - b * b ) / ( ax * ax ) ! onemee2 = one - ee2 onemex2 = one - ex2 !s0 = zero do n = 1 , maxiter !SS0 = s0 ! Design Matrix J Sphi = sin ( phi ) Cphi = cos ( phi ) Slambda = sin ( lambda ) Clambda = cos ( lambda ) NN = ax / sqrt ( one - ex2 * Sphi * Sphi - ee2 * Cphi * Cphi * Slambda * Slambda ) ! eqn. 4 Den = two * ( one - ex2 * Sphi ** 2 - ee2 * Cphi ** 2 * Slambda ** 2 ) ** ( three / two ) dndphi = - ax * sin ( two * phi ) * ( ex2 - ee2 * Slambda ** 2 ) / Den dxdphi = ( dndphi * Cphi - NN * Sphi ) * Clambda dydphi = onemee2 * ( dndphi * Cphi - NN * Sphi ) * Slambda dzdphi = onemex2 * ( dndphi * Sphi + NN * Cphi ) dndlam = - ax * ee2 * Cphi ** 2 * sin ( two * lambda ) / Den dxdlam = ( dndlam * Clambda - NN * Slambda ) * Cphi dydlam = onemee2 * ( dndlam * Slambda + NN * Clambda ) * Cphi dzdlam = onemex2 * dndlam * Sphi J = reshape ([ dxdphi , dydphi , dzdphi , dxdlam , dydlam , dzdlam ],[ 3 , 2 ]) ! Vector dl call geodetic_to_cartesian_triaxial_2 ( ax , ay , b , phi , lambda , 0.0_wp , r0 ) ! just use the main one with alt=0 dl (:, 1 ) = [ x , y , z ] - r0 ! eqn. 51 ! Solution Jt = transpose ( J ) Nmat = matmul ( Jt , J ) ! eqn. 53 Ninv = ( one / ( Nmat ( 1 , 1 ) * Nmat ( 2 , 2 ) - Nmat ( 1 , 2 ) * Nmat ( 2 , 1 ))) * & reshape ([ Nmat ( 2 , 2 ), - Nmat ( 2 , 1 ), - Nmat ( 1 , 2 ), Nmat ( 1 , 1 )], [ 2 , 2 ]) ! eqn. 54 dx = matmul ( Ninv , matmul ( Jt , dl )) ! eqn. 52 phi = phi + dx ( 1 , 1 ) ! corrections. eqn. 55 lambda = lambda + dx ( 2 , 1 ) ! ! ! original: ! UU      = matmul(J,dx) - dl ! tmp     = sqrt(matmul(transpose(UU),UU)) ! s0      = tmp(1,1) ! if (s0 == SS0) exit ! JW: I think this is a better stopping criterion: if ( all ( abs ( dx ) <= stop_tol )) exit end do end subroutine xyz2philambda","tags":"","url":"proc/xyz2philambda.html"},{"title":"xyz2fl – fortran-astrodynamics-toolkit","text":"private  subroutine xyz2fl(ax, ay, b, x, y, z, latitude, longitude) Computes the transformation of Cartesian to geodetic coordinates on the surface of the ellipsoid\nassuming x,y,z are all non-negative\nAngular coordinates in radians This is based on the C++ version Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ax real(kind=wp), intent(in) :: ay real(kind=wp), intent(in) :: b real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(out) :: latitude real(kind=wp), intent(out) :: longitude Called by proc~~xyz2fl~~CalledByGraph proc~xyz2fl xyz2fl proc~cartesian_to_geodetic_triaxial cartesian_to_geodetic_triaxial proc~cartesian_to_geodetic_triaxial->proc~xyz2fl Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine xyz2fl ( ax , ay , b , x , y , z , latitude , longitude ) real ( wp ), intent ( in ) :: ax , ay , b , x , y , z real ( wp ), intent ( out ) :: latitude , longitude real ( wp ) :: nom , den , dex , xme , rot real ( wp ) :: ax2 , ay2 , b2 , Ex2 , Ee2 , lex2 , lee2 , mex , mee ! note: these could be precomputed: ax2 = ax * ax ay2 = ay * ay b2 = b * b Ex2 = ax2 - b2 Ee2 = ax2 - ay2 lex2 = Ex2 / ax2 lee2 = Ee2 / ax2 mex = one - lex2 mee = one - lee2 nom = mee * z xme = mee * x dex = xme * xme + y * y den = mex * sqrt ( dex ) rot = sqrt ( dex ) if ( den == zero ) then latitude = halfpi longitude = zero else if ( nom <= den ) then latitude = atan ( nom / den ) else latitude = halfpi - atan ( den / nom ) end if if ( y <= xme ) then den = xme + rot longitude = two * atan ( y / den ) else den = y + rot longitude = halfpi - two * atan ( xme / den ) end if end if end subroutine xyz2fl","tags":"","url":"proc/xyz2fl.html"},{"title":"horner – fortran-astrodynamics-toolkit","text":"private pure subroutine horner(B, c, BB) Horner's method to compute B(x-c) in terms of B(x) . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(0:6) :: B Polynomial B = B(6) x&#94;6 + B(5) x&#94;5 + ... + B(0) real(kind=wp), intent(in) :: c real(kind=wp), intent(out), dimension(0:6) :: BB Polynomial BB such that B(x-c) = BB(x) Called by proc~~horner~~CalledByGraph proc~horner horner proc~cartesianintogeodetici CartesianIntoGeodeticI proc~cartesianintogeodetici->proc~horner Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine horner ( B , c , BB ) real ( wp ), dimension ( 0 : 6 ), intent ( in ) :: B !! Polynomial `B = B(6) x&#94;6 + B(5) x&#94;5 + ... + B(0)` real ( wp ), intent ( in ) :: c real ( wp ), dimension ( 0 : 6 ), intent ( out ) :: BB !! Polynomial `BB` such that `B(x-c) = BB(x)` integer :: i , j !! counters BB = B do i = 0 , 6 do j = 5 , i , - 1 BB ( j ) = BB ( j ) - BB ( j + 1 ) * c end do end do end subroutine horner","tags":"","url":"proc/horner.html"},{"title":"CartesianIntoGeodeticI – fortran-astrodynamics-toolkit","text":"public  subroutine CartesianIntoGeodeticI(ax, ay, az, r, latitude, longitude, altitude, error) Cartesian to Geodetic I See also CartesianIntoGeodeticII Reference Gema Maria Diaz-Toca, Leandro Marin, Ioana Necula,\n    \"Direct transformation from Cartesian into geodetic coordinates on a triaxial ellipsoid\"\n    Computers & Geosciences, Volume 142, September 2020, 104551. link , C++ code [CC BY 4.0 License] Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ax semiaxes of the celestial body: ax>ay>az real(kind=wp), intent(in) :: ay semiaxes of the celestial body: ax>ay>az real(kind=wp), intent(in) :: az semiaxes of the celestial body: ax>ay>az real(kind=wp), intent(in), dimension(3) :: r cartesian coordinates of the considered point\nin the first octant: xG, yG, zG with (xG,yG,zG)<>(0,0,0) real(kind=wp), intent(out) :: latitude geodetic coordinates of the considered point real(kind=wp), intent(out) :: longitude geodetic coordinates of the considered point real(kind=wp), intent(out) :: altitude geodetic coordinates of the considered point real(kind=wp), intent(in) :: error Values smaller than error treated as 0.0 Calls proc~~cartesianintogeodetici~~CallsGraph proc~cartesianintogeodetici CartesianIntoGeodeticI proc~horner horner proc~cartesianintogeodetici->proc~horner proc~philambda_quadrant philambda_quadrant proc~cartesianintogeodetici->proc~philambda_quadrant proc~solve_polynomial solve_polynomial proc~cartesianintogeodetici->proc~solve_polynomial proc~special_cases special_cases proc~cartesianintogeodetici->proc~special_cases Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine CartesianIntoGeodeticI ( ax , ay , az , r , latitude , longitude , altitude , error ) real ( wp ), intent ( in ) :: ax , ay , az !! semiaxes of the celestial body: ax>ay>az real ( wp ), dimension ( 3 ), intent ( in ) :: r !! cartesian coordinates of the considered point !! in the first octant: xG, yG, zG with (xG,yG,zG)<>(0,0,0) real ( wp ), intent ( out ) :: latitude , longitude , altitude !! geodetic coordinates of the considered point real ( wp ), intent ( in ) :: error !! Values smaller than error treated as 0.0 real ( wp ) :: ax2 , ay2 , az2 , ax4 , ay4 , az4 , b5 , b4 , b3 , b3x , b3y , b3z ,& b2 , b2x , b2y , b2z , b1 , b1x , b1y , b1z , b0 , b0x , b0y , b0z , eec , exc real ( wp ) :: xg2 , yg2 , zg2 , aux , xG , yG , zG real ( wp ) :: xE , yE , zE , k , B ( 0 : 6 ), BB ( 0 : 6 ) logical :: done call special_cases ( ax , ay , az , r ( 1 ), r ( 2 ), r ( 3 ), latitude , longitude , altitude , done ) if ( done ) return ! Computations independent of xG,yG,zG. They can be precomputed, if necessary. ax2 = ax * ax ay2 = ay * ay az2 = az * az ax4 = ax2 * ax2 ay4 = ay2 * ay2 az4 = az2 * az2 b5 = 2.0_wp * ( ax2 + ay2 + az2 ) b4 = ax4 + 4.0_wp * ax2 * ay2 + ay4 + 4.0_wp * ax2 * az2 + 4.0_wp * ay2 * az2 + az4 b3 = 2.0_wp * ax4 * ay2 + 2.0_wp * ax2 * ay4 + 2.0_wp * ax4 * az2 + 8.0_wp * ax2 * ay2 * az2 + 2.0_wp * ay4 * az2 + 2.0_wp * ax2 * az4 + 2.0_wp * ay2 * az4 b3x = - 2.0_wp * ax2 * ay2 - 2.0_wp * ax2 * az2 b3y = - 2.0_wp * ax2 * ay2 - 2.0_wp * ay2 * az2 b3z = - 2.0_wp * ay2 * az2 - 2.0_wp * ax2 * az2 b2 = 4.0_wp * ax4 * ay2 * az2 + 4.0_wp * ax2 * ay4 * az2 + ax4 * az4 + 4.0_wp * ax2 * ay2 * az4 + ax4 * ay4 + ay4 * az4 b2x = - ax2 * ay4 - 4.0_wp * ax2 * ay2 * az2 - ax2 * az4 b2y = - ax4 * ay2 - 4.0_wp * ax2 * ay2 * az2 - ay2 * az4 b2z = - ax4 * az2 - 4.0_wp * ax2 * ay2 * az2 - ay4 * az2 b1 = 2.0_wp * ax4 * ay4 * az2 + 2.0_wp * ax4 * ay2 * az4 + 2.0_wp * ax2 * ay4 * az4 b1x = - 2.0_wp * ax2 * ay4 * az2 - 2.0_wp * ax2 * ay2 * az4 b1y = - 2.0_wp * ax4 * ay2 * az2 - 2.0_wp * ax2 * ay2 * az4 b1z = - 2.0_wp * ax4 * ay2 * az2 - 2.0_wp * ax2 * ay4 * az2 b0 = ax4 * ay4 * az4 b0x = - ax2 * ay4 * az4 b0y = - ax4 * ay2 * az4 b0z = - ax4 * ay4 * az2 eec = ( ax2 - ay2 ) / ax2 exc = ( ax2 - az2 ) / ax2 ! Computations dependant of xG, yG, zG xG = abs ( r ( 1 )) yG = abs ( r ( 2 )) zG = abs ( r ( 3 )) xg2 = xG * xG yg2 = yG * yG zg2 = zG * zG aux = xg2 / ax2 + yg2 / ay2 + zg2 / az2 B = [ b0 + b0x * xg2 + b0y * yg2 + b0z * zg2 , & b1 + b1x * xg2 + b1y * yg2 + b1z * zg2 , & b2 + b2x * xg2 + b2y * yg2 + b2z * zg2 , & b3 + b3x * xg2 + b3y * yg2 + b3z * zg2 , & b4 - ( ax2 * xg2 + ay2 * yg2 + az2 * zg2 ), & b5 , & 1.0_wp ] if ( abs ( aux - 1.0_wp ) < error ) then ! The point is on the ellipsoid xE = xG yE = yG zE = zG else if ( aux > 1.0_wp ) then ! The point is outside the ellipsoid k = solve_polynomial ( B ,( xg2 + yg2 + zg2 ) / 3.0_wp , error ) xE = ax2 * xG / ( ax2 + k ) yE = ay2 * yG / ( ay2 + k ) zE = az2 * zG / ( az2 + k ) else if ( zG > 0.0_wp ) then ! The point  is inside the ellipsoid and zG>0 call horner ( B , az2 , BB ) ! B(x-az2) = BB(x) k = solve_polynomial ( BB ,( xg2 + yg2 + zg2 ) / 3.0_wp + az2 , error ) - az2 xE = ax2 * xG / ( ax2 + k ) yE = ay2 * yG / ( ay2 + k ) zE = az2 * zG / ( az2 + k ) else if ( xG > 0.0_wp . and . yG > 0.0_wp ) then ! The point is inside the ellipsoid and zG=0, yG > 0, xG > 0 call horner ( B , ay2 , BB ) k = solve_polynomial ( BB ,( xg2 + yg2 + zg2 ) / 3.0_wp + ay2 , error ) - ay2 xE = ax2 * xG / ( ax2 + k ) yE = ay2 * yG / ( ay2 + k ) zE = 0.0_wp else if ( xG < error . and . yG > 0.0_wp ) then xE = 0.0_wp yE = ay zE = 0.0_wp else if ( xG > 0.0_wp . and . yG < error ) then xE = ax yE = 0.0_wp zE = 0.0_wp end if ! Computing longitude if ( xG > 0.0_wp ) then longitude = atan ( yE / (( 1.0_wp - eec ) * xE )) else if ( yG > 0.0_wp ) then longitude = halfpi else longitude = huge ( 1.0_wp ) ! undefined end if ! Computing latitude if ( xE > 0.0_wp . or . yE > 0.0_wp ) then latitude = atan (( 1.0_wp - eec ) / ( 1.0_wp - exc ) * zE / norm2 ([ xE * ( 1.0_wp - eec ), yE ])) else latitude = halfpi end if ! Computing altitude if ( aux >= 1.0_wp ) then altitude = norm2 ([ xE - xG , yE - yG , zE - zG ]) else altitude = - norm2 ([ xE - xG , yE - yG , zE - zG ]) end if call philambda_quadrant ( r ( 1 ), r ( 2 ), r ( 3 ), latitude , longitude ) end subroutine CartesianIntoGeodeticI","tags":"","url":"proc/cartesianintogeodetici.html"},{"title":"CartesianIntoGeodeticII – fortran-astrodynamics-toolkit","text":"public  subroutine CartesianIntoGeodeticII(ax, ay, az, r, latitude, longitude, altitude, error) Cartesian into Geodetic II See also CartesianIntoGeodeticI Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ax semiaxes of the celestial body: ax>ay>az real(kind=wp), intent(in) :: ay semiaxes of the celestial body: ax>ay>az real(kind=wp), intent(in) :: az semiaxes of the celestial body: ax>ay>az real(kind=wp), intent(in), dimension(3) :: r cartesian coordinates of the considered point\nin the first octant: xG, yG, zG with (xG,yG,zG)<>(0,0,0) real(kind=wp), intent(out) :: latitude geodetic coordinates of the considered point real(kind=wp), intent(out) :: longitude geodetic coordinates of the considered point real(kind=wp), intent(out) :: altitude geodetic coordinates of the considered point real(kind=wp), intent(in) :: error Values smaller than error treated as 0.0 Calls proc~~cartesianintogeodeticii~~CallsGraph proc~cartesianintogeodeticii CartesianIntoGeodeticII proc~philambda_quadrant philambda_quadrant proc~cartesianintogeodeticii->proc~philambda_quadrant proc~solve_polynomial solve_polynomial proc~cartesianintogeodeticii->proc~solve_polynomial proc~special_cases special_cases proc~cartesianintogeodeticii->proc~special_cases Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine CartesianIntoGeodeticII ( ax , ay , az , r , latitude , longitude , altitude , error ) real ( wp ), intent ( in ) :: ax , ay , az !! semiaxes of the celestial body: ax>ay>az real ( wp ), dimension ( 3 ), intent ( in ) :: r !! cartesian coordinates of the considered point !! in the first octant: xG, yG, zG with (xG,yG,zG)<>(0,0,0) real ( wp ), intent ( out ) :: latitude , longitude , altitude !! geodetic coordinates of the considered point real ( wp ), intent ( in ) :: error !! Values smaller than error treated as 0.0 real ( wp ) :: aymaz , aypaz , axmaz , axpaz , axpaz2 , ax2 , ay2 , az2 , ax4 , ay4 , az4 , az6 ,& az8 , temp0 , temp1 , temp2 , temp3 , temp4 , temp5 , temp6 , temp7 , temp8 ,& temp9 , tempa , az6ax2 , az6ay2 , tempb , maz10 , excc , eecc real ( wp ) :: xg2 , yg2 , zg2 , zgxg2 , zgyg2 , zg3 , zg4 , aux , xG , yG , zG real ( wp ) :: xE , yE , zE , k , B ( 0 : 6 ) logical :: done call special_cases ( ax , ay , az , r ( 1 ), r ( 2 ), r ( 3 ), latitude , longitude , altitude , done ) if ( done ) return ! Computations independent of xG,yG,zG. They can be precomputed, if necessary. aymaz = ay - az aypaz = ay + az axmaz = ax - az axpaz = ax + az axpaz2 = axpaz * axpaz ax2 = ax * ax ay2 = ay * ay az2 = az * az ax4 = ax2 * ax2 ay4 = ay2 * ay2 az4 = az2 * az2 az6 = az4 * az2 az8 = az4 * az4 temp0 = aymaz * aymaz * aypaz * aypaz * axmaz * axmaz * axpaz2 temp1 = 2 * az2 * aymaz * aypaz * axmaz * axpaz * ( ax2 + ay2 - 2 * az2 ) temp2 = - az2 * ( ax4 * ay4 - 2 * ax4 * ay2 * az2 + ax4 * az4 - 2 * ax2 * ay4 * az2 + 4 * ax2 * ay2 * az4 - 2 * ay2 * az6 + az8 - 2 * ax2 * az6 + ay4 * az4 ) temp3 = - az2 * ( - ax2 * ay4 + 2 * ax2 * ay2 * az2 - ax2 * az4 ) temp4 = - az2 * ( - ax4 * ay2 + 2 * ax2 * ay2 * az2 - ay2 * az4 ) temp5 = - az2 * ( - ax4 * az2 - 4 * ax2 * ay2 * az2 + 6 * ax2 * az4 - ay4 * az2 + 6 * ay2 * az4 - 6 * az6 ) temp6 = - 2 * az4 * ( ax4 * ay2 - ax4 * az2 + ax2 * ay4 - 4 * ax2 * ay2 * az2 + 3 * ax2 * az4 - ay4 * az2 + 3 * ay2 * az4 - 2 * az6 ) temp7 = - 2 * az4 * ( - ax2 * ay2 + ax2 * az2 ) temp8 = - 2 * az4 * ( - ax2 * ay2 + ay2 * az2 ) temp9 = - 2 * az4 * ( - ax2 * az2 - ay2 * az2 + 2 * az4 ) tempa = - az6 * ( ax4 + 4 * ax2 * ay2 - 6 * ax2 * az2 + ay4 - 6 * ay2 * az2 + 6 * az4 ) az6ax2 = az6 * ax2 az6ay2 = az6 * ay2 tempb = - 2 * az8 * ( ax2 + ay2 - 2 * az2 ) maz10 = - az6 * az4 excc = ( ax2 - az2 ) / ( ax2 ) eecc = ( ax2 - ay2 ) / ( ax2 ) xG = abs ( r ( 1 )) yG = abs ( r ( 2 )) zG = abs ( r ( 3 )) xg2 = xG * xG yg2 = yG * yG zg2 = zG * zG zgxg2 = zG * xg2 zgyg2 = zG * yg2 zg3 = zg2 * zG zg4 = zg2 * zg2 aux = xg2 / ax2 + yg2 / ay2 + zg2 / az2 if ( abs ( aux - 1.0_wp ) < error ) then ! The point is on the ellipsoid xE = xG yE = yG zE = zG else if ( zG > error ) then ! The point is inside or outside the ellipsoid with zG != 0 B ( 6 ) = temp0 B ( 5 ) = temp1 * zG B ( 4 ) = temp2 + temp3 * xg2 + temp4 * yg2 + temp5 * zg2 B ( 3 ) = zG * temp6 + temp7 * zgxg2 + temp8 * zgyg2 + temp9 * zg3 B ( 2 ) = zg2 * ( tempa + az6ax2 * xg2 + az6ay2 * yg2 + az8 * zg2 ) B ( 1 ) = tempb * zg3 B ( 0 ) = maz10 * zg4 k = solve_polynomial ( B , az * zG / norm2 ([ xG , yG , zG ]), error ) xE = ax2 * xG * k / ( ax2 * k - az2 * k + az2 * zG ) yE = ay2 * yG * k / ( ay2 * k - az2 * k + az2 * zG ) zE = k else if ( yG > error ) then B = [ - ay4 * ay2 * zg2 , & - 2 * ay4 * ( ax2 - ay2 ) * zG , & - ay2 * ( ax4 - 2 * ax2 * ay2 - ax2 * yg2 + ay4 - ay2 * zg2 ), & 2 * ay2 * ( ax2 - ay2 ) * zG , & ax4 + ay4 - 2 * ax2 * ay2 , & 0.0_wp , & 0.0_wp ] k = solve_polynomial ( B , ay * yG / norm2 ([ xG , yG , zG ]), error ) xE = k * ax2 * xG / ( ax2 * k - ay2 * k + ay2 * yG ) yE = k zE = 0.0_wp else xE = ax yE = 0.0_wp zE = 0.0_wp end if ! Computing longitude if ( xG > 0.0_wp ) then longitude = atan ( yE / (( 1.0_wp - eecc ) * xE )) else if ( yG > 0.0_wp ) then longitude = halfpi else longitude = huge ( 1.0_wp ) ! undefined end if ! Computing latitude if ( xE > 0.0_wp . or . yE > 0.0_wp ) then latitude = atan (( 1.0_wp - eecc ) / ( 1.0_wp - excc ) * zE / norm2 ([ xE * ( 1.0_wp - eecc ), yE ])) else latitude = halfpi end if ! Computing altitude if ( aux >= 1.0 ) then altitude = norm2 ([ xE - xG , yE - yG , zE - zG ]) else altitude = - norm2 ([ xE - xG , yE - yG , zE - zG ]) end if call philambda_quadrant ( r ( 1 ), r ( 2 ), r ( 3 ), latitude , longitude ) end subroutine CartesianIntoGeodeticII","tags":"","url":"proc/cartesianintogeodeticii.html"},{"title":"cartesian_to_geodetic_triaxial_2 – fortran-astrodynamics-toolkit","text":"public  subroutine cartesian_to_geodetic_triaxial_2(a, b, c, r, eps, phi, lambda, h) Cartesian to geodetic for Triaxial Ellipsoid. References S. Bektas, \"Geodetic Computations on Triaxial Ellipsoid\",\n    International Journal of Mining Science (IJMS),\n    Volume 1, Issue 1, June 2015, p 25-34 Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: b ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: c ellipsoid radii a >= b >= c real(kind=wp), intent(in), dimension(3) :: r Cartesian coordinates (x,y,z) real(kind=wp), intent(in) :: eps convergence tolerance real(kind=wp), intent(out) :: phi latitude (rad) real(kind=wp), intent(out) :: lambda longitude (rad) real(kind=wp), intent(out) :: h altitude Calls proc~~cartesian_to_geodetic_triaxial_2~~CallsGraph proc~cartesian_to_geodetic_triaxial_2 cartesian_to_geodetic_triaxial_2 proc~special_cases special_cases proc~cartesian_to_geodetic_triaxial_2->proc~special_cases Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine cartesian_to_geodetic_triaxial_2 ( a , b , c , r , eps , phi , lambda , h ) implicit none real ( wp ), intent ( in ) :: a !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: b !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: c !! ellipsoid radii `a >= b >= c` real ( wp ), dimension ( 3 ), intent ( in ) :: r !! Cartesian coordinates (x,y,z) real ( wp ), intent ( in ) :: eps !! convergence tolerance real ( wp ), intent ( out ) :: phi !! latitude (rad) real ( wp ), intent ( out ) :: lambda !! longitude (rad) real ( wp ), intent ( out ) :: h !! altitude integer , parameter :: maxiter = 20 !! maximum number of iterations integer :: i !! iteration counter real ( wp ), dimension ( 3 , 3 ) :: AA real ( wp ), dimension ( 3 ) :: bvec , xvec real ( wp ) :: a2 , b2 , c2 , x , y , z , ex2 , ee2 , e , f , g , xo , yo , zo , j11 , j12 , j21 , j23 , rmag , omee2 logical :: success x = r ( 1 ) y = r ( 2 ) z = r ( 3 ) if ( a < b . or . b < c ) error stop 'error in cartesian_to_geodetic_triaxial_2: invalid a,b,c' call special_cases ( a , b , c , x , y , z , phi , lambda , h , success ) if ( success ) return rmag = norm2 ( r ) a2 = a * a b2 = b * b c2 = c * c ex2 = ( a2 - c2 ) / a2 ee2 = ( a2 - b2 ) / a2 omee2 = one - ee2 E = one / a2 F = one / b2 G = one / c2 xo = a * x / rmag yo = b * y / rmag zo = c * z / rmag do i = 1 , maxiter j11 = F * yo - ( yo - y ) * E j12 = ( xo - x ) * F - E * xo j21 = G * zo - ( zo - z ) * E j23 = ( xo - x ) * G - E * xo ! solve the linear system: AA = reshape ( - [ j11 , j21 , two * E * xo ,& j12 , zero , two * F * yo ,& zero , j23 , two * G * zo ], [ 3 , 3 ]) bvec = [ ( xo - x ) * F * yo - ( yo - y ) * E * xo , & ( xo - x ) * G * zo - ( zo - z ) * E * xo , & E * xo ** 2 + F * yo ** 2 + G * zo ** 2 - one ] call linear_solver ( AA , bvec , xvec , success ) if (. not . success ) then write ( * , * ) 'error in cartesian_to_geodetic_triaxial_2: matrix is singular' phi = zero lambda = zero h = zero return end if xo = xo + xvec ( 1 ) yo = yo + xvec ( 2 ) zo = zo + xvec ( 3 ) if ( maxval ( abs ( xvec )) < eps ) exit end do ! outputs: phi = atan ( zo * omee2 / ( one - ex2 ) / sqrt ( omee2 ** 2 * xo ** 2 + yo ** 2 )) lambda = atan2 ( yo , omee2 * xo ) h = sign ( one , z - zo ) * sign ( one , zo ) * sqrt (( x - xo ) ** 2 + ( y - yo ) ** 2 + ( z - zo ) ** 2 ) contains subroutine linear_solver ( a , b , x , success ) !!  Solve the 3x3 system: `A * x = b` !!  Reference: https://caps.gsfc.nasa.gov/simpson/software/m33inv_f90.txt implicit none real ( wp ), dimension ( 3 , 3 ), intent ( in ) :: a real ( wp ), dimension ( 3 ), intent ( in ) :: b real ( wp ), dimension ( 3 ), intent ( out ) :: x logical , intent ( out ) :: success real ( wp ) :: det !! determinant of a real ( wp ), dimension ( 3 , 3 ) :: adj !! adjoint of a real ( wp ), dimension ( 3 , 3 ) :: ainv !! inverse of a det = a ( 1 , 1 ) * a ( 2 , 2 ) * a ( 3 , 3 ) & - a ( 1 , 1 ) * a ( 2 , 3 ) * a ( 3 , 2 ) & - a ( 1 , 2 ) * a ( 2 , 1 ) * a ( 3 , 3 ) & + a ( 1 , 2 ) * a ( 2 , 3 ) * a ( 3 , 1 ) & + a ( 1 , 3 ) * a ( 2 , 1 ) * a ( 3 , 2 ) & - a ( 1 , 3 ) * a ( 2 , 2 ) * a ( 3 , 1 ) success = abs ( det ) > tiny ( 1.0_wp ) ! check for singularity if ( success ) then adj (:, 1 ) = [ a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 2 ),& a ( 2 , 3 ) * a ( 3 , 1 ) - a ( 2 , 1 ) * a ( 3 , 3 ),& a ( 2 , 1 ) * a ( 3 , 2 ) - a ( 2 , 2 ) * a ( 3 , 1 )] adj (:, 2 ) = [ a ( 1 , 3 ) * a ( 3 , 2 ) - a ( 1 , 2 ) * a ( 3 , 3 ),& a ( 1 , 1 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 1 ),& a ( 1 , 2 ) * a ( 3 , 1 ) - a ( 1 , 1 ) * a ( 3 , 2 )] adj (:, 3 ) = [ a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 ),& a ( 1 , 3 ) * a ( 2 , 1 ) - a ( 1 , 1 ) * a ( 2 , 3 ),& a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 )] ainv = adj / det x = matmul ( ainv , b ) else x = zero end if end subroutine linear_solver end subroutine cartesian_to_geodetic_triaxial_2","tags":"","url":"proc/cartesian_to_geodetic_triaxial_2.html"},{"title":"special_cases – fortran-astrodynamics-toolkit","text":"private  subroutine special_cases(a, b, c, x, y, z, phi, lambda, h, done) Special cases for lat/lon/altitude Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: b ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: c ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: x Cartesian x coordinate real(kind=wp), intent(in) :: y Cartesian y coordinate real(kind=wp), intent(in) :: z Cartesian z coordinate real(kind=wp), intent(out) :: phi latitude (rad) real(kind=wp), intent(out) :: lambda longitude (rad) real(kind=wp), intent(out) :: h altitude logical, intent(out) :: done true if one of the special cases was computed Called by proc~~special_cases~~CalledByGraph proc~special_cases special_cases proc~cartesian_to_geodetic_triaxial_2 cartesian_to_geodetic_triaxial_2 proc~cartesian_to_geodetic_triaxial_2->proc~special_cases proc~cartesianintogeodetici CartesianIntoGeodeticI proc~cartesianintogeodetici->proc~special_cases proc~cartesianintogeodeticii CartesianIntoGeodeticII proc~cartesianintogeodeticii->proc~special_cases Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine special_cases ( a , b , c , x , y , z , phi , lambda , h , done ) real ( wp ), intent ( in ) :: a !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: b !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: c !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: x !! Cartesian x coordinate real ( wp ), intent ( in ) :: y !! Cartesian y coordinate real ( wp ), intent ( in ) :: z !! Cartesian z coordinate real ( wp ), intent ( out ) :: phi !! latitude (rad) real ( wp ), intent ( out ) :: lambda !! longitude (rad) real ( wp ), intent ( out ) :: h !! altitude logical , intent ( out ) :: done !! true if one of the special cases was computed logical :: x0 , y0 , z0 real ( wp ), parameter :: zero_tol = 1 0.0_wp * epsilon ( 1.0_wp ) !! zero tolerance for singularities x0 = abs ( x ) <= zero_tol y0 = abs ( y ) <= zero_tol z0 = abs ( z ) <= zero_tol if ( x0 . and . y0 . and . z0 ) then ! center of the body phi = zero lambda = zero h = - c ! just pick this value done = . true . return else if ( x0 . and . y0 ) then ! (on the z-axis) if ( z >= zero ) then phi = halfpi lambda = zero h = z - c else phi = - halfpi lambda = zero h = - ( z + c ) end if done = . true . return else if ( x0 . and . z0 ) then ! on the y-axis if ( y >= zero ) then phi = zero lambda = halfpi h = y - b else phi = zero lambda = - halfpi h = - ( y + b ) end if done = . true . return else if ( y0 . and . z0 ) then ! on the x-axis if ( x >= zero ) then phi = zero lambda = zero h = x - a else phi = zero lambda = pi h = - ( x + a ) end if done = . true . return end if phi = zero lambda = zero h = zero done = . false . end subroutine special_cases","tags":"","url":"proc/special_cases.html"},{"title":"direct_inverse_test – fortran-astrodynamics-toolkit","text":"public  subroutine direct_inverse_test() Unit test for the direct and inverse geodetic routines. Arguments None Calls proc~~direct_inverse_test~~CallsGraph proc~direct_inverse_test direct_inverse_test proc~direct direct proc~direct_inverse_test->proc~direct proc~inverse inverse proc~direct_inverse_test->proc~inverse Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine direct_inverse_test () implicit none !Ellipsoid : GRS80 / WGS84 (NAD83) real ( wp ), parameter :: a = 637813 7.0000_wp !! Equatorial radius real ( wp ), parameter :: rf = 29 8.25722210088_wp !! Inverse flattening real ( wp ), parameter :: f = 1.0_wp / rf !! flattening real ( wp ) :: glat1 , glon1 , glat2 , glon2 , faz , baz , s , sig , lam , glat2_ , glon2_ , baz_ integer :: it , kind write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' direct_inverse_test' write ( * , * ) '---------------' write ( * , * ) '' !specify two points: glat1 = 0.523599_wp glon1 = 1.74533_wp glat2 = 0.698132_wp glon2 = 2.0944_wp call inverse ( a , rf , glat1 , glon1 , glat2 , glon2 , faz , baz , s , it , sig , lam , kind ) call direct ( a , f , glat1 , glon1 , faz , s , glat2_ , glon2_ , baz_ ) write ( * , * ) 'lat error: ' , glat2_ - glat2 write ( * , * ) 'lon error: ' , glon2_ - glon2 write ( * , * ) 'baz error: ' , baz_ - baz end subroutine direct_inverse_test","tags":"","url":"proc/direct_inverse_test.html"},{"title":"norm2_func – fortran-astrodynamics-toolkit","text":"public pure function norm2_func(x) result(xmag) Use intrinsic norm2(x) for computing the vector norm. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Return Value real(kind=wp) Source Code pure function norm2_func ( x ) result ( xmag ) implicit none real ( wp ), dimension (:), intent ( in ) :: x real ( wp ) :: xmag xmag = norm2 ( x ) end function norm2_func","tags":"","url":"proc/norm2_func.html"},{"title":"maxval_func – fortran-astrodynamics-toolkit","text":"public pure function maxval_func(x) result(xmag) Use maxval(abs(x)) for computing the vector norm. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Return Value real(kind=wp) Source Code pure function maxval_func ( x ) result ( xmag ) implicit none real ( wp ), dimension (:), intent ( in ) :: x real ( wp ) :: xmag xmag = maxval ( abs ( x )) end function maxval_func","tags":"","url":"proc/maxval_func.html"},{"title":"rkf78_order – fortran-astrodynamics-toolkit","text":"private pure function rkf78_order(me) result(p) Returns the order of the rkf78 method. Type Bound rkf78_class Arguments Type Intent Optional Attributes Name class( rkf78_class ), intent(in) :: me Return Value integer order of the method Source Code pure function rkf78_order ( me ) result ( p ) implicit none class ( rkf78_class ), intent ( in ) :: me integer :: p !! order of the method p = 7 end function rkf78_order","tags":"","url":"proc/rkf78_order.html"},{"title":"rkf89_order – fortran-astrodynamics-toolkit","text":"private pure function rkf89_order(me) result(p) Returns the order of the rkf89 method. Type Bound rkf89_class Arguments Type Intent Optional Attributes Name class( rkf89_class ), intent(in) :: me Return Value integer order of the method Source Code pure function rkf89_order ( me ) result ( p ) implicit none class ( rkf89_class ), intent ( in ) :: me integer :: p !! order of the method p = 8 end function rkf89_order","tags":"","url":"proc/rkf89_order.html"},{"title":"rkv89_order – fortran-astrodynamics-toolkit","text":"private pure function rkv89_order(me) result(p) Returns the order of the rkv89 method. Type Bound rkv89_class Arguments Type Intent Optional Attributes Name class( rkv89_class ), intent(in) :: me Return Value integer order of the method Source Code pure function rkv89_order ( me ) result ( p ) implicit none class ( rkv89_class ), intent ( in ) :: me integer :: p !! order of the method p = 8 end function rkv89_order","tags":"","url":"proc/rkv89_order.html"},{"title":"rkf108_order – fortran-astrodynamics-toolkit","text":"private pure function rkf108_order(me) result(p) Returns the order of the rkf108 method. Type Bound rkf108_class Arguments Type Intent Optional Attributes Name class( rkf108_class ), intent(in) :: me Return Value integer order of the method Source Code pure function rkf108_order ( me ) result ( p ) implicit none class ( rkf108_class ), intent ( in ) :: me integer :: p !! order of the method p = 10 end function rkf108_order","tags":"","url":"proc/rkf108_order.html"},{"title":"rkf1210_order – fortran-astrodynamics-toolkit","text":"private pure function rkf1210_order(me) result(p) Returns the order of the rkf1210 method. Type Bound rkf1210_class Arguments Type Intent Optional Attributes Name class( rkf1210_class ), intent(in) :: me Return Value integer order of the method Source Code pure function rkf1210_order ( me ) result ( p ) implicit none class ( rkf1210_class ), intent ( in ) :: me integer :: p !! order of the method p = 12 end function rkf1210_order","tags":"","url":"proc/rkf1210_order.html"},{"title":"rkf1412_order – fortran-astrodynamics-toolkit","text":"private pure function rkf1412_order(me) result(p) Returns the order of the rkf1412 method. Type Bound rkf1412_class Arguments Type Intent Optional Attributes Name class( rkf1412_class ), intent(in) :: me Return Value integer order of the method Source Code pure function rkf1412_order ( me ) result ( p ) implicit none class ( rkf1412_class ), intent ( in ) :: me integer :: p !! order of the method p = 14 end function rkf1412_order","tags":"","url":"proc/rkf1412_order.html"},{"title":"hinit – fortran-astrodynamics-toolkit","text":"private  function hinit(me, x, y, posneg, f0, hmax, atol, rtol) computation of an initial step size guess Type Bound rk_variable_step_class Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in), dimension(:) :: y dimension(n) real(kind=wp), intent(in) :: posneg posneg = sign(1.0_wp,xend-x) real(kind=wp), intent(in), dimension(:) :: f0 dimension(n) real(kind=wp), intent(in) :: hmax real(kind=wp), intent(in), dimension(:) :: atol real(kind=wp), intent(in), dimension(:) :: rtol Return Value real(kind=wp) Called by proc~~hinit~~CalledByGraph proc~hinit rk_variable_step_class%hinit proc~integrate_to_event~2 rk_variable_step_class%integrate_to_event proc~integrate_to_event~2->proc~hinit proc~integrate~2 rk_variable_step_class%integrate proc~integrate~2->proc~hinit proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->proc~integrate_to_event~2 proc~rk_test_variable_step->proc~integrate~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function hinit ( me , x , y , posneg , f0 , hmax , atol , rtol ) implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y !! dimension(n) real ( wp ), intent ( in ) :: posneg !! posneg = sign(1.0_wp,xend-x) real ( wp ), dimension (:), intent ( in ) :: f0 !! dimension(n) real ( wp ), intent ( in ) :: hmax real ( wp ), dimension (:), intent ( in ) :: atol real ( wp ), dimension (:), intent ( in ) :: rtol real ( wp ) :: der12 , der2 , dnf , dny , h , h1 , hinit , sk integer :: i integer :: iord !! order of the method real ( wp ), dimension ( me % n ) :: f1 , y1 iord = me % p ! compute a first guess for explicit euler as !   h = 0.01 * norm (y0) / norm (f0) ! the increment for explicit euler is small ! compared to the solution dnf = zero dny = zero do i = 1 , me % n sk = atol ( i ) + rtol ( i ) * abs ( y ( i )) dnf = dnf + ( f0 ( i ) / sk ) ** 2 dny = dny + ( y ( i ) / sk ) ** 2 end do if ( dnf <= 1.0e-10_wp . or . dny <= 1.0e-10_wp ) then h = 1.0e-6_wp else h = sqrt ( dny / dnf ) * 0.01_wp end if h = min ( h , hmax ) h = sign ( h , posneg ) ! perform an explicit euler step do i = 1 , me % n y1 ( i ) = y ( i ) + h * f0 ( i ) end do call me % f ( x + h , y1 , f1 ) ! estimate the second derivative of the solution der2 = zero do i = 1 , me % n sk = atol ( i ) + rtol ( i ) * abs ( y ( i )) der2 = der2 + (( f1 ( i ) - f0 ( i )) / sk ) ** 2 end do der2 = sqrt ( der2 ) / h ! step size is computed such that !  h**iord * max ( norm (f0), norm (der2)) = 0.01 der12 = max ( abs ( der2 ), sqrt ( dnf )) if ( der12 <= 1.0e-15_wp ) then h1 = max ( 1.0e-6_wp , abs ( h ) * 1.0e-3_wp ) else h1 = ( 0.01_wp / der12 ) ** ( 1.0_wp / iord ) end if h = min ( 10 0.0_wp * abs ( h ), h1 , hmax ) hinit = sign ( h , posneg ) end function hinit","tags":"","url":"proc/hinit.html"},{"title":"stepsize_class_constructor – fortran-astrodynamics-toolkit","text":"private pure subroutine stepsize_class_constructor(me, hmin, hmax, hfactor_reject, hfactor_accept, norm, accept_mode, relative_err, safety_factor, p_exponent_offset, max_attempts) Constructor for a stepsize_class . Need to fix this. Type Bound stepsize_class Arguments Type Intent Optional Attributes Name class( stepsize_class ), intent(inout) :: me real(kind=wp), intent(in), optional :: hmin minimum allowed step size (>0) real(kind=wp), intent(in), optional :: hmax maximum allowed step size (>0) real(kind=wp), intent(in), optional :: hfactor_reject minimum allowed factor for\ndecreasing step size after\nrejected step (>0) real(kind=wp), intent(in), optional :: hfactor_accept maximum allowed factor for\ndecreasing step size after\naccepted step (>0) procedure( norm_func ), optional :: norm the user-specified function integer, intent(in), optional :: accept_mode method to determine if step\nis accepted [1,2] logical, intent(in), optional :: relative_err to use tol*h in the hfactor equation real(kind=wp), intent(in), optional :: safety_factor for hfactor equation (>0) integer, intent(in), optional :: p_exponent_offset p + this value in the exponent (0 or 1) integer, intent(in), optional :: max_attempts max step size change attempts\nafter rejected step Called by proc~~stepsize_class_constructor~~CalledByGraph proc~stepsize_class_constructor stepsize_class%stepsize_class_constructor proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->proc~stepsize_class_constructor proc~step_size_test step_size_test proc~step_size_test->proc~stepsize_class_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine stepsize_class_constructor ( me , hmin , hmax , hfactor_reject ,& hfactor_accept , norm , accept_mode , relative_err ,& safety_factor , p_exponent_offset , max_attempts ) implicit none class ( stepsize_class ), intent ( inout ) :: me real ( wp ), intent ( in ), optional :: hmin !! minimum allowed step size (>0) real ( wp ), intent ( in ), optional :: hmax !! maximum allowed step size (>0) real ( wp ), intent ( in ), optional :: hfactor_reject !! minimum allowed factor for !! decreasing step size after !! rejected step (>0) real ( wp ), intent ( in ), optional :: hfactor_accept !! maximum allowed factor for !! decreasing step size after !! accepted step (>0) procedure ( norm_func ), optional :: norm !! the user-specified  ||x||  !! function integer , intent ( in ), optional :: accept_mode !! method to determine if step !! is accepted [1,2] integer , intent ( in ), optional :: max_attempts !! max step size change attempts !! after rejected step logical , intent ( in ), optional :: relative_err !! to use `tol*h` in the `hfactor` equation real ( wp ), intent ( in ), optional :: safety_factor !! for `hfactor` equation (>0) integer , intent ( in ), optional :: p_exponent_offset !! p + this value in the exponent (0 or 1) if ( present ( hmin )) me % hmin = abs ( hmin ) if ( present ( hmax )) me % hmax = abs ( hmax ) if ( present ( hfactor_reject )) me % hfactor_reject = abs ( hfactor_reject ) if ( present ( hfactor_accept )) me % hfactor_accept = abs ( hfactor_accept ) if ( present ( norm )) me % norm => norm if ( present ( accept_mode )) me % accept_mode = accept_mode if ( present ( max_attempts )) me % max_attempts = max_attempts !if (present(compute_h_factor)) me%compute_h_factor => compute_h_factor if ( present ( relative_err )) me % relative_err = relative_err if ( present ( safety_factor )) me % safety_factor = abs ( safety_factor ) if ( present ( p_exponent_offset )) me % p_exponent_offset = abs ( p_exponent_offset ) end subroutine stepsize_class_constructor","tags":"","url":"proc/stepsize_class_constructor.html"},{"title":"destroy_stepsize_class – fortran-astrodynamics-toolkit","text":"private  subroutine destroy_stepsize_class(me) Destructor for stepsize_class . Type Bound stepsize_class Arguments Type Intent Optional Attributes Name class( stepsize_class ), intent(out) :: me Source Code subroutine destroy_stepsize_class ( me ) implicit none class ( stepsize_class ), intent ( out ) :: me end subroutine destroy_stepsize_class","tags":"","url":"proc/destroy_stepsize_class.html"},{"title":"compute_stepsize – fortran-astrodynamics-toolkit","text":"private pure subroutine compute_stepsize(me, h, tol, err, p, hnew, accept) Compute the new step size using the specific method. Type Bound stepsize_class Arguments Type Intent Optional Attributes Name class( stepsize_class ), intent(in) :: me real(kind=wp), intent(in) :: h current step size (<>0) real(kind=wp), intent(in) :: tol abs error tolerance (>0) real(kind=wp), intent(in) :: err truncation error estimate (>0) integer, intent(in) :: p order of the method real(kind=wp), intent(out) :: hnew new step size (<>0) logical, intent(out) :: accept if the step is accepted Called by proc~~compute_stepsize~~CalledByGraph proc~compute_stepsize stepsize_class%compute_stepsize proc~integrate_to_event~2 rk_variable_step_class%integrate_to_event proc~integrate_to_event~2->proc~compute_stepsize proc~integrate~2 rk_variable_step_class%integrate proc~integrate~2->proc~compute_stepsize proc~step_size_test step_size_test proc~step_size_test->proc~compute_stepsize proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->proc~integrate_to_event~2 proc~rk_test_variable_step->proc~integrate~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine compute_stepsize ( me , h , tol , err , p , hnew , accept ) !! Compute the new step size using the specific method. implicit none class ( stepsize_class ), intent ( in ) :: me real ( wp ), intent ( in ) :: h !! current step size (<>0) real ( wp ), intent ( in ) :: tol !! abs error tolerance (>0) real ( wp ), intent ( in ) :: err !! truncation error estimate (>0) integer , intent ( in ) :: p !! order of the method real ( wp ), intent ( out ) :: hnew !! new step size (<>0) logical , intent ( out ) :: accept !! if the step is accepted real ( wp ) :: hfactor !! step size factor (>0) real ( wp ), parameter :: small = ten * epsilon ( one ) !! small error value if ( err <= small ) then ! the error is extremely small hfactor = me % hfactor_accept accept = . true . else ! compute base factor based on the selected formula: !hfactor = abs(me%compute_h_factor(h,tol,err,p)) if ( me % relative_err ) then hfactor = abs ( me % safety_factor * abs ( tol * h / err ) ** ( one / real ( p + me % p_exponent_offset , wp )) ) else hfactor = abs ( me % safety_factor * abs ( tol / err ) ** ( one / real ( p + me % p_exponent_offset , wp )) ) end if ! if the step is to be accepted: select case ( me % accept_mode ) case ( 1 ) !algorithm 17.12 accept = ( hfactor >= one ) case ( 2 ) !algorithm 17.13 accept = ( err <= tol ) end select !...notes: ! see: L. Shampine \"Some Practical Runge-Kutta Formulas\", !      Mathematics of Computation, 46(173), Jan 1986. ! different conditions for satisfying error conditions: !  ||err|| <= tol   -- Error per step (EPS) !  ||err|| <= h*tol -- Error per unit step (EPUS) !compute the actual hfactor based on the limits: if ( accept ) then hfactor = min ( me % hfactor_accept , hfactor ) else hfactor = max ( me % hfactor_reject , hfactor ) end if end if ! compute the new step size (enforce min/max bounds & add sign): hnew = sign ( max ( me % hmin , min ( me % hmax , abs ( h ) * hfactor )), h ) end subroutine compute_stepsize","tags":"","url":"proc/compute_stepsize.html"},{"title":"initialize – fortran-astrodynamics-toolkit","text":"private  subroutine initialize(me, n, f, rtol, atol, stepsize_method, hinit_method, report, g) Initialize the rk_variable_step_class . Type Bound rk_variable_step_class Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me integer, intent(in) :: n number of equations procedure( deriv_func ) :: f derivative function real(kind=wp), intent(in), dimension(:) :: rtol relative tolerance (if size=1,\nthen same tol used for all\nequations) real(kind=wp), intent(in), dimension(:) :: atol absolute tolerance (if size=1,\nthen same tol used for all\nequations) class( stepsize_class ), intent(in) :: stepsize_method method for varying the step size integer, intent(in), optional :: hinit_method which method to use for\nautomatic initial step size\ncomputation.\n1 = use hstart , 2 = use hinit . procedure( report_func ), optional :: report for reporting the steps procedure( event_func ), optional :: g for stopping at an event Calls proc~~initialize~2~~CallsGraph proc~initialize~2 rk_variable_step_class%initialize proc~destroy~2 rk_variable_step_class%destroy proc~initialize~2->proc~destroy~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine initialize ( me , n , f , rtol , atol , stepsize_method , hinit_method , report , g ) implicit none class ( rk_variable_step_class ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of equations procedure ( deriv_func ) :: f !! derivative function real ( wp ), dimension (:), intent ( in ) :: rtol !! relative tolerance (if size=1, !! then same tol used for all !! equations) real ( wp ), dimension (:), intent ( in ) :: atol !! absolute tolerance (if size=1, !! then same tol used for all !! equations) class ( stepsize_class ), intent ( in ) :: stepsize_method !! method for varying the step size integer , intent ( in ), optional :: hinit_method !! which method to use for !! automatic initial step size !! computation. !! 1 = use `hstart`, 2 = use `hinit`. procedure ( report_func ), optional :: report !! for reporting the steps procedure ( event_func ), optional :: g !! for stopping at an event call me % destroy () me % n = n me % f => f allocate ( me % rtol ( n )) allocate ( me % atol ( n )) if ( size ( rtol ) == 1 ) then me % rtol = rtol ( 1 ) !use this for all equations else if ( size ( rtol ) == n ) then me % rtol = rtol else error stop 'invalid size for rtol array.' end if if ( size ( atol ) == 1 ) then me % atol = atol ( 1 ) !use this for all equations else if ( size ( atol ) == n ) then me % atol = atol else error stop 'invalid size for atol array.' end if if ( present ( hinit_method )) me % hinit_method = hinit_method if ( present ( report )) me % report => report if ( present ( g )) me % g => g allocate ( me % stepsize_method , source = stepsize_method ) me % num_rejected_steps = 0 end subroutine initialize","tags":"","url":"proc/initialize~2.html"},{"title":"destroy – fortran-astrodynamics-toolkit","text":"private  subroutine destroy(me) Destructor for rk_variable_step_class . Type Bound rk_variable_step_class Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(out) :: me Called by proc~~destroy~2~~CalledByGraph proc~destroy~2 rk_variable_step_class%destroy proc~initialize~2 rk_variable_step_class%initialize proc~initialize~2->proc~destroy~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine destroy ( me ) implicit none class ( rk_variable_step_class ), intent ( out ) :: me end subroutine destroy","tags":"","url":"proc/destroy~2.html"},{"title":"integrate – fortran-astrodynamics-toolkit","text":"private  subroutine integrate(me, t0, x0, h, tf, xf, ierr) Main integration routine for the rk_variable_step_class . Type Bound rk_variable_step_class Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(:) :: x0 initial state real(kind=wp), intent(in) :: h initial abs(time step) real(kind=wp), intent(in) :: tf final time real(kind=wp), intent(out), dimension(:) :: xf final state integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. Calls proc~~integrate~2~~CallsGraph proc~integrate~2 rk_variable_step_class%integrate order order proc~integrate~2->order proc~compute_stepsize stepsize_class%compute_stepsize proc~integrate~2->proc~compute_stepsize proc~hinit rk_variable_step_class%hinit proc~integrate~2->proc~hinit proc~hstart rk_variable_step_class%hstart proc~integrate~2->proc~hstart step step proc~integrate~2->step Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~integrate~2~~CalledByGraph proc~integrate~2 rk_variable_step_class%integrate proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->proc~integrate~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine integrate ( me , t0 , x0 , h , tf , xf , ierr ) implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t0 !! initial time real ( wp ), dimension (:), intent ( in ) :: x0 !! initial state real ( wp ), intent ( in ) :: h !! initial abs(time step) real ( wp ), intent ( in ) :: tf !! final time real ( wp ), dimension (:), intent ( out ) :: xf !! final state integer , intent ( out ), optional :: ierr !! 0 = no errors, !! <0 = error. !! if not present, an error will stop program. real ( wp ) :: t , dt , t2 , err , tol , dt_new real ( wp ), dimension ( me % n ) :: x , terr , etol , xp0 logical :: last , export , accept integer :: i , p if ( present ( ierr )) ierr = 0 if (. not . associated ( me % f )) then if ( present ( ierr )) then ierr = - 1 return else error stop 'Error in integrate: f is not associated.' end if end if me % num_rejected_steps = 0 export = associated ( me % report ) if ( export ) call me % report ( t0 , x0 ) !first point if ( t0 == tf ) then xf = x0 else t = t0 x = x0 if ( h == zero ) then ! compute an appropriate initial step size: ! WARNING: this may not be working in all cases ..... etol = me % rtol * me % stepsize_method % norm ( x0 ) + me % atol call me % f ( t0 , x0 , xp0 ) ! get initial dx/dt select case ( me % hinit_method ) case ( 1 ) call me % hstart ( t0 , tf , x0 , xp0 , etol , dt ) case ( 2 ) dt = me % hinit ( t0 , x0 , sign ( one , tf - t0 ), xp0 , me % stepsize_method % hmax , me % atol , me % rtol ) case default if ( present ( ierr )) then ierr = - 2 return else error stop 'invalid hinit_method selection' end if end select !write(*,*) 'inital step size: ',dt else ! user-specified initial step size: dt = sign ( h , tf - t0 ) ! (correct sign) end if p = me % order () !order of the method do t2 = t + dt last = (( dt >= zero . and . t2 >= tf ) . or . & !adjust last time step ( dt < zero . and . t2 <= tf )) ! if ( last ) dt = tf - t ! do i = 0 , me % stepsize_method % max_attempts ! take a step: call me % step ( t , x , dt , xf , terr ) ! evaluate error and compute new step size: err = me % stepsize_method % norm ( terr ) tol = me % stepsize_method % norm ( me % rtol * xf + me % atol ) call me % stepsize_method % compute_stepsize ( dt , tol , err , p , dt_new , accept ) dt = dt_new if ( accept ) then !accept this step exit else !step is rejected, repeat step with new dt me % num_rejected_steps = me % num_rejected_steps + 1 !note: if we have reached the min step size, and the error !is still too large, we can't proceed. if ( i >= me % stepsize_method % max_attempts ) then if ( present ( ierr )) then ierr = - 3 return else error stop 'error: too many attempts to reduce step size.' end if end if if ( abs ( dt ) <= abs ( me % stepsize_method % hmin )) then if ( present ( ierr )) then ierr = - 4 return else error stop 'warning: min step size.' end if end if !...... !... if we have two rejected steps and the step size hasn't changed.. !    then we need to abort, since no progress is being made... !...... last = (( dt >= zero . and . t2 >= tf ) . or . & !adjust last time step ( dt < zero . and . t2 <= tf )) ! if ( last ) dt = tf - t ! t2 = t + dt end if end do if ( last ) exit if ( export ) call me % report ( t2 , xf ) !intermediate point x = xf t = t2 end do end if if ( export ) call me % report ( tf , xf ) !last point end subroutine integrate","tags":"","url":"proc/integrate~2.html"},{"title":"integrate_to_event – fortran-astrodynamics-toolkit","text":"private  subroutine integrate_to_event(me, t0, x0, h, tmax, tol, tf, xf, gf, ierr) Uses brent_module proc~~integrate_to_event~2~~UsesGraph proc~integrate_to_event~2 rk_variable_step_class%integrate_to_event module~brent_module brent_module proc~integrate_to_event~2->module~brent_module module~kind_module kind_module module~brent_module->module~kind_module module~numbers_module numbers_module module~brent_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Event-finding integration routine for the rk_variable_step_class .\nIntegrates until g(t,x)=0, or until t=tf (whichever happens first). This is a work in progress. Type Bound rk_variable_step_class Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tmax max final time if event not located real(kind=wp), intent(in) :: tol function tolerance for root finding real(kind=wp), intent(out) :: tf actual final time reached real(kind=wp), intent(out), dimension(me%n) :: xf final state (at tf) real(kind=wp), intent(out) :: gf g value at tf integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. Calls proc~~integrate_to_event~2~~CallsGraph proc~integrate_to_event~2 rk_variable_step_class%integrate_to_event order order proc~integrate_to_event~2->order proc~compute_stepsize stepsize_class%compute_stepsize proc~integrate_to_event~2->proc~compute_stepsize proc~hinit rk_variable_step_class%hinit proc~integrate_to_event~2->proc~hinit proc~hstart rk_variable_step_class%hstart proc~integrate_to_event~2->proc~hstart proc~set_function brent_class%set_function proc~integrate_to_event~2->proc~set_function proc~zeroin brent_class%zeroin proc~integrate_to_event~2->proc~zeroin step step proc~integrate_to_event~2->step Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~integrate_to_event~2~~CalledByGraph proc~integrate_to_event~2 rk_variable_step_class%integrate_to_event proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->proc~integrate_to_event~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine integrate_to_event ( me , t0 , x0 , h , tmax , tol , tf , xf , gf , ierr ) use brent_module implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t0 !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x0 !! initial state real ( wp ), intent ( in ) :: h !! abs(time step) real ( wp ), intent ( in ) :: tmax !! max final time if event not located real ( wp ), intent ( in ) :: tol !! function tolerance for root finding real ( wp ), intent ( out ) :: tf !! actual final time reached real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! final state (at tf) real ( wp ), intent ( out ) :: gf !! g value at tf integer , intent ( out ), optional :: ierr !! 0 = no errors, !! <0 = error. !! if not present, an error will stop program. real ( wp ), dimension ( me % n ) :: etol , xp0 real ( wp ), dimension ( me % n ) :: x , g_xf real ( wp ), dimension ( me % n ) :: terr !! truncation error estimate integer :: i , p , iflag real ( wp ) :: t , dt , t2 , ga , gb , dt_root , dum , err , dt_new , stol logical :: first , last , export , accept procedure ( report_func ), pointer :: report type ( brent_class ) :: solver if ( present ( ierr )) ierr = 0 if (. not . associated ( me % f )) then if ( present ( ierr )) then ierr = - 1 return else error stop 'Error in integrate_to_event: f is not associated.' end if end if if (. not . associated ( me % g )) then if ( present ( ierr )) then ierr = - 2 return else error stop 'Error in integrate_to_event: g is not associated.' end if end if me % num_rejected_steps = 0 export = associated ( me % report ) if ( export ) call me % report ( t0 , x0 ) !first point if ( t0 == tmax ) then xf = x0 tf = t0 call me % g ( t0 , x0 , gf ) else first = . true . t = t0 x = x0 call me % g ( t , x , ga ) !evaluate event function if ( h == zero ) then ! compute an appropriate initial step size: ! WARNING: this may not be working in all cases ..... etol = me % rtol * me % stepsize_method % norm ( x0 ) + me % atol call me % f ( t0 , x0 , xp0 ) ! get initial dx/dt select case ( me % hinit_method ) case ( 1 ) call me % hstart ( t0 , tmax , x0 , xp0 , etol , dt ) case ( 2 ) dt = me % hinit ( t0 , x0 , sign ( one , tmax - t0 ), xp0 , me % stepsize_method % hmax , me % atol , me % rtol ) case default if ( present ( ierr )) then ierr = - 3 return else error stop 'invalid hinit_method selection' end if end select else ! user-specified initial step size: dt = sign ( h , tmax - t0 ) ! (correct sign) end if p = me % order () !order of the method do t2 = t + dt last = (( dt >= zero . and . t2 >= tmax ) . or . & !adjust last time step ( dt < zero . and . t2 <= tmax )) ! if ( last ) then dt = tmax - t t2 = tmax end if do i = 0 , me % stepsize_method % max_attempts ! take a step: call me % step ( t , x , dt , xf , terr ) ! evaluate error and compute new step size: err = me % stepsize_method % norm ( terr ) stol = me % stepsize_method % norm ( me % rtol * xf + me % atol ) call me % stepsize_method % compute_stepsize ( dt , stol , err , p , dt_new , accept ) dt = dt_new if ( accept ) then !accept this step exit else !step is rejected, repeat step with new dt me % num_rejected_steps = me % num_rejected_steps + 1 !note: if we have reached the min step size, and the error !is still too large, we can't proceed. if ( i >= me % stepsize_method % max_attempts ) then if ( present ( ierr )) then ierr = - 4 return else error stop 'error: too many attempts to reduce step size.' end if end if if ( abs ( dt ) <= abs ( me % stepsize_method % hmin )) then if ( present ( ierr )) then ierr = - 5 return else error stop 'warning: min step size.' end if end if !...... !... if we have two rejected steps and the step size hasn't changed.. !    then we need to abort, since no progress is being made... !...... last = (( dt >= zero . and . t2 >= tmax ) . or . & !adjust last time step ( dt < zero . and . t2 <= tmax )) ! if ( last ) then dt = tmax - t t2 = tmax else t2 = t + dt end if end if end do call me % g ( t2 , xf , gb ) !evaluate event function if ( first . and . abs ( ga ) <= tol ) then !we ignore a root at t0 after the first step if ( abs ( gb ) <= tol ) then !check this one since it could have landed on a root gf = gb tf = t2 exit else if ( last ) then !exiting without having found a root tf = t2 gf = gb exit end if if ( export ) call me % report ( t2 , xf ) !intermediate point x = xf t = t2 ga = gb end if elseif ( ga * gb <= zero ) then !there is a root somewhere on [t,t+dt] !find the root: call solver % set_function ( solver_func ) call solver % find_zero ( zero , dt , tol , dt_root , dum , iflag , ga , gb ) t2 = t + dt_root gf = solver_func ( solver , dt_root ) tf = t2 xf = g_xf !computed in the solver function exit else !no root yet, continue if ( last ) then !exiting without having found a root tf = t2 gf = gb exit end if if ( export ) call me % report ( t2 , xf ) !intermediate point x = xf t = t2 ga = gb end if if ( first ) first = . false . if ( last ) exit x = xf t = t2 end do end if if ( export ) call me % report ( tf , xf ) !last point contains function solver_func ( this , delt ) result ( g ) !! root solver function. The input is the dt offset from time t. implicit none class ( brent_class ), intent ( inout ) :: this real ( wp ), intent ( in ) :: delt !! from [0 to dt] real ( wp ) :: g real ( wp ), dimension ( me % n ) :: terr !! truncation error estimate !take a step from t to t+delt and evaluate g function: ! [we don't check the error because we are within a !  step that was already accepted, so it should be ok] call me % step ( t , x , delt , g_xf , terr ) call me % g ( t + delt , g_xf , g ) end function solver_func end subroutine integrate_to_event","tags":"","url":"proc/integrate_to_event~2.html"},{"title":"rkf78 – fortran-astrodynamics-toolkit","text":"private  subroutine rkf78(me, t, x, h, xf, terr) Fehlberg's 7(8) algorithm. Reference E. Fehlberg, \"Classical Fifth-, Sixth-, Seventh-, and Eighth-Order\n    Runge-Kutta Formulas with Stepsize Control\", NASA TR R-2870 . Type Bound rkf78_class Arguments Type Intent Optional Attributes Name class( rkf78_class ), intent(inout) :: me real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(me%n) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out), dimension(me%n) :: xf real(kind=wp), intent(out), dimension(me%n) :: terr Calls proc~~rkf78~~CallsGraph proc~rkf78 rkf78_class%rkf78 f f proc~rkf78->f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine rkf78 ( me , t , x , h , xf , terr ) implicit none class ( rkf78_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension ( me % n ), intent ( in ) :: x real ( wp ), intent ( in ) :: h real ( wp ), dimension ( me % n ), intent ( out ) :: xf real ( wp ), dimension ( me % n ), intent ( out ) :: terr real ( wp ), parameter :: a1 = 2.0_wp / 2 7.0_wp real ( wp ), parameter :: a2 = 1.0_wp / 9.0_wp real ( wp ), parameter :: a3 = 1.0_wp / 6.0_wp real ( wp ), parameter :: a4 = 5.0_wp / 1 2.0_wp real ( wp ), parameter :: a5 = 1.0_wp / 2.0_wp real ( wp ), parameter :: a6 = 5.0_wp / 6.0_wp real ( wp ), parameter :: a7 = 1.0_wp / 6.0_wp real ( wp ), parameter :: a8 = 2.0_wp / 3.0_wp real ( wp ), parameter :: a9 = 1.0_wp / 3.0_wp !real(wp),parameter :: a10 = 1.0_wp !real(wp),parameter :: a12 = 1.0_wp real ( wp ), parameter :: b10 = 2.0_wp / 2 7.0_wp real ( wp ), parameter :: b20 = 1.0_wp / 3 6.0_wp real ( wp ), parameter :: b21 = 1.0_wp / 1 2.0_wp real ( wp ), parameter :: b30 = 1.0_wp / 2 4.0_wp real ( wp ), parameter :: b32 = 1.0_wp / 8.0_wp real ( wp ), parameter :: b40 = 5.0_wp / 1 2.0_wp real ( wp ), parameter :: b42 = - 2 5.0_wp / 1 6.0_wp real ( wp ), parameter :: b43 = 2 5.0_wp / 1 6.0_wp real ( wp ), parameter :: b50 = 1.0_wp / 2 0.0_wp real ( wp ), parameter :: b53 = 1.0_wp / 4.0_wp real ( wp ), parameter :: b54 = 1.0_wp / 5.0_wp real ( wp ), parameter :: b60 = - 2 5.0_wp / 10 8.0_wp real ( wp ), parameter :: b63 = 12 5.0_wp / 10 8.0_wp real ( wp ), parameter :: b64 = - 6 5.0_wp / 2 7.0_wp real ( wp ), parameter :: b65 = 12 5.0_wp / 5 4.0_wp real ( wp ), parameter :: b70 = 3 1.0_wp / 30 0.0_wp real ( wp ), parameter :: b74 = 6 1.0_wp / 22 5.0_wp real ( wp ), parameter :: b75 = - 2.0_wp / 9.0_wp real ( wp ), parameter :: b76 = 1 3.0_wp / 90 0.0_wp real ( wp ), parameter :: b80 = 2.0_wp real ( wp ), parameter :: b83 = - 5 3.0_wp / 6.0_wp real ( wp ), parameter :: b84 = 70 4.0_wp / 4 5.0_wp real ( wp ), parameter :: b85 = - 10 7.0_wp / 9.0_wp real ( wp ), parameter :: b86 = 6 7.0_wp / 9 0.0_wp real ( wp ), parameter :: b87 = 3.0_wp real ( wp ), parameter :: b90 = - 9 1.0_wp / 10 8.0_wp real ( wp ), parameter :: b93 = 2 3.0_wp / 10 8.0_wp real ( wp ), parameter :: b94 = - 97 6.0_wp / 13 5.0_wp real ( wp ), parameter :: b95 = 31 1.0_wp / 5 4.0_wp real ( wp ), parameter :: b96 = - 1 9.0_wp / 6 0.0_wp real ( wp ), parameter :: b97 = 1 7.0_wp / 6.0_wp real ( wp ), parameter :: b98 = - 1.0_wp / 1 2.0_wp real ( wp ), parameter :: b100 = 238 3.0_wp / 410 0.0_wp real ( wp ), parameter :: b103 = - 34 1.0_wp / 16 4.0_wp real ( wp ), parameter :: b104 = 449 6.0_wp / 102 5.0_wp real ( wp ), parameter :: b105 = - 30 1.0_wp / 8 2.0_wp real ( wp ), parameter :: b106 = 213 3.0_wp / 410 0.0_wp real ( wp ), parameter :: b107 = 4 5.0_wp / 8 2.0_wp real ( wp ), parameter :: b108 = 4 5.0_wp / 16 4.0_wp real ( wp ), parameter :: b109 = 1 8.0_wp / 4 1.0_wp real ( wp ), parameter :: b110 = 3.0_wp / 20 5.0_wp real ( wp ), parameter :: b115 = - 6.0_wp / 4 1.0_wp real ( wp ), parameter :: b116 = - 3.0_wp / 20 5.0_wp real ( wp ), parameter :: b117 = - 3.0_wp / 4 1.0_wp real ( wp ), parameter :: b118 = 3.0_wp / 4 1.0_wp real ( wp ), parameter :: b119 = 6.0_wp / 4 1.0_wp real ( wp ), parameter :: b120 = - 177 7.0_wp / 410 0.0_wp real ( wp ), parameter :: b123 = - 34 1.0_wp / 16 4.0_wp real ( wp ), parameter :: b124 = 449 6.0_wp / 102 5.0_wp real ( wp ), parameter :: b125 = - 28 9.0_wp / 8 2.0_wp real ( wp ), parameter :: b126 = 219 3.0_wp / 410 0.0_wp real ( wp ), parameter :: b127 = 5 1.0_wp / 8 2.0_wp real ( wp ), parameter :: b128 = 3 3.0_wp / 16 4.0_wp real ( wp ), parameter :: b129 = 1 2.0_wp / 4 1.0_wp !real(wp),parameter :: b1211 = 1.0_wp real ( wp ), parameter :: c5 = 3 4.0_wp / 10 5.0_wp real ( wp ), parameter :: c6 = 9.0_wp / 3 5.0_wp real ( wp ), parameter :: c7 = 9.0_wp / 3 5.0_wp real ( wp ), parameter :: c8 = 9.0_wp / 28 0.0_wp real ( wp ), parameter :: c9 = 9.0_wp / 28 0.0_wp real ( wp ), parameter :: c11 = 4 1.0_wp / 84 0.0_wp real ( wp ), parameter :: c12 = 4 1.0_wp / 84 0.0_wp real ( wp ), dimension ( me % n ) :: f0 , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 , f10 , f11 , f12 if ( h == zero ) then xf = x terr = zero return end if call me % f ( t , x , f0 ) call me % f ( t + h * a1 , x + f0 * b10 * h , f1 ) call me % f ( t + h * a2 , x + ( f0 * b20 + f1 * b21 ) * h , f2 ) call me % f ( t + h * a3 , x + ( f0 * b30 + f2 * b32 ) * h , f3 ) call me % f ( t + h * a4 , x + ( f0 * b40 + f2 * b42 + f3 * b43 ) * h , f4 ) call me % f ( t + h * a5 , x + ( f0 * b50 + f3 * b53 + f4 * b54 ) * h , f5 ) call me % f ( t + h * a6 , x + ( f0 * b60 + f3 * b63 + f4 * b64 + f5 * b65 ) * h , f6 ) call me % f ( t + h * a7 , x + ( f0 * b70 + f4 * b74 + f5 * b75 + f6 * b76 ) * h , f7 ) call me % f ( t + h * a8 , x + ( f0 * b80 + f3 * b83 + f4 * b84 + f5 * b85 + f6 * b86 + & f7 * b87 ) * h , f8 ) call me % f ( t + h * a9 , x + ( f0 * b90 + f3 * b93 + f4 * b94 + f5 * b95 + f6 * b96 + & f7 * b97 + f8 * b98 ) * h , f9 ) call me % f ( t + h , x + ( f0 * b100 + f3 * b103 + f4 * b104 + f5 * b105 + & f6 * b106 + f7 * b107 + f8 * b108 + f9 * b109 ) * h , f10 ) call me % f ( t , x + ( f0 * b110 + f5 * b115 + f6 * b116 + f7 * b117 + f8 * b118 + & f9 * b119 ) * h , f11 ) call me % f ( t + h , x + ( f0 * b120 + f3 * b123 + f4 * b124 + f5 * b125 + f6 * b126 + & f7 * b127 + f8 * b128 + f9 * b129 + f11 ) * h , f12 ) xf = x + h * ( f5 * c5 + f6 * c6 + f7 * c7 + f8 * c8 + f9 * c9 + f11 * c11 + f12 * c12 ) terr = ( 4 1.0_wp / 84 0.0_wp ) * ( f0 + f10 - f11 - f12 ) end subroutine rkf78","tags":"","url":"proc/rkf78.html"},{"title":"rkf89 – fortran-astrodynamics-toolkit","text":"private  subroutine rkf89(me, t, x, h, xf, terr) Fehlberg 8(9) method. Reference E. Fehlberg, \"Classical Fifth-, Sixth-, Seventh-, and Eighth-Order\n    Runge-Kutta Formulas with Stepsize Control\", NASA TR R-2870 . Type Bound rkf89_class Arguments Type Intent Optional Attributes Name class( rkf89_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate Calls proc~~rkf89~~CallsGraph proc~rkf89 rkf89_class%rkf89 f f proc~rkf89->f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine rkf89 ( me , t , x , h , xf , terr ) implicit none class ( rkf89_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state real ( wp ), intent ( in ) :: h !! time step real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! state at time `t+h` real ( wp ), dimension ( me % n ), intent ( out ) :: terr !! truncation error estimate real ( wp ), parameter :: a1 = 0.44368940376498183109599404281370_wp real ( wp ), parameter :: a2 = 0.66553410564747274664399106422055_wp real ( wp ), parameter :: a3 = 0.99830115847120911996598659633083_wp real ( wp ), parameter :: a4 = 0.3155_wp real ( wp ), parameter :: a5 = 0.50544100948169068626516126737384_wp real ( wp ), parameter :: a6 = 0.17142857142857142857142857142857_wp real ( wp ), parameter :: a7 = 0.82857142857142857142857142857143_wp real ( wp ), parameter :: a8 = 0.66543966121011562534953769255586_wp real ( wp ), parameter :: a9 = 0.24878317968062652069722274560771_wp real ( wp ), parameter :: a10 = 0.1090_wp real ( wp ), parameter :: a11 = 0.8910_wp real ( wp ), parameter :: a12 = 0.3995_wp real ( wp ), parameter :: a13 = 0.6005_wp real ( wp ), parameter :: a14 = 1.0_wp real ( wp ), parameter :: a16 = 1.0_wp real ( wp ), parameter :: b1 = 0.44368940376498183109599404281370_wp real ( wp ), parameter :: b20 = 0.16638352641186818666099776605514_wp real ( wp ), parameter :: b21 = 0.49915057923560455998299329816541_wp real ( wp ), parameter :: b30 = 0.24957528961780227999149664908271_wp real ( wp ), parameter :: b32 = 0.74872586885340683997448994724812_wp real ( wp ), parameter :: b40 = 0.20661891163400602426556710393185_wp real ( wp ), parameter :: b42 = 0.17707880377986347040380997288319_wp real ( wp ), parameter :: b43 = - 0.68197715413869494669377076815048e-1_wp real ( wp ), parameter :: b50 = 0.10927823152666408227903890926157_wp real ( wp ), parameter :: b53 = 0.40215962642367995421990563690087e-2_wp real ( wp ), parameter :: b54 = 0.39214118169078980444392330174325_wp real ( wp ), parameter :: b60 = 0.98899281409164665304844765434355e-1_wp real ( wp ), parameter :: b63 = 0.35138370227963966951204487356703e-2_wp real ( wp ), parameter :: b64 = 0.12476099983160016621520625872489_wp real ( wp ), parameter :: b65 = - 0.55745546834989799643742901466348e-1_wp real ( wp ), parameter :: b70 = - 0.36806865286242203724153101080691_wp real ( wp ), parameter :: b74 = - 0.22273897469476007645024020944166e+1_wp real ( wp ), parameter :: b75 = 0.13742908256702910729565691245744e+1_wp real ( wp ), parameter :: b76 = 0.20497390027111603002159354092206e+1_wp real ( wp ), parameter :: b80 = 0.45467962641347150077351950603349e-1_wp real ( wp ), parameter :: b85 = 0.32542131701589147114677469648853_wp real ( wp ), parameter :: b86 = 0.28476660138527908888182420573687_wp real ( wp ), parameter :: b87 = 0.97837801675979152435868397271099e-2_wp real ( wp ), parameter :: b90 = 0.60842071062622057051094145205182e-1_wp real ( wp ), parameter :: b95 = - 0.21184565744037007526325275251206e-1_wp real ( wp ), parameter :: b96 = 0.19596557266170831957464490662983_wp real ( wp ), parameter :: b97 = - 0.42742640364817603675144835342899e-2_wp real ( wp ), parameter :: b98 = 0.17434365736814911965323452558189e-1_wp real ( wp ), parameter :: b100 = 0.54059783296931917365785724111182e-1_wp real ( wp ), parameter :: b106 = 0.11029825597828926530283127648228_wp real ( wp ), parameter :: b107 = - 0.12565008520072556414147763782250e-2_wp real ( wp ), parameter :: b108 = 0.36790043477581460136384043566339e-2_wp real ( wp ), parameter :: b109 = - 0.57780542770972073040840628571866e-1_wp real ( wp ), parameter :: b110 = 0.12732477068667114646645181799160_wp real ( wp ), parameter :: b117 = 0.11448805006396105323658875721817_wp real ( wp ), parameter :: b118 = 0.28773020709697992776202201849198_wp real ( wp ), parameter :: b119 = 0.50945379459611363153735885079465_wp real ( wp ), parameter :: b1110 = - 0.14799682244372575900242144449640_wp real ( wp ), parameter :: b120 = - 0.36526793876616740535848544394333e-2_wp real ( wp ), parameter :: b125 = 0.81629896012318919777819421247030e-1_wp real ( wp ), parameter :: b126 = - 0.38607735635693506490517694343215_wp real ( wp ), parameter :: b127 = 0.30862242924605106450474166025206e-1_wp real ( wp ), parameter :: b128 = - 0.58077254528320602815829374733518e-1_wp real ( wp ), parameter :: b129 = 0.33598659328884971493143451362322_wp real ( wp ), parameter :: b1210 = 0.41066880401949958613549622786417_wp real ( wp ), parameter :: b1211 = - 0.11840245972355985520633156154536e-1_wp real ( wp ), parameter :: b130 = - 0.12375357921245143254979096135669e+1_wp real ( wp ), parameter :: b135 = - 0.24430768551354785358734861366763e+2_wp real ( wp ), parameter :: b136 = 0.54779568932778656050436528991173_wp real ( wp ), parameter :: b137 = - 0.44413863533413246374959896569346e+1_wp real ( wp ), parameter :: b138 = 0.10013104813713266094792617851022e+2_wp real ( wp ), parameter :: b139 = - 0.14995773102051758447170985073142e+2_wp real ( wp ), parameter :: b1310 = 0.58946948523217013620824539651427e+1_wp real ( wp ), parameter :: b1311 = 0.17380377503428984877616857440542e+1_wp real ( wp ), parameter :: b1312 = 0.27512330693166730263758622860276e+2_wp real ( wp ), parameter :: b140 = - 0.35260859388334522700502958875588_wp real ( wp ), parameter :: b145 = - 0.18396103144848270375044198988231_wp real ( wp ), parameter :: b146 = - 0.65570189449741645138006879985251_wp real ( wp ), parameter :: b147 = - 0.39086144880439863435025520241310_wp real ( wp ), parameter :: b148 = 0.26794646712850022936584423271209_wp real ( wp ), parameter :: b149 = - 0.10383022991382490865769858507427e+1_wp real ( wp ), parameter :: b1410 = 0.16672327324258671664727346168501e+1_wp real ( wp ), parameter :: b1411 = 0.49551925855315977067732967071441_wp real ( wp ), parameter :: b1412 = 0.11394001132397063228586738141784e+1_wp real ( wp ), parameter :: b1413 = 0.51336696424658613688199097191534e-1_wp real ( wp ), parameter :: b150 = 0.10464847340614810391873002406755e-2_wp real ( wp ), parameter :: b158 = - 0.67163886844990282237778446178020e-2_wp real ( wp ), parameter :: b159 = 0.81828762189425021265330065248999e-2_wp real ( wp ), parameter :: b1510 = - 0.42640342864483347277142138087561e-2_wp real ( wp ), parameter :: b1511 = 0.28009029474168936545976331153703e-3_wp real ( wp ), parameter :: b1512 = - 0.87835333876238676639057813145633e-2_wp real ( wp ), parameter :: b1513 = 0.10254505110825558084217769664009e-1_wp real ( wp ), parameter :: b160 = - 0.13536550786174067080442168889966e+1_wp real ( wp ), parameter :: b165 = - 0.18396103144848270375044198988231_wp real ( wp ), parameter :: b166 = - 0.65570189449741645138006879985251_wp real ( wp ), parameter :: b167 = - 0.39086144880439863435025520241310_wp real ( wp ), parameter :: b168 = 0.27466285581299925758962207732989_wp real ( wp ), parameter :: b169 = - 0.10464851753571915887035188572676e+1_wp real ( wp ), parameter :: b1610 = 0.16714967667123155012004488306588e+1_wp real ( wp ), parameter :: b1611 = 0.49523916825841808131186990740287_wp real ( wp ), parameter :: b1612 = 0.11481836466273301905225795954930e+1_wp real ( wp ), parameter :: b1613 = 0.41082191313833055603981327527525e-1_wp real ( wp ), parameter :: b1615 = 1.0_wp real ( wp ), parameter :: c0 = 0.32256083500216249913612900960247e-1_wp real ( wp ), parameter :: c8 = 0.25983725283715403018887023171963_wp real ( wp ), parameter :: c9 = 0.92847805996577027788063714302190e-1_wp real ( wp ), parameter :: c10 = 0.16452339514764342891647731842800_wp real ( wp ), parameter :: c11 = 0.17665951637860074367084298397547_wp real ( wp ), parameter :: c12 = 0.23920102320352759374108933320941_wp real ( wp ), parameter :: c13 = 0.39484274604202853746752118829325e-2_wp real ( wp ), parameter :: c14 = 0.30726495475860640406368305522124e-1_wp real ( wp ), dimension ( me % n ) :: f0 , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 , f10 , f11 , f12 , f13 , f14 , f15 , f16 if ( h == zero ) then xf = x terr = zero return end if call me % f ( t , x , f0 ) call me % f ( t + h * a1 , x + f0 * b1 * h , f1 ) call me % f ( t + h * a2 , x + ( f0 * b20 + f1 * b21 ) * h , f2 ) call me % f ( t + h * a3 , x + ( f0 * b30 + f2 * b32 ) * h , f3 ) call me % f ( t + h * a4 , x + ( f0 * b40 + f2 * b42 + f3 * b43 ) * h , f4 ) call me % f ( t + h * a5 , x + ( f0 * b50 + f3 * b53 + f4 * b54 ) * h , f5 ) call me % f ( t + h * a6 , x + ( f0 * b60 + f3 * b63 + f4 * b64 + f5 * b65 ) * h , f6 ) call me % f ( t + h * a7 , x + ( f0 * b70 + f4 * b74 + f5 * b75 + f6 * b76 ) * h , f7 ) call me % f ( t + h * a8 , x + ( f0 * b80 + f5 * b85 + f6 * b86 + f7 * b87 ) * h , f8 ) call me % f ( t + h * a9 , x + ( f0 * b90 + f5 * b95 + f6 * b96 + f7 * b97 + f8 * b98 ) * h , f9 ) call me % f ( t + h * a10 , x + ( f0 * b100 + f6 * b106 + f7 * b107 + f8 * b108 + & f9 * b109 ) * h , f10 ) call me % f ( t + h * a11 , x + ( f0 * b110 + f7 * b117 + f8 * b118 + f9 * b119 + & f10 * b1110 ) * h , f11 ) call me % f ( t + h * a12 , x + ( f0 * b120 + f5 * b125 + f6 * b126 + f7 * b127 + & f8 * b128 + f9 * b129 + f10 * b1210 + f11 * b1211 ) * h , f12 ) call me % f ( t + h * a13 , x + ( f0 * b130 + f5 * b135 + f6 * b136 + f7 * b137 + & f8 * b138 + f9 * b139 + f10 * b1310 + f11 * b1311 + f12 * b1312 ) * h , f13 ) call me % f ( t + h * a14 , x + ( f0 * b140 + f5 * b145 + f6 * b146 + f7 * b147 + f8 * b148 + & f9 * b149 + f10 * b1410 + f11 * b1411 + f12 * b1412 + f13 * b1413 ) * h , f14 ) call me % f ( t , x + ( f0 * b150 + f8 * b158 + f9 * b159 + f10 * b1510 + f11 * b1511 + & f12 * b1512 + f13 * b1513 ) * h , f15 ) call me % f ( t + h * a16 , x + ( f0 * b160 + f5 * b165 + f6 * b166 + f7 * b167 + f8 * b168 + & f9 * b169 + f10 * b1610 + f11 * b1611 + f12 * b1612 + f13 * b1613 + & f15 * b1615 ) * h , f16 ) xf = x + h * ( f0 * c0 + f8 * c8 + f9 * c9 + f10 * c10 + f11 * c11 + f12 * c12 + f13 * c13 + f14 * c14 ) terr = c14 * h * ( f0 + f14 - f15 - f16 ) end subroutine rkf89","tags":"","url":"proc/rkf89.html"},{"title":"rkv89 – fortran-astrodynamics-toolkit","text":"private  subroutine rkv89(me, t, x, h, xf, terr) Runge Kutta Verner 8(9) Reference J. H. Verner, \"Explicit Runge–Kutta Methods with Estimates of the\n    Local Truncation Error\", SIAM Journal on Numerical Analysis,\n   15(4), 772–790, 1978. Type Bound rkv89_class Arguments Type Intent Optional Attributes Name class( rkv89_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate Calls proc~~rkv89~~CallsGraph proc~rkv89 rkv89_class%rkv89 f f proc~rkv89->f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine rkv89 ( me , t , x , h , xf , terr ) implicit none class ( rkv89_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state real ( wp ), intent ( in ) :: h !! time step real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! state at time `t+h` real ( wp ), dimension ( me % n ), intent ( out ) :: terr !! truncation error estimate real ( wp ), parameter :: s6 = sqrt ( 6.0_wp ) real ( wp ), parameter :: a2 = 1.0_wp / 1 2.0_wp real ( wp ), parameter :: a3 = 1.0_wp / 9.0_wp real ( wp ), parameter :: a4 = 1.0_wp / 6.0_wp real ( wp ), parameter :: a5 = 2.0_wp * ( 1.0_wp + s6 ) / 1 5.0_wp real ( wp ), parameter :: a6 = ( 6.0_wp + s6 ) / 1 5.0_wp real ( wp ), parameter :: a7 = ( 6.0_wp - s6 ) / 1 5.0_wp real ( wp ), parameter :: a8 = 2.0_wp / 3.0_wp real ( wp ), parameter :: a9 = 1.0_wp / 2.0_wp real ( wp ), parameter :: a10 = 1.0_wp / 3.0_wp real ( wp ), parameter :: a11 = 1.0_wp / 4.0_wp real ( wp ), parameter :: a12 = 4.0_wp / 3.0_wp real ( wp ), parameter :: a13 = 5.0_wp / 6.0_wp real ( wp ), parameter :: a15 = 1.0_wp / 6.0_wp real ( wp ), parameter :: b31 = 1.0_wp / 2 7.0_wp real ( wp ), parameter :: b32 = 2.0_wp / 2 7.0_wp real ( wp ), parameter :: b41 = 1.0_wp / 2 4.0_wp real ( wp ), parameter :: b43 = 3.0_wp / 2 4.0_wp real ( wp ), parameter :: b51 = ( 4.0_wp + 9 4.0_wp * s6 ) / 37 5.0_wp real ( wp ), parameter :: b53 = - ( 28 2.0_wp + 25 2.0_wp * s6 ) / 37 5.0_wp real ( wp ), parameter :: b54 = ( 32 8.0_wp + 20 8.0_wp * s6 ) / 37 5.0_wp real ( wp ), parameter :: b61 = ( 9.0_wp - s6 ) / 15 0.0_wp real ( wp ), parameter :: b64 = ( 31 2.0_wp + 3 2.0_wp * s6 ) / 142 5.0_wp real ( wp ), parameter :: b65 = ( 6 9.0_wp + 2 9.0_wp * s6 ) / 57 0.0_wp real ( wp ), parameter :: b71 = ( 92 7.0_wp - 34 7.0_wp * s6 ) / 125 0.0_wp real ( wp ), parameter :: b74 = ( - 1624 8.0_wp + 732 8.0_wp * s6 ) / 937 5.0_wp real ( wp ), parameter :: b75 = ( - 48 9.0_wp + 17 9.0_wp * s6 ) / 375 0.0_wp real ( wp ), parameter :: b76 = ( 1426 8.0_wp - 579 8.0_wp * s6 ) / 937 5.0_wp real ( wp ), parameter :: b81 = 4.0_wp / 5 4.0_wp real ( wp ), parameter :: b86 = ( 1 6.0_wp - s6 ) / 5 4.0_wp real ( wp ), parameter :: b87 = ( 1 6.0_wp + s6 ) / 5 4.0_wp real ( wp ), parameter :: b91 = 3 8.0_wp / 51 2.0_wp real ( wp ), parameter :: b96 = ( 11 8.0_wp - 2 3.0_wp * s6 ) / 51 2.0_wp real ( wp ), parameter :: b97 = ( 11 8.0_wp + 2 3.0_wp * s6 ) / 51 2.0_wp real ( wp ), parameter :: b98 = - 1 8.0_wp / 51 2.0_wp real ( wp ), parameter :: b101 = 1 1.0_wp / 14 4.0_wp real ( wp ), parameter :: b106 = ( 26 6.0_wp - s6 ) / 86 4.0_wp real ( wp ), parameter :: b107 = ( 26 6.0_wp + s6 ) / 86 4.0_wp real ( wp ), parameter :: b108 = - 1.0_wp / 1 6.0_wp real ( wp ), parameter :: b109 = - 8.0_wp / 2 7.0_wp real ( wp ), parameter :: b111 = ( 503 4.0_wp - 27 1.0_wp * s6 ) / 6144 0.0_wp real ( wp ), parameter :: b117 = ( 785 9.0_wp - 162 6.0_wp * s6 ) / 1024 0.0_wp real ( wp ), parameter :: b118 = ( - 223 2.0_wp + 81 3.0_wp * s6 ) / 2048 0.0_wp real ( wp ), parameter :: b119 = ( - 59 4.0_wp + 27 1.0_wp * s6 ) / 96 0.0_wp real ( wp ), parameter :: b1110 = ( 65 7.0_wp - 81 3.0_wp * s6 ) / 512 0.0_wp real ( wp ), parameter :: b121 = ( 599 6.0_wp - 379 4.0_wp * s6 ) / 40 5.0_wp real ( wp ), parameter :: b126 = ( - 434 2.0_wp - 33 8.0_wp * s6 ) / 9.0_wp real ( wp ), parameter :: b127 = ( 15492 2.0_wp - 4045 8.0_wp * s6 ) / 13 5.0_wp real ( wp ), parameter :: b128 = ( - 417 6.0_wp + 379 4.0_wp * s6 ) / 4 5.0_wp real ( wp ), parameter :: b129 = ( - 34086 4.0_wp + 24281 6.0_wp * s6 ) / 40 5.0_wp real ( wp ), parameter :: b1210 = ( 2630 4.0_wp - 1517 6.0_wp * s6 ) / 4 5.0_wp real ( wp ), parameter :: b1211 = - 2662 4.0_wp / 8 1.0_wp real ( wp ), parameter :: b131 = ( 379 3.0_wp + 216 8.0_wp * s6 ) / 10368 0.0_wp real ( wp ), parameter :: b136 = ( 404 2.0_wp + 226 3.0_wp * s6 ) / 1382 4.0_wp real ( wp ), parameter :: b137 = ( - 23127 8.0_wp + 4071 7.0_wp * s6 ) / 6912 0.0_wp real ( wp ), parameter :: b138 = ( 794 7.0_wp - 216 8.0_wp * s6 ) / 1152 0.0_wp real ( wp ), parameter :: b139 = ( 104 8.0_wp - 54 2.0_wp * s6 ) / 40 5.0_wp real ( wp ), parameter :: b1310 = ( - 138 3.0_wp + 54 2.0_wp * s6 ) / 72 0.0_wp real ( wp ), parameter :: b1311 = 262 4.0_wp / 105 3.0_wp real ( wp ), parameter :: b1312 = 3.0_wp / 166 4.0_wp real ( wp ), parameter :: b141 = - 13 7.0_wp / 129 6.0_wp real ( wp ), parameter :: b146 = ( 564 2.0_wp - 33 7.0_wp * s6 ) / 86 4.0_wp real ( wp ), parameter :: b147 = ( 564 2.0_wp + 33 7.0_wp * s6 ) / 86 4.0_wp real ( wp ), parameter :: b148 = - 29 9.0_wp / 4 8.0_wp real ( wp ), parameter :: b149 = 18 4.0_wp / 8 1.0_wp real ( wp ), parameter :: b1410 = - 4 4.0_wp / 9.0_wp real ( wp ), parameter :: b1411 = - 512 0.0_wp / 105 3.0_wp real ( wp ), parameter :: b1412 = - 1 1.0_wp / 46 8.0_wp real ( wp ), parameter :: b1413 = 1 6.0_wp / 9.0_wp real ( wp ), parameter :: b151 = ( 3361 7.0_wp - 216 8.0_wp * s6 ) / 51840 0.0_wp real ( wp ), parameter :: b156 = ( - 384 6.0_wp + 3 1.0_wp * s6 ) / 1382 4.0_wp real ( wp ), parameter :: b157 = ( 15533 8.0_wp - 5280 7.0_wp * s6 ) / 34560 0.0_wp real ( wp ), parameter :: b158 = ( - 1253 7.0_wp + 216 8.0_wp * s6 ) / 5760 0.0_wp real ( wp ), parameter :: b159 = ( 9 2.0_wp + 54 2.0_wp * s6 ) / 202 5.0_wp real ( wp ), parameter :: b1510 = ( - 179 7.0_wp - 54 2.0_wp * s6 ) / 360 0.0_wp real ( wp ), parameter :: b1511 = 32 0.0_wp / 56 7.0_wp real ( wp ), parameter :: b1512 = - 1.0_wp / 192 0.0_wp real ( wp ), parameter :: b1513 = 4.0_wp / 10 5.0_wp real ( wp ), parameter :: b161 = ( - 3648 7.0_wp - 3035 2.0_wp * s6 ) / 27960 0.0_wp real ( wp ), parameter :: b166 = ( - 2966 6.0_wp - 449 9.0_wp * s6 ) / 745 6.0_wp real ( wp ), parameter :: b167 = ( 277918 2.0_wp - 61597 3.0_wp * s6 ) / 18640 0.0_wp real ( wp ), parameter :: b168 = ( - 9432 9.0_wp + 9105 6.0_wp * s6 ) / 9320 0.0_wp real ( wp ), parameter :: b169 = ( - 23219 2.0_wp + 12140 8.0_wp * s6 ) / 1747 5.0_wp real ( wp ), parameter :: b1610 = ( 10122 6.0_wp - 2276 4.0_wp * s6 ) / 582 5.0_wp real ( wp ), parameter :: b1611 = - 16998 4.0_wp / 908 7.0_wp real ( wp ), parameter :: b1612 = - 8 7.0_wp / 3029 0.0_wp real ( wp ), parameter :: b1613 = 49 2.0_wp / 116 5.0_wp real ( wp ), parameter :: b1615 = 126 0.0_wp / 23 3.0_wp real ( wp ), parameter :: c1 = 10 3.0_wp / 168 0.0_wp real ( wp ), parameter :: c8 = - 2 7.0_wp / 14 0.0_wp real ( wp ), parameter :: c9 = 7 6.0_wp / 10 5.0_wp real ( wp ), parameter :: c10 = - 20 1.0_wp / 28 0.0_wp real ( wp ), parameter :: c11 = 102 4.0_wp / 136 5.0_wp real ( wp ), parameter :: c12 = 3.0_wp / 728 0.0_wp real ( wp ), parameter :: c13 = 1 2.0_wp / 3 5.0_wp real ( wp ), parameter :: c14 = 9.0_wp / 28 0.0_wp real ( wp ), parameter :: e1 = - 191 1.0_wp / 10920 0.0_wp real ( wp ), parameter :: e8 = 3439 8.0_wp / 10920 0.0_wp real ( wp ), parameter :: e9 = - 6115 2.0_wp / 10920 0.0_wp real ( wp ), parameter :: e10 = 11466 0.0_wp / 10920 0.0_wp real ( wp ), parameter :: e11 = - 11468 8.0_wp / 10920 0.0_wp real ( wp ), parameter :: e12 = - 6 3.0_wp / 10920 0.0_wp real ( wp ), parameter :: e13 = - 1310 4.0_wp / 10920 0.0_wp real ( wp ), parameter :: e14 = - 351 0.0_wp / 10920 0.0_wp real ( wp ), parameter :: e15 = 3931 2.0_wp / 10920 0.0_wp real ( wp ), parameter :: e16 = 605 8.0_wp / 10920 0.0_wp real ( wp ), dimension ( me % n ) :: f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 ,& f10 , f11 , f12 , f13 , f14 , f15 , f16 call me % f ( t , x , f1 ) call me % f ( t + a2 * h , x + h * ( a2 * f1 ), f2 ) call me % f ( t + a3 * h , x + h * ( b31 * f1 + b32 * f2 ), f3 ) call me % f ( t + a4 * h , x + h * ( b41 * f1 + b43 * f3 ), f4 ) call me % f ( t + a5 * h , x + h * ( b51 * f1 + b53 * f3 + b54 * f4 ), f5 ) call me % f ( t + a6 * h , x + h * ( b61 * f1 + b64 * f4 + b65 * f5 ), f6 ) call me % f ( t + a7 * h , x + h * ( b71 * f1 + b74 * f4 + b75 * f5 + b76 * f6 ), f7 ) call me % f ( t + a8 * h , x + h * ( b81 * f1 + b86 * f6 + b87 * f7 ), f8 ) call me % f ( t + a9 * h , x + h * ( b91 * f1 + b96 * f6 + b97 * f7 + b98 * f8 ), f9 ) call me % f ( t + a10 * h , x + h * ( b101 * f1 + b106 * f6 + b107 * f7 + b108 * f8 + b109 * f9 ), f10 ) call me % f ( t + a11 * h , x + h * ( b111 * f1 + b117 * f7 + b118 * f8 + b119 * f9 + b1110 * f10 ), f11 ) call me % f ( t + a12 * h , x + h * ( b121 * f1 + b126 * f6 + b127 * f7 + b128 * f8 + b129 * f9 + & b1210 * f10 + b1211 * f11 ), f12 ) call me % f ( t + a13 * h , x + h * ( b131 * f1 + b136 * f6 + b137 * f7 + b138 * f8 + b139 * f9 + & b1310 * f10 + b1311 * f11 + b1312 * f12 ), f13 ) call me % f ( t + h , x + h * ( b141 * f1 + b146 * f6 + b147 * f7 + b148 * f8 + b149 * f9 + b1410 * f10 + & b1411 * f11 + b1412 * f12 + b1413 * f13 ), f14 ) call me % f ( t + a15 * h , x + h * ( b151 * f1 + b156 * f6 + b157 * f7 + b158 * f8 + b159 * f9 + b1510 * f10 + & b1511 * f11 + b1512 * f12 + b1513 * f13 ), f15 ) call me % f ( t + h , x + h * ( b161 * f1 + b166 * f6 + b167 * f7 + b168 * f8 + b169 * f9 + b1610 * f10 + & b1611 * f11 + b1612 * f12 + b1613 * f13 + b1615 * f15 ), f16 ) xf = x + h * ( c1 * f1 + c8 * f8 + c9 * f9 + c10 * f10 + c11 * f11 + c12 * f12 + c13 * f13 + c14 * f14 ) terr = e1 * f1 + e8 * f8 + e9 * f9 + e10 * f10 + e11 * f11 + e12 * f12 + e13 * f13 + e14 * f14 + e15 * f15 + e16 * f16 end subroutine rkv89","tags":"","url":"proc/rkv89.html"},{"title":"rkf108 – fortran-astrodynamics-toolkit","text":"private  subroutine rkf108(me, t, x, h, xf, terr) Feagin's RK8(10) method -- a 10th-order method with an embedded 8th-order method. Reference T. Feagin, \"[A Tenth-Order Runge-Kutta Method with Error Estimate]\n    (http://sce.uhcl.edu/feagin/courses/rk10.pdf)\", coefficient file Type Bound rkf108_class Arguments Type Intent Optional Attributes Name class( rkf108_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate Calls proc~~rkf108~~CallsGraph proc~rkf108 rkf108_class%rkf108 f f proc~rkf108->f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine rkf108 ( me , t , x , h , xf , terr ) implicit none class ( rkf108_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state real ( wp ), intent ( in ) :: h !! time step real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! state at time `t+h` real ( wp ), dimension ( me % n ), intent ( out ) :: terr !! truncation error estimate real ( wp ), parameter :: a1 = 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a2 = 0.539357840802981787532485197881302436857273449701009015505500_wp real ( wp ), parameter :: a3 = 0.809036761204472681298727796821953655285910174551513523258250_wp real ( wp ), parameter :: a4 = 0.309036761204472681298727796821953655285910174551513523258250_wp real ( wp ), parameter :: a5 = 0.981074190219795268254879548310562080489056746118724882027805_wp real ( wp ), parameter :: a6 = 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a7 = 0.354017365856802376329264185948796742115824053807373968324184_wp real ( wp ), parameter :: a8 = 0.882527661964732346425501486979669075182867844268052119663791_wp real ( wp ), parameter :: a9 = 0.642615758240322548157075497020439535959501736363212695909875_wp real ( wp ), parameter :: a10 = 0.357384241759677451842924502979560464040498263636787304090125_wp real ( wp ), parameter :: a11 = 0.117472338035267653574498513020330924817132155731947880336209_wp real ( wp ), parameter :: a12 = 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a13 = 0.309036761204472681298727796821953655285910174551513523258250_wp real ( wp ), parameter :: a14 = 0.539357840802981787532485197881302436857273449701009015505500_wp real ( wp ), parameter :: a15 = 0.100000000000000000000000000000000000000000000000000000000000_wp !real(wp),parameter :: a16 = 1.00000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c0 = 0.0333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: c1 = 0.0250000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c2 = 0.0333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: c4 = 0.0500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c6 = 0.0400000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c8 = 0.189237478148923490158306404106012326238162346948625830327194_wp real ( wp ), parameter :: c9 = 0.277429188517743176508360262560654340428504319718040836339472_wp real ( wp ), parameter :: c10 = 0.277429188517743176508360262560654340428504319718040836339472_wp real ( wp ), parameter :: c11 = 0.189237478148923490158306404106012326238162346948625830327194_wp real ( wp ), parameter :: c12 = - 0.0400000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c13 = - 0.0500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c14 = - 0.0333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: c15 = - 0.0250000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c16 = 0.0333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b10 = 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b20 = - 0.915176561375291440520015019275342154318951387664369720564660_wp real ( wp ), parameter :: b21 = 1.45453440217827322805250021715664459117622483736537873607016_wp real ( wp ), parameter :: b30 = 0.202259190301118170324681949205488413821477543637878380814562_wp real ( wp ), parameter :: b32 = 0.606777570903354510974045847616465241464432630913635142443687_wp real ( wp ), parameter :: b40 = 0.184024714708643575149100693471120664216774047979591417844635_wp real ( wp ), parameter :: b42 = 0.197966831227192369068141770510388793370637287463360401555746_wp real ( wp ), parameter :: b43 = - 0.0729547847313632629185146671595558023015011608914382961421311_wp real ( wp ), parameter :: b50 = 0.0879007340206681337319777094132125475918886824944548534041378_wp real ( wp ), parameter :: b53 = 0.410459702520260645318174895920453426088035325902848695210406_wp real ( wp ), parameter :: b54 = 0.482713753678866489204726942976896106809132737721421333413261_wp real ( wp ), parameter :: b60 = 0.0859700504902460302188480225945808401411132615636600222593880_wp real ( wp ), parameter :: b63 = 0.330885963040722183948884057658753173648240154838402033448632_wp real ( wp ), parameter :: b64 = 0.489662957309450192844507011135898201178015478433790097210790_wp real ( wp ), parameter :: b65 = - 0.0731856375070850736789057580558988816340355615025188195854775_wp real ( wp ), parameter :: b70 = 0.120930449125333720660378854927668953958938996999703678812621_wp real ( wp ), parameter :: b74 = 0.260124675758295622809007617838335174368108756484693361887839_wp real ( wp ), parameter :: b75 = 0.0325402621549091330158899334391231259332716675992700000776101_wp real ( wp ), parameter :: b76 = - 0.0595780211817361001560122202563305121444953672762930724538856_wp real ( wp ), parameter :: b80 = 0.110854379580391483508936171010218441909425780168656559807038_wp real ( wp ), parameter :: b85 = - 0.0605761488255005587620924953655516875526344415354339234619466_wp real ( wp ), parameter :: b86 = 0.321763705601778390100898799049878904081404368603077129251110_wp real ( wp ), parameter :: b87 = 0.510485725608063031577759012285123416744672137031752354067590_wp real ( wp ), parameter :: b90 = 0.112054414752879004829715002761802363003717611158172229329393_wp real ( wp ), parameter :: b95 = - 0.144942775902865915672349828340980777181668499748506838876185_wp real ( wp ), parameter :: b96 = - 0.333269719096256706589705211415746871709467423992115497968724_wp real ( wp ), parameter :: b97 = 0.499269229556880061353316843969978567860276816592673201240332_wp real ( wp ), parameter :: b98 = 0.509504608929686104236098690045386253986643232352989602185060_wp real ( wp ), parameter :: b100 = 0.113976783964185986138004186736901163890724752541486831640341_wp real ( wp ), parameter :: b105 = - 0.0768813364203356938586214289120895270821349023390922987406384_wp real ( wp ), parameter :: b106 = 0.239527360324390649107711455271882373019741311201004119339563_wp real ( wp ), parameter :: b107 = 0.397774662368094639047830462488952104564716416343454639902613_wp real ( wp ), parameter :: b108 = 0.0107558956873607455550609147441477450257136782823280838547024_wp real ( wp ), parameter :: b109 = - 0.327769124164018874147061087350233395378262992392394071906457_wp real ( wp ), parameter :: b110 = 0.0798314528280196046351426864486400322758737630423413945356284_wp real ( wp ), parameter :: b115 = - 0.0520329686800603076514949887612959068721311443881683526937298_wp real ( wp ), parameter :: b116 = - 0.0576954146168548881732784355283433509066159287152968723021864_wp real ( wp ), parameter :: b117 = 0.194781915712104164976306262147382871156142921354409364738090_wp real ( wp ), parameter :: b118 = 0.145384923188325069727524825977071194859203467568236523866582_wp real ( wp ), parameter :: b119 = - 0.0782942710351670777553986729725692447252077047239160551335016_wp real ( wp ), parameter :: b1110 = - 0.114503299361098912184303164290554670970133218405658122674674_wp real ( wp ), parameter :: b120 = 0.985115610164857280120041500306517278413646677314195559520529_wp real ( wp ), parameter :: b123 = 0.330885963040722183948884057658753173648240154838402033448632_wp real ( wp ), parameter :: b124 = 0.489662957309450192844507011135898201178015478433790097210790_wp real ( wp ), parameter :: b125 = - 1.37896486574843567582112720930751902353904327148559471526397_wp real ( wp ), parameter :: b126 = - 0.861164195027635666673916999665534573351026060987427093314412_wp real ( wp ), parameter :: b127 = 5.78428813637537220022999785486578436006872789689499172601856_wp real ( wp ), parameter :: b128 = 3.28807761985103566890460615937314805477268252903342356581925_wp real ( wp ), parameter :: b129 = - 2.38633905093136384013422325215527866148401465975954104585807_wp real ( wp ), parameter :: b1210 = - 3.25479342483643918654589367587788726747711504674780680269911_wp real ( wp ), parameter :: b1211 = - 2.16343541686422982353954211300054820889678036420109999154887_wp real ( wp ), parameter :: b130 = 0.895080295771632891049613132336585138148156279241561345991710_wp real ( wp ), parameter :: b132 = 0.197966831227192369068141770510388793370637287463360401555746_wp real ( wp ), parameter :: b133 = - 0.0729547847313632629185146671595558023015011608914382961421311_wp real ( wp ), parameter :: b135 = - 0.851236239662007619739049371445966793289359722875702227166105_wp real ( wp ), parameter :: b136 = 0.398320112318533301719718614174373643336480918103773904231856_wp real ( wp ), parameter :: b137 = 3.63937263181035606029412920047090044132027387893977804176229_wp real ( wp ), parameter :: b138 = 1.54822877039830322365301663075174564919981736348973496313065_wp real ( wp ), parameter :: b139 = - 2.12221714704053716026062427460427261025318461146260124401561_wp real ( wp ), parameter :: b1310 = - 1.58350398545326172713384349625753212757269188934434237975291_wp real ( wp ), parameter :: b1311 = - 1.71561608285936264922031819751349098912615880827551992973034_wp real ( wp ), parameter :: b1312 = - 0.0244036405750127452135415444412216875465593598370910566069132_wp real ( wp ), parameter :: b140 = - 0.915176561375291440520015019275342154318951387664369720564660_wp real ( wp ), parameter :: b141 = 1.45453440217827322805250021715664459117622483736537873607016_wp real ( wp ), parameter :: b144 = - 0.777333643644968233538931228575302137803351053629547286334469_wp real ( wp ), parameter :: b146 = - 0.0910895662155176069593203555807484200111889091770101799647985_wp real ( wp ), parameter :: b1412 = 0.0910895662155176069593203555807484200111889091770101799647985_wp real ( wp ), parameter :: b1413 = 0.777333643644968233538931228575302137803351053629547286334469_wp real ( wp ), parameter :: b150 = 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b152 = - 0.157178665799771163367058998273128921867183754126709419409654_wp real ( wp ), parameter :: b1514 = 0.157178665799771163367058998273128921867183754126709419409654_wp real ( wp ), parameter :: b160 = 0.181781300700095283888472062582262379650443831463199521664945_wp real ( wp ), parameter :: b161 = 0.675000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b162 = 0.342758159847189839942220553413850871742338734703958919937260_wp real ( wp ), parameter :: b164 = 0.259111214548322744512977076191767379267783684543182428778156_wp real ( wp ), parameter :: b165 = - 0.358278966717952089048961276721979397739750634673268802484271_wp real ( wp ), parameter :: b166 = - 1.04594895940883306095050068756409905131588123172378489286080_wp real ( wp ), parameter :: b167 = 0.930327845415626983292300564432428777137601651182965794680397_wp real ( wp ), parameter :: b168 = 1.77950959431708102446142106794824453926275743243327790536000_wp real ( wp ), parameter :: b169 = 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b1610 = - 0.282547569539044081612477785222287276408489375976211189952877_wp real ( wp ), parameter :: b1611 = - 0.159327350119972549169261984373485859278031542127551931461821_wp real ( wp ), parameter :: b1612 = - 0.145515894647001510860991961081084111308650130578626404945571_wp real ( wp ), parameter :: b1613 = - 0.259111214548322744512977076191767379267783684543182428778156_wp real ( wp ), parameter :: b1614 = - 0.342758159847189839942220553413850871742338734703958919937260_wp real ( wp ), parameter :: b1615 = - 0.675000000000000000000000000000000000000000000000000000000000_wp real ( wp ), dimension ( me % n ) :: f0 , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 , f10 , f11 , f12 , f13 , f14 , f15 , f16 if ( h == zero ) then xf = x terr = zero return end if call me % f ( t , x , f0 ) call me % f ( t + a1 * h , x + h * ( b10 * f0 ), f1 ) call me % f ( t + a2 * h , x + h * ( b20 * f0 + b21 * f1 ), f2 ) call me % f ( t + a3 * h , x + h * ( b30 * f0 + b32 * f2 ), f3 ) call me % f ( t + a4 * h , x + h * ( b40 * f0 + b42 * f2 + b43 * f3 ), f4 ) call me % f ( t + a5 * h , x + h * ( b50 * f0 + b53 * f3 + b54 * f4 ), f5 ) call me % f ( t + a6 * h , x + h * ( b60 * f0 + b63 * f3 + b64 * f4 + b65 * f5 ), f6 ) call me % f ( t + a7 * h , x + h * ( b70 * f0 + b74 * f4 + b75 * f5 + b76 * f6 ), f7 ) call me % f ( t + a8 * h , x + h * ( b80 * f0 + b85 * f5 + b86 * f6 + b87 * f7 ), f8 ) call me % f ( t + a9 * h , x + h * ( b90 * f0 + b95 * f5 + b96 * f6 + b97 * f7 + b98 * f8 ), f9 ) call me % f ( t + a10 * h , x + h * ( b100 * f0 + b105 * f5 + b106 * f6 + b107 * f7 + b108 * f8 + & b109 * f9 ), f10 ) call me % f ( t + a11 * h , x + h * ( b110 * f0 + b115 * f5 + b116 * f6 + b117 * f7 + b118 * f8 + & b119 * f9 + b1110 * f10 ), f11 ) call me % f ( t + a12 * h , x + h * ( b120 * f0 + b123 * f3 + b124 * f4 + b125 * f5 + b126 * f6 + & b127 * f7 + b128 * f8 + b129 * f9 + b1210 * f10 + b1211 * f11 ), f12 ) call me % f ( t + a13 * h , x + h * ( b130 * f0 + b132 * f2 + b133 * f3 + b135 * f5 + b136 * f6 + & b137 * f7 + b138 * f8 + b139 * f9 + b1310 * f10 + b1311 * f11 + & b1312 * f12 ), f13 ) call me % f ( t + a14 * h , x + h * ( b140 * f0 + b141 * f1 + b144 * f4 + b146 * f6 + b1412 * f12 + & b1413 * f13 ), f14 ) call me % f ( t + a15 * h , x + h * ( b150 * f0 + b152 * f2 + b1514 * f14 ), f15 ) call me % f ( t + h , x + h * ( b160 * f0 + b161 * f1 + b162 * f2 + b164 * f4 + b165 * f5 + & b166 * f6 + b167 * f7 + b168 * f8 + b169 * f9 + b1610 * f10 + b1611 * f11 + & b1612 * f12 + b1613 * f13 + b1614 * f14 + b1615 * f15 ), f16 ) xf = x + h * ( c0 * f0 + c1 * f1 + c2 * f2 + c4 * f4 + c6 * f6 + c8 * f8 + c9 * f9 + & c10 * f10 + c11 * f11 + c12 * f12 + c13 * f13 + c14 * f14 + c15 * f15 + c16 * f16 ) terr = ( 1.0_wp / 36 0.0_wp ) * h * ( f1 - f15 ) end subroutine rkf108","tags":"","url":"proc/rkf108.html"},{"title":"rkf1210 – fortran-astrodynamics-toolkit","text":"private  subroutine rkf1210(me, t, x, h, xf, terr) Feagin's RK12(10) method -- a 12th-order method with an embedded 10th-order method. Reference coefficient file Type Bound rkf1210_class Arguments Type Intent Optional Attributes Name class( rkf1210_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate Calls proc~~rkf1210~~CallsGraph proc~rkf1210 rkf1210_class%rkf1210 f f proc~rkf1210->f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine rkf1210 ( me , t , x , h , xf , terr ) implicit none class ( rkf1210_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state real ( wp ), intent ( in ) :: h !! time step real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! state at time `t+h` real ( wp ), dimension ( me % n ), intent ( out ) :: terr !! truncation error estimate real ( wp ), parameter :: a0 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a1 = 0.200000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a2 = 0.555555555555555555555555555555555555555555555555555555555556_wp real ( wp ), parameter :: a3 = 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a4 = 0.333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a5 = 1.00000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a6 = 0.671835709170513812712245661002797570438953420568682550710222_wp real ( wp ), parameter :: a7 = 0.288724941110620201935458488967024976908118598341806976469674_wp real ( wp ), parameter :: a8 = 0.562500000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a9 = 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a10 = 0.947695431179199287562380162101836721649589325892740646458322_wp real ( wp ), parameter :: a11 = 0.0548112876863802643887753674810754475842153612931128785028369_wp real ( wp ), parameter :: a12 = 0.0848880518607165350639838930162674302064148175640019542045934_wp real ( wp ), parameter :: a13 = 0.265575603264642893098114059045616835297201264164077621448665_wp real ( wp ), parameter :: a14 = 0.500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a15 = 0.734424396735357106901885940954383164702798735835922378551335_wp real ( wp ), parameter :: a16 = 0.915111948139283464936016106983732569793585182435998045795407_wp real ( wp ), parameter :: a17 = 0.947695431179199287562380162101836721649589325892740646458322_wp real ( wp ), parameter :: a18 = 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a19 = 0.288724941110620201935458488967024976908118598341806976469674_wp real ( wp ), parameter :: a20 = 0.671835709170513812712245661002797570438953420568682550710222_wp real ( wp ), parameter :: a21 = 0.333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a22 = 0.555555555555555555555555555555555555555555555555555555555556_wp real ( wp ), parameter :: a23 = 0.200000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a24 = 1.00000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c0 = 0.0238095238095238095238095238095238095238095238095238095238095_wp real ( wp ), parameter :: c1 = 0.0234375000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c2 = 0.0312500000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c3 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c4 = 0.0416666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: c5 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c6 = 0.0500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c7 = 0.0500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c8 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c9 = 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c10 = 0.0714285714285714285714285714285714285714285714285714285714286_wp real ( wp ), parameter :: c11 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c12 = 0.138413023680782974005350203145033146748813640089941234591267_wp real ( wp ), parameter :: c13 = 0.215872690604931311708935511140681138965472074195773051123019_wp real ( wp ), parameter :: c14 = 0.243809523809523809523809523809523809523809523809523809523810_wp real ( wp ), parameter :: c15 = 0.215872690604931311708935511140681138965472074195773051123019_wp real ( wp ), parameter :: c16 = 0.138413023680782974005350203145033146748813640089941234591267_wp real ( wp ), parameter :: c17 = - 0.0714285714285714285714285714285714285714285714285714285714286_wp real ( wp ), parameter :: c18 = - 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c19 = - 0.0500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c20 = - 0.0500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c21 = - 0.0416666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: c22 = - 0.0312500000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c23 = - 0.0234375000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c24 = 0.0238095238095238095238095238095238095238095238095238095238095_wp real ( wp ), parameter :: b10 = 0.200000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b20 = - 0.216049382716049382716049382716049382716049382716049382716049_wp real ( wp ), parameter :: b21 = 0.771604938271604938271604938271604938271604938271604938271605_wp real ( wp ), parameter :: b30 = 0.208333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b31 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b32 = 0.625000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b40 = 0.193333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b41 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b42 = 0.220000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b43 = - 0.0800000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b50 = 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b51 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b52 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b53 = 0.400000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b54 = 0.500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b60 = 0.103364471650010477570395435690481791543342708330349879244197_wp real ( wp ), parameter :: b61 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b62 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b63 = 0.124053094528946761061581889237115328211074784955180298044074_wp real ( wp ), parameter :: b64 = 0.483171167561032899288836480451962508724109257517289177302380_wp real ( wp ), parameter :: b65 = - 0.0387530245694763252085681443767620580395733302341368038804290_wp real ( wp ), parameter :: b70 = 0.124038261431833324081904585980175168140024670698633612292480_wp real ( wp ), parameter :: b71 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b72 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b73 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b74 = 0.217050632197958486317846256953159942875916353757734167684657_wp real ( wp ), parameter :: b75 = 0.0137455792075966759812907801835048190594443990939408530842918_wp real ( wp ), parameter :: b76 = - 0.0661095317267682844455831341498149531672668252085016565917546_wp real ( wp ), parameter :: b80 = 0.0914774894856882983144991846980432197088832099976660100090486_wp real ( wp ), parameter :: b81 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b82 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b83 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b84 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b85 = - 0.00544348523717469689965754944144838611346156873847009178068318_wp real ( wp ), parameter :: b86 = 0.0680716801688453518578515120895103863112751730758794372203952_wp real ( wp ), parameter :: b87 = 0.408394315582641046727306852653894780093303185664924644551239_wp real ( wp ), parameter :: b90 = 0.0890013652502551018954509355423841780143232697403434118692699_wp real ( wp ), parameter :: b91 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b92 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b93 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b94 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b95 = 0.00499528226645532360197793408420692800405891149406814091955810_wp real ( wp ), parameter :: b96 = 0.397918238819828997341739603001347156083435060931424970826304_wp real ( wp ), parameter :: b97 = 0.427930210752576611068192608300897981558240730580396406312359_wp real ( wp ), parameter :: b98 = - 0.0865117637557827005740277475955029103267246394128995965941585_wp real ( wp ), parameter :: b100 = 0.0695087624134907543112693906409809822706021061685544615255758_wp real ( wp ), parameter :: b101 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b102 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b103 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b104 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b105 = 0.129146941900176461970759579482746551122871751501482634045487_wp real ( wp ), parameter :: b106 = 1.53073638102311295076342566143214939031177504112433874313011_wp real ( wp ), parameter :: b107 = 0.577874761129140052546751349454576715334892100418571882718036_wp real ( wp ), parameter :: b108 = - 0.951294772321088980532340837388859453930924498799228648050949_wp real ( wp ), parameter :: b109 = - 0.408276642965631951497484981519757463459627174520978426909934_wp real ( wp ), parameter :: b110 = 0.0444861403295135866269453507092463581620165501018684152933313_wp real ( wp ), parameter :: b111 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b112 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b113 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b114 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b115 = - 0.00380476867056961731984232686574547203016331563626856065717964_wp real ( wp ), parameter :: b116 = 0.0106955064029624200721262602809059154469206077644957399593972_wp real ( wp ), parameter :: b117 = 0.0209616244499904333296674205928919920806734650660039898074652_wp real ( wp ), parameter :: b118 = - 0.0233146023259321786648561431551978077665337818756053603898847_wp real ( wp ), parameter :: b119 = 0.00263265981064536974369934736325334761174975280887405725010964_wp real ( wp ), parameter :: b1110 = 0.00315472768977025060103545855572111407955208306374459723959783_wp real ( wp ), parameter :: b120 = 0.0194588815119755475588801096525317761242073762016273186231215_wp real ( wp ), parameter :: b121 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b122 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b123 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b124 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b125 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b126 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b127 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b128 = 0.0000678512949171812509306121653452367476194364781259165332321534_wp real ( wp ), parameter :: b129 = - 0.0000429795859049273623271005330230162343568863387724883603675550_wp real ( wp ), parameter :: b1210 = 0.0000176358982260285155407485928953302139937553442829975734148981_wp real ( wp ), parameter :: b1211 = 0.0653866627415027051009595231385181033549511358787382098351924_wp real ( wp ), parameter :: b130 = 0.206836835664277105916828174798272361078909196043446411598231_wp real ( wp ), parameter :: b131 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b132 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b133 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b134 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b135 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b136 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b137 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b138 = 0.0166796067104156472828045866664696450306326505094792505215514_wp real ( wp ), parameter :: b139 = - 0.00879501563200710214457024178249986591130234990219959208704979_wp real ( wp ), parameter :: b1310 = 0.00346675455362463910824462315246379209427513654098596403637231_wp real ( wp ), parameter :: b1311 = - 0.861264460105717678161432562258351242030270498966891201799225_wp real ( wp ), parameter :: b1312 = 0.908651882074050281096239478469262145034957129939256789178785_wp real ( wp ), parameter :: b140 = 0.0203926084654484010091511314676925686038504449562413004562382_wp real ( wp ), parameter :: b141 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b142 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b143 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b144 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b145 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b146 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b147 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b148 = 0.0869469392016685948675400555583947505833954460930940959577347_wp real ( wp ), parameter :: b149 = - 0.0191649630410149842286436611791405053287170076602337673587681_wp real ( wp ), parameter :: b1410 = 0.00655629159493663287364871573244244516034828755253746024098838_wp real ( wp ), parameter :: b1411 = 0.0987476128127434780903798528674033899738924968006632201445462_wp real ( wp ), parameter :: b1412 = 0.00535364695524996055083260173615567408717110247274021056118319_wp real ( wp ), parameter :: b1413 = 0.301167864010967916837091303817051676920059229784957479998077_wp real ( wp ), parameter :: b150 = 0.228410433917778099547115412893004398779136994596948545722283_wp real ( wp ), parameter :: b151 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b152 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b153 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b154 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b155 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b156 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b157 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b158 = - 0.498707400793025250635016567442511512138603770959682292383042_wp real ( wp ), parameter :: b159 = 0.134841168335724478552596703792570104791700727205981058201689_wp real ( wp ), parameter :: b1510 = - 0.0387458244055834158439904226924029230935161059142806805674360_wp real ( wp ), parameter :: b1511 = - 1.27473257473474844240388430824908952380979292713250350199641_wp real ( wp ), parameter :: b1512 = 1.43916364462877165201184452437038081875299303577911839630524_wp real ( wp ), parameter :: b1513 = - 0.214007467967990254219503540827349569639028092344812795499026_wp real ( wp ), parameter :: b1514 = 0.958202417754430239892724139109781371059908874605153648768037_wp real ( wp ), parameter :: b160 = 2.00222477655974203614249646012506747121440306225711721209798_wp real ( wp ), parameter :: b161 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b162 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b163 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b164 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b165 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b166 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b167 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b168 = 2.06701809961524912091954656438138595825411859673341600679555_wp real ( wp ), parameter :: b169 = 0.623978136086139541957471279831494466155292316167021080663140_wp real ( wp ), parameter :: b1610 = - 0.0462283685500311430283203554129062069391947101880112723185773_wp real ( wp ), parameter :: b1611 = - 8.84973288362649614860075246727118949286604835457092701094630_wp real ( wp ), parameter :: b1612 = 7.74257707850855976227437225791835589560188590785037197433615_wp real ( wp ), parameter :: b1613 = - 0.588358519250869210993353314127711745644125882130941202896436_wp real ( wp ), parameter :: b1614 = - 1.10683733362380649395704708016953056176195769617014899442903_wp real ( wp ), parameter :: b1615 = - 0.929529037579203999778397238291233214220788057511899747507074_wp real ( wp ), parameter :: b170 = 3.13789533412073442934451608989888796808161259330322100268310_wp real ( wp ), parameter :: b171 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b172 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b173 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b174 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b175 = 0.129146941900176461970759579482746551122871751501482634045487_wp real ( wp ), parameter :: b176 = 1.53073638102311295076342566143214939031177504112433874313011_wp real ( wp ), parameter :: b177 = 0.577874761129140052546751349454576715334892100418571882718036_wp real ( wp ), parameter :: b178 = 5.42088263055126683050056840891857421941300558851862156403363_wp real ( wp ), parameter :: b179 = 0.231546926034829304872663800877643660904880180835945693836936_wp real ( wp ), parameter :: b1710 = 0.0759292995578913560162301311785251873561801342333194895292058_wp real ( wp ), parameter :: b1711 = - 1 2.3729973380186513287414553402595806591349822617535905976253_wp real ( wp ), parameter :: b1712 = 9.85455883464769543935957209317369202080367765721777101906955_wp real ( wp ), parameter :: b1713 = 0.0859111431370436529579357709052367772889980495122329601159540_wp real ( wp ), parameter :: b1714 = - 5.65242752862643921117182090081762761180392602644189218673969_wp real ( wp ), parameter :: b1715 = - 1.94300935242819610883833776782364287728724899124166920477873_wp real ( wp ), parameter :: b1716 = - 0.128352601849404542018428714319344620742146491335612353559923_wp real ( wp ), parameter :: b180 = 1.38360054432196014878538118298167716825163268489922519995564_wp real ( wp ), parameter :: b181 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b182 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b183 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b184 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b185 = 0.00499528226645532360197793408420692800405891149406814091955810_wp real ( wp ), parameter :: b186 = 0.397918238819828997341739603001347156083435060931424970826304_wp real ( wp ), parameter :: b187 = 0.427930210752576611068192608300897981558240730580396406312359_wp real ( wp ), parameter :: b188 = - 1.30299107424475770916551439123047573342071475998399645982146_wp real ( wp ), parameter :: b189 = 0.661292278669377029097112528107513072734573412294008071500699_wp real ( wp ), parameter :: b1810 = - 0.144559774306954349765969393688703463900585822441545655530145_wp real ( wp ), parameter :: b1811 = - 6.96576034731798203467853867461083919356792248105919255460819_wp real ( wp ), parameter :: b1812 = 6.65808543235991748353408295542210450632193197576935120716437_wp real ( wp ), parameter :: b1813 = - 1.66997375108841486404695805725510845049807969199236227575796_wp real ( wp ), parameter :: b1814 = 2.06413702318035263832289040301832647130604651223986452170089_wp real ( wp ), parameter :: b1815 = - 0.674743962644306471862958129570837723192079875998405058648892_wp real ( wp ), parameter :: b1816 = - 0.00115618834794939500490703608435907610059605754935305582045729_wp real ( wp ), parameter :: b1817 = - 0.00544057908677007389319819914241631024660726585015012485938593_wp real ( wp ), parameter :: b190 = 0.951236297048287669474637975894973552166903378983475425758226_wp real ( wp ), parameter :: b191 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b192 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b193 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b194 = 0.217050632197958486317846256953159942875916353757734167684657_wp real ( wp ), parameter :: b195 = 0.0137455792075966759812907801835048190594443990939408530842918_wp real ( wp ), parameter :: b196 = - 0.0661095317267682844455831341498149531672668252085016565917546_wp real ( wp ), parameter :: b197 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b198 = 0.152281696736414447136604697040747131921486432699422112099617_wp real ( wp ), parameter :: b199 = - 0.337741018357599840802300793133998004354643424457539667670080_wp real ( wp ), parameter :: b1910 = - 0.0192825981633995781534949199286824400469353110630787982121133_wp real ( wp ), parameter :: b1911 = - 3.68259269696866809932409015535499603576312120746888880201882_wp real ( wp ), parameter :: b1912 = 3.16197870406982063541533528419683854018352080342887002331312_wp real ( wp ), parameter :: b1913 = - 0.370462522106885290716991856022051125477943482284080569177386_wp real ( wp ), parameter :: b1914 = - 0.0514974200365440434996434456698127984941168616474316871020314_wp real ( wp ), parameter :: b1915 = - 0.000829625532120152946787043541792848416659382675202720677536554_wp real ( wp ), parameter :: b1916 = 0.00000279801041419278598986586589070027583961355402640879503213503_wp real ( wp ), parameter :: b1917 = 0.0418603916412360287969841020776788461794119440689356178942252_wp real ( wp ), parameter :: b1918 = 0.279084255090877355915660874555379649966282167560126269290222_wp real ( wp ), parameter :: b200 = 0.103364471650010477570395435690481791543342708330349879244197_wp real ( wp ), parameter :: b201 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b202 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b203 = 0.124053094528946761061581889237115328211074784955180298044074_wp real ( wp ), parameter :: b204 = 0.483171167561032899288836480451962508724109257517289177302380_wp real ( wp ), parameter :: b205 = - 0.0387530245694763252085681443767620580395733302341368038804290_wp real ( wp ), parameter :: b206 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b207 = - 0.438313820361122420391059788940960176420682836652600698580091_wp real ( wp ), parameter :: b208 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b209 = - 0.218636633721676647685111485017151199362509373698288330593486_wp real ( wp ), parameter :: b2010 = - 0.0312334764394719229981634995206440349766174759626578122323015_wp real ( wp ), parameter :: b2011 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2012 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2013 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2014 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2015 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2016 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2017 = 0.0312334764394719229981634995206440349766174759626578122323015_wp real ( wp ), parameter :: b2018 = 0.218636633721676647685111485017151199362509373698288330593486_wp real ( wp ), parameter :: b2019 = 0.438313820361122420391059788940960176420682836652600698580091_wp real ( wp ), parameter :: b210 = 0.193333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b211 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b212 = 0.220000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b213 = - 0.0800000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b214 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b215 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b216 = 0.0984256130499315928152900286856048243348202521491288575952143_wp real ( wp ), parameter :: b217 = - 0.196410889223054653446526504390100417677539095340135532418849_wp real ( wp ), parameter :: b218 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b219 = 0.436457930493068729391826122587949137609670676712525034763317_wp real ( wp ), parameter :: b2110 = 0.0652613721675721098560370939805555698350543810708414716730270_wp real ( wp ), parameter :: b2111 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2112 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2113 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2114 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2115 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2116 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2117 = - 0.0652613721675721098560370939805555698350543810708414716730270_wp real ( wp ), parameter :: b2118 = - 0.436457930493068729391826122587949137609670676712525034763317_wp real ( wp ), parameter :: b2119 = 0.196410889223054653446526504390100417677539095340135532418849_wp real ( wp ), parameter :: b2120 = - 0.0984256130499315928152900286856048243348202521491288575952143_wp real ( wp ), parameter :: b220 = - 0.216049382716049382716049382716049382716049382716049382716049_wp real ( wp ), parameter :: b221 = 0.771604938271604938271604938271604938271604938271604938271605_wp real ( wp ), parameter :: b222 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b223 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b224 = - 0.666666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: b225 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b226 = - 0.390696469295978451446999802258495981249099665294395945559163_wp real ( wp ), parameter :: b227 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b228 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b229 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2210 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2211 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2212 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2213 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2214 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2215 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2216 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2217 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2218 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2219 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2220 = 0.390696469295978451446999802258495981249099665294395945559163_wp real ( wp ), parameter :: b2221 = 0.666666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: b230 = 0.200000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b231 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b232 = - 0.164609053497942386831275720164609053497942386831275720164609_wp real ( wp ), parameter :: b233 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b234 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b235 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b236 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b237 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b238 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b239 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2310 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2311 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2312 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2313 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2314 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2315 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2316 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2317 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2318 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2319 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2320 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2321 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2322 = 0.164609053497942386831275720164609053497942386831275720164609_wp real ( wp ), parameter :: b240 = 1.47178724881110408452949550989023611293535315518571691939396_wp real ( wp ), parameter :: b241 = 0.787500000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b242 = 0.421296296296296296296296296296296296296296296296296296296296_wp real ( wp ), parameter :: b243 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b244 = 0.291666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: b245 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b246 = 0.348600717628329563206854421629657569274689947367847465753757_wp real ( wp ), parameter :: b247 = 0.229499544768994849582890233710555447073823569666506700662510_wp real ( wp ), parameter :: b248 = 5.79046485790481979159831978177003471098279506036722411333192_wp real ( wp ), parameter :: b249 = 0.418587511856506868874073759426596207226461447604248151080016_wp real ( wp ), parameter :: b2410 = 0.307039880222474002649653817490106690389251482313213999386651_wp real ( wp ), parameter :: b2411 = - 4.68700905350603332214256344683853248065574415794742040470287_wp real ( wp ), parameter :: b2412 = 3.13571665593802262152038152399873856554395436199962915429076_wp real ( wp ), parameter :: b2413 = 1.40134829710965720817510506275620441055845017313930508348898_wp real ( wp ), parameter :: b2414 = - 5.52931101439499023629010306005764336421276055777658156400910_wp real ( wp ), parameter :: b2415 = - 0.853138235508063349309546894974784906188927508039552519557498_wp real ( wp ), parameter :: b2416 = 0.103575780373610140411804607167772795518293914458500175573749_wp real ( wp ), parameter :: b2417 = - 0.140474416950600941142546901202132534870665923700034957196546_wp real ( wp ), parameter :: b2418 = - 0.418587511856506868874073759426596207226461447604248151080016_wp real ( wp ), parameter :: b2419 = - 0.229499544768994849582890233710555447073823569666506700662510_wp real ( wp ), parameter :: b2420 = - 0.348600717628329563206854421629657569274689947367847465753757_wp real ( wp ), parameter :: b2421 = - 0.291666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: b2422 = - 0.421296296296296296296296296296296296296296296296296296296296_wp real ( wp ), parameter :: b2423 = - 0.787500000000000000000000000000000000000000000000000000000000_wp real ( wp ), dimension ( me % n ) :: f0 , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 , f10 , f11 , f12 ,& f13 , f14 , f15 , f16 , f17 , f18 , f19 , f20 , f21 , f22 , f23 , f24 if ( h == zero ) then xf = x terr = zero return end if call me % f ( t + a0 * h , x , f0 ) call me % f ( t + a1 * h , x + h * ( b10 * f0 ), f1 ) call me % f ( t + a2 * h , x + h * ( b20 * f0 + b21 * f1 ), f2 ) call me % f ( t + a3 * h , x + h * ( b30 * f0 + b31 * f1 + b32 * f2 ), f3 ) call me % f ( t + a4 * h , x + h * ( b40 * f0 + b41 * f1 + b42 * f2 + b43 * f3 ), f4 ) call me % f ( t + a5 * h , x + h * ( b50 * f0 + b51 * f1 + b52 * f2 + b53 * f3 + & b54 * f4 ), f5 ) call me % f ( t + a6 * h , x + h * ( b60 * f0 + b61 * f1 + b62 * f2 + b63 * f3 + & b64 * f4 + b65 * f5 ), f6 ) call me % f ( t + a7 * h , x + h * ( b70 * f0 + b71 * f1 + b72 * f2 + b73 * f3 + & b74 * f4 + b75 * f5 + b76 * f6 ), f7 ) call me % f ( t + a8 * h , x + h * ( b80 * f0 + b81 * f1 + b82 * f2 + b83 * f3 + & b84 * f4 + b85 * f5 + b86 * f6 + b87 * f7 ), f8 ) call me % f ( t + a9 * h , x + h * ( b90 * f0 + b91 * f1 + b92 * f2 + b93 * f3 + & b94 * f4 + b95 * f5 + b96 * f6 + b97 * f7 + & b98 * f8 ), f9 ) call me % f ( t + a10 * h , x + h * ( b100 * f0 + b101 * f1 + b102 * f2 + b103 * f3 + & b104 * f4 + b105 * f5 + b106 * f6 + b107 * f7 + & b108 * f8 + b109 * f9 ), f10 ) call me % f ( t + a11 * h , x + h * ( b110 * f0 + b111 * f1 + b112 * f2 + b113 * f3 + & b114 * f4 + b115 * f5 + b116 * f6 + b117 * f7 + & b118 * f8 + b119 * f9 + b1110 * f10 ), f11 ) call me % f ( t + a12 * h , x + h * ( b120 * f0 + b121 * f1 + b122 * f2 + b123 * f3 + & b124 * f4 + b125 * f5 + b126 * f6 + b127 * f7 + & b128 * f8 + b129 * f9 + b1210 * f10 + b1211 * f11 ), f12 ) call me % f ( t + a13 * h , x + h * ( b130 * f0 + b131 * f1 + b132 * f2 + b133 * f3 + & b134 * f4 + b135 * f5 + b136 * f6 + b137 * f7 + & b138 * f8 + b139 * f9 + b1310 * f10 + b1311 * f11 + & b1312 * f12 ), f13 ) call me % f ( t + a14 * h , x + h * ( b140 * f0 + b141 * f1 + b142 * f2 + b143 * f3 + & b144 * f4 + b145 * f5 + b146 * f6 + b147 * f7 + & b148 * f8 + b149 * f9 + b1410 * f10 + b1411 * f11 + & b1412 * f12 + b1413 * f13 ), f14 ) call me % f ( t + a15 * h , x + h * ( b150 * f0 + b151 * f1 + b152 * f2 + b153 * f3 + & b154 * f4 + b155 * f5 + b156 * f6 + b157 * f7 + & b158 * f8 + b159 * f9 + b1510 * f10 + b1511 * f11 + & b1512 * f12 + b1513 * f13 + b1514 * f14 ), f15 ) call me % f ( t + a16 * h , x + h * ( b160 * f0 + b161 * f1 + b162 * f2 + b163 * f3 + & b164 * f4 + b165 * f5 + b166 * f6 + b167 * f7 + & b168 * f8 + b169 * f9 + b1610 * f10 + b1611 * f11 + & b1612 * f12 + b1613 * f13 + b1614 * f14 + b1615 * f15 ), f16 ) call me % f ( t + a17 * h , x + h * ( b170 * f0 + b171 * f1 + b172 * f2 + b173 * f3 + & b174 * f4 + b175 * f5 + b176 * f6 + b177 * f7 + & b178 * f8 + b179 * f9 + b1710 * f10 + b1711 * f11 + & b1712 * f12 + b1713 * f13 + b1714 * f14 + b1715 * f15 + & b1716 * f16 ), f17 ) call me % f ( t + a18 * h , x + h * ( b180 * f0 + b181 * f1 + b182 * f2 + b183 * f3 + & b184 * f4 + b185 * f5 + b186 * f6 + b187 * f7 + & b188 * f8 + b189 * f9 + b1810 * f10 + b1811 * f11 + & b1812 * f12 + b1813 * f13 + b1814 * f14 + b1815 * f15 + & b1816 * f16 + b1817 * f17 ), f18 ) call me % f ( t + a19 * h , x + h * ( b190 * f0 + b191 * f1 + b192 * f2 + b193 * f3 + & b194 * f4 + b195 * f5 + b196 * f6 + b197 * f7 + & b198 * f8 + b199 * f9 + b1910 * f10 + b1911 * f11 + & b1912 * f12 + b1913 * f13 + b1914 * f14 + b1915 * f15 + & b1916 * f16 + b1917 * f17 + b1918 * f18 ), f19 ) call me % f ( t + a20 * h , x + h * ( b200 * f0 + b201 * f1 + b202 * f2 + b203 * f3 + & b204 * f4 + b205 * f5 + b206 * f6 + b207 * f7 + & b208 * f8 + b209 * f9 + b2010 * f10 + b2011 * f11 + & b2012 * f12 + b2013 * f13 + b2014 * f14 + b2015 * f15 + & b2016 * f16 + b2017 * f17 + b2018 * f18 + b2019 * f19 ), f20 ) call me % f ( t + a21 * h , x + h * ( b210 * f0 + b211 * f1 + b212 * f2 + b213 * f3 + & b214 * f4 + b215 * f5 + b216 * f6 + b217 * f7 + & b218 * f8 + b219 * f9 + b2110 * f10 + b2111 * f11 + & b2112 * f12 + b2113 * f13 + b2114 * f14 + b2115 * f15 + & b2116 * f16 + b2117 * f17 + b2118 * f18 + b2119 * f19 + & b2120 * f20 ), f21 ) call me % f ( t + a22 * h , x + h * ( b220 * f0 + b221 * f1 + b222 * f2 + b223 * f3 + & b224 * f4 + b225 * f5 + b226 * f6 + b227 * f7 + & b228 * f8 + b229 * f9 + b2210 * f10 + b2211 * f11 + & b2212 * f12 + b2213 * f13 + b2214 * f14 + b2215 * f15 + & b2216 * f16 + b2217 * f17 + b2218 * f18 + b2219 * f19 + & b2220 * f20 + b2221 * f21 ), f22 ) call me % f ( t + a23 * h , x + h * ( b230 * f0 + b231 * f1 + b232 * f2 + b233 * f3 + & b234 * f4 + b235 * f5 + b236 * f6 + b237 * f7 + & b238 * f8 + b239 * f9 + b2310 * f10 + b2311 * f11 + & b2312 * f12 + b2313 * f13 + b2314 * f14 + b2315 * f15 + & b2316 * f16 + b2317 * f17 + b2318 * f18 + b2319 * f19 + & b2320 * f20 + b2321 * f21 + b2322 * f22 ), f23 ) call me % f ( t + a24 * h , x + h * ( b240 * f0 + b241 * f1 + b242 * f2 + b243 * f3 + & b244 * f4 + b245 * f5 + b246 * f6 + b247 * f7 + & b248 * f8 + b249 * f9 + b2410 * f10 + b2411 * f11 + & b2412 * f12 + b2413 * f13 + b2414 * f14 + b2415 * f15 + & b2416 * f16 + b2417 * f17 + b2418 * f18 + b2419 * f19 + & b2420 * f20 + b2421 * f21 + b2422 * f22 + b2423 * f23 ), f24 ) xf = x + h * ( c0 * f0 + & c1 * f1 + & c2 * f2 + & c3 * f3 + & c4 * f4 + & c5 * f5 + & c6 * f6 + & c7 * f7 + & c8 * f8 + & c9 * f9 + & c10 * f10 + & c11 * f11 + & c12 * f12 + & c13 * f13 + & c14 * f14 + & c15 * f15 + & c16 * f16 + & c17 * f17 + & c18 * f18 + & c19 * f19 + & c20 * f20 + & c21 * f21 + & c22 * f22 + & c23 * f23 + & c24 * f24 ) terr = ( 4 9.0_wp / 64 0.0_wp ) * h * ( f1 - f23 ) end subroutine rkf1210","tags":"","url":"proc/rkf1210.html"},{"title":"rkf1412 – fortran-astrodynamics-toolkit","text":"private  subroutine rkf1412(me, t, x, h, xf, terr) Feagin's RK14(12) - a 14th-order method with an embedded 12th-order method. Reference coefficient file Type Bound rkf1412_class Arguments Type Intent Optional Attributes Name class( rkf1412_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate Calls proc~~rkf1412~~CallsGraph proc~rkf1412 rkf1412_class%rkf1412 f f proc~rkf1412->f Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine rkf1412 ( me , t , x , h , xf , terr ) implicit none class ( rkf1412_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state real ( wp ), intent ( in ) :: h !! time step real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! state at time `t+h` real ( wp ), dimension ( me % n ), intent ( out ) :: terr !! truncation error estimate real ( wp ), parameter :: a0 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a1 = 0.111111111111111111111111111111111111111111111111111111111111_wp real ( wp ), parameter :: a2 = 0.555555555555555555555555555555555555555555555555555555555556_wp real ( wp ), parameter :: a3 = 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a4 = 0.333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a5 = 1.00000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a6 = 0.669986979272772921764683785505998513938845229638460353285142_wp real ( wp ), parameter :: a7 = 0.297068384213818357389584716808219413223332094698915687379168_wp real ( wp ), parameter :: a8 = 0.727272727272727272727272727272727272727272727272727272727273_wp real ( wp ), parameter :: a9 = 0.140152799042188765276187487966946717629806463082532936287323_wp real ( wp ), parameter :: a10 = 0.700701039770150737151099854830749337941407049265546408969222_wp real ( wp ), parameter :: a11 = 0.363636363636363636363636363636363636363636363636363636363636_wp real ( wp ), parameter :: a12 = 0.263157894736842105263157894736842105263157894736842105263158_wp real ( wp ), parameter :: a13 = 0.0392172246650270859125196642501208648863714315266128052078483_wp real ( wp ), parameter :: a14 = 0.812917502928376762983393159278036506189612372617238550774312_wp real ( wp ), parameter :: a15 = 0.166666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: a16 = 0.900000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a17 = 0.0641299257451966923312771193896682809481096651615083225402924_wp real ( wp ), parameter :: a18 = 0.204149909283428848927744634301023405027149505241333751628870_wp real ( wp ), parameter :: a19 = 0.395350391048760565615671369827324372352227297456659450554577_wp real ( wp ), parameter :: a20 = 0.604649608951239434384328630172675627647772702543340549445423_wp real ( wp ), parameter :: a21 = 0.795850090716571151072255365698976594972850494758666248371130_wp real ( wp ), parameter :: a22 = 0.935870074254803307668722880610331719051890334838491677459708_wp real ( wp ), parameter :: a23 = 0.166666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: a24 = 0.812917502928376762983393159278036506189612372617238550774312_wp real ( wp ), parameter :: a25 = 0.0392172246650270859125196642501208648863714315266128052078483_wp real ( wp ), parameter :: a26 = 0.363636363636363636363636363636363636363636363636363636363636_wp real ( wp ), parameter :: a27 = 0.700701039770150737151099854830749337941407049265546408969222_wp real ( wp ), parameter :: a28 = 0.140152799042188765276187487966946717629806463082532936287323_wp real ( wp ), parameter :: a29 = 0.297068384213818357389584716808219413223332094698915687379168_wp real ( wp ), parameter :: a30 = 0.669986979272772921764683785505998513938845229638460353285142_wp real ( wp ), parameter :: a31 = 0.333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a32 = 0.555555555555555555555555555555555555555555555555555555555556_wp real ( wp ), parameter :: a33 = 0.111111111111111111111111111111111111111111111111111111111111_wp real ( wp ), parameter :: a34 = 1.00000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c0 = 0.0178571428571428571428571428571428571428571428571428571428571_wp real ( wp ), parameter :: c1 = 0.00585937500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c2 = 0.0117187500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c3 = 0.0_wp real ( wp ), parameter :: c4 = 0.0175781250000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c5 = 0.0_wp real ( wp ), parameter :: c6 = 0.0234375000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c7 = 0.0292968750000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c8 = 0.0_wp real ( wp ), parameter :: c9 = 0.0351562500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c10 = 0.0410156250000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c11 = 0.0468750000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c12 = 0.0_wp real ( wp ), parameter :: c13 = 0.0527343750000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c14 = 0.0585937500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c15 = 0.0644531250000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c16 = 0.0_wp real ( wp ), parameter :: c17 = 0.105352113571753019691496032887878162227673083080523884041670_wp real ( wp ), parameter :: c18 = 0.170561346241752182382120338553874085887555487802790804737501_wp real ( wp ), parameter :: c19 = 0.206229397329351940783526485701104894741914286259542454077972_wp real ( wp ), parameter :: c20 = 0.206229397329351940783526485701104894741914286259542454077972_wp real ( wp ), parameter :: c21 = 0.170561346241752182382120338553874085887555487802790804737501_wp real ( wp ), parameter :: c22 = 0.105352113571753019691496032887878162227673083080523884041670_wp real ( wp ), parameter :: c23 = - 0.0644531250000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c24 = - 0.0585937500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c25 = - 0.0527343750000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c26 = - 0.0468750000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c27 = - 0.0410156250000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c28 = - 0.0351562500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c29 = - 0.0292968750000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c30 = - 0.0234375000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c31 = - 0.0175781250000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c32 = - 0.0117187500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c33 = - 0.00585937500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c34 = 0.0178571428571428571428571428571428571428571428571428571428571_wp real ( wp ), parameter :: b10 = 0.111111111111111111111111111111111111111111111111111111111111_wp real ( wp ), parameter :: b20 = - 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b21 = 1.38888888888888888888888888888888888888888888888888888888889_wp real ( wp ), parameter :: b30 = 0.208333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b31 = 0.0_wp real ( wp ), parameter :: b32 = 0.625000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b40 = 0.193333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b41 = 0.0_wp real ( wp ), parameter :: b42 = 0.220000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b43 = - 0.0800000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b50 = 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b51 = 0.0_wp real ( wp ), parameter :: b52 = 0.0_wp real ( wp ), parameter :: b53 = 0.400000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b54 = 0.500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b60 = 0.103484561636679776672993546511910344499744798201971316606663_wp real ( wp ), parameter :: b61 = 0.0_wp real ( wp ), parameter :: b62 = 0.0_wp real ( wp ), parameter :: b63 = 0.122068887306407222589644082868962077139592714834162134741275_wp real ( wp ), parameter :: b64 = 0.482574490331246622475134780125688112865919023850168049679402_wp real ( wp ), parameter :: b65 = - 0.0381409600015606999730886240005620205664113072478411477421970_wp real ( wp ), parameter :: b70 = 0.124380526654094412881516420868799316268491466359671423163289_wp real ( wp ), parameter :: b71 = 0.0_wp real ( wp ), parameter :: b72 = 0.0_wp real ( wp ), parameter :: b73 = 0.0_wp real ( wp ), parameter :: b74 = 0.226120282197584301422238662979202901196752320742633143965145_wp real ( wp ), parameter :: b75 = 0.0137885887618080880607695837016477814530969417491493385363543_wp real ( wp ), parameter :: b76 = - 0.0672210133996684449749399507414305856950086341525382182856200_wp real ( wp ), parameter :: b80 = 0.0936919065659673815530885456083005933866349695217750085655603_wp real ( wp ), parameter :: b81 = 0.0_wp real ( wp ), parameter :: b82 = 0.0_wp real ( wp ), parameter :: b83 = 0.0_wp real ( wp ), parameter :: b84 = 0.0_wp real ( wp ), parameter :: b85 = - 0.00613406843450510987229498995641664735620914507128858871007099_wp real ( wp ), parameter :: b86 = 0.216019825625503063708860097659866573490979433278117320188668_wp real ( wp ), parameter :: b87 = 0.423695063515761937337619073960976753205867469544123532683116_wp real ( wp ), parameter :: b90 = 0.0838479812409052664616968791372814085980533139224911131069335_wp real ( wp ), parameter :: b91 = 0.0_wp real ( wp ), parameter :: b92 = 0.0_wp real ( wp ), parameter :: b93 = 0.0_wp real ( wp ), parameter :: b94 = 0.0_wp real ( wp ), parameter :: b95 = - 0.0117949367100973814319755056031295775367961960590736150777613_wp real ( wp ), parameter :: b96 = - 0.247299020568812652339473838743194598325992840353340132697498_wp real ( wp ), parameter :: b97 = 0.0978080858367729012259313014081291665503740655476733940756599_wp real ( wp ), parameter :: b98 = 0.217590689243420631360008651767860318344168120024782176879989_wp real ( wp ), parameter :: b100 = 0.0615255359769428227954562389614314714333423969064821107453940_wp real ( wp ), parameter :: b101 = 0.0_wp real ( wp ), parameter :: b102 = 0.0_wp real ( wp ), parameter :: b103 = 0.0_wp real ( wp ), parameter :: b104 = 0.0_wp real ( wp ), parameter :: b105 = 0.00592232780324503308042990005798046524738389560444257136834990_wp real ( wp ), parameter :: b106 = 0.470326159963841112217224303205894113455362530746108825010848_wp real ( wp ), parameter :: b107 = 0.299688863848679000853981837096192399136831121671781279184194_wp real ( wp ), parameter :: b108 = - 0.247656877593994914689992276329810825853958069263947095548189_wp real ( wp ), parameter :: b109 = 0.110895029771437682893999851839061714522445173600678718208625_wp real ( wp ), parameter :: b110 = 0.0419700073362782579861792864787277787213483656543104611245994_wp real ( wp ), parameter :: b111 = 0.0_wp real ( wp ), parameter :: b112 = 0.0_wp real ( wp ), parameter :: b113 = 0.0_wp real ( wp ), parameter :: b114 = 0.0_wp real ( wp ), parameter :: b115 = - 0.00317987696266205093901912847692712407988609169703103952205634_wp real ( wp ), parameter :: b116 = 0.806397714906192077260821711520379506393543111567419750119748_wp real ( wp ), parameter :: b117 = 0.0975983126412388979093522850684288851314672048003054550357187_wp real ( wp ), parameter :: b118 = 0.778575578158398909027512446452927238999763460594181964958853_wp real ( wp ), parameter :: b119 = 0.204890423831599428189499202098105603312029235081420653574829_wp real ( wp ), parameter :: b1110 = - 1.56261579627468188307070943950527825211462892236424360892806_wp real ( wp ), parameter :: b120 = 0.0437726782233730163574465242495339811688214967071614123256973_wp real ( wp ), parameter :: b121 = 0.0_wp real ( wp ), parameter :: b122 = 0.0_wp real ( wp ), parameter :: b123 = 0.0_wp real ( wp ), parameter :: b124 = 0.0_wp real ( wp ), parameter :: b125 = 0.0_wp real ( wp ), parameter :: b126 = 0.0_wp real ( wp ), parameter :: b127 = 0.0_wp real ( wp ), parameter :: b128 = 0.00624365027520195208794358628580933625281631216903095917201250_wp real ( wp ), parameter :: b129 = 0.200043097109577314994435165469647856829066232218264969608768_wp real ( wp ), parameter :: b1210 = - 0.00805328367804983036823857162048902911923392887337029314844206_wp real ( wp ), parameter :: b1211 = 0.0211517528067396521915711903523399601316877825157550573051221_wp real ( wp ), parameter :: b130 = 0.0283499250363514563095023591920717312247137654896477097768495_wp real ( wp ), parameter :: b131 = 0.0_wp real ( wp ), parameter :: b132 = 0.0_wp real ( wp ), parameter :: b133 = 0.0_wp real ( wp ), parameter :: b134 = 0.0_wp real ( wp ), parameter :: b135 = 0.0_wp real ( wp ), parameter :: b136 = 0.0_wp real ( wp ), parameter :: b137 = 0.0_wp real ( wp ), parameter :: b138 = 0.00249163204855817407538949148805995149459884653585417680098222_wp real ( wp ), parameter :: b139 = 0.0230138787854593149638399846373742768772087122638142234223658_wp real ( wp ), parameter :: b1310 = - 0.00322155956692977098724476092467120878189463604760620461043308_wp real ( wp ), parameter :: b1311 = 0.00988442549447664668946335414487885256040819982786014648129297_wp real ( wp ), parameter :: b1312 = - 0.0213010771328887351384307642875927384886634565429572466632092_wp real ( wp ), parameter :: b140 = 0.343511894290243001049432234735147943083353174980701426268122_wp real ( wp ), parameter :: b141 = 0.0_wp real ( wp ), parameter :: b142 = 0.0_wp real ( wp ), parameter :: b143 = 0.0_wp real ( wp ), parameter :: b144 = 0.0_wp real ( wp ), parameter :: b145 = 0.0_wp real ( wp ), parameter :: b146 = 0.0_wp real ( wp ), parameter :: b147 = 0.0_wp real ( wp ), parameter :: b148 = 0.210451912023627385609097011999010655788807405225626700040882_wp real ( wp ), parameter :: b149 = 1.03427452057230411936482926828825709938667999698324740166559_wp real ( wp ), parameter :: b1410 = 0.00600303645864422487051240448206640574939078092406156945568306_wp real ( wp ), parameter :: b1411 = 0.855938125099619537578012106002407728915062652616416005816477_wp real ( wp ), parameter :: b1412 = - 0.977235005036766810872264852372525633013107656892839677696022_wp real ( wp ), parameter :: b1413 = - 0.660026980479294694616225013856327693720573981219974874776419_wp real ( wp ), parameter :: b150 = - 0.0143574001672168069538206399935076366657755954378399880691949_wp real ( wp ), parameter :: b151 = 0.0_wp real ( wp ), parameter :: b152 = 0.0_wp real ( wp ), parameter :: b153 = 0.0_wp real ( wp ), parameter :: b154 = 0.0_wp real ( wp ), parameter :: b155 = 0.0_wp real ( wp ), parameter :: b156 = 0.0_wp real ( wp ), parameter :: b157 = 0.0_wp real ( wp ), parameter :: b158 = - 0.0366253270049039970293685796848974791733119081733552207318285_wp real ( wp ), parameter :: b159 = 0.0350254975636213681976849406979846524346789082471103574920148_wp real ( wp ), parameter :: b1510 = 0.0360946016362113508931786658758335239823689929864237671348749_wp real ( wp ), parameter :: b1511 = - 0.0265219967553681106351595946834601923649627012457464284442911_wp real ( wp ), parameter :: b1512 = 0.0445699011305698119638911537508839908104336323082226770910408_wp real ( wp ), parameter :: b1513 = 0.124343093331358243286225595741786448038973408895106741855721_wp real ( wp ), parameter :: b1514 = 0.00413829693239480694403512496204335960426192908674476033832967_wp real ( wp ), parameter :: b160 = 0.356032404425120290975609116398089176264106222379748802654822_wp real ( wp ), parameter :: b161 = 0.0_wp real ( wp ), parameter :: b162 = 0.0_wp real ( wp ), parameter :: b163 = 0.0_wp real ( wp ), parameter :: b164 = 0.0_wp real ( wp ), parameter :: b165 = 0.0_wp real ( wp ), parameter :: b166 = 0.0_wp real ( wp ), parameter :: b167 = 0.0_wp real ( wp ), parameter :: b168 = - 0.450192758947562595966821779075956175110645100214763601190349_wp real ( wp ), parameter :: b169 = 0.430527907083710898626656292808782917793030154094709462877146_wp real ( wp ), parameter :: b1610 = 0.511973029011022237668556960394071692077125787030651386389972_wp real ( wp ), parameter :: b1611 = 0.908303638886404260390159124638110213997496214819904630546596_wp real ( wp ), parameter :: b1612 = - 1.23921093371933931757372469151534028854413889248605726186520_wp real ( wp ), parameter :: b1613 = - 0.649048661671761465141672348879062553905402831967191097656668_wp real ( wp ), parameter :: b1614 = 0.251708904586819292210480529948970541404887852931447491219418_wp real ( wp ), parameter :: b1615 = 0.779906470345586398810756795282334476023540593411550187024263_wp real ( wp ), parameter :: b170 = 0.0130935687406513066406881206418834980127470438213192487844956_wp real ( wp ), parameter :: b171 = 0.0_wp real ( wp ), parameter :: b172 = 0.0_wp real ( wp ), parameter :: b173 = 0.0_wp real ( wp ), parameter :: b174 = 0.0_wp real ( wp ), parameter :: b175 = 0.0_wp real ( wp ), parameter :: b176 = 0.0_wp real ( wp ), parameter :: b177 = 0.0_wp real ( wp ), parameter :: b178 = 0.0_wp real ( wp ), parameter :: b179 = 0.0_wp real ( wp ), parameter :: b1710 = 0.0_wp real ( wp ), parameter :: b1711 = 0.0_wp real ( wp ), parameter :: b1712 = - 0.0000932053067985113945908461962767108237858631509684667142124826_wp real ( wp ), parameter :: b1713 = 0.0505374334262299359640090443138590726770942344716122381702746_wp real ( wp ), parameter :: b1714 = 8.04470341944487979109579109610197797641311868930865361048975e-7_wp real ( wp ), parameter :: b1715 = 0.000591726029494171190528755742777717259844340971924321528178248_wp real ( wp ), parameter :: b1716 = - 4.01614722154557337064691684906375587732264247950093804676867e-7_wp real ( wp ), parameter :: b180 = 0.0207926484466053012541944544000765652167255206144373407979758_wp real ( wp ), parameter :: b181 = 0.0_wp real ( wp ), parameter :: b182 = 0.0_wp real ( wp ), parameter :: b183 = 0.0_wp real ( wp ), parameter :: b184 = 0.0_wp real ( wp ), parameter :: b185 = 0.0_wp real ( wp ), parameter :: b186 = 0.0_wp real ( wp ), parameter :: b187 = 0.0_wp real ( wp ), parameter :: b188 = 0.0_wp real ( wp ), parameter :: b189 = 0.0_wp real ( wp ), parameter :: b1810 = 0.0_wp real ( wp ), parameter :: b1811 = 0.0_wp real ( wp ), parameter :: b1812 = 0.000582695918800085915101902697837284108951406103029871570103075_wp real ( wp ), parameter :: b1813 = - 0.00801700732358815939083342186525852746640558465919633524655451_wp real ( wp ), parameter :: b1814 = 4.03847643847136940375170821743560570484117290330895506618968e-6_wp real ( wp ), parameter :: b1815 = 0.0854609998055506144225056114567535602510114622033622491802597_wp real ( wp ), parameter :: b1816 = - 2.04486480935804242706707569691004307904442837552677456232848e-6_wp real ( wp ), parameter :: b1817 = 0.105328578824431893399799402979093997354240904235172843146582_wp real ( wp ), parameter :: b190 = 1.40153449795736021415446247355771306718486452917597731683689_wp real ( wp ), parameter :: b191 = 0.0_wp real ( wp ), parameter :: b192 = 0.0_wp real ( wp ), parameter :: b193 = 0.0_wp real ( wp ), parameter :: b194 = 0.0_wp real ( wp ), parameter :: b195 = 0.0_wp real ( wp ), parameter :: b196 = 0.0_wp real ( wp ), parameter :: b197 = 0.0_wp real ( wp ), parameter :: b198 = 0.0_wp real ( wp ), parameter :: b199 = 0.0_wp real ( wp ), parameter :: b1910 = 0.0_wp real ( wp ), parameter :: b1911 = 0.0_wp real ( wp ), parameter :: b1912 = - 0.230252000984221261616272410367415621261130298274455611733277_wp real ( wp ), parameter :: b1913 = - 7.21106840466912905659582237106874247165856493509961561958267_wp real ( wp ), parameter :: b1914 = 0.00372901560694836335236995327852132340217759566678662385552634_wp real ( wp ), parameter :: b1915 = - 4.71415495727125020678778179392224757011323373221820091641216_wp real ( wp ), parameter :: b1916 = - 0.00176367657545349242053841995032797673574903886695600132759652_wp real ( wp ), parameter :: b1917 = 7.64130548038698765563029310880237651185173367813936997648198_wp real ( wp ), parameter :: b1918 = 3.50602043659751834989896082949744710968212949893375368243588_wp real ( wp ), parameter :: b200 = 1 1.9514650694120686799372385830716401674473610826553517297976_wp real ( wp ), parameter :: b201 = 0.0_wp real ( wp ), parameter :: b202 = 0.0_wp real ( wp ), parameter :: b203 = 0.0_wp real ( wp ), parameter :: b204 = 0.0_wp real ( wp ), parameter :: b205 = 0.0_wp real ( wp ), parameter :: b206 = 0.0_wp real ( wp ), parameter :: b207 = 0.0_wp real ( wp ), parameter :: b208 = 0.0_wp real ( wp ), parameter :: b209 = 0.0_wp real ( wp ), parameter :: b2010 = 0.0_wp real ( wp ), parameter :: b2011 = 0.0_wp real ( wp ), parameter :: b2012 = 7.79480932108175968783516700231764388220284279598980948538579_wp real ( wp ), parameter :: b2013 = - 5 6.4501393867325792523560991120904281440468100061340556540132_wp real ( wp ), parameter :: b2014 = 0.0912376306930644901344530449290276645709607450403673704844997_wp real ( wp ), parameter :: b2015 = - 1 2.7336279925434886201945524309199275038162717529918963305155_wp real ( wp ), parameter :: b2016 = - 0.0396895921904719712313542810939736674712383070433147873009352_wp real ( wp ), parameter :: b2017 = 5 4.4392141883570886996225765155307791861438378423305337073797_wp real ( wp ), parameter :: b2018 = - 3.64411637921569236846406990361350645806721478409266709351203_wp real ( wp ), parameter :: b2019 = - 0.804503249910509910899030787958579499315694913210787878260459_wp real ( wp ), parameter :: b210 = - 14 8.809426507100488427838868268647625561930612082148597076690_wp real ( wp ), parameter :: b211 = 0.0_wp real ( wp ), parameter :: b212 = 0.0_wp real ( wp ), parameter :: b213 = 0.0_wp real ( wp ), parameter :: b214 = 0.0_wp real ( wp ), parameter :: b215 = 0.0_wp real ( wp ), parameter :: b216 = 0.0_wp real ( wp ), parameter :: b217 = 0.0_wp real ( wp ), parameter :: b218 = 0.0_wp real ( wp ), parameter :: b219 = 0.0_wp real ( wp ), parameter :: b2110 = 0.0_wp real ( wp ), parameter :: b2111 = 0.0_wp real ( wp ), parameter :: b2112 = - 9 1.7295278291256484357935662402321623495228729036354276506427_wp real ( wp ), parameter :: b2113 = 70 7.656144971598359834575719286335716154821128966649565194286_wp real ( wp ), parameter :: b2114 = - 1.10563611857482440905296961311590930801338308942637769555540_wp real ( wp ), parameter :: b2115 = 17 6.134591883811372587859898076055660406999516762301689616841_wp real ( wp ), parameter :: b2116 = 0.491384824214880662268898345164454557416884631402764792538746_wp real ( wp ), parameter :: b2117 = - 68 4.278000449814944358237535610895081956077167893600278300805_wp real ( wp ), parameter :: b2118 = 2 7.9910604998398258984224332124380407446002518400668657974589_wp real ( wp ), parameter :: b2119 = 1 3.1939710030282333443670964371153238435064159623744975073252_wp real ( wp ), parameter :: b2120 = 1.25128781283980445450114974148056006317268830077396406361417_wp real ( wp ), parameter :: b220 = - 9.67307946948196763644126118433219395839951408571877262880482_wp real ( wp ), parameter :: b221 = 0.0_wp real ( wp ), parameter :: b222 = 0.0_wp real ( wp ), parameter :: b223 = 0.0_wp real ( wp ), parameter :: b224 = 0.0_wp real ( wp ), parameter :: b225 = 0.0_wp real ( wp ), parameter :: b226 = 0.0_wp real ( wp ), parameter :: b227 = 0.0_wp real ( wp ), parameter :: b228 = 0.0_wp real ( wp ), parameter :: b229 = 0.0_wp real ( wp ), parameter :: b2210 = 0.0_wp real ( wp ), parameter :: b2211 = 0.0_wp real ( wp ), parameter :: b2212 = - 4.46990150858505531443846227701960360497830681408751431146712_wp real ( wp ), parameter :: b2213 = 4 5.5127128690952681968241950400052751178905907817398483534845_wp real ( wp ), parameter :: b2214 = - 0.0713085086183826912791492024438246129930559805352394367050813_wp real ( wp ), parameter :: b2215 = 1 1.2273614068412741582590624479939384207826800776794485051540_wp real ( wp ), parameter :: b2216 = 0.126244376717622724516237912909138809361786889819105426371393_wp real ( wp ), parameter :: b2217 = - 4 3.5439339549483313605810624907242107623814304467621407753424_wp real ( wp ), parameter :: b2218 = 0.787174307543058978398792994996550902064546091443233850464377_wp real ( wp ), parameter :: b2219 = 0.532264696744684215669300708603886690785395776821503851830821_wp real ( wp ), parameter :: b2220 = 0.422422733996325326010225127471388772575086538809603346825334_wp real ( wp ), parameter :: b2221 = 0.0859131249503067107308438031499859443441115056294154956487671_wp real ( wp ), parameter :: b230 = - 1 0.0664032447054702403396606900426891472202824757968765569183_wp real ( wp ), parameter :: b231 = 0.0_wp real ( wp ), parameter :: b232 = 0.0_wp real ( wp ), parameter :: b233 = 0.0_wp real ( wp ), parameter :: b234 = 0.0_wp real ( wp ), parameter :: b235 = 0.0_wp real ( wp ), parameter :: b236 = 0.0_wp real ( wp ), parameter :: b237 = 0.0_wp real ( wp ), parameter :: b238 = - 0.0366253270049039970293685796848974791733119081733552207318285_wp real ( wp ), parameter :: b239 = 0.0350254975636213681976849406979846524346789082471103574920148_wp real ( wp ), parameter :: b2310 = 0.0360946016362113508931786658758335239823689929864237671348749_wp real ( wp ), parameter :: b2311 = - 0.0265219967553681106351595946834601923649627012457464284442911_wp real ( wp ), parameter :: b2312 = - 6.27088972181464143590553149478871603839356122957396018530209_wp real ( wp ), parameter :: b2313 = 4 8.2079237442562989090702103008195063923492593141636117832993_wp real ( wp ), parameter :: b2314 = - 0.0694471689136165640882395180583732834557754169149088630301342_wp real ( wp ), parameter :: b2315 = 1 2.6810690204850295698341370913609807066108483811412127009785_wp real ( wp ), parameter :: b2316 = 0.0119671168968323754838161435501011294100927813964199613229864_wp real ( wp ), parameter :: b2317 = - 4 6.7249764992482408003358268242662695593201321659795608950429_wp real ( wp ), parameter :: b2318 = 1.33029613326626711314710039298216591399033511191227101321435_wp real ( wp ), parameter :: b2319 = 1.00766787503398298353438903619926657771162717793661719708370_wp real ( wp ), parameter :: b2320 = 0.0209512051933665091664122388475480702892770753864487241177616_wp real ( wp ), parameter :: b2321 = 0.0210134706331264177317735424331396407424412188443757490871603_wp real ( wp ), parameter :: b2322 = 0.00952196014417121794175101542454575907376360233658356240547761_wp real ( wp ), parameter :: b240 = - 40 9.478081677743708772589097409370357624424341606752069725341_wp real ( wp ), parameter :: b241 = 0.0_wp real ( wp ), parameter :: b242 = 0.0_wp real ( wp ), parameter :: b243 = 0.0_wp real ( wp ), parameter :: b244 = 0.0_wp real ( wp ), parameter :: b245 = 0.0_wp real ( wp ), parameter :: b246 = 0.0_wp real ( wp ), parameter :: b247 = 0.0_wp real ( wp ), parameter :: b248 = 0.210451912023627385609097011999010655788807405225626700040882_wp real ( wp ), parameter :: b249 = 1.03427452057230411936482926828825709938667999698324740166559_wp real ( wp ), parameter :: b2410 = 0.00600303645864422487051240448206640574939078092406156945568306_wp real ( wp ), parameter :: b2411 = 0.855938125099619537578012106002407728915062652616416005816477_wp real ( wp ), parameter :: b2412 = - 25 0.516998547447860492777657729316130386584050420782075966990_wp real ( wp ), parameter :: b2413 = 194 6.42466652388427766053750328264758595829850895761428240231_wp real ( wp ), parameter :: b2414 = - 3.04503882102310365506105809086860882786950544097602101685174_wp real ( wp ), parameter :: b2415 = 49 0.626379528281713521208265299168083841598542274061671576230_wp real ( wp ), parameter :: b2416 = 1.56647589531270907115484067013597445739595615245966775329993_wp real ( wp ), parameter :: b2417 = - 188 1.97428994011173362217267377035870619215906638453056643641_wp real ( wp ), parameter :: b2418 = 7 5.2592224724847175278837713643303149821620618914245864351135_wp real ( wp ), parameter :: b2419 = 3 4.5734356980331067622434344736554689696728644793551014989002_wp real ( wp ), parameter :: b2420 = 3.21147679440968961435417361847073755169022966748891627882572_wp real ( wp ), parameter :: b2421 = - 0.460408041738414391307201404237058848867245095265382820823055_wp real ( wp ), parameter :: b2422 = - 0.0870718339841810522431884137957986245724252047388936572215438_wp real ( wp ), parameter :: b2423 = - 7.39351814158303067567016952195521063999185773249132944724553_wp real ( wp ), parameter :: b250 = 3.43347475853550878921093496257596781120623891072008459930197_wp real ( wp ), parameter :: b251 = 0.0_wp real ( wp ), parameter :: b252 = 0.0_wp real ( wp ), parameter :: b253 = 0.0_wp real ( wp ), parameter :: b254 = 0.0_wp real ( wp ), parameter :: b255 = 0.0_wp real ( wp ), parameter :: b256 = 0.0_wp real ( wp ), parameter :: b257 = 0.0_wp real ( wp ), parameter :: b258 = 0.00249163204855817407538949148805995149459884653585417680098222_wp real ( wp ), parameter :: b259 = 0.0230138787854593149638399846373742768772087122638142234223658_wp real ( wp ), parameter :: b2510 = - 0.00322155956692977098724476092467120878189463604760620461043308_wp real ( wp ), parameter :: b2511 = 0.00988442549447664668946335414487885256040819982786014648129297_wp real ( wp ), parameter :: b2512 = 2.16252799377922507788307841904757354045759225335732707916530_wp real ( wp ), parameter :: b2513 = - 1 6.2699864546457421328065640660139489006987552040228852402716_wp real ( wp ), parameter :: b2514 = - 0.128534502120524552843583417470935010538029037542654506231743_wp real ( wp ), parameter :: b2515 = - 8.98915042666504253089307820833379330486511746063552853023189_wp real ( wp ), parameter :: b2516 = - 0.00348595363232025333387080201851013650192401767250513765000963_wp real ( wp ), parameter :: b2517 = 1 5.7936194113339807536235187388695574135853387025139738341334_wp real ( wp ), parameter :: b2518 = - 0.574403330914095065628165482017335820148383663195675408024658_wp real ( wp ), parameter :: b2519 = - 0.345602039021393296692722496608124982535237228827655306030152_wp real ( wp ), parameter :: b2520 = - 0.00662241490206585091731619991383757781133067992707418687587487_wp real ( wp ), parameter :: b2521 = - 0.00777788129242204164032546458607364309759347209626759111946150_wp real ( wp ), parameter :: b2522 = - 0.00356084192402274913338827232697437364675240818791706587952939_wp real ( wp ), parameter :: b2523 = 4.79282506449930799649797749629840189457296934139359048988332_wp real ( wp ), parameter :: b2524 = 0.153725464873068577844576387402512082757034273069877432944621_wp real ( wp ), parameter :: b260 = 3 2.3038520871985442326994734440031535091364975047784630088983_wp real ( wp ), parameter :: b261 = 0.0_wp real ( wp ), parameter :: b262 = 0.0_wp real ( wp ), parameter :: b263 = 0.0_wp real ( wp ), parameter :: b264 = 0.0_wp real ( wp ), parameter :: b265 = - 0.00317987696266205093901912847692712407988609169703103952205634_wp real ( wp ), parameter :: b266 = 0.806397714906192077260821711520379506393543111567419750119748_wp real ( wp ), parameter :: b267 = 0.0975983126412388979093522850684288851314672048003054550357187_wp real ( wp ), parameter :: b268 = 0.778575578158398909027512446452927238999763460594181964958853_wp real ( wp ), parameter :: b269 = 0.204890423831599428189499202098105603312029235081420653574829_wp real ( wp ), parameter :: b2610 = - 1.56261579627468188307070943950527825211462892236424360892806_wp real ( wp ), parameter :: b2611 = 0.0_wp real ( wp ), parameter :: b2612 = 1 6.3429891882310570648504243973927174708753353504154550405647_wp real ( wp ), parameter :: b2613 = - 15 4.544555293543621230730189631471036399316683669609116705323_wp real ( wp ), parameter :: b2614 = 1.56971088703334872692034283417621761466263593582497085955201_wp real ( wp ), parameter :: b2615 = 3.27685545087248131321429817269900731165522404974733504794135_wp real ( wp ), parameter :: b2616 = - 0.0503489245193653176348040727199783626534081095691632396802451_wp real ( wp ), parameter :: b2617 = 15 3.321151858041665070593767885914694011224363102594556731397_wp real ( wp ), parameter :: b2618 = 7.17568186327720495846766484814784143567826308034865369443637_wp real ( wp ), parameter :: b2619 = - 2.94036748675300481945917659896930989215320594380777597403592_wp real ( wp ), parameter :: b2620 = - 0.0665845946076803144470749676022628870281920493197256887985612_wp real ( wp ), parameter :: b2621 = - 0.0462346054990843661229248668562217261176966514016859284197145_wp real ( wp ), parameter :: b2622 = - 0.0204198733585679401539388228617269778848579774821581777675337_wp real ( wp ), parameter :: b2623 = - 5 3.3523106438735850515953441165998107974045090495791591218714_wp real ( wp ), parameter :: b2624 = - 1.35548714715078654978732186705996404017554501614191325114947_wp real ( wp ), parameter :: b2625 = - 1.57196275801232751882901735171459249177687219114442583461866_wp real ( wp ), parameter :: b270 = - 1 6.6451467486341512872031294403931758764560371130818978459405_wp real ( wp ), parameter :: b271 = 0.0_wp real ( wp ), parameter :: b272 = 0.0_wp real ( wp ), parameter :: b273 = 0.0_wp real ( wp ), parameter :: b274 = 0.0_wp real ( wp ), parameter :: b275 = 0.00592232780324503308042990005798046524738389560444257136834990_wp real ( wp ), parameter :: b276 = 0.470326159963841112217224303205894113455362530746108825010848_wp real ( wp ), parameter :: b277 = 0.299688863848679000853981837096192399136831121671781279184194_wp real ( wp ), parameter :: b278 = - 0.247656877593994914689992276329810825853958069263947095548189_wp real ( wp ), parameter :: b279 = 0.110895029771437682893999851839061714522445173600678718208625_wp real ( wp ), parameter :: b2710 = 0.0_wp real ( wp ), parameter :: b2711 = - 0.491719043846229147070666628704194097678081907210673044988866_wp real ( wp ), parameter :: b2712 = - 1 1.4743154427289496968389492564352536350842454130853175250727_wp real ( wp ), parameter :: b2713 = 8 0.2593166576230272541702485886484400152793366623589989106256_wp real ( wp ), parameter :: b2714 = - 0.384132303980042847625312526759029103746926841342088219165648_wp real ( wp ), parameter :: b2715 = 7.28147667468107583471326950926136115767612581862877764249646_wp real ( wp ), parameter :: b2716 = - 0.132699384612248379510571708176035274836827341616751884314074_wp real ( wp ), parameter :: b2717 = - 8 1.0799832525730726674679289752255240006070716633632990308935_wp real ( wp ), parameter :: b2718 = - 1.25037492835620639521768185656179119962253747492403205797494_wp real ( wp ), parameter :: b2719 = 2.59263594969543681023776379504377324994226447359296887778718_wp real ( wp ), parameter :: b2720 = - 0.301440298346404539830163997260526875264431537275641495291993_wp real ( wp ), parameter :: b2721 = 0.221384460789832337451706451572773791695246839057318414301020_wp real ( wp ), parameter :: b2722 = 0.0827577274771892931955989870974693152996276435429809890551210_wp real ( wp ), parameter :: b2723 = 1 8.9960662040611520464672450037243263998175161412237156872211_wp real ( wp ), parameter :: b2724 = 0.269231946409639685623468015128334167460051910348912845121977_wp real ( wp ), parameter :: b2725 = 1.62674827447066537462989364929628933988125029284183680279020_wp real ( wp ), parameter :: b2726 = 0.491719043846229147070666628704194097678081907210673044988866_wp real ( wp ), parameter :: b280 = 0.0838479812409052664616968791372814085980533139224911131069335_wp real ( wp ), parameter :: b281 = 0.0_wp real ( wp ), parameter :: b282 = 0.0_wp real ( wp ), parameter :: b283 = 0.0_wp real ( wp ), parameter :: b284 = 0.0_wp real ( wp ), parameter :: b285 = - 0.0117949367100973814319755056031295775367961960590736150777613_wp real ( wp ), parameter :: b286 = - 0.247299020568812652339473838743194598325992840353340132697498_wp real ( wp ), parameter :: b287 = 0.0978080858367729012259313014081291665503740655476733940756599_wp real ( wp ), parameter :: b288 = 0.217590689243420631360008651767860318344168120024782176879989_wp real ( wp ), parameter :: b289 = 0.0_wp real ( wp ), parameter :: b2810 = 0.137585606763325224865659632196787746647447222975084865975440_wp real ( wp ), parameter :: b2811 = 0.0439870229715046685058790092341545026046103890294261359042581_wp real ( wp ), parameter :: b2812 = 0.0_wp real ( wp ), parameter :: b2813 = - 0.513700813768193341957004456618630303738757363641964030086972_wp real ( wp ), parameter :: b2814 = 0.826355691151315508644211308399153458701423158616168576922372_wp real ( wp ), parameter :: b2815 = 2 5.7018139719811832625873882972519939511136556341960074626615_wp real ( wp ), parameter :: b2816 = 0.0_wp real ( wp ), parameter :: b2817 = 0.0_wp real ( wp ), parameter :: b2818 = 0.0_wp real ( wp ), parameter :: b2819 = 0.0_wp real ( wp ), parameter :: b2820 = 0.0_wp real ( wp ), parameter :: b2821 = 0.0_wp real ( wp ), parameter :: b2822 = 0.0_wp real ( wp ), parameter :: b2823 = - 2 5.7018139719811832625873882972519939511136556341960074626615_wp real ( wp ), parameter :: b2824 = - 0.826355691151315508644211308399153458701423158616168576922372_wp real ( wp ), parameter :: b2825 = 0.513700813768193341957004456618630303738757363641964030086972_wp real ( wp ), parameter :: b2826 = - 0.0439870229715046685058790092341545026046103890294261359042581_wp real ( wp ), parameter :: b2827 = - 0.137585606763325224865659632196787746647447222975084865975440_wp real ( wp ), parameter :: b290 = 0.124380526654094412881516420868799316268491466359671423163289_wp real ( wp ), parameter :: b291 = 0.0_wp real ( wp ), parameter :: b292 = 0.0_wp real ( wp ), parameter :: b293 = 0.0_wp real ( wp ), parameter :: b294 = 0.226120282197584301422238662979202901196752320742633143965145_wp real ( wp ), parameter :: b295 = 0.0137885887618080880607695837016477814530969417491493385363543_wp real ( wp ), parameter :: b296 = - 0.0672210133996684449749399507414305856950086341525382182856200_wp real ( wp ), parameter :: b297 = 0.0_wp real ( wp ), parameter :: b298 = 0.0_wp real ( wp ), parameter :: b299 = - 0.856238975085428354755349769879501772112121597411563802855067_wp real ( wp ), parameter :: b2910 = - 1.96337522866858908928262850028093813988180440518267404553576_wp real ( wp ), parameter :: b2911 = - 0.232332822724119401237246257308921847250108199230419994978218_wp real ( wp ), parameter :: b2912 = 0.0_wp real ( wp ), parameter :: b2913 = 4.30660719086453349461668936876562947772432562053478092626764_wp real ( wp ), parameter :: b2914 = - 2.92722963249465482659787911202390446687687394950633612630592_wp real ( wp ), parameter :: b2915 = - 8 2.3131666397858944454492334105458707735761966428138676971041_wp real ( wp ), parameter :: b2916 = 0.0_wp real ( wp ), parameter :: b2917 = 0.0_wp real ( wp ), parameter :: b2918 = 0.0_wp real ( wp ), parameter :: b2919 = 0.0_wp real ( wp ), parameter :: b2920 = 0.0_wp real ( wp ), parameter :: b2921 = 0.0_wp real ( wp ), parameter :: b2922 = 0.0_wp real ( wp ), parameter :: b2923 = 8 2.3131666397858944454492334105458707735761966428138676971041_wp real ( wp ), parameter :: b2924 = 2.92722963249465482659787911202390446687687394950633612630592_wp real ( wp ), parameter :: b2925 = - 4.30660719086453349461668936876562947772432562053478092626764_wp real ( wp ), parameter :: b2926 = 0.232332822724119401237246257308921847250108199230419994978218_wp real ( wp ), parameter :: b2927 = 1.96337522866858908928262850028093813988180440518267404553576_wp real ( wp ), parameter :: b2928 = 0.856238975085428354755349769879501772112121597411563802855067_wp real ( wp ), parameter :: b300 = 0.103484561636679776672993546511910344499744798201971316606663_wp real ( wp ), parameter :: b301 = 0.0_wp real ( wp ), parameter :: b302 = 0.0_wp real ( wp ), parameter :: b303 = 0.122068887306407222589644082868962077139592714834162134741275_wp real ( wp ), parameter :: b304 = 0.482574490331246622475134780125688112865919023850168049679402_wp real ( wp ), parameter :: b305 = - 0.0381409600015606999730886240005620205664113072478411477421970_wp real ( wp ), parameter :: b306 = 0.0_wp real ( wp ), parameter :: b307 = - 0.550499525310802324138388507020508177411414311000037561712836_wp real ( wp ), parameter :: b308 = 0.0_wp real ( wp ), parameter :: b309 = - 0.711915811585189227887648262043794387578291882406745570495765_wp real ( wp ), parameter :: b3010 = - 0.584129605671551340432988730158480872095335329645227595707052_wp real ( wp ), parameter :: b3011 = 0.0_wp real ( wp ), parameter :: b3012 = 0.0_wp real ( wp ), parameter :: b3013 = 2.11046308125864932128717300046622750300375054278936987850718_wp real ( wp ), parameter :: b3014 = - 0.0837494736739572135525742023001037992695260175335123517729291_wp real ( wp ), parameter :: b3015 = 5.10021499072320914075295969043344113107545060862804249161191_wp real ( wp ), parameter :: b3016 = 0.0_wp real ( wp ), parameter :: b3017 = 0.0_wp real ( wp ), parameter :: b3018 = 0.0_wp real ( wp ), parameter :: b3019 = 0.0_wp real ( wp ), parameter :: b3020 = 0.0_wp real ( wp ), parameter :: b3021 = 0.0_wp real ( wp ), parameter :: b3022 = 0.0_wp real ( wp ), parameter :: b3023 = - 5.10021499072320914075295969043344113107545060862804249161191_wp real ( wp ), parameter :: b3024 = 0.0837494736739572135525742023001037992695260175335123517729291_wp real ( wp ), parameter :: b3025 = - 2.11046308125864932128717300046622750300375054278936987850718_wp real ( wp ), parameter :: b3026 = 0.0_wp real ( wp ), parameter :: b3027 = 0.584129605671551340432988730158480872095335329645227595707052_wp real ( wp ), parameter :: b3028 = 0.711915811585189227887648262043794387578291882406745570495765_wp real ( wp ), parameter :: b3029 = 0.550499525310802324138388507020508177411414311000037561712836_wp real ( wp ), parameter :: b310 = 0.193333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b311 = 0.0_wp real ( wp ), parameter :: b312 = 0.220000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b313 = - 0.0800000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b314 = 0.0_wp real ( wp ), parameter :: b315 = 0.0_wp real ( wp ), parameter :: b316 = 0.109993425580724703919462404865068340845119058295846426463652_wp real ( wp ), parameter :: b317 = - 0.254297048076270161384068506997153122141835626976703920846242_wp real ( wp ), parameter :: b318 = 0.0_wp real ( wp ), parameter :: b319 = 0.865570777116694254343770343821098281832847401233011859346737_wp real ( wp ), parameter :: b3110 = 3.32416449114093083106799552786572018336860092936986407160200_wp real ( wp ), parameter :: b3111 = 0.0_wp real ( wp ), parameter :: b3112 = 0.0_wp real ( wp ), parameter :: b3113 = - 1 2.0102223315977933882352385148661841260301942633996815127277_wp real ( wp ), parameter :: b3114 = 0.476601466242493239430442776862061899602963782003580209476163_wp real ( wp ), parameter :: b3115 = - 2 9.0243011221036390525802623213654099596251221332470910692353_wp real ( wp ), parameter :: b3116 = 0.0_wp real ( wp ), parameter :: b3117 = 0.0_wp real ( wp ), parameter :: b3118 = 0.0_wp real ( wp ), parameter :: b3119 = 0.0_wp real ( wp ), parameter :: b3120 = 0.0_wp real ( wp ), parameter :: b3121 = 0.0_wp real ( wp ), parameter :: b3122 = 0.0_wp real ( wp ), parameter :: b3123 = 2 9.0243011221036390525802623213654099596251221332470910692353_wp real ( wp ), parameter :: b3124 = - 0.476601466242493239430442776862061899602963782003580209476163_wp real ( wp ), parameter :: b3125 = 1 2.0102223315977933882352385148661841260301942633996815127277_wp real ( wp ), parameter :: b3126 = 0.0_wp real ( wp ), parameter :: b3127 = - 3.32416449114093083106799552786572018336860092936986407160200_wp real ( wp ), parameter :: b3128 = - 0.865570777116694254343770343821098281832847401233011859346737_wp real ( wp ), parameter :: b3129 = 0.254297048076270161384068506997153122141835626976703920846242_wp real ( wp ), parameter :: b3130 = - 0.109993425580724703919462404865068340845119058295846426463652_wp real ( wp ), parameter :: b320 = - 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b321 = 1.38888888888888888888888888888888888888888888888888888888889_wp real ( wp ), parameter :: b322 = 0.0_wp real ( wp ), parameter :: b323 = 0.0_wp real ( wp ), parameter :: b324 = - 0.750000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b325 = 0.0_wp real ( wp ), parameter :: b326 = - 0.492529543718026304422682049114021320200214681580657784719074_wp real ( wp ), parameter :: b327 = 0.0_wp real ( wp ), parameter :: b328 = 0.0_wp real ( wp ), parameter :: b329 = 0.0_wp real ( wp ), parameter :: b3210 = 0.0_wp real ( wp ), parameter :: b3211 = 0.0_wp real ( wp ), parameter :: b3212 = 0.0_wp real ( wp ), parameter :: b3213 = 0.0_wp real ( wp ), parameter :: b3214 = 0.0_wp real ( wp ), parameter :: b3215 = 0.0_wp real ( wp ), parameter :: b3216 = 0.0_wp real ( wp ), parameter :: b3217 = 0.0_wp real ( wp ), parameter :: b3218 = 0.0_wp real ( wp ), parameter :: b3219 = 0.0_wp real ( wp ), parameter :: b3220 = 0.0_wp real ( wp ), parameter :: b3221 = 0.0_wp real ( wp ), parameter :: b3222 = 0.0_wp real ( wp ), parameter :: b3223 = 0.0_wp real ( wp ), parameter :: b3224 = 0.0_wp real ( wp ), parameter :: b3225 = 0.0_wp real ( wp ), parameter :: b3226 = 0.0_wp real ( wp ), parameter :: b3227 = 0.0_wp real ( wp ), parameter :: b3228 = 0.0_wp real ( wp ), parameter :: b3229 = 0.0_wp real ( wp ), parameter :: b3230 = 0.492529543718026304422682049114021320200214681580657784719074_wp real ( wp ), parameter :: b3231 = 0.750000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b330 = 0.111111111111111111111111111111111111111111111111111111111111_wp real ( wp ), parameter :: b331 = 0.0_wp real ( wp ), parameter :: b332 = - 0.222222222222222222222222222222222222222222222222222222222222_wp real ( wp ), parameter :: b333 = 0.0_wp real ( wp ), parameter :: b334 = 0.0_wp real ( wp ), parameter :: b335 = 0.0_wp real ( wp ), parameter :: b336 = 0.0_wp real ( wp ), parameter :: b337 = 0.0_wp real ( wp ), parameter :: b338 = 0.0_wp real ( wp ), parameter :: b339 = 0.0_wp real ( wp ), parameter :: b3310 = 0.0_wp real ( wp ), parameter :: b3311 = 0.0_wp real ( wp ), parameter :: b3312 = 0.0_wp real ( wp ), parameter :: b3313 = 0.0_wp real ( wp ), parameter :: b3314 = 0.0_wp real ( wp ), parameter :: b3315 = 0.0_wp real ( wp ), parameter :: b3316 = 0.0_wp real ( wp ), parameter :: b3317 = 0.0_wp real ( wp ), parameter :: b3318 = 0.0_wp real ( wp ), parameter :: b3319 = 0.0_wp real ( wp ), parameter :: b3320 = 0.0_wp real ( wp ), parameter :: b3321 = 0.0_wp real ( wp ), parameter :: b3322 = 0.0_wp real ( wp ), parameter :: b3323 = 0.0_wp real ( wp ), parameter :: b3324 = 0.0_wp real ( wp ), parameter :: b3325 = 0.0_wp real ( wp ), parameter :: b3326 = 0.0_wp real ( wp ), parameter :: b3327 = 0.0_wp real ( wp ), parameter :: b3328 = 0.0_wp real ( wp ), parameter :: b3329 = 0.0_wp real ( wp ), parameter :: b3330 = 0.0_wp real ( wp ), parameter :: b3331 = 0.0_wp real ( wp ), parameter :: b3332 = 0.222222222222222222222222222222222222222222222222222222222222_wp real ( wp ), parameter :: b340 = 0.285835140388971558796088842163836414852927537894596466840753_wp real ( wp ), parameter :: b341 = 0.291666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: b342 = 0.218750000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b343 = 0.0_wp real ( wp ), parameter :: b344 = 0.164062500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b345 = 0.0_wp real ( wp ), parameter :: b346 = 0.218194354945556658327188241581352107093288824322187941141516_wp real ( wp ), parameter :: b347 = 0.180392898478697766863635221946775437719620053641849228562435_wp real ( wp ), parameter :: b348 = 0.0_wp real ( wp ), parameter :: b349 = 0.205713839404845018859120755122929542277570094982808905393991_wp real ( wp ), parameter :: b3410 = 0.242715791581770239970282927959446515762745971386670541948576_wp real ( wp ), parameter :: b3411 = 0.246465780813629305833609291181891407799228103869305705137021_wp real ( wp ), parameter :: b3412 = - 3.44991940790890824979834154601622662060370460614931644223924_wp real ( wp ), parameter :: b3413 = 0.228875562160036081760729060738458584294220372552740218459295_wp real ( wp ), parameter :: b3414 = 0.283290599702151415321527419056733335978436595493855789831434_wp real ( wp ), parameter :: b3415 = 3.21085125837766640960131490544236787005557320332238705967955_wp real ( wp ), parameter :: b3416 = - 0.223538777364845699920233756214162507964125230083674032084065_wp real ( wp ), parameter :: b3417 = - 0.707121157204419073518727286207487212130091231955206160635271_wp real ( wp ), parameter :: b3418 = 3.21123345150287080408174729202856500893260034443022374267639_wp real ( wp ), parameter :: b3419 = 1.40954348309669766030414474301123175769045945573548986335553_wp real ( wp ), parameter :: b3420 = - 0.151362053443742613121602276742518111090963026203676055891793_wp real ( wp ), parameter :: b3421 = 0.372350574527014276454724080214619984397121028202148298716575_wp real ( wp ), parameter :: b3422 = 0.252978746406361336722199907762141285915775728129414319261111_wp real ( wp ), parameter :: b3423 = - 3.21085125837766640960131490544236787005557320332238705967955_wp real ( wp ), parameter :: b3424 = - 0.283290599702151415321527419056733335978436595493855789831434_wp real ( wp ), parameter :: b3425 = - 0.228875562160036081760729060738458584294220372552740218459295_wp real ( wp ), parameter :: b3426 = - 0.246465780813629305833609291181891407799228103869305705137021_wp real ( wp ), parameter :: b3427 = - 0.242715791581770239970282927959446515762745971386670541948576_wp real ( wp ), parameter :: b3428 = - 0.205713839404845018859120755122929542277570094982808905393991_wp real ( wp ), parameter :: b3429 = - 0.180392898478697766863635221946775437719620053641849228562435_wp real ( wp ), parameter :: b3430 = - 0.218194354945556658327188241581352107093288824322187941141516_wp real ( wp ), parameter :: b3431 = - 0.164062500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b3432 = - 0.218750000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b3433 = - 0.291666666666666666666666666666666666666666666666666666666667_wp real ( wp ), dimension ( me % n ) :: f0 , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 , f10 , f11 , f12 ,& f13 , f14 , f15 , f16 , f17 , f18 , f19 , f20 , f21 , f22 , f23 , f24 ,& f25 , f26 , f27 , f28 , f29 , f30 , f31 , f32 , f33 , f34 if ( h == zero ) then xf = x terr = zero return end if call me % f ( t + a0 * h , x , f0 ) call me % f ( t + a1 * h , x + h * ( b10 * f0 ), f1 ) call me % f ( t + a2 * h , x + h * ( b20 * f0 + b21 * f1 ), f2 ) call me % f ( t + a3 * h , x + h * ( b30 * f0 + b31 * f1 + b32 * f2 ), f3 ) call me % f ( t + a4 * h , x + h * ( b40 * f0 + b41 * f1 + b42 * f2 + b43 * f3 ), f4 ) call me % f ( t + a5 * h , x + h * ( b50 * f0 + b51 * f1 + b52 * f2 + b53 * f3 + & b54 * f4 ), f5 ) call me % f ( t + a6 * h , x + h * ( b60 * f0 + b61 * f1 + b62 * f2 + b63 * f3 + & b64 * f4 + b65 * f5 ), f6 ) call me % f ( t + a7 * h , x + h * ( b70 * f0 + b71 * f1 + b72 * f2 + b73 * f3 + & b74 * f4 + b75 * f5 + b76 * f6 ), f7 ) call me % f ( t + a8 * h , x + h * ( b80 * f0 + b81 * f1 + b82 * f2 + b83 * f3 + & b84 * f4 + b85 * f5 + b86 * f6 + b87 * f7 ), f8 ) call me % f ( t + a9 * h , x + h * ( b90 * f0 + b91 * f1 + b92 * f2 + b93 * f3 + & b94 * f4 + b95 * f5 + b96 * f6 + b97 * f7 + & b98 * f8 ), f9 ) call me % f ( t + a10 * h , x + h * ( b100 * f0 + b101 * f1 + b102 * f2 + b103 * f3 + & b104 * f4 + b105 * f5 + b106 * f6 + b107 * f7 + & b108 * f8 + b109 * f9 ), f10 ) call me % f ( t + a11 * h , x + h * ( b110 * f0 + b111 * f1 + b112 * f2 + b113 * f3 + & b114 * f4 + b115 * f5 + b116 * f6 + b117 * f7 + & b118 * f8 + b119 * f9 + b1110 * f10 ), f11 ) call me % f ( t + a12 * h , x + h * ( b120 * f0 + b121 * f1 + b122 * f2 + b123 * f3 + & b124 * f4 + b125 * f5 + b126 * f6 + b127 * f7 + & b128 * f8 + b129 * f9 + b1210 * f10 + b1211 * f11 ), f12 ) call me % f ( t + a13 * h , x + h * ( b130 * f0 + b131 * f1 + b132 * f2 + b133 * f3 + & b134 * f4 + b135 * f5 + b136 * f6 + b137 * f7 + & b138 * f8 + b139 * f9 + b1310 * f10 + b1311 * f11 + & b1312 * f12 ), f13 ) call me % f ( t + a14 * h , x + h * ( b140 * f0 + b141 * f1 + b142 * f2 + b143 * f3 + & b144 * f4 + b145 * f5 + b146 * f6 + b147 * f7 + & b148 * f8 + b149 * f9 + b1410 * f10 + b1411 * f11 + & b1412 * f12 + b1413 * f13 ), f14 ) call me % f ( t + a15 * h , x + h * ( b150 * f0 + b151 * f1 + b152 * f2 + b153 * f3 + & b154 * f4 + b155 * f5 + b156 * f6 + b157 * f7 + & b158 * f8 + b159 * f9 + b1510 * f10 + b1511 * f11 + & b1512 * f12 + b1513 * f13 + b1514 * f14 ), f15 ) call me % f ( t + a16 * h , x + h * ( b160 * f0 + b161 * f1 + b162 * f2 + b163 * f3 + & b164 * f4 + b165 * f5 + b166 * f6 + b167 * f7 + & b168 * f8 + b169 * f9 + b1610 * f10 + b1611 * f11 + & b1612 * f12 + b1613 * f13 + b1614 * f14 + b1615 * f15 ), f16 ) call me % f ( t + a17 * h , x + h * ( b170 * f0 + b171 * f1 + b172 * f2 + b173 * f3 + & b174 * f4 + b175 * f5 + b176 * f6 + b177 * f7 + & b178 * f8 + b179 * f9 + b1710 * f10 + b1711 * f11 + & b1712 * f12 + b1713 * f13 + b1714 * f14 + b1715 * f15 + & b1716 * f16 ), f17 ) call me % f ( t + a18 * h , x + h * ( b180 * f0 + b181 * f1 + b182 * f2 + b183 * f3 + & b184 * f4 + b185 * f5 + b186 * f6 + b187 * f7 + & b188 * f8 + b189 * f9 + b1810 * f10 + b1811 * f11 + & b1812 * f12 + b1813 * f13 + b1814 * f14 + b1815 * f15 + & b1816 * f16 + b1817 * f17 ), f18 ) call me % f ( t + a19 * h , x + h * ( b190 * f0 + b191 * f1 + b192 * f2 + b193 * f3 + & b194 * f4 + b195 * f5 + b196 * f6 + b197 * f7 + & b198 * f8 + b199 * f9 + b1910 * f10 + b1911 * f11 + & b1912 * f12 + b1913 * f13 + b1914 * f14 + b1915 * f15 + & b1916 * f16 + b1917 * f17 + b1918 * f18 ), f19 ) call me % f ( t + a20 * h , x + h * ( b200 * f0 + b201 * f1 + b202 * f2 + b203 * f3 + & b204 * f4 + b205 * f5 + b206 * f6 + b207 * f7 + & b208 * f8 + b209 * f9 + b2010 * f10 + b2011 * f11 + & b2012 * f12 + b2013 * f13 + b2014 * f14 + b2015 * f15 + & b2016 * f16 + b2017 * f17 + b2018 * f18 + b2019 * f19 ), f20 ) call me % f ( t + a21 * h , x + h * ( b210 * f0 + b211 * f1 + b212 * f2 + b213 * f3 + & b214 * f4 + b215 * f5 + b216 * f6 + b217 * f7 + & b218 * f8 + b219 * f9 + b2110 * f10 + b2111 * f11 + & b2112 * f12 + b2113 * f13 + b2114 * f14 + b2115 * f15 + & b2116 * f16 + b2117 * f17 + b2118 * f18 + b2119 * f19 + & b2120 * f20 ), f21 ) call me % f ( t + a22 * h , x + h * ( b220 * f0 + b221 * f1 + b222 * f2 + b223 * f3 + & b224 * f4 + b225 * f5 + b226 * f6 + b227 * f7 + & b228 * f8 + b229 * f9 + b2210 * f10 + b2211 * f11 + & b2212 * f12 + b2213 * f13 + b2214 * f14 + b2215 * f15 + & b2216 * f16 + b2217 * f17 + b2218 * f18 + b2219 * f19 + & b2220 * f20 + b2221 * f21 ), f22 ) call me % f ( t + a23 * h , x + h * ( b230 * f0 + b231 * f1 + b232 * f2 + b233 * f3 + & b234 * f4 + b235 * f5 + b236 * f6 + b237 * f7 + & b238 * f8 + b239 * f9 + b2310 * f10 + b2311 * f11 + & b2312 * f12 + b2313 * f13 + b2314 * f14 + b2315 * f15 + & b2316 * f16 + b2317 * f17 + b2318 * f18 + b2319 * f19 + & b2320 * f20 + b2321 * f21 + b2322 * f22 ), f23 ) call me % f ( t + a24 * h , x + h * ( b240 * f0 + b241 * f1 + b242 * f2 + b243 * f3 + & b244 * f4 + b245 * f5 + b246 * f6 + b247 * f7 + & b248 * f8 + b249 * f9 + b2410 * f10 + b2411 * f11 + & b2412 * f12 + b2413 * f13 + b2414 * f14 + b2415 * f15 + & b2416 * f16 + b2417 * f17 + b2418 * f18 + b2419 * f19 + & b2420 * f20 + b2421 * f21 + b2422 * f22 + b2423 * f23 ), f24 ) call me % f ( t + a25 * h , x + h * ( b250 * f0 + b251 * f1 + b252 * f2 + b253 * f3 + & b254 * f4 + b255 * f5 + b256 * f6 + b257 * f7 + & b258 * f8 + b259 * f9 + b2510 * f10 + b2511 * f11 + & b2512 * f12 + b2513 * f13 + b2514 * f14 + b2515 * f15 + & b2516 * f16 + b2517 * f17 + b2518 * f18 + b2519 * f19 + & b2520 * f20 + b2521 * f21 + b2522 * f22 + b2523 * f23 + & b2524 * f24 ), f25 ) call me % f ( t + a26 * h , x + h * ( b260 * f0 + b261 * f1 + b262 * f2 + b263 * f3 + & b264 * f4 + b265 * f5 + b266 * f6 + b267 * f7 + & b268 * f8 + b269 * f9 + b2610 * f10 + b2611 * f11 + & b2612 * f12 + b2613 * f13 + b2614 * f14 + b2615 * f15 + & b2616 * f16 + b2617 * f17 + b2618 * f18 + b2619 * f19 + & b2620 * f20 + b2621 * f21 + b2622 * f22 + b2623 * f23 + & b2624 * f24 + b2625 * f25 ), f26 ) call me % f ( t + a27 * h , x + h * ( b270 * f0 + b271 * f1 + b272 * f2 + b273 * f3 + & b274 * f4 + b275 * f5 + b276 * f6 + b277 * f7 + & b278 * f8 + b279 * f9 + b2710 * f10 + b2711 * f11 + & b2712 * f12 + b2713 * f13 + b2714 * f14 + b2715 * f15 + & b2716 * f16 + b2717 * f17 + b2718 * f18 + b2719 * f19 + & b2720 * f20 + b2721 * f21 + b2722 * f22 + b2723 * f23 + & b2724 * f24 + b2725 * f25 + b2726 * f26 ), f27 ) call me % f ( t + a28 * h , x + h * ( b280 * f0 + b281 * f1 + b282 * f2 + b283 * f3 + & b284 * f4 + b285 * f5 + b286 * f6 + b287 * f7 + & b288 * f8 + b289 * f9 + b2810 * f10 + b2811 * f11 + & b2812 * f12 + b2813 * f13 + b2814 * f14 + b2815 * f15 + & b2816 * f16 + b2817 * f17 + b2818 * f18 + b2819 * f19 + & b2820 * f20 + b2821 * f21 + b2822 * f22 + b2823 * f23 + & b2824 * f24 + b2825 * f25 + b2826 * f26 + b2827 * f27 ), f28 ) call me % f ( t + a29 * h , x + h * ( b290 * f0 + b291 * f1 + b292 * f2 + b293 * f3 + & b294 * f4 + b295 * f5 + b296 * f6 + b297 * f7 + & b298 * f8 + b299 * f9 + b2910 * f10 + b2911 * f11 + & b2912 * f12 + b2913 * f13 + b2914 * f14 + b2915 * f15 + & b2916 * f16 + b2917 * f17 + b2918 * f18 + b2919 * f19 + & b2920 * f20 + b2921 * f21 + b2922 * f22 + b2923 * f23 + & b2924 * f24 + b2925 * f25 + b2926 * f26 + b2927 * f27 + & b2928 * f28 ), f29 ) call me % f ( t + a30 * h , x + h * ( b300 * f0 + b301 * f1 + b302 * f2 + b303 * f3 + & b304 * f4 + b305 * f5 + b306 * f6 + b307 * f7 + & b308 * f8 + b309 * f9 + b3010 * f10 + b3011 * f11 + & b3012 * f12 + b3013 * f13 + b3014 * f14 + b3015 * f15 + & b3016 * f16 + b3017 * f17 + b3018 * f18 + b3019 * f19 + & b3020 * f20 + b3021 * f21 + b3022 * f22 + b3023 * f23 + & b3024 * f24 + b3025 * f25 + b3026 * f26 + b3027 * f27 + & b3028 * f28 + b3029 * f29 ), f30 ) call me % f ( t + a31 * h , x + h * ( b310 * f0 + b311 * f1 + b312 * f2 + b313 * f3 + & b314 * f4 + b315 * f5 + b316 * f6 + b317 * f7 + & b318 * f8 + b319 * f9 + b3110 * f10 + b3111 * f11 + & b3112 * f12 + b3113 * f13 + b3114 * f14 + b3115 * f15 + & b3116 * f16 + b3117 * f17 + b3118 * f18 + b3119 * f19 + & b3120 * f20 + b3121 * f21 + b3122 * f22 + b3123 * f23 + & b3124 * f24 + b3125 * f25 + b3126 * f26 + b3127 * f27 + & b3128 * f28 + b3129 * f29 + b3130 * f30 ), f31 ) call me % f ( t + a32 * h , x + h * ( b320 * f0 + b321 * f1 + b322 * f2 + b323 * f3 + & b324 * f4 + b325 * f5 + b326 * f6 + b327 * f7 + & b328 * f8 + b329 * f9 + b3210 * f10 + b3211 * f11 + & b3212 * f12 + b3213 * f13 + b3214 * f14 + b3215 * f15 + & b3216 * f16 + b3217 * f17 + b3218 * f18 + b3219 * f19 + & b3220 * f20 + b3221 * f21 + b3222 * f22 + b3223 * f23 + & b3224 * f24 + b3225 * f25 + b3226 * f26 + b3227 * f27 + & b3228 * f28 + b3229 * f29 + b3230 * f30 + b3231 * f31 ), f32 ) call me % f ( t + a33 * h , x + h * ( b330 * f0 + b331 * f1 + b332 * f2 + b333 * f3 + & b334 * f4 + b335 * f5 + b336 * f6 + b337 * f7 + & b338 * f8 + b339 * f9 + b3310 * f10 + b3311 * f11 + & b3312 * f12 + b3313 * f13 + b3314 * f14 + b3315 * f15 + & b3316 * f16 + b3317 * f17 + b3318 * f18 + b3319 * f19 + & b3320 * f20 + b3321 * f21 + b3322 * f22 + b3323 * f23 + & b3324 * f24 + b3325 * f25 + b3326 * f26 + b3327 * f27 + & b3328 * f28 + b3329 * f29 + b3330 * f30 + b3331 * f31 + & b3332 * f32 ), f33 ) call me % f ( t + a34 * h , x + h * ( b340 * f0 + b341 * f1 + b342 * f2 + b343 * f3 + & b344 * f4 + b345 * f5 + b346 * f6 + b347 * f7 + & b348 * f8 + b349 * f9 + b3410 * f10 + b3411 * f11 + & b3412 * f12 + b3413 * f13 + b3414 * f14 + b3415 * f15 + & b3416 * f16 + b3417 * f17 + b3418 * f18 + b3419 * f19 + & b3420 * f20 + b3421 * f21 + b3422 * f22 + b3423 * f23 + & b3424 * f24 + b3425 * f25 + b3426 * f26 + b3427 * f27 + & b3428 * f28 + b3429 * f29 + b3430 * f30 + b3431 * f31 + & b3432 * f32 + b3433 * f33 ), f34 ) xf = x + h * ( c0 * f0 + & c1 * f1 + & c2 * f2 + & c3 * f3 + & c4 * f4 + & c5 * f5 + & c6 * f6 + & c7 * f7 + & c8 * f8 + & c9 * f9 + & c10 * f10 + & c11 * f11 + & c12 * f12 + & c13 * f13 + & c14 * f14 + & c15 * f15 + & c16 * f16 + & c17 * f17 + & c18 * f18 + & c19 * f19 + & c20 * f20 + & c21 * f21 + & c22 * f22 + & c23 * f23 + & c24 * f24 + & c25 * f25 + & c26 * f26 + & c27 * f27 + & c28 * f28 + & c29 * f29 + & c30 * f30 + & c31 * f31 + & c32 * f32 + & c33 * f33 + & c34 * f34 ) terr = ( 1.0_wp / 100 0.0_wp ) * h * ( f1 - f33 ) end subroutine rkf1412","tags":"","url":"proc/rkf1412.html"},{"title":"hstart – fortran-astrodynamics-toolkit","text":"private  subroutine hstart(me, a, b, y, yprime, etol, h) Computes a starting step size to be used in solving initial\n  value problems in ordinary differential equations. It is based on an estimate of the local lipschitz constant for the\n  differential equation (lower bound on a norm of the jacobian) ,\n  a bound on the differential equation (first derivative), and\n  a bound on the partial derivative of the equation with respect to\n  the independent variable. (all approximated near the initial point a) function for computing vector norms History 820301  date written -- watts, h. a., (snla) 890531  changed all specific intrinsics to generic.  (wrb) 890831  modified array declarations.  (wrb) 890911  removed unnecessary intrinsics.  (wrb) 891024  changed references from dvnorm to dhvnrm.  (wrb) 891214  prologue converted to version 4.0 format.  (bab) 900328  added type section.  (wrb) 910722  updated author section.  (als) December, 2015 : Refactored this routine (jw) April 2016 : Some modifications for the variable-step RK module (jw) Type Bound rk_variable_step_class Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: a the initial point of integration. real(kind=wp), intent(in) :: b a value of the independent variable used to define\nthe direction of integration. a reasonable choice is to\nset b to the first point at which a solution is desired.\nyou can also use b , if necessary, to restrict the length\nof the first integration step because the algorithm will\nnot compute a starting step length which is bigger than abs(b-a) , unless b has been chosen too close to a .\n(it is presumed that hstart has been called with b different from a on the machine being used. also see the\ndiscussion about the parameter small .) real(kind=wp), intent(in), dimension(me%n) :: y the vector of initial values of the neq solution\ncomponents at the initial point a . real(kind=wp), intent(in), dimension(me%n) :: yprime the vector of derivatives of the neq solution components at the initial point a .\n(defined by the differential equations in subroutine me%f ) real(kind=wp), intent(in), dimension(me%n) :: etol the vector of error tolerances corresponding to\nthe neq solution components. it is assumed that all\nelements are positive. following the first integration\nstep, the tolerances are expected to be used by the\nintegrator in an error test which roughly requires that abs(local error) <= etol for each vector component. real(kind=wp), intent(out) :: h appropriate starting step size to be attempted by the\ndifferential equation method. Called by proc~~hstart~~CalledByGraph proc~hstart rk_variable_step_class%hstart proc~integrate_to_event~2 rk_variable_step_class%integrate_to_event proc~integrate_to_event~2->proc~hstart proc~integrate~2 rk_variable_step_class%integrate proc~integrate~2->proc~hstart proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->proc~integrate_to_event~2 proc~rk_test_variable_step->proc~integrate~2 Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine hstart ( me , a , b , y , yprime , etol , h ) implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: a !! the initial point of integration. real ( wp ), intent ( in ) :: b !! a value of the independent variable used to define !! the direction of integration. a reasonable choice is to !! set `b` to the first point at which a solution is desired. !! you can also use `b`, if necessary, to restrict the length !! of the first integration step because the algorithm will !! not compute a starting step length which is bigger than !! `abs(b-a)`, unless `b` has been chosen too close to `a`. !! (it is presumed that hstart has been called with `b` !! different from `a` on the machine being used. also see the !! discussion about the parameter `small`.) real ( wp ), dimension ( me % n ), intent ( in ) :: y !! the vector of initial values of the `neq` solution !! components at the initial point `a`. real ( wp ), dimension ( me % n ), intent ( in ) :: yprime !! the vector of derivatives of the `neq` !! solution components at the initial point `a`. !! (defined by the differential equations in subroutine `me%f`) real ( wp ), dimension ( me % n ), intent ( in ) :: etol !! the vector of error tolerances corresponding to !! the `neq` solution components. it is assumed that all !! elements are positive. following the first integration !! step, the tolerances are expected to be used by the !! integrator in an error test which roughly requires that !! `abs(local error) <= etol` for each vector component. real ( wp ), intent ( out ) :: h !! appropriate starting step size to be attempted by the !! differential equation method. real ( wp ), dimension ( me % n ) :: spy !! work array which provide the routine with needed storage space. real ( wp ), dimension ( me % n ) :: pv !! work array which provide the routine with needed storage space. real ( wp ), dimension ( me % n ) :: yp !! work array which provide the routine with needed storage space. real ( wp ), dimension ( me % n ) :: sf !! work array which provide the routine with needed storage space. real ( wp ), parameter :: small = epsilon ( one ) real ( wp ), parameter :: big = huge ( one ) real ( wp ), parameter :: relper = small ** 0.375_wp integer :: j , k , lk real ( wp ) :: absdx , da , delf , dely ,& dfdub , dfdxb ,& dx , dy , fbnd ,& srydpb , tolexp , tolmin , tolp , tolsum , ydpb integer :: morder !! the order of the formula which will be used by !! the initial value method for taking the first integration !! step. morder = me % p dx = b - a absdx = abs ( dx ) ! compute an approximate bound (dfdxb) on the partial ! derivative of the equation with respect to the ! independent variable. protect against an overflow. ! also compute a bound (fbnd) on the first derivative ! locally. da = sign ( max ( min ( relper * abs ( a ), absdx ), 10 0.0_wp * small * abs ( a )), dx ) if ( da == zero ) da = relper * dx call me % f ( a + da , y , sf ) yp = sf - yprime delf = me % stepsize_method % norm ( yp ) dfdxb = big if ( delf < big * abs ( da )) dfdxb = delf / abs ( da ) fbnd = me % stepsize_method % norm ( sf ) ! compute an estimate (dfdub) of the local lipschitz ! constant for the system of differential equations. this ! also represents an estimate of the norm of the jacobian ! locally.  three iterations (two when neq=1) are used to ! estimate the lipschitz constant by numerical differences. ! the first perturbation vector is based on the initial ! derivatives and direction of integration. the second ! perturbation vector is formed using another evaluation of ! the differential equation.  the third perturbation vector ! is formed using perturbations based only on the initial ! values. components that are zero are always changed to ! non-zero values (except on the first iteration). when ! information is available, care is taken to ensure that ! components of the perturbation vector have signs which are ! consistent with the slopes of local solution curves. ! also choose the largest bound (fbnd) for the first ! derivative. ! ! perturbation vector size is held ! constant for all iterations. compute ! this change from the ! size of the vector of initial ! values. dely = relper * me % stepsize_method % norm ( y ) if ( dely == zero ) dely = relper dely = sign ( dely , dx ) delf = me % stepsize_method % norm ( yprime ) fbnd = max ( fbnd , delf ) if ( delf == zero ) then ! cannot have a null perturbation vector spy = zero yp = one delf = me % stepsize_method % norm ( yp ) else ! use initial derivatives for first perturbation spy = yprime yp = yprime end if dfdub = zero lk = min ( me % n + 1 , 3 ) do k = 1 , lk ! define perturbed vector of initial values pv = y + yp * ( dely / delf ) if ( k == 2 ) then ! use a shifted value of the independent variable ! in computing one estimate call me % f ( a + da , pv , yp ) pv = yp - sf else ! evaluate derivatives associated with perturbed ! vector and compute corresponding differences call me % f ( a , pv , yp ) pv = yp - yprime end if ! choose largest bounds on the first derivative ! and a local lipschitz constant fbnd = max ( fbnd , me % stepsize_method % norm ( yp )) delf = me % stepsize_method % norm ( pv ) if ( delf >= big * abs ( dely )) then ! protect against an overflow dfdub = big exit end if dfdub = max ( dfdub , delf / abs ( dely )) if ( k == lk ) exit ! choose next perturbation vector if ( delf == zero ) delf = one do j = 1 , me % n if ( k == 2 ) then dy = y ( j ) if ( dy == zero ) dy = dely / relper else dy = abs ( pv ( j )) if ( dy == zero ) dy = delf end if if ( spy ( j ) == zero ) spy ( j ) = yp ( j ) if ( spy ( j ) /= zero ) dy = sign ( dy , spy ( j )) yp ( j ) = dy end do delf = me % stepsize_method % norm ( yp ) end do ! compute a bound (ydpb) on the norm of the second derivative ydpb = dfdxb + dfdub * fbnd ! define the tolerance parameter upon which the starting step ! size is to be based.  a value in the middle of the error ! tolerance range is selected. tolmin = big tolsum = zero do k = 1 , me % n tolexp = log10 ( etol ( k )) tolmin = min ( tolmin , tolexp ) tolsum = tolsum + tolexp end do tolp = 1 0.0_wp ** ( 0.5_wp * ( tolsum / me % n + tolmin ) / ( morder + 1 )) ! compute a starting step size based on the above first and ! second derivative information ! ! restrict the step length to be not bigger ! than abs(b-a). (unless b is too close to a) h = absdx if ( ydpb == zero . and . fbnd == zero ) then ! both first derivative term (fbnd) and second ! derivative term (ydpb) are zero if ( tolp < one ) h = absdx * tolp elseif ( ydpb == zero ) then ! only second derivative term (ydpb) is zero if ( tolp < fbnd * absdx ) h = tolp / fbnd else ! second derivative term (ydpb) is non-zero srydpb = sqrt ( 0.5_wp * ydpb ) if ( tolp < srydpb * absdx ) h = tolp / srydpb end if ! further restrict the step length to be not bigger than  1/dfdub if ( h * dfdub > one ) h = one / dfdub ! finally, restrict the step length to be not ! smaller than 100*small*abs(a). however, if ! a=0. and the computed h underflowed to zero, ! the algorithm returns small*abs(b) for the step length. h = max ( h , 10 0.0_wp * small * abs ( a )) if ( h == zero ) h = small * abs ( b ) ! now set direction of integration h = sign ( h , dx ) end subroutine hstart","tags":"","url":"proc/hstart.html"},{"title":"step_size_test – fortran-astrodynamics-toolkit","text":"public  subroutine step_size_test() Unit tests for step size adjustment routines. Arguments None Calls proc~~step_size_test~~CallsGraph proc~step_size_test step_size_test proc~compute_stepsize stepsize_class%compute_stepsize proc~step_size_test->proc~compute_stepsize proc~stepsize_class_constructor stepsize_class%stepsize_class_constructor proc~step_size_test->proc~stepsize_class_constructor Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine step_size_test () implicit none type ( stepsize_class ) :: s1 !! for testing the different methods type ( stepsize_class ) :: s2 !! for testing the different methods type ( stepsize_class ) :: s3 !! for testing the different methods real ( wp ) :: h !! current step size real ( wp ) :: tol !! abs error tolerance real ( wp ) :: err !! truncation error estimate integer :: p !! order of the method real ( wp ) :: hnew !! new step size logical :: accept !! if the step is accepted write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' step_size_test' write ( * , * ) '---------------' write ( * , * ) '' h = 1 0.0_wp tol = 1.0e-9_wp err = 1.0e-7_wp p = 4 call s1 % initialize () call s1 % compute_stepsize ( h , tol , err , p , hnew , accept ) write ( * , * ) 'stepsize_hull    : hnew = ' , hnew call s2 % initialize () call s2 % compute_stepsize ( h , tol , err , p , hnew , accept ) write ( * , * ) 'stepsize_stoer_1 : hnew = ' , hnew call s3 % initialize () call s3 % compute_stepsize ( h , tol , err , p , hnew , accept ) write ( * , * ) 'stepsize_stoer_2 : hnew = ' , hnew end subroutine step_size_test","tags":"","url":"proc/step_size_test.html"},{"title":"rk_test_variable_step – fortran-astrodynamics-toolkit","text":"public  subroutine rk_test_variable_step() Uses conversion_module orbital_mechanics_module proc~~rk_test_variable_step~~UsesGraph proc~rk_test_variable_step rk_test_variable_step module~conversion_module conversion_module proc~rk_test_variable_step->module~conversion_module module~orbital_mechanics_module orbital_mechanics_module proc~rk_test_variable_step->module~orbital_mechanics_module module~kind_module kind_module module~conversion_module->module~kind_module module~numbers_module numbers_module module~conversion_module->module~numbers_module module~orbital_mechanics_module->module~kind_module module~math_module math_module module~orbital_mechanics_module->module~math_module module~orbital_mechanics_module->module~numbers_module module~vector_module vector_module module~orbital_mechanics_module->module~vector_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~math_module->module~kind_module module~math_module->module~numbers_module module~numbers_module->module~kind_module module~vector_module->module~kind_module module~vector_module->module~numbers_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Unit test of the rk_module .\nIntegrate a two-body orbit around the Earth. Arguments None Calls proc~~rk_test_variable_step~~CallsGraph proc~rk_test_variable_step rk_test_variable_step proc~integrate_to_event~2 rk_variable_step_class%integrate_to_event proc~rk_test_variable_step->proc~integrate_to_event~2 proc~integrate~2 rk_variable_step_class%integrate proc~rk_test_variable_step->proc~integrate~2 proc~orbital_elements_to_rv orbital_elements_to_rv proc~rk_test_variable_step->proc~orbital_elements_to_rv proc~stepsize_class_constructor stepsize_class%stepsize_class_constructor proc~rk_test_variable_step->proc~stepsize_class_constructor order order proc~integrate_to_event~2->order proc~compute_stepsize stepsize_class%compute_stepsize proc~integrate_to_event~2->proc~compute_stepsize proc~hinit rk_variable_step_class%hinit proc~integrate_to_event~2->proc~hinit proc~hstart rk_variable_step_class%hstart proc~integrate_to_event~2->proc~hstart proc~set_function brent_class%set_function proc~integrate_to_event~2->proc~set_function proc~zeroin brent_class%zeroin proc~integrate_to_event~2->proc~zeroin step step proc~integrate_to_event~2->step proc~integrate~2->order proc~integrate~2->proc~compute_stepsize proc~integrate~2->proc~hinit proc~integrate~2->proc~hstart proc~integrate~2->step proc~orbit_check orbit_check proc~orbital_elements_to_rv->proc~orbit_check Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine rk_test_variable_step () use orbital_mechanics_module , only : orbital_elements_to_rv use conversion_module , only : deg2rad implicit none !type,extends(rkf78_class) :: spacecraft !type,extends(rkf89_class) :: spacecraft !type,extends(rkv89_class) :: spacecraft !type,extends(rkf108_class) :: spacecraft !type,extends(rkf1210_class) :: spacecraft type , extends ( rkf1412_class ) :: spacecraft !! spacecraft propagation type. real ( wp ) :: mu = zero !! central body gravitational parameter (km3/s2) integer :: fevals = 0 !! number of function evaluations logical :: first = . true . !! first point is being exported end type spacecraft integer , parameter :: n = 6 !! number of state variables real ( wp ), parameter :: tol = 1.0e-12_wp !! event location tolerance type ( spacecraft ) :: s , s2 real ( wp ) :: t0 , tf , x0 ( n ), dt , xf ( n ), x02 ( n ), gf , tf_actual , rtol , atol integer :: ierr !! error flag type ( stepsize_class ) :: sz integer :: icase logical :: relative_err real ( wp ) :: safety_factor , hfactor_accept integer :: p_exponent_offset real ( wp ) :: mu real ( wp ) :: a , p , ecc , inc , raan , aop , tru real ( wp ), dimension ( 3 ) :: r , v write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' rk_variable_step_test' write ( * , * ) '---------------' write ( * , * ) '' !*************************************************************************** do icase = 1 , 4 write ( * , * ) '' write ( * , * ) '***************' write ( * , * ) ' case' , icase write ( * , * ) '***************' write ( * , * ) '' ! ... relative_err,safety_factor,p_exponent_offset don't !     seem to change the results at all .... select case ( icase ) case ( 1 ) ! defaults relative_err = . false . safety_factor = 0.8_wp p_exponent_offset = 1 hfactor_accept = 2.0_wp ! changing this does change result case ( 2 ) relative_err = . false . safety_factor = 0.9_wp p_exponent_offset = 1 hfactor_accept = 5.0_wp case ( 3 ) relative_err = . false . safety_factor = 0.95_wp p_exponent_offset = 1 hfactor_accept = 1 0.0_wp case ( 4 ) relative_err = . false . safety_factor = 0.9_wp p_exponent_offset = 0 hfactor_accept = 2.0_wp end select !step size constructor: !call sz%initialize(hmin=1.0e-6_wp,hmax=1.0e6_wp) call sz % initialize ( hmin = 1.0e-6_wp , & hmax = 1.0e+6_wp , & hfactor_reject = 0.5_wp , & hfactor_accept = hfactor_accept , & max_attempts = 1000 , & accept_mode = 2 , & norm = maxval_func , & relative_err = relative_err , & safety_factor = safety_factor , & p_exponent_offset = p_exponent_offset ) !integrator constructor: call s % initialize ( n = n , f = twobody , rtol = [ 1.0e-15_wp ], atol = [ 1.0e-12_wp ],& stepsize_method = sz , report = twobody_report ) !initial conditions: !write(*,*) 'general elliptical:' mu = 3.9860043543609593E+05_wp ! for earth a = 800 0.0_wp ! km ecc = 0.1_wp inc = 4 5.0_wp * deg2rad raan = 4 5.0_wp * deg2rad aop = 4 5.0_wp * deg2rad tru = 4 5.0_wp * deg2rad p = a * ( one - ecc ** 2 ) call orbital_elements_to_rv ( mu , p , ecc , inc , raan , aop , tru , r , v ) x0 = [ r , v ] !x0   = [10000.0_wp,10000.0_wp,10000.0_wp,&   ! initial state [r,v] (km,km/s) !        1.0_wp,2.0_wp,3.0_wp] t0 = zero ! initial time (sec) !dt   = 0.0_wp           ! automatically compute an initial time step (sec) dt = 1 0.0_wp ! initial time step (sec) tf = 1000 0.0_wp ! final time (sec) s % mu = 39860 0.436233_wp ! main body is Earth s % num_rejected_steps = 0 s % fevals = 0 s % first = . true . call s % integrate ( t0 , x0 , dt , tf , xf , ierr ) !forward write ( * , * ) '' write ( * , * ) 'ierr = ' , ierr write ( * , '(A/,*(F15.6/))' ) 'Final state:' , xf write ( * , '(A,I5)' ) 'Function evaluations:' , s % fevals write ( * , '(A,I5)' ) 'Number of rejected steps:' , s % num_rejected_steps ! why is this 0 when ierr = -3 ??? s % num_rejected_steps = 0 s % fevals = 0 s % report => null () !disable reporting call s % integrate ( tf , xf , - dt , t0 , x02 , ierr ) !backwards write ( * , * ) 'ierr = ' , ierr write ( * , '(A/,*(E20.12/))' ) 'Error:' , x02 - x0 write ( * , '(A,I5)' ) 'Function evaluations:' , s % fevals write ( * , '(A,I5)' ) 'Number of rejected steps:' , s % num_rejected_steps write ( * , * ) '' end do !*************************************************************************** !event finding test: write ( * , * ) ' Event test - integrate until z = 12,000' ! NOTE: the following causes an ICE in gfortran 7.1, but works with ifort: ! s2 = spacecraft(n=n,f=twobody,g=twobody_event,mu=398600.436233_wp,& !                  rtol=[1.0e-12_wp],atol=[1.0e-12_wp],& !                  stepsize_method=sz,report=twobody_report) ! do it this way instead: call s2 % initialize ( n = n , f = twobody , g = twobody_event ,& rtol = [ 1.0e-12_wp ], atol = [ 1.0e-12_wp ],& stepsize_method = sz ,& report = twobody_report ) s2 % mu = 39860 0.436233_wp s2 % fevals = 0 s2 % first = . true . x0 = [ 1000 0.0_wp , 1000 0.0_wp , 1000 0.0_wp ,& !initial state [r,v] (km,km/s) 1.0_wp , 2.0_wp , 3.0_wp ] t0 = zero !initial time (sec) dt = 1 0.0_wp !time step (sec) tf = 100 0.0_wp !final time (sec) call s2 % integrate_to_event ( t0 , x0 , dt , tf , tol , tf_actual , xf , gf , ierr ) write ( * , * ) '' write ( * , '(A,I5)' ) 'ierr:       ' , ierr write ( * , '(A/,*(F15.6/))' ) 'Final time: ' , tf_actual write ( * , '(A/,*(F15.6/))' ) 'Final state:' , xf write ( * , '(A/,*(F15.6/))' ) 'Event func :' , gf write ( * , '(A,I5)' ) 'Function evaluations:' , s2 % fevals write ( * , '(A,I5)' ) 'Number of rejected steps:' , s2 % num_rejected_steps contains !***************************************************************************************** !********************************************************* subroutine twobody ( me , t , x , xdot ) !! derivative routine for two-body orbit propagation implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: xdot real ( wp ), dimension ( 3 ) :: r , v , a_grav real ( wp ) :: rmag select type ( me ) class is ( spacecraft ) r = x ( 1 : 3 ) v = x ( 4 : 6 ) rmag = norm2 ( r ) a_grav = - me % mu / rmag ** 3 * r !acceleration due to gravity xdot ( 1 : 3 ) = v xdot ( 4 : 6 ) = a_grav me % fevals = me % fevals + 1 end select end subroutine twobody !********************************************************* !********************************************************* subroutine twobody_report ( me , t , x ) !! report function - write time,state to console implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension (:), intent ( in ) :: x select type ( me ) class is ( spacecraft ) if ( me % first ) then !print header write ( * , * ) '' write ( * , '(*(A15,1X))' ) 'time (sec)' , 'x (km)' , 'y (km)' , 'z (km)' ,& 'vx (km/s)' , 'vy (km/s)' , 'vz (km/s)' me % first = . false . end if end select write ( * , '(*(F15.6,1X))' ) t , x end subroutine twobody_report !********************************************************* !********************************************************* subroutine twobody_event ( me , t , x , g ) !! event function (z = 12,000) implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), intent ( out ) :: g g = x ( 3 ) - 1200 0.0_wp end subroutine twobody_event !********************************************************* end subroutine rk_test_variable_step","tags":"","url":"proc/rk_test_variable_step.html"},{"title":"distance_from_point_to_line – fortran-astrodynamics-toolkit","text":"public pure function distance_from_point_to_line(x1, x2, x) result(d) Compute the distance between the point X and the line defined\n  by the two points X1 and X2. References http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: x1 real(kind=wp), intent(in), dimension(3) :: x2 real(kind=wp), intent(in), dimension(3) :: x Return Value real(kind=wp) Calls proc~~distance_from_point_to_line~~CallsGraph proc~distance_from_point_to_line distance_from_point_to_line proc~cross cross proc~distance_from_point_to_line->proc~cross Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function distance_from_point_to_line ( x1 , x2 , x ) result ( d ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: x1 real ( wp ), dimension ( 3 ), intent ( in ) :: x2 real ( wp ), dimension ( 3 ), intent ( in ) :: x real ( wp ) :: d real ( wp ), dimension ( 3 ) :: x21 real ( wp ) :: x21_mag x21 = x2 - x1 x21_mag = norm2 ( x21 ) if ( x21_mag /= 0.0_wp ) then d = norm2 ( cross ( x21 , x1 - x ) ) / x21_mag else d = norm2 ( x1 - x ) end if end function distance_from_point_to_line","tags":"","url":"proc/distance_from_point_to_line.html"},{"title":"distance_from_point_to_line_segment – fortran-astrodynamics-toolkit","text":"public pure function distance_from_point_to_line_segment(x1, x2, x) result(d) Compute the distance between a line segment and a point. References http://forums.codeguru.com/showthread.php?194400-Distance-between-point-and-line-segment Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x1 real(kind=wp), intent(in), dimension(:) :: x2 real(kind=wp), intent(in), dimension(:) :: x Return Value real(kind=wp) Called by proc~~distance_from_point_to_line_segment~~CalledByGraph proc~distance_from_point_to_line_segment distance_from_point_to_line_segment proc~distance_from_point_to_path distance_from_point_to_path proc~distance_from_point_to_path->proc~distance_from_point_to_line_segment proc~geometry_unit_test geometry_unit_test proc~geometry_unit_test->proc~distance_from_point_to_path Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure function distance_from_point_to_line_segment ( x1 , x2 , x ) result ( d ) implicit none real ( wp ), dimension (:), intent ( in ) :: x1 real ( wp ), dimension (:), intent ( in ) :: x2 real ( wp ), dimension (:), intent ( in ) :: x real ( wp ) :: d real ( wp ), dimension ( size ( x1 )) :: x12 real ( wp ) :: s real ( wp ) :: x12_mag x12 = x1 - x2 x12_mag = norm2 ( x12 ) if ( x12_mag == 0.0_wp ) then d = norm2 ( x1 - x ) else s = dot_product ( x1 - x , x12 ) / dot_product ( x12 , x12 ) !if the projection is not on the segment, ! then use the closest end point: if ( s < 0.0_wp ) then s = 0.0_wp else if ( s > 1.0_wp ) then s = 1.0_wp end if d = norm2 ( x - x1 + s * x12 ) end if end function distance_from_point_to_line_segment","tags":"","url":"proc/distance_from_point_to_line_segment.html"},{"title":"distance_from_point_to_path – fortran-astrodynamics-toolkit","text":"public  function distance_from_point_to_path(x0, y0, x, y, n) result(d) Compute the distance between a point and a polygonal path.\nGiven a point (x0,y0), and a path (x(n),y(n)), the distance\nto the path is the distance to the closest line segment (x(i),y(i)). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: y0 real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(in), dimension(n) :: y integer, intent(in) :: n Return Value real(kind=wp) Calls proc~~distance_from_point_to_path~~CallsGraph proc~distance_from_point_to_path distance_from_point_to_path proc~distance_from_point_to_line_segment distance_from_point_to_line_segment proc~distance_from_point_to_path->proc~distance_from_point_to_line_segment proc~locpt locpt proc~distance_from_point_to_path->proc~locpt Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~distance_from_point_to_path~~CalledByGraph proc~distance_from_point_to_path distance_from_point_to_path proc~geometry_unit_test geometry_unit_test proc~geometry_unit_test->proc~distance_from_point_to_path Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code function distance_from_point_to_path ( x0 , y0 , x , y , n ) result ( d ) implicit none !arguments: integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: y0 real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension ( n ), intent ( in ) :: y real ( wp ) :: d integer :: l , m , i real ( wp ) :: dmin !is the point inside, outside, or on the path: call locpt ( x0 , y0 , x , y , n , l , m ) select case ( l ) case ( 1 , - 1 ) !point is not on the path if ( n == 1 ) then !only one point in the path: d = norm2 ([ x0 - x ( 1 ), y0 - y ( 1 )]) else do i = 1 , n !loop through all line segments in the path !the distance to the path is the distance from the closest line segment if ( i < n ) then d = distance_from_point_to_line_segment ( & [ x ( i ), y ( i )], [ x ( i + 1 ), y ( i + 1 )], [ x0 , y0 ]) else !note: if 1st /= nth point, then have to check that line segment also. if ( x ( 1 ) /= x ( n ) . or . y ( 1 ) /= y ( n )) then d = distance_from_point_to_line_segment ( & [ x ( n ), y ( n )], [ x ( 1 ), y ( 1 )], [ x0 , y0 ]) end if end if !get lowest value: if ( d < dmin . or . i == 1 ) dmin = d end do end if !set sign of d: d = dmin * l ! <0 if outside the path ! >0 if inside the path case default !point is on the path d = 0.0_wp end select end function distance_from_point_to_path","tags":"","url":"proc/distance_from_point_to_path.html"},{"title":"locpt – fortran-astrodynamics-toolkit","text":"public pure subroutine locpt(x0, y0, x, y, n, l, m) given a polygonal line connecting the vertices (x(i),y(i))\n  (i = 1,...,n) taken in this order. it is assumed that the\n  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1))\n  or there is an arc from (x(n),y(n)) to (x(1),y(1)). (x0,y0) is an arbitrary point and l and m are variables.\n  l and m are assigned the following values: l = - 1 if ( x0 , y0 ) is outside the polygonal path l = 0 if ( x0 , y0 ) lies on the polygonal path l = 1 if ( x0 , y0 ) is inside the polygonal path m = 0 if (x0,y0) is on or outside the path. if (x0,y0)\n  is inside the path then m is the winding number of the\n  path around the point (x0,y0). History Original version from the NSWC Library Modified by J. Williams : 08/04/2012 : refactored to modern Fortran Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: y0 real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(in), dimension(n) :: y integer, intent(in) :: n integer, intent(out) :: l integer, intent(out) :: m Called by proc~~locpt~~CalledByGraph proc~locpt locpt proc~distance_from_point_to_path distance_from_point_to_path proc~distance_from_point_to_path->proc~locpt proc~geometry_unit_test geometry_unit_test proc~geometry_unit_test->proc~locpt proc~geometry_unit_test->proc~distance_from_point_to_path Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code pure subroutine locpt ( x0 , y0 , x , y , n , l , m ) implicit none !arguments: integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: y0 real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension ( n ), intent ( in ) :: y integer , intent ( out ) :: l integer , intent ( out ) :: m !constants: real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ), parameter :: pi = atan2 ( 0.0_wp , - 1.0_wp ) real ( wp ), parameter :: pi2 = 2.0_wp * pi real ( wp ), parameter :: tol = 4.0_wp * eps * pi !local variables: integer :: i , n0 real ( wp ) :: u , v , theta1 , sum , theta , angle , thetai n0 = n if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n0 = n - 1 l = - 1 m = 0 u = x ( 1 ) - x0 v = y ( 1 ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path else if ( n0 >= 2 ) then theta1 = atan2 ( v , u ) sum = 0.0_wp theta = theta1 do i = 2 , n0 u = x ( i ) - x0 v = y ( i ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path exit end if thetai = atan2 ( v , u ) angle = abs ( thetai - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path exit end if if ( angle > pi ) angle = angle - pi2 if ( theta > thetai ) angle = - angle sum = sum + angle theta = thetai end do if ( l /= 0 ) then angle = abs ( theta1 - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path else if ( angle > pi ) angle = angle - pi2 if ( theta > theta1 ) angle = - angle sum = sum + angle !sum = 2*pi*m where m is the winding number m = abs ( sum ) / pi2 + 0.2_wp if ( m /= 0 ) then l = 1 if ( sum < 0.0_wp ) m = - m end if end if end if end if end if end subroutine locpt","tags":"","url":"proc/locpt.html"},{"title":"geometry_unit_test – fortran-astrodynamics-toolkit","text":"public  subroutine geometry_unit_test() Unit test routine Output x0,y0=  0.59999999999999998       0.59999999999999998\nl=           1\nm=          -1\ndist to path=  0.40000000000000002\n\nx0,y0=   1.5000000000000000       0.50000000000000000\nl=          -1\nm=           0\ndist to path= -0.50000000000000000\n\nx0,y0=   1.0000000000000000        0.0000000000000000\nl=           0\nm=           0\ndist to path=   0.0000000000000000 Arguments None Calls proc~~geometry_unit_test~~CallsGraph proc~geometry_unit_test geometry_unit_test proc~distance_from_point_to_path distance_from_point_to_path proc~geometry_unit_test->proc~distance_from_point_to_path proc~locpt locpt proc~geometry_unit_test->proc~locpt proc~distance_from_point_to_path->proc~locpt proc~distance_from_point_to_line_segment distance_from_point_to_line_segment proc~distance_from_point_to_path->proc~distance_from_point_to_line_segment Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine geometry_unit_test () implicit none integer :: l , m real ( wp ) :: x0 , y0 !a 1x1 square: integer , parameter :: n = 4 real ( wp ), dimension ( n ), parameter :: x = [ 0.0_wp , 0.0_wp , 1.0_wp , 1.0_wp ] real ( wp ), dimension ( n ), parameter :: y = [ 0.0_wp , 1.0_wp , 1.0_wp , 0.0_wp ] x0 = 0.6_wp !inside the path y0 = 0.6_wp call go () x0 = 1.5_wp !outside the path y0 = 0.5_wp call go () x0 = 1 0.0_wp !outside the path y0 = 0.0_wp call go () x0 = 1.0_wp !on the path y0 = 0.0_wp call go () contains subroutine go () !call locpt for the x0,y0 point, and print results implicit none real ( wp ) :: d call locpt ( x0 , y0 , x , y , n , l , m ) write ( * , * ) '' write ( * , * ) 'x0,y0=' , x0 , y0 write ( * , * ) 'l=' , l write ( * , * ) 'm=' , m d = distance_from_point_to_path ( x0 , y0 , x , y , n ) write ( * , * ) 'dist to path=' , d end subroutine go end subroutine geometry_unit_test","tags":"","url":"proc/geometry_unit_test.html"},{"title":"hyperbolic_turning_angle – fortran-astrodynamics-toolkit","text":"public pure function hyperbolic_turning_angle(e) result(delta) Compute the hyperbolic turning angle from the eccentricity. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: e eccentricity [--] Return Value real(kind=wp) turning angle [rad] Source Code pure function hyperbolic_turning_angle ( e ) result ( delta ) implicit none real ( wp ), intent ( in ) :: e !! eccentricity [--] real ( wp ) :: delta !! turning angle [rad] delta = two * asin ( one / e ) end function hyperbolic_turning_angle","tags":"","url":"proc/hyperbolic_turning_angle.html"},{"title":"vinf_to_energy – fortran-astrodynamics-toolkit","text":"public pure function vinf_to_energy(vinfmag) result(energy) Convert V-infinity magnitude to energy. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vinfmag vector magnitude [km/s] Return Value real(kind=wp) two-body orbital energy [km&#94;2/s&#94;2] Source Code pure function vinf_to_energy ( vinfmag ) result ( energy ) implicit none real ( wp ), intent ( in ) :: vinfmag !! v&#94;{\\infty}  vector magnitude [km/s] real ( wp ) :: energy !! two-body orbital energy [km&#94;2/s&#94;2] energy = ( vinfmag ** 2 ) / two end function vinf_to_energy","tags":"","url":"proc/vinf_to_energy.html"},{"title":"bplane – fortran-astrodynamics-toolkit","text":"public  subroutine bplane(mu, rv, vinfvec, bmag, theta, BdotT, BdotR, status_ok) Compute B-plane parameters from position and velocity. References W. Kizner, \"A method of describing miss distances for lunar and interplanetary trajectories\",\n     Planetary and Space Science, Volume 7, July 1961. W. Kizner, \" Some orbital elements useful in space trajectory calculations \",\n     JPL Technical Release No. 34-84, July 25, 1960. A. B. Sergeyevsky, G. C. Snyder, R. A. Cunniff,\n     \" Interplanetary Mission Design Handbook, Volume I, Part 2 \",\n     JPL Publication 82-43, September 15, 1983. B-Plane Targeting Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu central body grav parameter real(kind=wp), intent(in), dimension(6) :: rv state vector (km,km/s) real(kind=wp), intent(out), dimension(3) :: vinfvec incoming V-infinity vector (km/s) real(kind=wp), intent(out) :: bmag magnitude of B vector (km) real(kind=wp), intent(out) :: theta aim point orientation [rad] real(kind=wp), intent(out) :: BdotT (km) real(kind=wp), intent(out) :: BdotR (km) logical, intent(out) :: status_ok false if there were errors (non-hyperbolic or degenerate state) Calls proc~~bplane~~CallsGraph proc~bplane bplane proc~cross cross proc~bplane->proc~cross proc~ucross ucross proc~bplane->proc~ucross proc~unit unit proc~bplane->proc~unit proc~ucross->proc~cross proc~ucross->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~bplane~~CalledByGraph proc~bplane bplane proc~bplane_test bplane_test proc~bplane_test->proc~bplane Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine bplane ( mu , rv , vinfvec , bmag , theta , BdotT , BdotR , status_ok ) implicit none real ( wp ), intent ( in ) :: mu !! central body grav parameter  (km&#94;3/s&#94;2)  real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! state vector (km,km/s) real ( wp ), dimension ( 3 ), intent ( out ) :: vinfvec !! incoming V-infinity vector (km/s) real ( wp ), intent ( out ) :: bmag !! magnitude of B vector (km) real ( wp ), intent ( out ) :: theta !! aim point orientation [rad] real ( wp ), intent ( out ) :: BdotT !!  \\mathbf{B} \\cdot \\mathbf{T}  (km) real ( wp ), intent ( out ) :: BdotR !!  \\mathbf{B} \\cdot \\mathbf{R}  (km) logical , intent ( out ) :: status_ok !! false if there were errors (non-hyperbolic or degenerate state) !local variables: real ( wp ), dimension ( 3 ) :: r , v , h , evec , bvec , tvec , ehat , hhat , hehat , Shat , That , Rhat , Bhat real ( wp ) :: rmag , vmag , vinf2 , rdv , vmag2 , a , alpha , sd2 , cd2 , ct , st , vinf , e status_ok = . true . r = rv ( 1 : 3 ) v = rv ( 4 : 6 ) h = cross ( r , v ) hhat = unit ( h ) if ( all ( hhat == zero )) then write ( * , * ) 'error: degenerate state.' status_ok = . false . return end if rdv = dot_product ( r , v ) rmag = norm2 ( r ) vmag = norm2 ( v ) vmag2 = vmag * vmag vinf2 = vmag2 - two * mu / rmag vinf = sqrt ( vinf2 ) ! magnitude of v-infinity vector evec = cross ( v , h ) / mu - r / rmag ! eccentricity vector e = norm2 ( evec ) ! eccentricity if ( e <= one ) then write ( * , * ) 'error: state is not hyperbolic.' status_ok = . false . return end if ehat = evec / e ! eccentricity unit vector a = one / ( two / rmag - vmag2 / mu ) ! semi-major axis hehat = cross ( hhat , ehat ) ! h x e unit vector sd2 = one / e ! sin(delta/2) cd2 = sqrt ( one - sd2 * sd2 ) ! cos(delta/2) Shat = cd2 * hehat + sd2 * ehat ! incoming vinf unit vector !Shat     = cd2*hehat - sd2*ehat            ! outgoing vinf unit vector That = ucross ( Shat ,[ zero , zero , one ]) ! here we define Tvec relative to the Z-axis of ! the frame in which the state is defined if ( all ( That == zero )) then write ( * , * ) 'error: vinf vector is parallel to z-axis.' status_ok = . false . return end if Rhat = cross ( Shat , That ) ! Eqn 1 in [1] Bhat = ucross ( Shat , h ) ct = dot_product ( Bhat , That ) ! cos(theta) st = dot_product ( Bhat , Rhat ) ! sin(theta) !outputs: Bmag = abs ( a ) * sqrt ( e * e - one ) ! magnitude of B vector theta = atan2 ( st , ct ) ! aim point orientation vinfvec = vinf * Shat ! incoming vinf vector BdotT = bmag * ct ! B dot T BdotR = bmag * st ! B dot R end subroutine bplane","tags":"","url":"proc/bplane.html"},{"title":"calculate_bplane_data – fortran-astrodynamics-toolkit","text":"public  subroutine calculate_bplane_data(mu, state, bdotr, bdott, bmag, theta, istat) Compute B-plane parameters from position and velocity -- alternate version. See also bplane Reference This one is based on the algorithm in GMAT: GmatCalcUtil::CalculateBPlaneData Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu central body grav parameter real(kind=wp), intent(in), dimension(6) :: state state vector (km,km/s) real(kind=wp), intent(out) :: bdotr (km) real(kind=wp), intent(out) :: bdott (km) real(kind=wp), intent(out) :: bmag magnitude of B vector (km) real(kind=wp), intent(out) :: theta aim point orientation [rad] integer, intent(out) :: istat status flag: 0 if no errors. -1 if state is not hyperbolic Calls proc~~calculate_bplane_data~~CallsGraph proc~calculate_bplane_data calculate_bplane_data proc~cross cross proc~calculate_bplane_data->proc~cross proc~unit unit proc~calculate_bplane_data->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~calculate_bplane_data~~CalledByGraph proc~calculate_bplane_data calculate_bplane_data proc~bplane_test bplane_test proc~bplane_test->proc~calculate_bplane_data Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine calculate_bplane_data ( mu , state , bdotr , bdott , bmag , theta , istat ) implicit none real ( wp ), intent ( in ) :: mu !! central body grav parameter  (km&#94;3/s&#94;2)  real ( wp ), dimension ( 6 ), intent ( in ) :: state !! state vector (km,km/s) real ( wp ), intent ( out ) :: bdotr !!  \\mathbf{B} \\cdot \\mathbf{R}  (km) real ( wp ), intent ( out ) :: bdott !!  \\mathbf{B} \\cdot \\mathbf{T}  (km) real ( wp ), intent ( out ) :: bmag !! magnitude of B vector (km) real ( wp ), intent ( out ) :: theta !! aim point orientation [rad] integer , intent ( out ) :: istat !! status flag: !! !! * 0 if no errors. !! * -1 if state is not hyperbolic real ( wp ), dimension ( 3 ) :: r !! position vector real ( wp ), dimension ( 3 ) :: v !! velocity vector real ( wp ), dimension ( 3 ) :: evec !! eccentricity vector real ( wp ), dimension ( 3 ) :: hvec !! angular momentum vector real ( wp ), dimension ( 3 ) :: nvec !! orbit normal vector real ( wp ), dimension ( 3 ) :: svec !! incoming asymptote real ( wp ), dimension ( 3 ) :: bvec !! B vector real ( wp ), dimension ( 3 ) :: tvec !! T vector real ( wp ), dimension ( 3 ) :: rvec !! R vector real ( wp ) :: rmag !! magnitude of `r` real ( wp ) :: vmag !! magnitude of `v` real ( wp ) :: e !! eccentricity real ( wp ) :: hmag !! magnitude of `hvec` vector real ( wp ) :: b !! semiminor axis real ( wp ) :: oneovere !! 1/e real ( wp ) :: temp r = state ( 1 : 3 ) v = state ( 4 : 6 ) hvec = cross ( r , v ) rmag = norm2 ( r ) vmag = norm2 ( v ) evec = cross ( v , hvec ) / mu - r / rmag e = norm2 ( evec ) if ( e <= 1.0 ) then ! not hyperbolic write ( * , * ) 'error: state is not hyperbolic.' istat = - 1 bdotr = 0.0_wp bdott = 0.0_wp bmag = 0.0_wp theta = 0.0_wp else istat = 0 evec = unit ( evec ) hmag = norm2 ( hvec ) hvec = unit ( hvec ) nvec = cross ( hvec , evec ) b = ( hmag * hmag ) / ( mu * sqrt ( e * e - 1.0_wp )) oneovere = 1.0_wp / e temp = sqrt ( 1.0_wp - oneovere * oneovere ) svec = ( evec / e ) + ( temp * nvec ) bvec = b * ( temp * evec - oneovere * nvec ) tvec = [ svec ( 2 ), - svec ( 1 ), 0.0_wp ] / sqrt ( svec ( 1 ) * svec ( 1 ) + svec ( 2 ) * svec ( 2 )) rvec = cross ( svec , tvec ) bdott = dot_product ( bvec , tvec ) bdotr = dot_product ( bvec , rvec ) bmag = sqrt ( bdott * bdott + bdotr * bdotr ) theta = atan ( bdotr , bdott ) end if end subroutine calculate_bplane_data","tags":"","url":"proc/calculate_bplane_data.html"},{"title":"compute_vinf_vectors – fortran-astrodynamics-toolkit","text":"private  subroutine compute_vinf_vectors(mu, rv, vinfin, vinfout) Compute the incoming and/or outgoing v-infinity vectors, given\nthe position and velocity of a hyperbola. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu central body gravitational parameter real(kind=wp), intent(in), dimension(6) :: rv position,velocity vector real(kind=wp), intent(out), optional, dimension(3) :: vinfin incoming v-infinity vector real(kind=wp), intent(out), optional, dimension(3) :: vinfout outgoing v-infinity vector Calls proc~~compute_vinf_vectors~~CallsGraph proc~compute_vinf_vectors compute_vinf_vectors proc~cross cross proc~compute_vinf_vectors->proc~cross Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Called by proc~~compute_vinf_vectors~~CalledByGraph proc~compute_vinf_vectors compute_vinf_vectors proc~bplane_test bplane_test proc~bplane_test->proc~compute_vinf_vectors Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine compute_vinf_vectors ( mu , rv , vinfin , vinfout ) implicit none real ( wp ), intent ( in ) :: mu !! central body gravitational parameter real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! position,velocity vector real ( wp ), dimension ( 3 ), intent ( out ), optional :: vinfin !! incoming v-infinity vector real ( wp ), dimension ( 3 ), intent ( out ), optional :: vinfout !! outgoing v-infinity vector real ( wp ), dimension ( 3 ) :: h , e , p , q , r , v real ( wp ) :: rmag , vmag , vinfmag , emag , qmag , cbeta , sbeta if ( present ( vinfin ) . or . present ( vinfout )) then r = rv ( 1 : 3 ) v = rv ( 4 : 6 ) rmag = norm2 ( r ) vmag = norm2 ( v ) h = cross ( r , v ) q = cross ( v , h ) vinfmag = sqrt ( vmag * vmag - two * mu / rmag ) e = q / mu - r / rmag emag = norm2 ( e ) q = cross ( h , e ) qmag = norm2 ( q ) cbeta = one / emag sbeta = sqrt ( one - cbeta * cbeta ) p = e / emag q = q / qmag if ( present ( vinfin )) vinfin = vinfmag * ( cbeta * p + sbeta * q ) if ( present ( vinfout )) vinfout = vinfmag * ( - cbeta * p + sbeta * q ) end if end subroutine compute_vinf_vectors","tags":"","url":"proc/compute_vinf_vectors.html"},{"title":"bplane_test – fortran-astrodynamics-toolkit","text":"public  subroutine bplane_test() Unit test for bplane_module . Arguments None Calls proc~~bplane_test~~CallsGraph proc~bplane_test bplane_test proc~bplane bplane proc~bplane_test->proc~bplane proc~calculate_bplane_data calculate_bplane_data proc~bplane_test->proc~calculate_bplane_data proc~compute_vinf_vectors compute_vinf_vectors proc~bplane_test->proc~compute_vinf_vectors proc~cross cross proc~bplane->proc~cross proc~ucross ucross proc~bplane->proc~ucross proc~unit unit proc~bplane->proc~unit proc~calculate_bplane_data->proc~cross proc~calculate_bplane_data->proc~unit proc~compute_vinf_vectors->proc~cross proc~ucross->proc~cross proc~ucross->proc~unit Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Source Code subroutine bplane_test () implicit none real ( wp ), dimension ( 3 ) :: vinfvec real ( wp ) :: bmag , theta , BdotT , BdotR , bmag2 , theta2 , BdotT2 , BdotR2 logical :: status_ok integer :: istat real ( wp ), parameter :: mu = 0.398600436233000e+06_wp !! grav. param. for earth  (km&#94;2/s&#94;2)  real ( wp ), dimension ( 6 ), parameter :: rv = [ - 1.518170076605391E+04_wp , & 1.518170076605392E+04_wp , & 2.147016712324346E+04_wp , & - 4.613927243557805E+00_wp , & - 2.352686048227026E+00_wp , & 1.598938983116768E+00_wp ] !! example hyperbolic state write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' bplane_test' write ( * , * ) '---------------' write ( * , * ) '' call compute_vinf_vectors ( mu , rv , vinfin = vinfvec ) write ( * , * ) 'vinfvec(1) =' , vinfvec ( 1 ) write ( * , * ) 'vinfvec(2) =' , vinfvec ( 2 ) write ( * , * ) 'vinfvec(3) =' , vinfvec ( 3 ) call bplane ( mu , rv , vinfvec , bmag , theta , BdotT , BdotR , status_ok ) write ( * , * ) '' write ( * , * ) 'vinfvec(1) =' , vinfvec ( 1 ) write ( * , * ) 'vinfvec(2) =' , vinfvec ( 2 ) write ( * , * ) 'vinfvec(3) =' , vinfvec ( 3 ) write ( * , * ) 'bmag       =' , bmag write ( * , * ) 'theta      =' , theta write ( * , * ) 'BdotT      =' , BdotT write ( * , * ) 'BdotR      =' , BdotR call calculate_bplane_data ( mu , rv , BdotR2 , BdotT2 , bmag2 , theta2 , istat ) write ( * , * ) '' write ( * , * ) 'Alternate version:' write ( * , * ) '' write ( * , * ) 'bmag       =' , bmag2 write ( * , * ) 'theta      =' , theta2 write ( * , * ) 'BdotT      =' , BdotT2 write ( * , * ) 'BdotR      =' , BdotR2 write ( * , * ) '' write ( * , * ) 'Difference:' write ( * , * ) '' write ( * , * ) 'bmag       =' , bmag2 - bmag write ( * , * ) 'theta      =' , theta2 - theta write ( * , * ) 'BdotT      =' , BdotT2 - BdotT write ( * , * ) 'BdotR      =' , BdotR2 - BdotR end subroutine bplane_test","tags":"","url":"proc/bplane_test.html"},{"title":"random_module – fortran-astrodynamics-toolkit","text":"Random number generation. Uses kind_module module~~random_module~~UsesGraph module~random_module random_module module~kind_module kind_module module~random_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~random_module~~UsedByGraph module~random_module random_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~random_module proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->module~random_module proc~lambert_test lambert_test proc~lambert_test->module~random_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function get_random_number (a, b) result(x) Author Jacob Williams Returns a uniform random number x , such that: a <= x < b . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b Return Value real(kind=wp)","tags":"","url":"module/random_module.html"},{"title":"standish_module – fortran-astrodynamics-toolkit","text":"Approximate positions of the major planets. See also analytical_ephemeris_module -- analytical ephemeris for Earth's Moon. Reference E.M. Standish, Solar System Dynamics Group, JPL/Caltech,\n    \" Keplerian Elements for Approximate Positions of the Major Planets \" History Original version copyright 2018 https://github.com/CumuloEpsilon BSD License . Jacob Williams, extensive refactoring with some modifications,\n    and integration into the FAT ephemeris module. Original license Copyright ( c ) 2018 , CumuloEpsilon All rights reserved . Redistribution and use in source and binary forms , with or without modification , are permitted provided that the following conditions are met : * Redistributions of source code must retain the above copyright notice , this list of conditions and the following disclaimer . * Redistributions in binary form must reproduce the above copyright notice , this list of conditions and the following disclaimer in the documentation and / or other materials provided with the distribution . THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES , INCLUDING , BUT NOT LIMITED TO , THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED . IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT , INDIRECT , INCIDENTAL , SPECIAL , EXEMPLARY , OR CONSEQUENTIAL DAMAGES ( INCLUDING , BUT NOT LIMITED TO , PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES ; LOSS OF USE , DATA , OR PROFITS ; OR BUSINESS INTERRUPTION ) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY , WHETHER IN CONTRACT , STRICT LIABILITY , OR TORT ( INCLUDING NEGLIGENCE OR OTHERWISE ) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE , EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE . Uses kind_module time_module numbers_module conversion_module celestial_body_module ephemeris_module base_class_module module~~standish_module~~UsesGraph module~standish_module standish_module module~base_class_module base_class_module module~standish_module->module~base_class_module module~celestial_body_module celestial_body_module module~standish_module->module~celestial_body_module module~conversion_module conversion_module module~standish_module->module~conversion_module module~ephemeris_module ephemeris_module module~standish_module->module~ephemeris_module module~kind_module kind_module module~standish_module->module~kind_module module~numbers_module numbers_module module~standish_module->module~numbers_module module~time_module time_module module~standish_module->module~time_module module~celestial_body_module->module~base_class_module module~celestial_body_module->module~kind_module module~celestial_body_module->module~numbers_module module~conversion_module->module~kind_module module~conversion_module->module~numbers_module module~ephemeris_module->module~celestial_body_module module~ephemeris_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module module~time_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~standish_module~~UsedByGraph module~standish_module standish_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~standish_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=wp), private, parameter :: obliquity = 23.43928_wp obliquity at J2000 [deg] real(kind=wp), private, parameter :: s_sobl = sin(obliquity*deg2rad) sin of j2000 obliquity real(kind=wp), private, parameter :: s_cobl = cos(obliquity*deg2rad) cos of j2000 obliquity real(kind=wp), private, parameter :: epoch = 2451545.0_wp Julian date of J2000 epoch type( ephem ), private, parameter :: eph1 = ephem(1, 'Keplerian Elements Valid 1800AD-2050AD', [2378497.0_wp, 2470172.0_wp], reshape([0.38709927_wp, 0.20563594_wp, 0.12225995_wp, 4.4025989_wp, 1.3518935_wp, 0.84353095_wp, 3.70000009e-07_wp, 1.90600003e-05_wp, -1.03803286e-04_wp, 2608.7903_wp, 2.80085020e-03_wp, -2.18760967e-03_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.72333568_wp, 6.77671982e-03_wp, 5.92482723e-02_wp, 3.1761343_wp, 2.2968962_wp, 1.3383157_wp, 3.90000014e-06_wp, -4.10700013e-05_wp, -1.37689030e-05_wp, 1021.3286_wp, 4.68322469e-05_wp, -4.84667765e-03_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, 1.0000026_wp, 1.67112295e-02_wp, -2.67209913e-07_wp, 1.7534375_wp, 1.7966015_wp, 0.0_wp, 5.62000014e-06_wp, -4.39200012e-05_wp, -2.25962198e-04_wp, 628.30756_wp, 5.64218918e-03_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, 1.5237104_wp, 9.33941007e-02_wp, 3.22832055e-02_wp, -7.94723779e-02_wp, -0.41789517_wp, 0.86497712_wp, 1.84700002e-05_wp, 7.88199977e-05_wp, -1.41918135e-04_wp, 334.06131_wp, 7.75643345e-03_wp, -5.10636950e-03_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, 5.2028871_wp, 4.83862385e-02_wp, 2.27660220e-02_wp, 0.60033119_wp, 0.25706047_wp, 1.7536005_wp, -1.16069998e-04_wp, -1.32529996e-04_wp, -3.20641411e-05_wp, 52.966312_wp, 3.70929041e-03_wp, 3.57253314e-03_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, 9.5366764_wp, 5.38617894e-02_wp, 4.33887430e-02_wp, 0.87186599_wp, 1.6161553_wp, 1.9837835_wp, -1.25059998e-03_wp, -5.09909994e-04_wp, 3.37911442e-05_wp, 21.336540_wp, -7.31244357e-03_wp, -5.03838016e-03_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, 19.189165_wp, 4.72574383e-02_wp, 1.34850740e-02_wp, 5.4670362_wp, 2.9837148_wp, 1.2918390_wp, -1.96175999e-03_wp, -4.39700016e-05_wp, -4.24008576e-05_wp, 7.4784222_wp, 7.12186471e-03_wp, 7.40122399e-04_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, 30.069923_wp, 8.59048031e-03_wp, 3.08930874e-02_wp, -0.96202600_wp, 0.78478318_wp, 2.3000686_wp, 2.62910005e-04_wp, 5.10499995e-05_wp, 6.17357864e-06_wp, 3.8128369_wp, -5.62719675e-03_wp, -8.87786155e-05_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, 39.482117_wp, 0.24882729_wp, 0.29914966_wp, 4.1700983_wp, 3.9107401_wp, 1.9251670_wp, -3.15960002e-04_wp, 5.17000008e-05_wp, 8.40899645e-07_wp, 2.5343544_wp, -7.09117157e-04_wp, -2.06556579e-04_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.0_wp], [16, 9])) The first ephemeris data table (this is standish's table 1).\nkeplerian elements valid 1800 ad - 2050 ad type( ephem ), private, parameter :: eph2 = ephem(2, 'Keplerian Elements Valid 3000BC-3000AD', [625674.0_wp, 2816788.0_wp], reshape([0.38709843_wp, 0.20563661_wp, 0.12227069_wp, 4.4026222_wp, 1.3518922_wp, 0.84368551_wp, 0.0_wp, 2.12300001e-05_wp, -1.03002007e-04_wp, 2608.7903_wp, 2.78205727e-03_wp, -2.13177688e-03_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.72332102_wp, 6.76399004e-03_wp, 5.93023673e-02_wp, 3.1761451_wp, 2.2997777_wp, 1.3381896_wp, -2.60000007e-07_wp, -5.10700011e-05_wp, 7.59113527e-06_wp, 1021.3286_wp, 9.91285546e-04_wp, -4.76024114e-03_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, 1.0000002_wp, 1.67316291e-02_wp, -9.48516663e-06_wp, 1.7534785_wp, 1.7964685_wp, -8.92317668e-02_wp, -2.99999989e-08_wp, -3.66099994e-05_wp, -2.33381579e-04_wp, 628.30762_wp, 5.54932002e-03_wp, -4.21040738e-03_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, 1.5237124_wp, 9.33651105e-02_wp, 3.23203318e-02_wp, -7.97289312e-02_wp, -0.41743821_wp, 0.86765921_wp, 9.69999974e-07_wp, 9.14900011e-05_wp, -1.26493964e-04_wp, 334.06125_wp, 7.89301097e-03_wp, -4.68663359e-03_wp, 0.0_wp, 0.0_wp, 0.0_wp, 0.0_wp, 5.2024803_wp, 4.85358983e-02_wp, 2.26650927e-02_wp, 0.59925520_wp, 0.24914493_wp, 1.7504400_wp, -2.86400009e-05_wp, 1.80260002e-04_wp, -5.63216017e-05_wp, 52.969063_wp, 3.17635899e-03_wp, 2.27322499e-03_wp, -2.17328397e-06_wp, 1.05837814e-03_wp, -6.21955749e-03_wp, 0.66935557_wp, 9.5414991_wp, 5.55082485e-02_wp, 4.35327180e-02_wp, 0.87398607_wp, 1.6207365_wp, 1.9833919_wp, -3.06500006e-05_wp, -3.20440013e-04_wp, 7.88834659e-05_wp, 21.329931_wp, 9.45610274e-03_wp, -4.36594151e-03_wp, 4.52022823e-06_wp, -2.34475732e-03_wp, 1.52402408e-02_wp, 0.66935557_wp, 19.187979_wp, 4.68574017e-02_wp, 1.34910680e-02_wp, 5.4838729_wp, 3.0095420_wp, 1.2908891_wp, -2.04550000e-04_wp, -1.54999998e-05_wp, -3.14429781e-05_wp, 7.4786506_wp, 1.61739404e-03_wp, 1.00176642e-03_wp, 1.01806800e-05_wp, -1.70574244e-02_wp, 3.08735552e-03_wp, 0.13387112_wp, 30.069527_wp, 8.95438995e-03_wp, 3.08932904e-02_wp, 5.3096914_wp, 0.81474739_wp, 2.3001058_wp, 6.44699976e-05_wp, 8.17999990e-06_wp, 3.90953755e-06_wp, 3.8129361_wp, 1.76267436e-04_wp, -1.05819658e-04_wp, -7.21658762e-06_wp, 1.19286822e-02_wp, -1.77369907e-03_wp, 0.13387112_wp, 39.486862_wp, 0.24885239_wp, 0.29916763_wp, 4.1707320_wp, 3.9112310_wp, 1.9251275_wp, 4.49750992e-03_wp, 6.01600004e-05_wp, 8.74410020e-08_wp, 2.5338767_wp, -1.69092222e-04_wp, -1.41368364e-04_wp, -2.20386923e-04_wp, 0.0_wp, 0.0_wp, 0.0_wp], [16, 9])) The first ephemeris data table (this is standish's table 2).\nkeplerian elements valid 3000 bc - 3000 ad type( ephem ), private, parameter,               dimension(2) :: eph_set = [eph1, eph2] the set of ephem options\nthat are available. Derived Types type, public, extends( ephemeris_class ) :: standish_ephemeris Standish ephemeris class for computing the\napproximate positions of the major planets. Type-Bound Procedures procedure, public :: get_rv => standish_rv_func procedure, public :: get_r => standish_r_func type, private, extends( base_class ) :: ephem an ephemeris defined using a date range\nand a set of elements from the reference. Read more… Components Type Visibility Attributes Name Initial integer, public :: id = 0 a unique ID code that distinguishes a\nvariable from other variables of the same type. character(len=name_len), public :: name = '' the variable name real(kind=wp), public, dimension(2) :: jd_range = zero valid julian date range real(kind=wp), public, dimension (16, 9) :: o = zero keplerian elements terms Type-Bound Procedures generic, public :: operator(==) => base_class_equal generic, public :: operator(/=) => base_class_not_equal Functions private pure function spice_id_to_standish_id (spice_id) result(old_id) Author Jacob Williams Date 3/4/2018 Convert the NAIF SPICE ID code to the one used by the standish ephemeris.\n  Returns 0 if the body was not found. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: spice_id the ID code used by SPICE Return Value integer the ID code used by this module private pure function kepler (ma, ec) solve kepler's equation ma = ea + ec*sin(ea) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ma eccentricity real(kind=wp), intent(in) :: ec mean anomaly in rad Return Value real(kind=wp) private pure function tbl (jd) result(itbl) Determine which data set to use for highest accuracy for the given julian date. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: jd julian date (eg 2451545.0) Return Value integer Which data set to use: itbl=1 jd in range of table 1\n  (1800ad-2050ad) - highest accuracy itbl=2 jd outside range of table 1\n  but in range of table 2 (3000bc-3000ad) itbl=0 3000bc 3000ad  julian\n  date out of range for ephemeris. Subroutines private  subroutine standish_rv_func (me, et, targ, obs, rv, status_ok) Author Jacob Williams Date 3/4/2018 Return the state of the targ body relative to\nthe obs body, in the inertial frame [ICRF]. Read more… Arguments Type Intent Optional Attributes Name class( standish_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(6) :: rv state of targ w.r.t. obs [km, km/s] logical, intent(out) :: status_ok true if there were no problems private  subroutine standish_r_func (me, et, targ, obs, r, status_ok) Return the position of the targ body relative to\n the obs body, in the inertial frame [ICRF]. Read more… Arguments Type Intent Optional Attributes Name class( standish_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(3) :: r position of targ w.r.t. obs [km] logical, intent(out) :: status_ok true if there were no problems private pure subroutine helio (np, jd, p, itbl) For planet np and julian date jd and using using table itbl ,\nreturn j2000 ecliptic position (au) and velocity (au/yr).\nin cartesian coordinates (p(1)-p(6)). Arguments Type Intent Optional Attributes Name integer, intent(in) :: np planet 1-9 real(kind=wp), intent(in) :: jd julian date real(kind=wp), intent(out), dimension(6) :: p position (au)/velocity (au/yr) integer, intent(out) :: itbl table used or error if zero private pure subroutine calcelements (np, jd, itbl, z) Calculate current elements z(jd) for planet j from jpl data Arguments Type Intent Optional Attributes Name integer, intent(in) :: np planet number (1-9) real(kind=wp), intent(in) :: jd julian date integer, intent(in) :: itbl which table to use (1-2) real(kind=wp), intent(out), dimension(8) :: z elements for jd Read more… private pure subroutine el2op (z, po) heliocentric coordinates for orbital plane from elements Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(8) :: z elements [a,e,i,l,w,o,ma,ea] real(kind=wp), intent(out), dimension(6) :: po coordinates and velocities private pure subroutine op2ec (z, po, pe) heliocentric coordinates j2000 ecliptic plane from orbital plane Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(8) :: z elements a,e,i,l,w,o,ma,ea real(kind=wp), intent(in), dimension(6) :: po orbital plane coordinates real(kind=wp), intent(out), dimension(6) :: pe j2000 ecliptic plane coordinates private pure subroutine ec2eq (pe, pq) converts cartesian heliocentric j2000 ecliptic to equatorial Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: pe ecliptic real(kind=wp), intent(out), dimension(6) :: pq equatorial private pure subroutine eq2ec (pq, pe) converts cartesian heliocentric equatorial to ecliptic Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: pq equatorial real(kind=wp), intent(out), dimension(6) :: pe ecliptic private pure subroutine sphere (x, y, z, rho, theta, phi) cartesian to spherical coordinates (angles in radians) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x x = r cos(phi) cos (theta) real(kind=wp), intent(in) :: y y = r cos(phi) sin(theta) real(kind=wp), intent(in) :: z z = r sin(phi) real(kind=wp), intent(out) :: rho distance real(kind=wp), intent(out) :: theta longitude real(kind=wp), intent(out) :: phi latitude public  subroutine standish_module_test () Author Jacob Williams Date 3/4/2018 Test routine for the standish_module routines. Arguments None","tags":"","url":"module/standish_module.html"},{"title":"obliquity_module – fortran-astrodynamics-toolkit","text":"For computing the obliquity of the ecliptic. Notes Mean obliquity does not include the short-period terms\n    due to nutation. True obliquity includes these terms. Uses conversion_module kind_module module~~obliquity_module~~UsesGraph module~obliquity_module obliquity_module module~conversion_module conversion_module module~obliquity_module->module~conversion_module module~kind_module kind_module module~obliquity_module->module~kind_module module~conversion_module->module~kind_module module~numbers_module numbers_module module~conversion_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~obliquity_module~~UsedByGraph module~obliquity_module obliquity_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~obliquity_module proc~get_c_cdot_ecliptic ecliptic_frame%get_c_cdot_ecliptic proc~get_c_cdot_ecliptic->module~obliquity_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private pure function mean_obliquity_func(et) result(e) a function for computing the mean obliquity of the ecliptic. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: et ephemeris time (sec) Return Value real(kind=wp) obliquity of ecliptic (deg) Functions public pure function mean_ecliptic_to_equatorial_rotmat (obliquity_func) result(rot) Rotation matrix from Mean Ecliptic to J2000. Read more… Arguments Type Intent Optional Attributes Name procedure( mean_obliquity_func ), optional :: obliquity_func optional function to compute\nthe mean obliquity. If not\npresent, then mean_obliquity_of_ecliptic_iau1980 is used. Return Value real(kind=wp), dimension(3,3) rotation matrix public pure function equatorial_to_mean_ecliptic_rotmat (obliquity_func) result(rot) Rotation matrix from J2000 to Mean Ecliptic. Arguments Type Intent Optional Attributes Name procedure( mean_obliquity_func ), optional :: obliquity_func optional function to compute\nthe mean obliquity. If not\npresent, then mean_obliquity_of_ecliptic_iau1980 is used. Return Value real(kind=wp), dimension(3,3) rotation matrix public pure function mean_obliquity_of_ecliptic_iau2006 (et) result(e) Mean obliquity of the ecliptic, IAU 2006 formula. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: et ephemeris time (sec) Return Value real(kind=wp) obliquity of ecliptic (deg) public pure function mean_obliquity_of_ecliptic_iau1980 (et) result(e) Mean obliquity of the ecliptic, IAU 1980 formula. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: et ephemeris time (sec) Return Value real(kind=wp) obliquity of ecliptic (deg)","tags":"","url":"module/obliquity_module.html"},{"title":"newton_module – fortran-astrodynamics-toolkit","text":"Basic Newton solver. Uses numbers_module kind_module module~~newton_module~~UsesGraph module~newton_module newton_module module~kind_module kind_module module~newton_module->module~kind_module module~numbers_module numbers_module module~newton_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~newton_module~~UsedByGraph module~newton_module newton_module proc~kepler_classical kepler_classical proc~kepler_classical->module~newton_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  subroutine func(x, f) interface for the function and derivative Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(out) :: f Subroutines public  subroutine newton (x, f, dfdx, ftol, xtol, max_iter, xs, fx, iflag) Newton's method for root finding of scalar function f(x) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x initial point (initial guess) procedure( func ) :: f function f(x) procedure( func ) :: dfdx first derivative function f'(x) real(kind=wp), intent(in) :: ftol convergence tolerance for f(x) real(kind=wp), intent(in) :: xtol convergence tolerance for x integer, intent(in) :: max_iter the maximum number of iterations real(kind=wp), intent(out) :: xs the value where f(x) is zero real(kind=wp), intent(out) :: fx the value of f(x) at the root xs integer, intent(out) :: iflag status flag:\n 0 : absolute convergence in f\n 1 : relative convergence in x\n-1 : Error: derivative is zero\n-2 : Error: max iterations exceeded","tags":"","url":"module/newton_module.html"},{"title":"fortran_astrodynamics_toolkit – fortran-astrodynamics-toolkit","text":"The main module that uses all the other modules.\nAllows for a single use fortran_astrodynamics_toolkit to access the entire library. Uses jpl_ephemeris_module obliquity_module geodesy_module gravity_module minpack_module conversion_module celestial_body_module crtbp_module math_module relative_motion_module orbital_mechanics_module analytical_ephemeris_module geopotential_module brent_module string_module eispack_module c_interface_module matrix_module numbers_module random_module ephemeris_module modified_equinoctial_module standish_module vector_module complex_step_module base_class_module lambert_module lighting_module kind_module rk_module_variable_step time_module halo_orbit_module iau_orientation_module bplane_module drag_module rk_module transformation_module gooding_module kepler_module geometry_module module~~fortran_astrodynamics_toolkit~~UsesGraph module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~analytical_ephemeris_module analytical_ephemeris_module module~fortran_astrodynamics_toolkit->module~analytical_ephemeris_module module~base_class_module base_class_module module~fortran_astrodynamics_toolkit->module~base_class_module module~bplane_module bplane_module module~fortran_astrodynamics_toolkit->module~bplane_module module~brent_module brent_module module~fortran_astrodynamics_toolkit->module~brent_module module~c_interface_module c_interface_module module~fortran_astrodynamics_toolkit->module~c_interface_module module~celestial_body_module celestial_body_module module~fortran_astrodynamics_toolkit->module~celestial_body_module module~complex_step_module complex_step_module module~fortran_astrodynamics_toolkit->module~complex_step_module module~conversion_module conversion_module module~fortran_astrodynamics_toolkit->module~conversion_module module~crtbp_module crtbp_module module~fortran_astrodynamics_toolkit->module~crtbp_module module~drag_module drag_module module~fortran_astrodynamics_toolkit->module~drag_module module~eispack_module eispack_module module~fortran_astrodynamics_toolkit->module~eispack_module module~ephemeris_module ephemeris_module module~fortran_astrodynamics_toolkit->module~ephemeris_module module~geodesy_module geodesy_module module~fortran_astrodynamics_toolkit->module~geodesy_module module~geometry_module geometry_module module~fortran_astrodynamics_toolkit->module~geometry_module module~geopotential_module geopotential_module module~fortran_astrodynamics_toolkit->module~geopotential_module module~gooding_module gooding_module module~fortran_astrodynamics_toolkit->module~gooding_module module~gravity_module gravity_module module~fortran_astrodynamics_toolkit->module~gravity_module module~halo_orbit_module halo_orbit_module module~fortran_astrodynamics_toolkit->module~halo_orbit_module module~iau_orientation_module iau_orientation_module module~fortran_astrodynamics_toolkit->module~iau_orientation_module module~jpl_ephemeris_module jpl_ephemeris_module module~fortran_astrodynamics_toolkit->module~jpl_ephemeris_module module~kepler_module kepler_module module~fortran_astrodynamics_toolkit->module~kepler_module module~kind_module kind_module module~fortran_astrodynamics_toolkit->module~kind_module module~lambert_module lambert_module module~fortran_astrodynamics_toolkit->module~lambert_module module~lighting_module lighting_module module~fortran_astrodynamics_toolkit->module~lighting_module module~math_module math_module module~fortran_astrodynamics_toolkit->module~math_module module~matrix_module matrix_module module~fortran_astrodynamics_toolkit->module~matrix_module module~minpack_module minpack_module module~fortran_astrodynamics_toolkit->module~minpack_module module~modified_equinoctial_module modified_equinoctial_module module~fortran_astrodynamics_toolkit->module~modified_equinoctial_module module~numbers_module numbers_module module~fortran_astrodynamics_toolkit->module~numbers_module module~obliquity_module obliquity_module module~fortran_astrodynamics_toolkit->module~obliquity_module module~orbital_mechanics_module orbital_mechanics_module module~fortran_astrodynamics_toolkit->module~orbital_mechanics_module module~random_module random_module module~fortran_astrodynamics_toolkit->module~random_module module~relative_motion_module relative_motion_module module~fortran_astrodynamics_toolkit->module~relative_motion_module module~rk_module rk_module module~fortran_astrodynamics_toolkit->module~rk_module module~rk_module_variable_step rk_module_variable_step module~fortran_astrodynamics_toolkit->module~rk_module_variable_step module~standish_module standish_module module~fortran_astrodynamics_toolkit->module~standish_module module~string_module string_module module~fortran_astrodynamics_toolkit->module~string_module module~time_module time_module module~fortran_astrodynamics_toolkit->module~time_module module~transformation_module transformation_module module~fortran_astrodynamics_toolkit->module~transformation_module module~vector_module vector_module module~fortran_astrodynamics_toolkit->module~vector_module module~analytical_ephemeris_module->module~conversion_module module~analytical_ephemeris_module->module~kind_module module~analytical_ephemeris_module->module~numbers_module module~bplane_module->module~kind_module module~bplane_module->module~numbers_module module~bplane_module->module~vector_module module~brent_module->module~kind_module module~brent_module->module~numbers_module module~c_interface_module->module~geopotential_module module~c_interface_module->module~kind_module iso_c_binding iso_c_binding module~c_interface_module->iso_c_binding module~celestial_body_module->module~base_class_module module~celestial_body_module->module~kind_module module~celestial_body_module->module~numbers_module module~complex_step_module->module~kind_module module~conversion_module->module~kind_module module~conversion_module->module~numbers_module module~crtbp_module->module~kind_module module~crtbp_module->module~numbers_module module~drag_module->module~kind_module module~eispack_module->module~kind_module module~ephemeris_module->module~celestial_body_module module~ephemeris_module->module~kind_module module~geodesy_module->module~kind_module module~geodesy_module->module~numbers_module module~geometry_module->module~kind_module module~geometry_module->module~vector_module module~geopotential_module->module~kind_module module~geopotential_module->module~numbers_module module~gooding_module->module~kind_module module~gooding_module->module~numbers_module module~gravity_module->module~kind_module module~gravity_module->module~numbers_module iso_fortran_env iso_fortran_env module~gravity_module->iso_fortran_env module~halo_orbit_module->module~crtbp_module module~halo_orbit_module->module~kind_module module~halo_orbit_module->module~numbers_module module~halo_orbit_module->iso_fortran_env module~iau_orientation_module->module~conversion_module module~iau_orientation_module->module~kind_module module~iau_orientation_module->module~numbers_module module~jpl_ephemeris_module->module~ephemeris_module module~jpl_ephemeris_module->module~kind_module module~jpl_ephemeris_module->iso_fortran_env module~kepler_module->module~kind_module module~kepler_module->module~numbers_module module~kepler_module->iso_fortran_env module~kind_module->iso_fortran_env module~lambert_module->module~kind_module module~lambert_module->module~numbers_module module~lambert_module->module~vector_module module~lighting_module->module~celestial_body_module module~lighting_module->module~conversion_module module~lighting_module->module~ephemeris_module module~lighting_module->module~kind_module module~lighting_module->module~math_module module~lighting_module->module~numbers_module module~lighting_module->module~transformation_module module~lighting_module->module~vector_module module~math_module->module~kind_module module~math_module->module~numbers_module module~matrix_module->module~kind_module module~matrix_module->module~numbers_module module~minpack_module->module~kind_module module~minpack_module->module~numbers_module module~modified_equinoctial_module->module~kind_module module~modified_equinoctial_module->module~numbers_module module~modified_equinoctial_module->module~vector_module module~numbers_module->module~kind_module module~obliquity_module->module~conversion_module module~obliquity_module->module~kind_module module~orbital_mechanics_module->module~kind_module module~orbital_mechanics_module->module~math_module module~orbital_mechanics_module->module~numbers_module module~orbital_mechanics_module->module~vector_module module~random_module->module~kind_module module~relative_motion_module->module~kind_module module~relative_motion_module->module~numbers_module module~rk_module->module~kind_module module~rk_module->module~numbers_module module~rk_module_variable_step->module~kind_module module~rk_module_variable_step->module~numbers_module module~standish_module->module~base_class_module module~standish_module->module~celestial_body_module module~standish_module->module~conversion_module module~standish_module->module~ephemeris_module module~standish_module->module~kind_module module~standish_module->module~numbers_module module~standish_module->module~time_module module~time_module->module~kind_module module~transformation_module->module~celestial_body_module module~transformation_module->module~ephemeris_module module~transformation_module->module~iau_orientation_module module~transformation_module->module~kind_module module~transformation_module->module~numbers_module module~transformation_module->module~time_module module~transformation_module->module~vector_module module~transformation_module->iso_fortran_env module~vector_module->module~kind_module module~vector_module->module~numbers_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: fat_wp = wp default real kind","tags":"","url":"module/fortran_astrodynamics_toolkit.html"},{"title":"complex_step_module – fortran-astrodynamics-toolkit","text":"Complex-step differentiation routines. See also J.R.R.A. Martins, P. Sturdza, J.J. Alonso,\n     \"The Complex-Step Derivative Approximation\",\n     ACM Transactions on Mathematical Software,\n     Vol. 29, No. 3, September 2003, Pages 245262. Uses kind_module module~~complex_step_module~~UsesGraph module~complex_step_module complex_step_module module~kind_module kind_module module~complex_step_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~complex_step_module~~UsedByGraph module~complex_step_module complex_step_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~complex_step_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface private  function func(x) result(f) Arguments Type Intent Optional Attributes Name complex(kind=wp), intent(in) :: x Return Value complex(kind=wp) Subroutines public  subroutine complex_step_derivative (f, x, h, dfdx) Compute the first derivative using the complex-step method.\nThis is Equation 6 from Reference [1]. Arguments Type Intent Optional Attributes Name procedure( func ) :: f complex(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out) :: dfdx private  subroutine forward_diff (f, x, h, dfdx) Compute the first derivative using a forward difference.\nThis is Equation 1 from Reference [1]. Arguments Type Intent Optional Attributes Name procedure( func ) :: f complex(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out) :: dfdx private  subroutine central_diff (f, x, h, dfdx) Compute the first derivative using a 2-point central difference [-h,h]. Arguments Type Intent Optional Attributes Name procedure( func ) :: f complex(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out) :: dfdx private  subroutine central_diff_4 (f, x, h, dfdx) Compute the first derivative using a 4-point central difference [-2h,-h,h,2h]. Arguments Type Intent Optional Attributes Name procedure( func ) :: f complex(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out) :: dfdx public  subroutine complex_step_test () Unit test for the complex_step module. Arguments None","tags":"","url":"module/complex_step_module.html"},{"title":"gravity_module – fortran-astrodynamics-toolkit","text":"Gravity model See also geopotential_module Uses numbers_module kind_module iso_fortran_env module~~gravity_module~~UsesGraph module~gravity_module gravity_module iso_fortran_env iso_fortran_env module~gravity_module->iso_fortran_env module~kind_module kind_module module~gravity_module->module~kind_module module~numbers_module numbers_module module~gravity_module->module~numbers_module module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~gravity_module~~UsedByGraph module~gravity_module gravity_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~gravity_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine third_body_gravity (r, rb, mu, acc) Third-body (pointmass) gravitational acceleration. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r satellite position vector [km] real(kind=wp), intent(in), dimension(3) :: rb third-body position vector [km] real(kind=wp), intent(in) :: mu third-body gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(out), dimension(3) :: acc gravity acceleration vector [km/s&#94;2] public  subroutine third_body_gravity_alt (r, rb, mu, acc) Third-body (pointmass) gravitational acceleration (alternate Battin formulation).\nSee Equation 8.61 in Battin. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r satellite position vector [km] real(kind=wp), intent(in), dimension(3) :: rb third-body position vector [km] real(kind=wp), intent(in) :: mu third-body gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(out), dimension(3) :: acc gravity acceleration vector [km/s&#94;2] public  subroutine gravity_j2_j3_j4 (r, mu, req, j2, j3, j4, acc) Gravitational acceleration due to simplified spherical harmonic\n  expansion (only the J2-J4 terms are used). Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r satellite position vector [km] real(kind=wp), intent(in) :: mu central body gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: req body equatorial radius [km] real(kind=wp), intent(in) :: j2 j2 coefficient real(kind=wp), intent(in) :: j3 j3 coefficient real(kind=wp), intent(in) :: j4 j4 coefficient real(kind=wp), intent(out), dimension(3) :: acc gravity acceleration vector [km/s&#94;2]","tags":"","url":"module/gravity_module.html"},{"title":"modified_equinoctial_module – fortran-astrodynamics-toolkit","text":"Modified equinoctial elements routines. The modified equinoctial elements are applicable to all orbits\n  and have non-singular equations of motion (except for a singularity\n  at ). They are defined as: Where is the true longitude, is the semi-latus rectum,\n  and is the true anomaly. References Broucke, R. A. & Cefola, P. J., \"On the Equinoctial Orbit Elements\"\n    Celestial Mechanics, Volume 5, Issue 3, p 303-310. (1972) M. J. H. Walker, B. Ireland, Joyce Owens,\n    \"A Set of Modified Equinoctial Orbit Elements\"\n    Celestial Mechanics, Volume 36, Issue 4, p 409-419. (1985) Walker, M. J. H, \"Erratum - a Set of Modified Equinoctial Orbit Elements\"\n    Celestial Mechanics, Volume 38, Issue 4, p 391-392. (1986) Uses numbers_module kind_module vector_module module~~modified_equinoctial_module~~UsesGraph module~modified_equinoctial_module modified_equinoctial_module module~kind_module kind_module module~modified_equinoctial_module->module~kind_module module~numbers_module numbers_module module~modified_equinoctial_module->module~numbers_module module~vector_module vector_module module~modified_equinoctial_module->module~vector_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module module~vector_module->module~kind_module module~vector_module->module~numbers_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~modified_equinoctial_module~~UsedByGraph module~modified_equinoctial_module modified_equinoctial_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~modified_equinoctial_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine cartesian_to_equinoctial (mu, rv, evec) Convert Cartesian coordinates to modified equinoctial elements (posigrade formulation). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu central body gravitational parameter ( ) real(kind=wp), intent(in), dimension(6) :: rv Cartesian state vector real(kind=wp), intent(out), dimension(6) :: evec Modified equinoctial element vector public  subroutine equinoctial_to_cartesian (mu, evec, rv) Convert modified equinoctial elements (posigrade formulation) to Cartesian coordinates. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu central body gravitational parameter ( ) real(kind=wp), intent(in), dimension(6) :: evec Modified equinoctial element vector real(kind=wp), intent(out), dimension(6) :: rv Cartesian state vector public  subroutine modified_equinoctial_derivs (mu, evec, scn, evecd) Modified equinoctial elements (posigrade formulation) equations of motion. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu central body gravitational parameter ( ) real(kind=wp), intent(in), dimension(6) :: evec modified equinoctial element vector real(kind=wp), intent(in), dimension(3) :: scn Perturbation (in the RSW frame) real(kind=wp), intent(out), dimension(6) :: evecd derivative of evec public  subroutine modified_equinoctial_test () Unit tests for the modified_equinoctial_module. Arguments None","tags":"","url":"module/modified_equinoctial_module.html"},{"title":"vector_module – fortran-astrodynamics-toolkit","text":"Routines for the manipulation of vectors. Uses numbers_module kind_module module~~vector_module~~UsesGraph module~vector_module vector_module module~kind_module kind_module module~vector_module->module~kind_module module~numbers_module numbers_module module~vector_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~vector_module~~UsedByGraph module~vector_module vector_module module~bplane_module bplane_module module~bplane_module->module~vector_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~vector_module module~fortran_astrodynamics_toolkit->module~bplane_module module~geometry_module geometry_module module~fortran_astrodynamics_toolkit->module~geometry_module module~lambert_module lambert_module module~fortran_astrodynamics_toolkit->module~lambert_module module~lighting_module lighting_module module~fortran_astrodynamics_toolkit->module~lighting_module module~modified_equinoctial_module modified_equinoctial_module module~fortran_astrodynamics_toolkit->module~modified_equinoctial_module module~orbital_mechanics_module orbital_mechanics_module module~fortran_astrodynamics_toolkit->module~orbital_mechanics_module module~transformation_module transformation_module module~fortran_astrodynamics_toolkit->module~transformation_module module~geometry_module->module~vector_module module~lambert_module->module~vector_module module~lighting_module->module~vector_module module~lighting_module->module~transformation_module module~modified_equinoctial_module->module~vector_module module~orbital_mechanics_module->module~vector_module module~transformation_module->module~vector_module proc~from_ijk_to_lvlh_mat from_ijk_to_lvlh_mat proc~from_ijk_to_lvlh_mat->module~vector_module proc~from_ijk_to_rsw_mat from_ijk_to_rsw_mat proc~from_ijk_to_rsw_mat->module~vector_module proc~from_ijk_to_vuw_mat from_ijk_to_vuw_mat proc~from_ijk_to_vuw_mat->module~vector_module proc~from_lvlh_to_ijk_mat from_lvlh_to_ijk_mat proc~from_lvlh_to_ijk_mat->module~vector_module proc~from_rsw_to_ijk_mat from_rsw_to_ijk_mat proc~from_rsw_to_ijk_mat->module~vector_module proc~from_vuw_to_ijk_mat from_vuw_to_ijk_mat proc~from_vuw_to_ijk_mat->module~vector_module proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->module~vector_module proc~iau_rotation_matrix iau_rotation_matrix proc~iau_rotation_matrix->module~vector_module proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->module~orbital_mechanics_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: x_axis = 1 integer, public, parameter :: y_axis = 2 integer, public, parameter :: z_axis = 3 real(kind=wp), public, parameter,               dimension(3) :: x_unit = [one, zero, zero] x-axis unit vector real(kind=wp), public, parameter,               dimension(3) :: y_unit = [zero, one, zero] y-axis unit vector real(kind=wp), public, parameter,               dimension(3) :: z_unit = [zero, zero, one] z-axis unit vector Interfaces public        interface fill_vector private  subroutine fill_vector_with_vector (x, vals, i) Put the vector in the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: vals integer, intent(inout) :: i should be initialized to 0 before the first call private  subroutine fill_vector_with_scalar (x, val, i) Put the value in the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: x real(kind=wp), intent(in) :: val integer, intent(inout) :: i should be initialized to 0 before the first call private  subroutine fill_char_vector_with_vector (x, vals, i) Put the vector in the vector and update the index (character version) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout), dimension(:) :: x character(len=*), intent(in), dimension(:) :: vals integer, intent(inout) :: i should be initialized to 0 before the first call private  subroutine fill_char_vector_with_scalar (x, val, i) Put the value in the vector and update the index (character version) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout), dimension(:) :: x character(len=*), intent(in) :: val integer, intent(inout) :: i should be initialized to 0 before the first call public        interface extract_vector private  subroutine extract_vector_from_vector (vals, x, i) Extract a vector from the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:) :: vals real(kind=wp), intent(in), dimension(:) :: x integer, intent(inout) :: i should be initialized to 0 before the first call private  subroutine extract_scalar_from_vector (val, x, i) Extract the value from the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out) :: val real(kind=wp), intent(in), dimension(:) :: x integer, intent(inout) :: i should be initialized to 0 before the first call Functions public pure function cross (r, v) result(rxv) Author Jacob Williams Cross product of two 3x1 vectors Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r real(kind=wp), intent(in), dimension(3) :: v Return Value real(kind=wp), dimension(3) public pure function unit (r) result(u) Author Jacob Williams Unit vector Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: r Return Value real(kind=wp), dimension(size(r)) public pure function uhat_dot (u, udot) result(uhatd) Author Jacob Williams Time derivative of a unit vector. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: u vector [ u ] real(kind=wp), intent(in), dimension(3) :: udot derivative of vector [ du/dt ] Return Value real(kind=wp), dimension(3) derivative of unit vector [ d(uhat)/dt ] public pure function ucross (v1, v2) result(u) Author Jacob Williams Unit vector of the cross product of two 3x1 vectors Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: v1 real(kind=wp), intent(in), dimension(3) :: v2 Return Value real(kind=wp), dimension(3) public pure function cross_matrix (r) result(rcross) Author Jacob Williams Date 7/20/2014 Computes the cross product matrix, where: cross(a,b) == matmul(cross_matrix(a),b) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r Return Value real(kind=wp), dimension(3,3) public pure function outer_product (a, b) result(c) Author Jacob Williams Date 7/21/2014 Computes the outer product of the two vectors. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: a real(kind=wp), intent(in), dimension(:) :: b Return Value real(kind=wp), dimension(size(a),size(b)) public pure function box_product (a, b, c) result(d) Author Jacob Williams Date 7/21/2014 Computes the box product (scalar triple product) of the three vectors. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: a real(kind=wp), intent(in), dimension(:) :: b real(kind=wp), intent(in), dimension(:) :: c Return Value real(kind=wp) public pure function vector_projection (a, b) result(c) Author Jacob Williams Date 7/21/2014 The projection of one vector onto another vector. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: a the original vector real(kind=wp), intent(in), dimension(size(a)) :: b the vector to project on to Return Value real(kind=wp), dimension(size(a)) the projection of a onto b public pure function spherical_to_cartesian (r, alpha, beta) result(rvec) Author Jacob Williams Date 9/24/2014 Convert spherical (r,alpha,beta) to Cartesian (x,y,z). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r magnitude real(kind=wp), intent(in) :: alpha right ascension [rad] real(kind=wp), intent(in) :: beta declination [rad] Return Value real(kind=wp), dimension(3) [x,y,z] vector public pure function rotation_matrix (axis, angle) result(rotmat) Author Jacob Williams Date 2/3/2015 The 3x3 rotation matrix for a rotation about the x, y, or z-axis. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: axis x_axis, y_axis, or z_axis real(kind=wp), intent(in) :: angle angle in radians Return Value real(kind=wp), dimension(3,3) the rotation matrix public pure function rotation_matrix_dot (axis, angle, angledot) result(rotmatdot) Author Jacob Williams Date 3/19/2016 Time derivative of the 3x3 rotation matrix\nfor a rotation about the x, y, or z-axis. Arguments Type Intent Optional Attributes Name integer, intent(in) :: axis x_axis, y_axis, or z_axis real(kind=wp), intent(in) :: angle angle in radians real(kind=wp), intent(in) :: angledot time derivative of angle in radians/sec Return Value real(kind=wp), dimension(3,3) the rotation matrix derivative public pure function angle_between_vectors (v1, v2) result(ang) Author Jacob Williams Date 3/13/2015 The angle between two vectors (in radians). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: v1 real(kind=wp), intent(in), dimension(3) :: v2 Return Value real(kind=wp) [rad] Subroutines public pure subroutine axis_angle_rotation (v, k, theta, vrot) Author Jacob Williams Date 7/20/2014 Rotate a 3x1 vector in space, given an axis and angle of rotation. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: v vector to rotate real(kind=wp), intent(in), dimension(3) :: k rotation axis real(kind=wp), intent(in) :: theta rotation angle [rad] real(kind=wp), intent(out), dimension(3) :: vrot result public pure subroutine vector_projection_on_plane (a, b, c) Project a vector onto a plane. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: a the original vector real(kind=wp), intent(in), dimension(3) :: b the plane to project on to (a normal vector) real(kind=wp), intent(out), dimension(3) :: c the projection of a onto the b plane public pure subroutine axis_angle_rotation_to_rotation_matrix (k, theta, rotmat) Author Jacob Williams Date 7/20/2014 Computes the rotation matrix that corresponds to a\nrotation about the axis k by an angle theta . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: k rotation axis real(kind=wp), intent(in) :: theta rotation angle [rad] real(kind=wp), intent(out), dimension(3,3) :: rotmat rotation matrix public pure subroutine cartesian_to_spherical (rvec, r, alpha, beta) Author Jacob Williams Date 3/6/2016 Convert Cartesian (x,y,z) to spherical (r,alpha,beta). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: rvec [x,y,z] vector real(kind=wp), intent(out) :: r magnitude real(kind=wp), intent(out) :: alpha right ascension [rad] real(kind=wp), intent(out) :: beta declination [rad] private  subroutine fill_vector_with_vector (x, vals, i) Put the vector in the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: x real(kind=wp), intent(in), dimension(:) :: vals integer, intent(inout) :: i should be initialized to 0 before the first call private  subroutine fill_vector_with_scalar (x, val, i) Put the value in the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(inout), dimension(:) :: x real(kind=wp), intent(in) :: val integer, intent(inout) :: i should be initialized to 0 before the first call private  subroutine fill_char_vector_with_vector (x, vals, i) Put the vector in the vector and update the index (character version) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout), dimension(:) :: x character(len=*), intent(in), dimension(:) :: vals integer, intent(inout) :: i should be initialized to 0 before the first call private  subroutine fill_char_vector_with_scalar (x, val, i) Put the value in the vector and update the index (character version) Arguments Type Intent Optional Attributes Name character(len=*), intent(inout), dimension(:) :: x character(len=*), intent(in) :: val integer, intent(inout) :: i should be initialized to 0 before the first call private  subroutine extract_vector_from_vector (vals, x, i) Extract a vector from the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out), dimension(:) :: vals real(kind=wp), intent(in), dimension(:) :: x integer, intent(inout) :: i should be initialized to 0 before the first call private  subroutine extract_scalar_from_vector (val, x, i) Extract the value from the vector and update the index Arguments Type Intent Optional Attributes Name real(kind=wp), intent(out) :: val real(kind=wp), intent(in), dimension(:) :: x integer, intent(inout) :: i should be initialized to 0 before the first call public  subroutine vector_test () Author Jacob Williams Date 7/20/2014 Unit test routine for the vector_module . Arguments None","tags":"","url":"module/vector_module.html"},{"title":"math_module – fortran-astrodynamics-toolkit","text":"General math routines Uses numbers_module kind_module module~~math_module~~UsesGraph module~math_module math_module module~kind_module kind_module module~math_module->module~kind_module module~numbers_module numbers_module module~math_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~math_module~~UsedByGraph module~math_module math_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~math_module module~lighting_module lighting_module module~fortran_astrodynamics_toolkit->module~lighting_module module~orbital_mechanics_module orbital_mechanics_module module~fortran_astrodynamics_toolkit->module~orbital_mechanics_module module~lighting_module->module~math_module module~orbital_mechanics_module->module~math_module proc~compute_libration_points compute_libration_points proc~compute_libration_points->module~math_module proc~compute_libration_points_v2 compute_libration_points_v2 proc~compute_libration_points_v2->module~math_module proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->module~math_module proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->module~orbital_mechanics_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public pure elemental function magnitude (a, mina) result(m) Returns a positive number the same magnitude as the input,\n  with only one significant digit. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in), optional :: mina Return Value real(kind=wp) public pure elemental function wrap_angle (a) result(r) Wrap an angle (in rad) from -pi to pi. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a Return Value real(kind=wp) public pure elemental function cube_root (x) result(y) Author Jacob Williams Cube root of a number (real solution only). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp)","tags":"","url":"module/math_module.html"},{"title":"minpack_module – fortran-astrodynamics-toolkit","text":"Minpack routines for solving a set of nonlinear equations.\n  The two main routines here are hybrj (user-provided Jacobian) and hybrd (estimates the Jacobian using finite differences). License *** Original Minpack License *** Minpack Copyright Notice ( 1999 ) University of Chicago . All rights reserved Redistribution and use in source and binary forms , with or without modification , are permitted provided that the following conditions are met : 1. Redistributions of source code must retain the above copyright notice , this list of conditions and the following disclaimer . 2. Redistributions in binary form must reproduce the above copyright notice , this list of conditions and the following disclaimer in the documentation and / or other materials provided with the distribution . 3. The end - user documentation included with the redistribution , if any , must include the following acknowledgment : \"This product includes software developed by the University of Chicago, as Operator of Argonne National Laboratory. Alternately, this acknowledgment may appear in the software itself, if and wherever such third-party acknowledgments normally appear. 4. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \" AS IS \" WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL BE CORRECTED. 5. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE POSSIBILITY OF SUCH LOSS OR DAMAGES. *** Modifications *** Modifications for the Fortran Astrodynamics Toolkit are covered\n  under the following license . History Argonne National Laboratory. minpack project. march 1980.\n    burton s. garbow, kenneth e. hillstrom, jorge j. more, john l. nazareth Jacob Williams, Jan 2016, extensive refactoring into modern Fortran. Uses numbers_module kind_module module~~minpack_module~~UsesGraph module~minpack_module minpack_module module~kind_module kind_module module~minpack_module->module~kind_module module~numbers_module numbers_module module~minpack_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~minpack_module~~UsedByGraph module~minpack_module minpack_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~minpack_module proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->module~minpack_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface public  subroutine fcn_hybrd(n, x, fvec, iflag) function for hybrd .\ncalculate the functions at x and\nreturn this vector in fvec . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(out), dimension(n) :: fvec integer, intent(inout) :: iflag the value of iflag should not be changed by fcn unless\nthe user wants to terminate execution of hybrd .\nin this case set iflag to a negative integer. abstract interface public  subroutine fcn_hybrj(n, x, fvec, fjac, ldfjac, iflag) function for hybrj Arguments Type Intent Optional Attributes Name integer, intent(in) :: n real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(out), dimension(n) :: fvec real(kind=wp), intent(out), dimension(ldfjac,n) :: fjac integer, intent(in) :: ldfjac integer, intent(inout) :: iflag Functions public  function dpmpar (i) Replacement for the original Minpack routine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: i Return Value real(kind=wp) public  function enorm (n, x) given an n-vector x, this function calculates the\neuclidean norm of x. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n size of x real(kind=wp), intent(in), dimension(n) :: x input array Return Value real(kind=wp) Subroutines public  subroutine dogleg (n, r, lr, diag, qtb, delta, x, wa1, wa2) given an m by n matrix a, an n by n nonsingular diagonal\nmatrix d, an m-vector b, and a positive number delta, the\nproblem is to determine the convex combination x of the\ngauss-newton and scaled gradient directions that minimizes\n(a x - b) in the least squares sense, subject to the\nrestriction that the euclidean norm of d x be at most delta. Read more… Arguments Type Intent Optional Attributes Name integer :: n real(kind=wp) :: r (lr) integer :: lr real(kind=wp) :: diag (n) real(kind=wp) :: qtb (n) real(kind=wp) :: delta real(kind=wp) :: x (n) real(kind=wp) :: wa1 (n) real(kind=wp) :: wa2 (n) public  subroutine fdjac1 (fcn, n, x, fvec, fjac, ldfjac, iflag, ml, mu, epsfcn, wa1, wa2) this subroutine computes a forward-difference approximation\nto the n by n jacobian matrix associated with a specified\nproblem of n functions in n variables. if the jacobian has\na banded form, then function evaluations are saved by only\napproximating the nonzero terms. Read more… Arguments Type Intent Optional Attributes Name procedure( fcn_hybrd ) :: fcn integer :: n real(kind=wp) :: x (n) real(kind=wp) :: fvec (n) real(kind=wp) :: fjac (ldfjac,n) integer :: ldfjac integer :: iflag integer :: ml integer :: mu real(kind=wp) :: epsfcn real(kind=wp) :: wa1 (n) real(kind=wp) :: wa2 (n) public  subroutine hybrd (fcn, n, x, fvec, xtol, maxfev, ml, mu, epsfcn, diag, mode, factor, nprint, info, nfev, fjac, ldfjac, r, lr, qtf, wa1, wa2, wa3, wa4) The purpose of hybrd is to find a zero of a system of\n  n nonlinear functions in n variables by a modification\n  of the powell hybrid method. the user must provide a\n  subroutine which calculates the functions. the jacobian is\n  then calculated by a forward-difference approximation. Read more… Arguments Type Intent Optional Attributes Name procedure( fcn_hybrd ) :: fcn user-supplied subroutine which calculates the functions integer, intent(in) :: n a positive integer input variable set to the number\nof functions and variables. real(kind=wp), intent(inout) :: x (n) array of length n. on input x must contain\nan initial estimate of the solution vector. on output x contains the final estimate of the solution vector. real(kind=wp), intent(out) :: fvec (n) an output array of length n which contains\nthe functions evaluated at the output x . real(kind=wp), intent(in) :: xtol a nonnegative input variable. termination\noccurs when the relative error between two consecutive\niterates is at most xtol . integer, intent(in) :: maxfev a positive integer input variable. termination\noccurs when the number of calls to fcn is at least maxfev by the end of an iteration. integer, intent(in) :: ml a nonnegative integer input variable which specifies\nthe number of subdiagonals within the band of the\njacobian matrix. if the jacobian is not banded, set ml to at least n - 1 . integer, intent(in) :: mu a nonnegative integer input variable which specifies\nthe number of superdiagonals within the band of the\njacobian matrix. if the jacobian is not banded, set mu to at least n - 1 . real(kind=wp), intent(in) :: epsfcn an input variable used in determining a suitable\nstep length for the forward-difference approximation. this\napproximation assumes that the relative errors in the\nfunctions are of the order of epsfcn . if epsfcn is less\nthan the machine precision, it is assumed that the relative\nerrors in the functions are of the order of the machine\nprecision. real(kind=wp), intent(inout) :: diag (n) an array of length n . if mode = 1 (see\nbelow), diag is internally set. if mode = 2 , diag must contain positive entries that serve as\nmultiplicative scale factors for the variables. integer, intent(in) :: mode if mode = 1 , the\nvariables will be scaled internally. if mode = 2 ,\nthe scaling is specified by the input diag . other\nvalues of mode are equivalent to mode = 1 . real(kind=wp), intent(in) :: factor a positive input variable used in determining the\ninitial step bound. this bound is set to the product of factor and the euclidean norm of diag*x if nonzero, or else\nto factor itself. in most cases factor should lie in the\ninterval (.1,100.). 100. is a generally recommended value. integer, intent(in) :: nprint an integer input variable that enables controlled\nprinting of iterates if it is positive. in this case, fcn is called with iflag = 0 at the beginning of the first\niteration and every nprint iterations thereafter and\nimmediately prior to return, with x and fvec available\nfor printing. if nprint is not positive, no special calls\nof fcn with iflag = 0 are made. integer, intent(out) :: info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag . see description of fcn . otherwise, info is set as follows:\n * info = 0 improper input parameters.\n * info = 1 relative error between two consecutive iterates\n   is at most xtol .\n * info = 2 number of calls to fcn has reached or exceeded maxfev .\n * info = 3 xtol is too small. no further improvement in\n   the approximate solution x is possible.\n * info = 4 iteration is not making good progress, as\n   measured by the improvement from the last\n   five jacobian evaluations.\n * info = 5 iteration is not making good progress, as\n   measured by the improvement from the last\n   ten iterations. integer, intent(out) :: nfev output variable set to the number of calls to fcn . real(kind=wp), intent(out) :: fjac (ldfjac,n) array which contains the\northogonal matrix q produced by the QR factorization\nof the final approximate jacobian. integer, intent(in) :: ldfjac a positive integer input variable not less than n which specifies the leading dimension of the array fjac . real(kind=wp), intent(out) :: r (lr) an output array which contains the\nupper triangular matrix produced by the QR factorization\nof the final approximate jacobian, stored rowwise. integer, intent(in) :: lr a positive integer input variable not less than (n*(n+1))/2 . real(kind=wp), intent(out) :: qtf (n) an output array of length n which contains\nthe vector (q transpose)*fvec . real(kind=wp), intent(inout) :: wa1 (n) work array real(kind=wp), intent(inout) :: wa2 (n) work array real(kind=wp), intent(inout) :: wa3 (n) work array real(kind=wp), intent(inout) :: wa4 (n) work array public  subroutine hybrd1 (fcn, n, x, fvec, tol, info) the purpose of hybrd1 is to find a zero of a system of n nonlinear functions in n variables by a modification\nof the powell hybrid method. this is done by using the\nmore general nonlinear equation solver hybrd . the user\nmust provide a subroutine which calculates the functions.\nthe jacobian is then calculated by a forward-difference\napproximation. Arguments Type Intent Optional Attributes Name procedure( fcn_hybrd ) :: fcn user-supplied subroutine which calculates the functions integer, intent(in) :: n a positive integer input variable set to the number\nof functions and variables. real(kind=wp), intent(inout), dimension(n) :: x an array of length n . on input x must contain\nan initial estimate of the solution vector. on output x contains the final estimate of the solution vector. real(kind=wp), intent(out), dimension(n) :: fvec an output array of length n which contains\nthe functions evaluated at the output x . real(kind=wp), intent(in) :: tol a nonnegative input variable. termination occurs\nwhen the algorithm estimates that the relative error\nbetween x and the solution is at most tol . integer, intent(out) :: info an integer output variable. if the user has\nterminated execution, info is set to the (negative)\nvalue of iflag . see description of fcn . otherwise, info is set as follows: info = 0 improper input parameters. info = 1 algorithm estimates that the relative error\n between x and the solution is at most tol . info = 2 number of calls to fcn has reached or exceeded 200*(n+1) . info = 3 tol is too small. no further improvement in\n the approximate solution x is possible. info = 4 iteration is not making good progress. public  subroutine hybrj (fcn, n, x, fvec, fjac, ldfjac, xtol, maxfev, diag, mode, factor, nprint, info, nfev, njev, r, lr, qtf, wa1, wa2, wa3, wa4) the purpose of hybrj is to find a zero of a system of\n  n nonlinear functions in n variables by a modification\n  of the powell hybrid method. the user must provide a\n  subroutine which calculates the functions and the jacobian. Read more… Arguments Type Intent Optional Attributes Name procedure( fcn_hybrj ) :: fcn integer :: n real(kind=wp) :: x (n) real(kind=wp) :: fvec (n) real(kind=wp) :: fjac (ldfjac,n) integer :: ldfjac real(kind=wp) :: xtol integer :: maxfev real(kind=wp) :: diag (n) integer :: mode real(kind=wp) :: factor integer :: nprint integer :: info integer :: nfev integer :: njev real(kind=wp) :: r (lr) integer :: lr real(kind=wp) :: qtf (n) real(kind=wp) :: wa1 (n) real(kind=wp) :: wa2 (n) real(kind=wp) :: wa3 (n) real(kind=wp) :: wa4 (n) public  subroutine hybrj1 (fcn, n, x, fvec, fjac, ldfjac, tol, info, wa, lwa) the purpose of hybrj1 is to find a zero of a system of\nn nonlinear functions in n variables by a modification\nof the powell hybrid method. this is done by using the\nmore general nonlinear equation solver hybrj. the user\nmust provide a subroutine which calculates the functions\nand the jacobian. Read more… Arguments Type Intent Optional Attributes Name procedure( fcn_hybrj ) :: fcn integer :: n real(kind=wp) :: x (n) real(kind=wp) :: fvec (n) real(kind=wp) :: fjac (ldfjac,n) integer :: ldfjac real(kind=wp) :: tol integer :: info real(kind=wp) :: wa (lwa) integer :: lwa public  subroutine qform (m, n, q, ldq, wa) this subroutine proceeds from the computed qr factorization of\nan m by n matrix a to accumulate the m by m orthogonal matrix\nq from its factored form. Read more… Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=wp) :: q (ldq,m) integer :: ldq real(kind=wp) :: wa (m) public  subroutine qrfac (m, n, a, lda, pivot, ipvt, lipvt, rdiag, acnorm, wa) this subroutine uses householder transformations with column\npivoting (optional) to compute a qr factorization of the\nm by n matrix a. that is, qrfac determines an orthogonal\nmatrix q, a permutation matrix p, and an upper trapezoidal\nmatrix r with diagonal elements of nonincreasing magnitude,\nsuch that a p = q r. the householder transformation for\ncolumn k, k = 1,2,...,min(m,n), is of the form Read more… Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=wp) :: a (lda,n) integer :: lda logical :: pivot integer :: ipvt (lipvt) integer :: lipvt real(kind=wp) :: rdiag (n) real(kind=wp) :: acnorm (n) real(kind=wp) :: wa (n) public  subroutine r1mpyq (m, n, a, lda, v, w) given an m by n matrix a, this subroutine computes a q where\nq is the product of 2 (n - 1) transformations Read more… Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=wp) :: a (lda,n) integer :: lda real(kind=wp) :: v (n) real(kind=wp) :: w (n) public  subroutine r1updt (m, n, s, ls, u, v, w, sing) given an m by n lower trapezoidal matrix s, an m-vector u,\nand an n-vector v, the problem is to determine an\northogonal matrix q such that Read more… Arguments Type Intent Optional Attributes Name integer :: m integer :: n real(kind=wp) :: s (ls) integer :: ls real(kind=wp) :: u (m) real(kind=wp) :: v (n) real(kind=wp) :: w (m) logical :: sing","tags":"","url":"module/minpack_module.html"},{"title":"lambert_module – fortran-astrodynamics-toolkit","text":"This module contains the Izzo and Gooding algorithms for solving Lambert's problem. Uses numbers_module kind_module vector_module module~~lambert_module~~UsesGraph module~lambert_module lambert_module module~kind_module kind_module module~lambert_module->module~kind_module module~numbers_module numbers_module module~lambert_module->module~numbers_module module~vector_module vector_module module~lambert_module->module~vector_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module module~vector_module->module~kind_module module~vector_module->module~numbers_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lambert_module~~UsedByGraph module~lambert_module lambert_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~lambert_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=wp), private, parameter :: log2 = log(two) real(kind=wp), private, parameter :: two_third = two/three real(kind=wp), private, parameter :: four_third = four/three real(kind=wp), private, parameter :: five_half = five/two real(kind=wp), private, parameter :: three_half = three/two Abstract Interfaces abstract interface private  function func(t) result(f) interface to the zeroin input function Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t Independant variable for the function. Return Value real(kind=wp) The function evaluated at t . Subroutines public  subroutine solve_lambert_izzo (r1, r2, tof, mu, long_way, multi_revs, v1, v2, status_ok) Solve Lambert's problem using Izzo's method. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r1 first cartesian position [km] real(kind=wp), intent(in), dimension(3) :: r2 second cartesian position [km] real(kind=wp), intent(in) :: tof time of flight [sec] real(kind=wp), intent(in) :: mu gravity parameter [km&#94;3/s&#94;2] logical, intent(in) :: long_way when true, do \"long way\" (>pi) transfers integer, intent(in) :: multi_revs maximum number of multi-rev solutions to compute real(kind=wp), intent(out), dimension(:,:), allocatable :: v1 vector containing 3d arrays with the cartesian components of the velocities at r1 real(kind=wp), intent(out), dimension(:,:), allocatable :: v2 vector containing 3d arrays with the cartesian components of the velocities at r2 logical, intent(out) :: status_ok true if everything is OK public  subroutine solve_lambert_gooding (r1, r2, tof, mu, long_way, multi_revs, v1, v2, status_ok) Solve Lambert's problem using Gooding's method. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r1 first cartesian position [km] real(kind=wp), intent(in), dimension(3) :: r2 second cartesian position [km] real(kind=wp), intent(in) :: tof time of flight [sec] real(kind=wp), intent(in) :: mu gravity parameter [km&#94;3/s&#94;2] logical, intent(in) :: long_way when true, do \"long way\" (>pi) transfers integer, intent(in) :: multi_revs maximum number of multi-rev solutions to compute real(kind=wp), intent(out), dimension(:,:), allocatable :: v1 vector containing 3d arrays with the cartesian components of the velocities at r1 real(kind=wp), intent(out), dimension(:,:), allocatable :: v2 vector containing 3d arrays with the cartesian components of the velocities at r2 logical, intent(out) :: status_ok true if everything is OK public  subroutine solve_lambert_arorarussell (r1, r2, tofin, mu, lu, nrev, long_way, shortperiod, tolerance, max_iterations, v1, v2) Solve Lambert's problem using the Arora/Russell method. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r1 real(kind=wp), intent(in), dimension(3) :: r2 real(kind=wp), intent(in) :: tofin real(kind=wp), intent(in) :: mu real(kind=wp), intent(in) :: lu scale factor in km integer, intent(in) :: nrev logical, intent(in) :: long_way logical, intent(in) :: shortperiod real(kind=wp), intent(in) :: tolerance integer, intent(in) :: max_iterations real(kind=wp), intent(out), dimension(3) :: v1 real(kind=wp), intent(out), dimension(3) :: v2 public  subroutine lambert_test () Author Jacob Williams Compare the Lambert routines. Arguments None","tags":"","url":"module/lambert_module.html"},{"title":"drag_module – fortran-astrodynamics-toolkit","text":"Drag model Uses kind_module module~~drag_module~~UsesGraph module~drag_module drag_module module~kind_module kind_module module~drag_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~drag_module~~UsedByGraph module~drag_module drag_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~drag_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public pure subroutine drag_acceleration (vrel, cd, area, m, rho, acc) Acceleration due to atmospheric drag. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: vrel velocity relative to the atmosphere [km/s] real(kind=wp), intent(in) :: cd spacecraft drag coefficient [--] real(kind=wp), intent(in) :: area cross-section area [km&#94;2] real(kind=wp), intent(in) :: m spacecraft mass [kg] real(kind=wp), intent(in) :: rho atmospheric density [kg/km&#94;3] real(kind=wp), intent(out), dimension(3) :: acc drag acceleration vector [km/s&#94;2]","tags":"","url":"module/drag_module.html"},{"title":"halo_orbit_module – fortran-astrodynamics-toolkit","text":"Halo orbit routines. References D.L. Richardson, \"Analytic Construction of Periodic\n    Orbits About the Collinear Points\", Celestial Mechanics 22 (1980) Uses numbers_module kind_module crtbp_module iso_fortran_env module~~halo_orbit_module~~UsesGraph module~halo_orbit_module halo_orbit_module iso_fortran_env iso_fortran_env module~halo_orbit_module->iso_fortran_env module~crtbp_module crtbp_module module~halo_orbit_module->module~crtbp_module module~kind_module kind_module module~halo_orbit_module->module~kind_module module~numbers_module numbers_module module~halo_orbit_module->module~numbers_module module~crtbp_module->module~kind_module module~crtbp_module->module~numbers_module module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~halo_orbit_module~~UsedByGraph module~halo_orbit_module halo_orbit_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~halo_orbit_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine halo_to_rv_diffcorr (libpoint, mu1, mu2, dist, A_z, n, t1, rv, info, period) Compute the state vector for a halo orbit.\nThis uses the approximation, which is retargeted in the\nreal CR3BP system to produce a periodic orbit. Arguments Type Intent Optional Attributes Name integer, intent(in) :: libpoint Libration point number: [1,2,3] real(kind=wp), intent(in) :: mu1 grav param for primary body [km3/s2] real(kind=wp), intent(in) :: mu2 grav param for secondary body [km3/s2] real(kind=wp), intent(in) :: dist distance between bodies [km] real(kind=wp), intent(in) :: A_z halo z amplitude [km] integer, intent(in) :: n halo family: 1, 3 real(kind=wp), intent(in) :: t1 tau1 [rad] real(kind=wp), intent(out), dimension(6) :: rv cr3bp normalized state vector\n[wrt barycenter] integer, intent(out) :: info status code (1=no errors) real(kind=wp), intent(out), optional :: period period of halo (normalized time units) public  subroutine halo_to_rv (libpoint, mu1, mu2, dist, A_z, n, t1, rv, period) Compute the state vector from the halo orbit approximation.\nThis will be an approximation of a halo orbit in the CR3BP system,\nand will need to be corrected to produce a real halo orbit. Arguments Type Intent Optional Attributes Name integer, intent(in) :: libpoint Libration point number: [1,2,3] real(kind=wp), intent(in) :: mu1 grav param for primary body [km3/s2] real(kind=wp), intent(in) :: mu2 grav param for secondary body [km3/s2] real(kind=wp), intent(in) :: dist distance between bodies [km] real(kind=wp), intent(in) :: A_z halo z amplitude [km] integer, intent(in) :: n halo family: 1, 3 real(kind=wp), intent(in) :: t1 tau1 [rad] real(kind=wp), intent(out), dimension(6) :: rv cr3bp normalized state vector\n[wrt barycenter] real(kind=wp), intent(out), optional :: period normalized halo orbit period public  subroutine compute_halo_monodromy_matrix (mu, rv, period, phi) Compute the halo orbit monodromy matrix\n(which is the state transition matrix propagated for one period)\nThe input should be the result from the halo_to_rv_diffcorr routine. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu CRTBP parameter real(kind=wp), intent(in), dimension(6) :: rv halo orbit state vector\n(normalized) real(kind=wp), intent(in) :: period halo orbit period\n(normalized) real(kind=wp), intent(out), dimension(6,6) :: phi monodromy matrix public  subroutine compute_monodromy_matrix_eigenvalues (phi, lambda) Compute the eigenvalues of the monodromy matrix. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6,6) :: phi monodromy matrix complex(kind=wp), intent(out), dimension(6) :: lambda eigenvalues of phi public  subroutine halo_orbit_test () Unit test for the halo orbit module. Arguments None","tags":"","url":"module/halo_orbit_module.html"},{"title":"string_module – fortran-astrodynamics-toolkit","text":"Module for string manipulation. Used by module~~string_module~~UsedByGraph module~string_module string_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~string_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial character(len=*), private, parameter :: lower = 'abcdefghijklmnopqrstuvwxyz' lowercase characters character(len=*), private, parameter :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' uppercase characters Functions public pure function replace_char (str, s1, s2) result(newstr) Replace all occurrences of a single character s1 in str with s2 . Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str original string character(len=1), intent(in) :: s1 find all occurrences of this character character(len=1), intent(in) :: s2 replace with this character Return Value character(len=:), allocatable new string public pure function lchop (str, chars) result(newstr) Chop leading chars string from str .\nNote that trailing spaces are not ignored in either string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str original string character(len=*), intent(in) :: chars characters to strip Return Value character(len=:), allocatable new string public pure function rchop (str, chars) result(newstr) Chop trailing chars string from str .\nNote that trailing spaces are not ignored in either string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str original string character(len=*), intent(in) :: chars characters to strip Return Value character(len=:), allocatable new string public pure function reverse (str) result(newstr) Reverse a string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str original string Return Value character(len=:), allocatable new string public pure function strip (str, chars) result(newstr) Strip all occurances of chars from the beginning and end of the string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str original string character(len=*), intent(in), optional :: chars characters to strip Return Value character(len=:), allocatable new string Subroutines public pure subroutine uppercase (str) Convert the string to uppercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str public pure subroutine lowercase (str) Convert the string to lowercase. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: str","tags":"","url":"module/string_module.html"},{"title":"iau_orientation_module – fortran-astrodynamics-toolkit","text":"IAU orientation models for the Earth and planets. See also NAIF SPICE pck.html documentation \"Report of the IAU Working Group on Cartographic Coordinates\n     and Rotational Elements: 2009\", Celestial Mechanics and\n     Dynamical Astronomy, February 2011, Vol 109, Issue 2, p 101-135. Uses numbers_module kind_module conversion_module module~~iau_orientation_module~~UsesGraph module~iau_orientation_module iau_orientation_module module~conversion_module conversion_module module~iau_orientation_module->module~conversion_module module~kind_module kind_module module~iau_orientation_module->module~kind_module module~numbers_module numbers_module module~iau_orientation_module->module~numbers_module module~conversion_module->module~kind_module module~conversion_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~iau_orientation_module~~UsedByGraph module~iau_orientation_module iau_orientation_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~iau_orientation_module module~transformation_module transformation_module module~fortran_astrodynamics_toolkit->module~transformation_module module~lighting_module lighting_module module~fortran_astrodynamics_toolkit->module~lighting_module module~transformation_module->module~iau_orientation_module module~lighting_module->module~transformation_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public pure function iau_rotation_matrix (w, dec, ra) result(rotmat) Author Jacob Williams Date 2/3/2015 Returns the rotation matrix for a coordinate transformation from\nthe International Celestial Reference Frame (ICRF) frame to the\nIAU rotating frame associated with a body.\nThe IAU orientation models use three Euler angles to describe\nthe pole and prime meridian location (ra, dec, and w). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: w right ascension of the pole [rad] real(kind=wp), intent(in) :: dec declination of the pole [rad] real(kind=wp), intent(in) :: ra prime meridian location [rad] Return Value real(kind=wp), dimension(3,3) the rotation matrix public pure function icrf_to_iau_earth (et) result(rotmat) Author Jacob Williams Date 2/3/2015 Rotation matrix from ICRF to IAU_EARTH. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: et ephemeris time [sec] Return Value real(kind=wp), dimension(3,3) the rotation matrix public pure function icrf_to_iau_moon (et) result(rotmat) Author Jacob Williams Date 3/5/2016 Rotation matrix from ICRF to IAU_MOON. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: et ephemeris time [sec] Return Value real(kind=wp), dimension(3,3) the rotation matrix Subroutines public  subroutine iau_test () Author Jacob Williams Date 2/3/2015 Unit test routine for iau_module. Arguments None","tags":"","url":"module/iau_orientation_module.html"},{"title":"analytical_ephemeris_module – fortran-astrodynamics-toolkit","text":"Analytical ephemeris routines for solar system bodies. Uses conversion_module numbers_module kind_module module~~analytical_ephemeris_module~~UsesGraph module~analytical_ephemeris_module analytical_ephemeris_module module~conversion_module conversion_module module~analytical_ephemeris_module->module~conversion_module module~kind_module kind_module module~analytical_ephemeris_module->module~kind_module module~numbers_module numbers_module module~analytical_ephemeris_module->module~numbers_module module~conversion_module->module~kind_module module~conversion_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~analytical_ephemeris_module~~UsedByGraph module~analytical_ephemeris_module analytical_ephemeris_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~analytical_ephemeris_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines public  subroutine simpson_lunar_ephemeris (jd, r_moon, v_moon) A simple analytical lunar ephemeris model.\n  Returns Lunar cartesian coordinates\n  (mean equator and equinox of epoch J2000). Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: jd Julian date real(kind=wp), intent(out), dimension(3) :: r_moon Moon position (km) real(kind=wp), intent(out), optional, dimension(3) :: v_moon Moon velocity (km/s)","tags":"","url":"module/analytical_ephemeris_module.html"},{"title":"numbers_module – fortran-astrodynamics-toolkit","text":"Defines some numeric parameters. Uses kind_module module~~numbers_module~~UsesGraph module~numbers_module numbers_module module~kind_module kind_module module~numbers_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~numbers_module~~UsedByGraph module~numbers_module numbers_module module~analytical_ephemeris_module analytical_ephemeris_module module~analytical_ephemeris_module->module~numbers_module module~conversion_module conversion_module module~analytical_ephemeris_module->module~conversion_module module~bplane_module bplane_module module~bplane_module->module~numbers_module module~vector_module vector_module module~bplane_module->module~vector_module module~brent_module brent_module module~brent_module->module~numbers_module module~celestial_body_module celestial_body_module module~celestial_body_module->module~numbers_module module~conversion_module->module~numbers_module module~crtbp_module crtbp_module module~crtbp_module->module~numbers_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~numbers_module module~fortran_astrodynamics_toolkit->module~analytical_ephemeris_module module~fortran_astrodynamics_toolkit->module~bplane_module module~fortran_astrodynamics_toolkit->module~brent_module module~fortran_astrodynamics_toolkit->module~celestial_body_module module~fortran_astrodynamics_toolkit->module~conversion_module module~fortran_astrodynamics_toolkit->module~crtbp_module module~geodesy_module geodesy_module module~fortran_astrodynamics_toolkit->module~geodesy_module module~geopotential_module geopotential_module module~fortran_astrodynamics_toolkit->module~geopotential_module module~gooding_module gooding_module module~fortran_astrodynamics_toolkit->module~gooding_module module~gravity_module gravity_module module~fortran_astrodynamics_toolkit->module~gravity_module module~halo_orbit_module halo_orbit_module module~fortran_astrodynamics_toolkit->module~halo_orbit_module module~iau_orientation_module iau_orientation_module module~fortran_astrodynamics_toolkit->module~iau_orientation_module module~kepler_module kepler_module module~fortran_astrodynamics_toolkit->module~kepler_module module~lambert_module lambert_module module~fortran_astrodynamics_toolkit->module~lambert_module module~lighting_module lighting_module module~fortran_astrodynamics_toolkit->module~lighting_module module~math_module math_module module~fortran_astrodynamics_toolkit->module~math_module module~matrix_module matrix_module module~fortran_astrodynamics_toolkit->module~matrix_module module~minpack_module minpack_module module~fortran_astrodynamics_toolkit->module~minpack_module module~modified_equinoctial_module modified_equinoctial_module module~fortran_astrodynamics_toolkit->module~modified_equinoctial_module module~orbital_mechanics_module orbital_mechanics_module module~fortran_astrodynamics_toolkit->module~orbital_mechanics_module module~relative_motion_module relative_motion_module module~fortran_astrodynamics_toolkit->module~relative_motion_module module~rk_module rk_module module~fortran_astrodynamics_toolkit->module~rk_module module~rk_module_variable_step rk_module_variable_step module~fortran_astrodynamics_toolkit->module~rk_module_variable_step module~standish_module standish_module module~fortran_astrodynamics_toolkit->module~standish_module module~transformation_module transformation_module module~fortran_astrodynamics_toolkit->module~transformation_module module~fortran_astrodynamics_toolkit->module~vector_module module~c_interface_module c_interface_module module~fortran_astrodynamics_toolkit->module~c_interface_module module~ephemeris_module ephemeris_module module~fortran_astrodynamics_toolkit->module~ephemeris_module module~geometry_module geometry_module module~fortran_astrodynamics_toolkit->module~geometry_module module~obliquity_module obliquity_module module~fortran_astrodynamics_toolkit->module~obliquity_module module~jpl_ephemeris_module jpl_ephemeris_module module~fortran_astrodynamics_toolkit->module~jpl_ephemeris_module module~geodesy_module->module~numbers_module module~geopotential_module->module~numbers_module module~gooding_module->module~numbers_module module~gravity_module->module~numbers_module module~halo_orbit_module->module~numbers_module module~halo_orbit_module->module~crtbp_module module~iau_orientation_module->module~numbers_module module~iau_orientation_module->module~conversion_module module~kepler_module->module~numbers_module module~lambert_module->module~numbers_module module~lambert_module->module~vector_module module~lighting_module->module~numbers_module module~lighting_module->module~celestial_body_module module~lighting_module->module~conversion_module module~lighting_module->module~math_module module~lighting_module->module~transformation_module module~lighting_module->module~vector_module module~lighting_module->module~ephemeris_module module~math_module->module~numbers_module module~matrix_module->module~numbers_module module~minpack_module->module~numbers_module module~modified_equinoctial_module->module~numbers_module module~modified_equinoctial_module->module~vector_module module~newton_module newton_module module~newton_module->module~numbers_module module~orbital_mechanics_module->module~numbers_module module~orbital_mechanics_module->module~math_module module~orbital_mechanics_module->module~vector_module module~relative_motion_module->module~numbers_module module~rk_module->module~numbers_module module~rk_module_variable_step->module~numbers_module module~standish_module->module~numbers_module module~standish_module->module~celestial_body_module module~standish_module->module~conversion_module module~standish_module->module~ephemeris_module module~transformation_module->module~numbers_module module~transformation_module->module~celestial_body_module module~transformation_module->module~iau_orientation_module module~transformation_module->module~vector_module module~transformation_module->module~ephemeris_module module~vector_module->module~numbers_module proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors proc~compute_eigenvalues_and_eigenvectors->module~numbers_module proc~compute_real_eigenvalues_and_normalized_eigenvectors compute_real_eigenvalues_and_normalized_eigenvectors proc~compute_real_eigenvalues_and_normalized_eigenvectors->module~numbers_module proc~cube_root cube_root proc~cube_root->module~numbers_module proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~get_r_from_jpl_ephemeris->module~numbers_module proc~get_r_from_jpl_ephemeris->module~celestial_body_module proc~get_r_from_jpl_ephemeris->module~conversion_module proc~get_r_from_spice_ephemeris spice_ephemeris%get_r_from_spice_ephemeris proc~get_r_from_spice_ephemeris->module~numbers_module proc~get_r_from_spice_ephemeris->module~celestial_body_module proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~get_rv_from_jpl_ephemeris->module~numbers_module proc~get_rv_from_jpl_ephemeris->module~celestial_body_module proc~get_rv_from_jpl_ephemeris->module~conversion_module proc~get_rv_from_spice_ephemeris spice_ephemeris%get_rv_from_spice_ephemeris proc~get_rv_from_spice_ephemeris->module~numbers_module proc~get_rv_from_spice_ephemeris->module~celestial_body_module module~c_interface_module->module~geopotential_module module~ephemeris_module->module~celestial_body_module module~geometry_module->module~vector_module module~obliquity_module->module~conversion_module proc~calendar_date_to_et calendar_date_to_et proc~calendar_date_to_et->module~conversion_module proc~compute_halo_monodromy_matrix compute_halo_monodromy_matrix proc~compute_halo_monodromy_matrix->module~rk_module proc~compute_libration_points compute_libration_points proc~compute_libration_points->module~math_module proc~compute_libration_points_v2 compute_libration_points_v2 proc~compute_libration_points_v2->module~math_module proc~compute_monodromy_matrix_eigenvalues compute_monodromy_matrix_eigenvalues proc~compute_monodromy_matrix_eigenvalues->module~matrix_module proc~crtbp_test crtbp_test proc~crtbp_test->module~celestial_body_module proc~ephemeris_test ephemeris_test proc~ephemeris_test->module~celestial_body_module proc~et_to_jd et_to_jd proc~et_to_jd->module~conversion_module proc~from_ijk_to_lvlh_mat from_ijk_to_lvlh_mat proc~from_ijk_to_lvlh_mat->module~vector_module proc~from_ijk_to_rsw_mat from_ijk_to_rsw_mat proc~from_ijk_to_rsw_mat->module~vector_module proc~from_ijk_to_vuw_mat from_ijk_to_vuw_mat proc~from_ijk_to_vuw_mat->module~vector_module proc~from_lvlh_to_ijk_mat from_lvlh_to_ijk_mat proc~from_lvlh_to_ijk_mat->module~vector_module proc~from_rsw_to_ijk_mat from_rsw_to_ijk_mat proc~from_rsw_to_ijk_mat->module~vector_module proc~from_vuw_to_ijk_mat from_vuw_to_ijk_mat proc~from_vuw_to_ijk_mat->module~vector_module proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->module~conversion_module proc~geopotential_module_test->module~vector_module proc~halo_orbit_test halo_orbit_test proc~halo_orbit_test->module~celestial_body_module proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->module~math_module proc~halo_to_rv_diffcorr->module~minpack_module proc~halo_to_rv_diffcorr->module~rk_module proc~iau_rotation_matrix iau_rotation_matrix proc~iau_rotation_matrix->module~vector_module proc~integrate_to_event rk_class%integrate_to_event proc~integrate_to_event->module~brent_module proc~integrate_to_event~2 rk_variable_step_class%integrate_to_event proc~integrate_to_event~2->module~brent_module proc~jd_to_et jd_to_et proc~jd_to_et->module~conversion_module proc~kepler_classical kepler_classical proc~kepler_classical->module~newton_module proc~lambert_test lambert_test proc~lambert_test->module~gooding_module proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->module~conversion_module proc~rk_test_variable_step->module~orbital_mechanics_module module~jpl_ephemeris_module->module~ephemeris_module module~spice_ephemeris_module spice_ephemeris_module module~spice_ephemeris_module->module~ephemeris_module proc~get_c_cdot_ecliptic ecliptic_frame%get_c_cdot_ecliptic proc~get_c_cdot_ecliptic->module~obliquity_module proc~transformation_module_test transformation_module_test proc~transformation_module_test->module~jpl_ephemeris_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: zero = 0.0_wp real(kind=wp), public, parameter :: one = 1.0_wp real(kind=wp), public, parameter :: two = 2.0_wp real(kind=wp), public, parameter :: three = 3.0_wp real(kind=wp), public, parameter :: four = 4.0_wp real(kind=wp), public, parameter :: five = 5.0_wp real(kind=wp), public, parameter :: six = 6.0_wp real(kind=wp), public, parameter :: seven = 7.0_wp real(kind=wp), public, parameter :: eight = 8.0_wp real(kind=wp), public, parameter :: nine = 9.0_wp real(kind=wp), public, parameter :: ten = 10.0_wp real(kind=wp), public, parameter :: pi = acos(-one) real(kind=wp), public, parameter :: twopi = two*pi real(kind=wp), public, parameter :: fourpi = four*pi real(kind=wp), public, parameter :: halfpi = 0.5_wp*pi real(kind=wp), public, parameter :: universal_grav_constant = 6.67408e-20_wp CODATA-recommended universal gravitational\nconstant real(kind=wp), public, parameter :: c_light = 299792.458_wp speed of light in km/s real(kind=wp), public, parameter :: solar_luminosity = 3.828+26_wp nominal solar luminosity (W)\nsee: \"Resolution B3 on recommended nominal conversion constants for selected solar and planetary properties\". IAU. 2015 real(kind=wp), public, parameter,               dimension(3,3) :: identity_3x3 = reshape([[one, zero, zero], [zero, one, zero], [zero, zero, one]], [3, 3]) 3x3 identity matrix: real(kind=wp), public, parameter,               dimension(6,6) :: identity_6x6 = reshape([[one, zero, zero, zero, zero, zero], [zero, one, zero, zero, zero, zero], [zero, zero, one, zero, zero, zero], [zero, zero, zero, one, zero, zero], [zero, zero, zero, zero, one, zero], [zero, zero, zero, zero, zero, one]], [6, 6]) 6x6 identity matrix:","tags":"","url":"module/numbers_module.html"},{"title":"matrix_module – fortran-astrodynamics-toolkit","text":"Various matrix routines Uses numbers_module kind_module module~~matrix_module~~UsesGraph module~matrix_module matrix_module module~kind_module kind_module module~matrix_module->module~kind_module module~numbers_module numbers_module module~matrix_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~matrix_module~~UsedByGraph module~matrix_module matrix_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~matrix_module proc~compute_monodromy_matrix_eigenvalues compute_monodromy_matrix_eigenvalues proc~compute_monodromy_matrix_eigenvalues->module~matrix_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public pure recursive function matrix_determinant (n, a) result(det) Matrix determinant of an matrix (recursive formulation). Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n size of a matrix real(kind=wp), intent(in), dimension(n,n) :: a the matrix Return Value real(kind=wp) the determinant of a matrix public pure function matrix_cofactor (n, a) result(c) Compute the cofactors matrix (the transpose of the adjugate matrix). Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n size of a matrix real(kind=wp), intent(in), dimension(n,n) :: a the matrix Return Value real(kind=wp), dimension(n,n) the cofactors of a matrix public pure function matrix_trace (n, mat) result(trace) Compute the matrix trace (sum of the diagonal elements). Arguments Type Intent Optional Attributes Name integer, intent(in) :: n size of the matrix real(kind=wp), intent(in), dimension(n,n) :: mat the matrix Return Value real(kind=wp) the matrix trace Subroutines public  subroutine print_matrix (mat, unit) Print a matrix to the console. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:,:) :: mat the matrix to print integer, intent(in), optional :: unit unit number (assumed to be an open file).\nif not present, then the standard output is used.","tags":"","url":"module/matrix_module.html"},{"title":"spice_ephemeris_module – fortran-astrodynamics-toolkit","text":"Interface to the SPICE ephemeris library. Not a standard part of FAT. If used, it requires linking with the Fortran SPICELIB SPICE Toolkit . Uses kind_module ephemeris_module iso_fortran_env module~~spice_ephemeris_module~~UsesGraph module~spice_ephemeris_module spice_ephemeris_module iso_fortran_env iso_fortran_env module~spice_ephemeris_module->iso_fortran_env module~ephemeris_module ephemeris_module module~spice_ephemeris_module->module~ephemeris_module module~kind_module kind_module module~spice_ephemeris_module->module~kind_module module~ephemeris_module->module~kind_module module~celestial_body_module celestial_body_module module~ephemeris_module->module~celestial_body_module module~kind_module->iso_fortran_env module~celestial_body_module->module~kind_module module~base_class_module base_class_module module~celestial_body_module->module~base_class_module module~numbers_module numbers_module module~celestial_body_module->module~numbers_module module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Derived Types type, public, extends( ephemeris_class ) :: spice_ephemeris Main class for accessing the SPICE ephemeris system. Read more… Components Type Visibility Attributes Name Initial character(len=:), public, dimension(:), allocatable :: kernels the list of kernels Type-Bound Procedures procedure, public :: get_rv => get_rv_from_spice_ephemeris procedure, public :: get_r => get_r_from_spice_ephemeris procedure, public :: initialize => initialize_spice_ephemeris procedure, public :: close => close_spice_ephemeris Subroutines private  subroutine close_spice_ephemeris (me) Close the SPICE ephemeris and unload all the kernels. Arguments Type Intent Optional Attributes Name class( spice_ephemeris ), intent(inout) :: me private  subroutine initialize_spice_ephemeris (me, kernels) Initialize a SPICE ephemeris by loading the specified kernels. Arguments Type Intent Optional Attributes Name class( spice_ephemeris ), intent(inout) :: me character(len=*), intent(in), dimension(:) :: kernels list of kernels to load private  subroutine get_rv_from_spice_ephemeris (me, et, targ, obs, rv, status_ok) Interface for the ephemeris_module . Read more… Arguments Type Intent Optional Attributes Name class( spice_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(6) :: rv state of targ w.r.t. obs [km,km/s] in ICRF frame logical, intent(out) :: status_ok true if there were no problems private  subroutine get_r_from_spice_ephemeris (me, et, targ, obs, r, status_ok) Interface for the ephemeris_module . Read more… Arguments Type Intent Optional Attributes Name class( spice_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(3) :: r position of targ w.r.t. obs [km] in ICRF frame logical, intent(out) :: status_ok true if there were no problems","tags":"","url":"module/spice_ephemeris_module.html"},{"title":"orbital_mechanics_module – fortran-astrodynamics-toolkit","text":"Basic orbital mechanics routines. Uses numbers_module kind_module vector_module math_module module~~orbital_mechanics_module~~UsesGraph module~orbital_mechanics_module orbital_mechanics_module module~kind_module kind_module module~orbital_mechanics_module->module~kind_module module~math_module math_module module~orbital_mechanics_module->module~math_module module~numbers_module numbers_module module~orbital_mechanics_module->module~numbers_module module~vector_module vector_module module~orbital_mechanics_module->module~vector_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~math_module->module~kind_module module~math_module->module~numbers_module module~numbers_module->module~kind_module module~vector_module->module~kind_module module~vector_module->module~numbers_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~orbital_mechanics_module~~UsedByGraph module~orbital_mechanics_module orbital_mechanics_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~orbital_mechanics_module proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->module~orbital_mechanics_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public pure function orbit_period (mu, a) result(period) Compute the two-body orbital period. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [ ] real(kind=wp), intent(in) :: a semimajor axis [km] Return Value real(kind=wp) two-body orbital period [s] public pure function orbit_energy (mu, rv) result(energy) Compute the two-body orbital energy. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [ ] real(kind=wp), intent(in), dimension(6) :: rv position and velocity vector [km,km/s] Return Value real(kind=wp) two-body orbital energy [ ] public pure function sphere_of_influence (mu_primary, mu_secondary, r_ps) result(r_soi) Computes the sphere-of-influence radius of the secondary body. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu_primary primary body gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: mu_secondary secondary body gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: r_ps distance between the two bodies [km] Return Value real(kind=wp) sphere of influence radius [km] public pure function sphere_of_influence_earth_moon (mu_primary, mu_secondary, r, r_sp) result(r_soi) Computes the sphere-of-influence radius of the secondary body. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu_primary primary body gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: mu_secondary secondary body gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r vector from the secondary body to the spacecraft [km] real(kind=wp), intent(in), dimension(3) :: r_sp vector from the secondary to the primary body [km] Return Value real(kind=wp) sphere of influence radius of the secondary body [km] Subroutines public pure subroutine rv_to_orbital_elements (mu, r, v, p, ecc, inc, raan, aop, tru) Convert position and velocity vectors to orbital elements. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [ ] real(kind=wp), intent(in), dimension(3) :: r position vector [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector [km/s] real(kind=wp), intent(out) :: p semiparameter [km] real(kind=wp), intent(out) :: ecc eccentricity [--] real(kind=wp), intent(out) :: inc inclination [rad] real(kind=wp), intent(out) :: raan raan [rad] real(kind=wp), intent(out) :: aop argument of peripsis [rad] real(kind=wp), intent(out) :: tru true anomaly [rad] public pure subroutine orbital_elements_to_rv (mu, p, ecc, inc, raan, aop, tru, r, v) Convert orbital elements to position and velocity vectors. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [ ] real(kind=wp), intent(in) :: p semiparameter [km] real(kind=wp), intent(in) :: ecc eccentricity [--] real(kind=wp), intent(in) :: inc inclination [rad] real(kind=wp), intent(in) :: raan raan [rad] real(kind=wp), intent(in) :: aop argument of peripsis [rad] real(kind=wp), intent(in) :: tru true anomaly [rad] real(kind=wp), intent(out), dimension(3) :: r position vector [km] real(kind=wp), intent(out), dimension(3) :: v velocity vector [km/s] private pure subroutine orbit_check (ecc, inc, circular, equatorial) Check the orbit for singularities. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ecc eccentricity real(kind=wp), intent(in) :: inc inclination [rad] logical, intent(out) :: circular is the orbit circular? logical, intent(out) :: equatorial is the orbit equatorial? public pure subroutine periapsis_apoapsis (mu, a, e, rp, ra, vp, va) Compute the periapsis and apoapsis position and velocity magnitudes. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [ ] real(kind=wp), intent(in) :: a semimajor axis [km] real(kind=wp), intent(in) :: e eccentricity [--] real(kind=wp), intent(out) :: rp periapsis position magnitude [km] real(kind=wp), intent(out) :: ra apoapsis position magnitude [km] real(kind=wp), intent(out) :: vp periapsis velocity magnitude [km/s] real(kind=wp), intent(out) :: va apoapsis velocity magnitude [km/s]","tags":"","url":"module/orbital_mechanics_module.html"},{"title":"geopotential_module – fortran-astrodynamics-toolkit","text":"Gravity models for computing gravitational acceleration due to geopotential. Each routine returns the acceleration in the body-fixed frame. Example type ( geopotential_model_mueller ), target :: g call g % initialize ( gravfile , n , m , status_ok ) call g % get_acc ( rvec , n , m , acc ) Uses numbers_module kind_module module~~geopotential_module~~UsesGraph module~geopotential_module geopotential_module module~kind_module kind_module module~geopotential_module->module~kind_module module~numbers_module numbers_module module~geopotential_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~geopotential_module~~UsedByGraph module~geopotential_module geopotential_module module~c_interface_module c_interface_module module~c_interface_module->module~geopotential_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~geopotential_module module~fortran_astrodynamics_toolkit->module~c_interface_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  subroutine acc_function(me, r, n, m, a) Interface to the acceleration function for the different methods Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a Derived Types type, public, abstract :: geopotential_model The base abstract class for the various geopotential models Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] Type-Bound Procedures procedure, public :: initialize => read_geopotential_file procedure, public :: destroy => destroy_geopotential_model procedure( acc_function ), public, deferred :: get_acc type, public, abstract, extends( geopotential_model ) :: geopotential_model_vector_coeff The models where the C,S coefficients are stored in vectors Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] real(kind=wp), public, dimension(:), allocatable :: c real(kind=wp), public, dimension(:), allocatable :: s Type-Bound Procedures procedure, public :: initialize => read_geopotential_file procedure, public :: destroy => destroy_geopotential_model procedure( acc_function ), public, deferred :: get_acc type, public, abstract, extends( geopotential_model ) :: geopotential_model_matrix_coeff The models where the C,S coefficients are stored in matrices Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] real(kind=wp), public, dimension(:,:), allocatable :: cnm real(kind=wp), public, dimension(:,:), allocatable :: snm Type-Bound Procedures procedure, public :: initialize => read_geopotential_file procedure, public :: destroy => destroy_geopotential_model procedure( acc_function ), public, deferred :: get_acc type, public, extends( geopotential_model_vector_coeff ) :: geopotential_model_mueller Mueller method Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] real(kind=wp), public, dimension(:), allocatable :: c real(kind=wp), public, dimension(:), allocatable :: s Type-Bound Procedures procedure, public :: initialize => read_geopotential_file procedure, public :: destroy => destroy_geopotential_model procedure, public :: get_acc => compute_gravity_acceleration_mueller type, public, extends( geopotential_model_matrix_coeff ) :: geopotential_model_lear Lear method Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] real(kind=wp), public, dimension(:,:), allocatable :: cnm real(kind=wp), public, dimension(:,:), allocatable :: snm Type-Bound Procedures procedure, public :: initialize => read_geopotential_file procedure, public :: destroy => destroy_geopotential_model procedure, public :: get_acc => compute_gravity_acceleration_lear type, public, extends( geopotential_model_matrix_coeff ) :: geopotential_model_pines Pines method Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] real(kind=wp), public, dimension(:,:), allocatable :: cnm real(kind=wp), public, dimension(:,:), allocatable :: snm Type-Bound Procedures procedure, public :: initialize => read_geopotential_file procedure, public :: destroy => destroy_geopotential_model procedure, public :: get_acc => compute_gravity_acceleration_pines type, public, extends( geopotential_model_matrix_coeff ) :: geopotential_model_normalized_pines Pines (normalized) method Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] real(kind=wp), public, dimension(:,:), allocatable :: cnm real(kind=wp), public, dimension(:,:), allocatable :: snm Type-Bound Procedures procedure, public :: initialize => read_geopotential_file procedure, public :: destroy => destroy_geopotential_model procedure, public :: get_acc => compute_gravity_acceleration_normalized_pines type, public, extends( geopotential_model_matrix_coeff ) :: geopotential_model_kuga_carrara Kuga/Carrara method Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: name model name character(len=:), public, allocatable :: filename model file name integer, public :: nmax = 0 degree of the model integer, public :: mmax = 0 order of the model real(kind=wp), public :: re = zero body radius [km] real(kind=wp), public :: mu = zero body grav. parameter [km3/s2] real(kind=wp), public, dimension(:,:), allocatable :: cnm real(kind=wp), public, dimension(:,:), allocatable :: snm Type-Bound Procedures procedure, public :: initialize => read_geopotential_file procedure, public :: destroy => destroy_geopotential_model procedure, public :: get_acc => compute_gravity_acceleration_kuga_carrara Functions private pure function number_of_coefficients (n, m) result(np) Author Jacob Williams Date 9/20/2014 Number of (c,s) coefficients for n x m geopotential model\nStarting with n=2,m=0. Arguments Type Intent Optional Attributes Name integer, intent(in) :: n degree integer, intent(in) :: m order Return Value integer number of coefficients private  function FL (n) Author Jacob Williams Date 9/20/2014 The FL factorial function from [1]. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n Return Value real(kind=wp) private pure function pinesnorm (mu, req, r_f, cnm, snm, nmax, mmax) result(accel) Normalized Pines geopotential code. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational constant [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: req body equatorial radius [km] real(kind=wp), intent(in), dimension(3) :: r_f body-fixed Cartesian position vector [km] real(kind=wp), intent(in), dimension(:,0:) :: cnm c coefficients (Normalized) real(kind=wp), intent(in), dimension(:,0:) :: snm s coefficients (Normalized) integer, intent(in) :: nmax desired degree integer, intent(in) :: mmax desired order Return Value real(kind=wp), dimension(3) body-fixed Cartesian acceleration vector [km/s&#94;2] Subroutines private  subroutine destroy_geopotential_model (me) Destroy a gravity model. Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me private  subroutine compute_gravity_acceleration_mueller (me, r, n, m, a) Wrapper for Mueller method. Arguments Type Intent Optional Attributes Name class( geopotential_model_mueller ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a private  subroutine compute_gravity_acceleration_pines (me, r, n, m, a) Wrapper for Pines method. Arguments Type Intent Optional Attributes Name class( geopotential_model_pines ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a private  subroutine compute_gravity_acceleration_lear (me, r, n, m, a) Wrapper for Lear method. Arguments Type Intent Optional Attributes Name class( geopotential_model_lear ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a private  subroutine compute_gravity_acceleration_kuga_carrara (me, r, n, m, a) Wrapper for Kuga/Carrara method. Arguments Type Intent Optional Attributes Name class( geopotential_model_kuga_carrara ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a private  subroutine compute_gravity_acceleration_normalized_pines (me, r, n, m, a) Wrapper for normalized Pines method. Arguments Type Intent Optional Attributes Name class( geopotential_model_normalized_pines ), intent(inout) :: me real(kind=wp), intent(in), dimension(3) :: r integer, intent(in) :: n integer, intent(in) :: m real(kind=wp), intent(out), dimension(3) :: a private  subroutine read_geopotential_file (me, filename, nmax, mmax, status_ok) Author Jacob Williams Date 9/20/2014 Read the gravity coefficient file.\nExample file: ftp://ftp.csr.utexas.edu/pub/grav/EGM96.GEO.Z Arguments Type Intent Optional Attributes Name class( geopotential_model ), intent(inout) :: me character(len=*), intent(in) :: filename integer, intent(in) :: nmax integer, intent(in) :: mmax logical, intent(out) :: status_ok private  subroutine get_format_statement (str, fmt) Author Jacob Williams Date 1/24/2015 Returns the format statement from a line\nin a .GEO gravity coefficient file. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str character(len=*), intent(out) :: fmt private  subroutine convert (nmodel, cnm, snm) Author Jacob Williams Date 9/20/2014 Based on the CONVERT subroutine from [1].\n  Unnormalizes the C,S coefficients. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmodel real(kind=wp), intent(inout), dimension(nmodel,0:nmodel) :: cnm real(kind=wp), intent(inout), dimension(nmodel,0:nmodel) :: snm private  subroutine gravpot (r, nmax, re, mu, c, s, fg) Author Jacob Williams Date 1/25/2014 Spencer's implementation of the Pines algorithms from [1] Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r position vector integer, intent(in) :: nmax degree/order real(kind=wp), intent(in) :: re body radius real(kind=wp), intent(in) :: mu grav constant real(kind=wp), intent(in), dimension(nmax,0:nmax) :: c C coefficients real(kind=wp), intent(in), dimension(nmax,0:nmax) :: s S coefficients real(kind=wp), intent(out), dimension(3) :: fg grav acceleration private  subroutine geopot (x, y, z, nmax, mmax, re, ksq, c, s, fx, fy, fz) Compute the gravitational acceleration vector using the Mueller method. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x position vector x-component real(kind=wp), intent(in) :: y position vector y-component real(kind=wp), intent(in) :: z position vector z-component integer, intent(in) :: nmax degree of model integer, intent(in) :: mmax order+1 of model real(kind=wp), intent(in) :: re body radius real(kind=wp), intent(in) :: ksq body GM real(kind=wp), intent(in), dimension(:) :: c C coefficients real(kind=wp), intent(in), dimension(:) :: s S coefficients real(kind=wp), intent(out) :: fx gravitational acceleration x-component real(kind=wp), intent(out) :: fy gravitational acceleration y-component real(kind=wp), intent(out) :: fz gravitational acceleration z-component private  subroutine grav (mu, rgr, rbar, nmodel, mmodel, cnm, snm, agr) Author Jacob Williams Date 9/20/2014 Based on the GRAV subroutine from [1]. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational constant real(kind=wp), intent(in), dimension(3) :: rgr position vector [body-fixed coordinates] real(kind=wp), intent(in) :: rbar gravitational scaling radius (generally the equatorial radius) integer, intent(in) :: nmodel the degree of the gravity model (>=2) integer, intent(in) :: mmodel the order of the gravity model (>=0, <=nmodel) real(kind=wp), intent(in), dimension(nmodel,0:nmodel) :: cnm C gravity coefficients real(kind=wp), intent(in), dimension(nmodel,0:nmodel) :: snm S gravity coefficients real(kind=wp), intent(out), dimension(3) :: agr gravitational acceleration vector [body-fixed coordinates] private  subroutine kuga_carrara_geopotential (nmax, nm, re, gm, c, s, x, ac) Compute geopotential acceleration using the Kuga/Carrara algorithm.\n  Based on Leg_ForCol_Ac from [1]. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: nmax max. order and degree loaded integer, intent(in) :: nm desired order and degree (nm <= nmax) real(kind=wp), intent(in) :: re body equatorial radius [km] real(kind=wp), intent(in) :: gm gravitational constant [km3/s2] real(kind=wp), intent(in), dimension(nmax,0:nm) :: c c coefficients (Normalized) real(kind=wp), intent(in), dimension(nmax,0:nm) :: s s coefficients (Normalized) real(kind=wp), intent(in), dimension(3) :: x body-fixed cartesian position vector [km] real(kind=wp), intent(out), dimension(3) :: ac body-fixed cartesian acceleration vector [km/s2] public  subroutine geopotential_module_test () Author Jacob Williams Date 9/20/2014 Unit test routine for geopotential_module Arguments None","tags":"","url":"module/geopotential_module.html"},{"title":"eispack_module – fortran-astrodynamics-toolkit","text":"Refactored SLATEC/EISPACK routines for computing eigenvalues and eigenvectors. Uses kind_module module~~eispack_module~~UsesGraph module~eispack_module eispack_module module~kind_module kind_module module~eispack_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~eispack_module~~UsedByGraph module~eispack_module eispack_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~eispack_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Subroutines private  subroutine balanc (Nm, n, a, Low, Igh, Scale) Balance a real general matrix and isolate eigenvalues\n  whenever possible. Read more… Arguments Type Intent Optional Attributes Name integer :: Nm integer :: n real(kind=wp) :: a (Nm,*) integer :: Low integer :: Igh real(kind=wp) :: Scale (*) private  subroutine balbak (Nm, n, Low, Igh, Scale, m, z) Form the eigenvectors of a real general matrix from the\n  eigenvectors of matrix output from BALANC. Read more… Arguments Type Intent Optional Attributes Name integer :: Nm integer :: n integer :: Low integer :: Igh real(kind=wp) :: Scale (*) integer :: m real(kind=wp) :: z (Nm,*) private  subroutine cdiv (Ar, Ai, Br, Bi, Cr, Ci) Compute the complex quotient of two complex numbers. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp) :: Ar real(kind=wp) :: Ai real(kind=wp) :: Br real(kind=wp) :: Bi real(kind=wp) :: Cr real(kind=wp) :: Ci private  subroutine elmhes (Nm, n, Low, Igh, a, Intv) Reduce a real general matrix to upper Hessenberg form\n  using stabilized elementary similarity transformations. Read more… Arguments Type Intent Optional Attributes Name integer :: Nm integer :: n integer :: Low integer :: Igh real(kind=wp) :: a (Nm,*) integer :: Intv (*) private  subroutine eltran (Nm, n, Low, Igh, a, Int, z) Accumulates the stabilized elementary similarity\n  transformations used in the reduction of a real general\n  matrix to upper Hessenberg form by ELMHES. Read more… Arguments Type Intent Optional Attributes Name integer :: Nm integer :: n integer :: Low integer :: Igh real(kind=wp) :: a (Nm,*) integer :: Int (*) real(kind=wp) :: z (Nm,*) private  subroutine hqr (Nm, n, Low, Igh, h, Wr, Wi, Ierr) Compute the eigenvalues of a real upper Hessenberg matrix\n  using the QR method. Read more… Arguments Type Intent Optional Attributes Name integer :: Nm integer :: n integer :: Low integer :: Igh real(kind=wp) :: h (Nm,*) real(kind=wp) :: Wr (*) real(kind=wp) :: Wi (*) integer :: Ierr private  subroutine hqr2 (Nm, n, Low, Igh, h, Wr, Wi, z, Ierr) Compute the eigenvalues and eigenvectors of a real upper\n  Hessenberg matrix using QR method. Read more… Arguments Type Intent Optional Attributes Name integer :: Nm integer :: n integer :: Low integer :: Igh real(kind=wp) :: h (Nm,*) real(kind=wp) :: Wr (*) real(kind=wp) :: Wi (*) real(kind=wp) :: z (Nm,*) integer :: Ierr private  subroutine rg (Nm, n, a, Wr, Wi, Matz, z, Iv1, Fv1, Ierr) Compute the eigenvalues and, optionally, the eigenvectors\n  of a real general matrix. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: Nm must be set to the row dimension of the two-dimensional\narray parameters, A and Z, as declared in the calling\nprogram dimension statement. integer, intent(in) :: n the order of the matrix A.\nN must be less than or equal to NM. real(kind=wp), intent(inout) :: a (Nm,*) contains the real general matrix.\ndimensioned A(NM,N).\nNote: A is destroyed on output. real(kind=wp), intent(out) :: Wr (*) real part of the eigenvalues.  The eigenvalues are unordered except\nthat complex conjugate pairs of eigenvalues appear consecutively\nwith the eigenvalue having the positive imaginary part\nfirst.  If an error exit is made, the eigenvalues should be\ncorrect for indices IERR+1, IERR+2, ..., N.  WR and WI are\none-dimensional REAL arrays, dimensioned WR(N) and WI(N). real(kind=wp), intent(out) :: Wi (*) imaginary part of the eigenvalues. integer, intent(in) :: Matz an INTEGER variable set equal to zero if only\neigenvalues are desired.  Otherwise, it is set to any\nnon-zero integer for both eigenvalues and eigenvectors. real(kind=wp), intent(out) :: z (Nm,*) contains the real and imaginary parts of the eigenvectors\nif MATZ is not zero.  If the J-th eigenvalue is real, the\nJ-th column of Z contains its eigenvector.  If the J-th\neigenvalue is complex with positive imaginary part, the\nJ-th and (J+1)-th columns of Z contain the real and\nimaginary parts of its eigenvector.  The conjugate of this\nvector is the eigenvector for the conjugate eigenvalue.\nZ is a two-dimensional REAL array, dimensioned Z(NM,N). integer, intent(inout) :: Iv1 (*) one-dimensional temporary storage arrays of dimension N. real(kind=wp), intent(inout) :: Fv1 (*) one-dimensional temporary storage arrays of dimension N. integer, intent(out) :: Ierr an INTEGER flag set to: Read more… public  subroutine compute_eigenvalues_and_eigenvectors (n, a, w, z, ierr) Compute the eigenvalues and, optionally, the eigenvectors\n  of a real general matrix. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: n the order of the matrix a real(kind=wp), intent(in), dimension(n,n) :: a contains the real general matrix real(kind=wp), intent(out), dimension(n,2) :: w real and imaginary parts of the eigenvalues real(kind=wp), intent(out), dimension(n,n) :: z real and imaginary parts of the eigenvectors integer, intent(out) :: ierr output flag from rg public  subroutine compute_real_eigenvalues_and_normalized_eigenvectors (n, a, e, v, n_results, ierr) Returns only the real eigenvalues and the associated eigenvectors.\nWrapper for compute_eigenvalues_and_eigenvectors . Arguments Type Intent Optional Attributes Name integer, intent(in) :: n the order of the matrix a real(kind=wp), intent(in), dimension(n,n) :: a contains the real general matrix real(kind=wp), intent(out), dimension(:), allocatable :: e eigenvalues (size n_results ) real(kind=wp), intent(out), dimension(:,:), allocatable :: v eigenvectors (size n,n_results ) integer, intent(out) :: n_results number of real eigenvalues integer, intent(out) :: ierr output flag from rg public  subroutine eispack_test () Unit test Arguments None","tags":"","url":"module/eispack_module.html"},{"title":"c_interface_module – fortran-astrodynamics-toolkit","text":"C interfaces to some of the routines.\nThis is an experiment to be able to call them from Python.\n(see the python_test.py file in tests ) Uses kind_module geopotential_module iso_c_binding module~~c_interface_module~~UsesGraph module~c_interface_module c_interface_module iso_c_binding iso_c_binding module~c_interface_module->iso_c_binding module~geopotential_module geopotential_module module~c_interface_module->module~geopotential_module module~kind_module kind_module module~c_interface_module->module~kind_module module~geopotential_module->module~kind_module module~numbers_module numbers_module module~geopotential_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~c_interface_module~~UsedByGraph module~c_interface_module c_interface_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~c_interface_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface private  function strlen(str) result(isize) bind(C, name='strlen') C string length Arguments Type Intent Optional Attributes Name type(c_ptr), value :: str Return Value integer(kind=c_int) Derived Types type, private :: container a container for data that is\nto be passed to C. We include\nit here so that we can use c_loc() Components Type Visibility Attributes Name Initial class(*), private, pointer :: data Functions private  function initialize_geopotential_model (itype, gravfile, n, m) result(cp) bind(c,name='initialize_geopotential_model') mueller method Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: itype mode : Read more… type(c_ptr), intent(in), value :: gravfile gravity coefficient file name integer(kind=c_int), intent(in), value :: n degree integer(kind=c_int), intent(in), value :: m order Return Value type(c_ptr) pointer to a container containing a geopotential_model Subroutines private  subroutine destroy_geopotential_model (cp) bind(c,name='destroy_geopotential_model') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: cp pointer to a container containing a geopotential_model private  subroutine get_acceleration (cp, n, m, rvec, acc) bind(c,name='get_acceleration') Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in), value :: cp pointer to a container containing a geopotential_model integer(kind=c_int), intent(in), value :: n degree integer(kind=c_int), intent(in), value :: m order real(kind=c_double), intent(in), dimension(3) :: rvec position vector real(kind=c_double), intent(out), dimension(3) :: acc acceleration vector private  subroutine c_ptr_to_f_string (cp, fstr) Convert a c_ptr to a string into a Fortran string. Arguments Type Intent Optional Attributes Name type(c_ptr), intent(in) :: cp character(len=:), intent(out), allocatable :: fstr private  subroutine f_string_to_c_ptr (fstr, buffer) Convert a Fortran string to a c_ptr to a string.\n(the C string must already have been allocated to a fixed size) Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fstr type(c_ptr), intent(inout) :: buffer a preallocated string buffer private  subroutine return_a_string (ival, buffer) bind(c,name='return_a_string') Just a test of f_string_to_c_ptr . Arguments Type Intent Optional Attributes Name integer(kind=c_int), intent(in), value :: ival type(c_ptr), intent(inout) :: buffer a preallocated string buffer","tags":"","url":"module/c_interface_module.html"},{"title":"rk_module – fortran-astrodynamics-toolkit","text":"Runge-Kutta integration. Uses numbers_module kind_module module~~rk_module~~UsesGraph module~rk_module rk_module module~kind_module kind_module module~rk_module->module~kind_module module~numbers_module numbers_module module~rk_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~rk_module~~UsedByGraph module~rk_module rk_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~rk_module proc~compute_halo_monodromy_matrix compute_halo_monodromy_matrix proc~compute_halo_monodromy_matrix->module~rk_module proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->module~rk_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces interface private  subroutine deriv_func(me, t, x, xdot) derivative function Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t time real(kind=wp), intent(in), dimension(me%n) :: x state vector real(kind=wp), intent(out), dimension(me%n) :: xdot derivative of state vector interface private  subroutine event_func(me, t, x, g) event function Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t time real(kind=wp), intent(in), dimension(me%n) :: x state vector real(kind=wp), intent(out) :: g g(t,x). The goal is to stop the integration when g=0. interface private  subroutine report_func(me, t, x) report function Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t time real(kind=wp), intent(in), dimension(me%n) :: x state vector interface private  subroutine step_func(me, t, x, h, xf) rk step function Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state vector real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf final state vector Derived Types type, public, abstract :: rk_class main integration class: Components Type Visibility Attributes Name Initial integer, public :: n = 0 user specified number of variables procedure( deriv_func ), public, pointer :: f => null() user-specified derivative function procedure( report_func ), public, pointer :: report => null() user-specified report function procedure( event_func ), public, pointer :: g => null() event function (stop when this is zero) Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) procedure, public, non_overridable :: integrate main integration routine procedure, public, non_overridable :: integrate_to_event integration with event finding procedure( step_func ), public, deferred :: step the step routine for the rk method procedure, public :: destroy destructor type, public, extends( rk_class ) :: rk4_class 4th order Runge-Kutta method. Components Type Visibility Attributes Name Initial integer, public :: n = 0 user specified number of variables procedure( deriv_func ), public, pointer :: f => null() user-specified derivative function procedure( report_func ), public, pointer :: report => null() user-specified report function procedure( event_func ), public, pointer :: g => null() event function (stop when this is zero) Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) procedure, public, non_overridable :: integrate main integration routine procedure, public, non_overridable :: integrate_to_event integration with event finding procedure, public :: destroy destructor procedure, public :: step => rk4 type, public, extends( rk_class ) :: rk8_10_class 8th order Runge-Kutta method. Components Type Visibility Attributes Name Initial integer, public :: n = 0 user specified number of variables procedure( deriv_func ), public, pointer :: f => null() user-specified derivative function procedure( report_func ), public, pointer :: report => null() user-specified report function procedure( event_func ), public, pointer :: g => null() event function (stop when this is zero) Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) procedure, public, non_overridable :: integrate main integration routine procedure, public, non_overridable :: integrate_to_event integration with event finding procedure, public :: destroy destructor procedure, public :: step => rk8_10 Subroutines private  subroutine initialize (me, n, f, report, g) Initialize the rk_class . Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me integer, intent(in) :: n number of variables procedure( deriv_func ) :: f derivative function procedure( report_func ), optional :: report for reporting the steps procedure( event_func ), optional :: g for stopping at an event private  subroutine destroy (me) Destructor for rk_class . Arguments Type Intent Optional Attributes Name class( rk_class ), intent(out) :: me private  subroutine integrate (me, t0, x0, h, tf, xf) Main integration routine for the rk_class . Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tf final time real(kind=wp), intent(out), dimension(me%n) :: xf final state private  subroutine integrate_to_event (me, t0, x0, h, tmax, tol, tf, xf, gf) Event-finding integration routine for the rk_class .\nIntegrates until g(t,x)=0, or until t=tf (whichever happens first). Read more… Arguments Type Intent Optional Attributes Name class( rk_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tmax max final time if event not located real(kind=wp), intent(in) :: tol function tolerance for root finding real(kind=wp), intent(out) :: tf actual final time reached real(kind=wp), intent(out), dimension(me%n) :: xf final state (at tf) real(kind=wp), intent(out) :: gf g value at tf private  subroutine rk4 (me, t, x, h, xf) Take one Runge Kutta 4 integration step: t -> t+h (x -> xf) Arguments Type Intent Optional Attributes Name class( rk4_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h private  subroutine rk8_10 (me, t, x, h, xf) Take one Runge Kutta 8 integration step: t -> t+h (x -> xf) This is Formula (8-10) from Reference [1]. Read more… Arguments Type Intent Optional Attributes Name class( rk8_10_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h public  subroutine rk_test () Unit test of the rk_module .\nIntegrate a two-body orbit around the Earth. Arguments None","tags":"","url":"module/rk_module.html"},{"title":"transformation_module – fortran-astrodynamics-toolkit","text":"Coordinate transformations. Uses kind_module time_module numbers_module iau_orientation_module iso_fortran_env celestial_body_module ephemeris_module vector_module module~~transformation_module~~UsesGraph module~transformation_module transformation_module iso_fortran_env iso_fortran_env module~transformation_module->iso_fortran_env module~celestial_body_module celestial_body_module module~transformation_module->module~celestial_body_module module~ephemeris_module ephemeris_module module~transformation_module->module~ephemeris_module module~iau_orientation_module iau_orientation_module module~transformation_module->module~iau_orientation_module module~kind_module kind_module module~transformation_module->module~kind_module module~numbers_module numbers_module module~transformation_module->module~numbers_module module~time_module time_module module~transformation_module->module~time_module module~vector_module vector_module module~transformation_module->module~vector_module module~celestial_body_module->module~kind_module module~celestial_body_module->module~numbers_module module~base_class_module base_class_module module~celestial_body_module->module~base_class_module module~ephemeris_module->module~celestial_body_module module~ephemeris_module->module~kind_module module~iau_orientation_module->module~kind_module module~iau_orientation_module->module~numbers_module module~conversion_module conversion_module module~iau_orientation_module->module~conversion_module module~kind_module->iso_fortran_env module~numbers_module->module~kind_module module~time_module->module~kind_module module~vector_module->module~kind_module module~vector_module->module~numbers_module module~conversion_module->module~kind_module module~conversion_module->module~numbers_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~transformation_module~~UsedByGraph module~transformation_module transformation_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~transformation_module module~lighting_module lighting_module module~fortran_astrodynamics_toolkit->module~lighting_module module~lighting_module->module~transformation_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: center_at_primary_body = 1 integer, public, parameter :: center_at_secondary_body = 2 integer, public, parameter :: center_at_barycenter = 3 Interfaces public        interface two_body_rotating_frame private pure function two_body_rotating_frame_constructor (primary_body, secondary_body, center, et, inertial) result(f) Constructor for a two_body_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: primary_body the primary body of\nthe frame type( celestial_body ), intent(in) :: secondary_body the secondary body used\nto construct the frame integer, intent(in) :: center the frame center (can\nbe primary_body , secondary_body , or barycenter ) real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] logical, intent(in), optional :: inertial if true, it's a quasi-inertial frame\n[default is false] Return Value type( two_body_rotating_frame ) public        interface two_body_rotating_pulsating_frame private pure function two_body_rotating_pulsating_frame_constructor (primary_body, secondary_body, center, scale, et) result(f) Constructor for a two_body_rotating_pulsating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: primary_body the primary body of\nthe frame type( celestial_body ), intent(in) :: secondary_body the secondary body used\nto construct the frame integer, intent(in) :: center the frame center (can\nbe primary_body , secondary_body , or barycenter ) real(kind=wp), intent(in) :: scale scale factor real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( two_body_rotating_pulsating_frame ) public        interface iau_earth_rotating_frame private pure function iau_earth_rotating_frame_constructor (b, et) result(f) Constructor for a iau_earth_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( iau_earth_rotating_frame ) public        interface iau_moon_rotating_frame private pure function iau_moon_rotating_frame_constructor (b, et) result(f) Constructor for a iau_moon_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( iau_earth_rotating_frame ) public        interface icrf_frame private pure function icrf_frame_constructor (b) result(f) Constructor for a icrf_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body Return Value type( icrf_frame ) public        interface ecliptic_frame private pure function ecliptic_frame_constructor (b) result(f) Constructor for a ecliptic_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body Return Value type( ecliptic_frame ) Abstract Interfaces abstract interface private  subroutine c_cdot_func(me, eph, to_icrf, c, cdot, status_ok) Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations\n(assumed to have already\nbeen initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok Derived Types type, public, abstract :: reference_frame a reference frame defines an orientation at\na specified frame center at a specified epoch.\nUsually, the center is the primary_body of the\nframe, but can be otherwise for a two_body_rotating_frame . Components Type Visibility Attributes Name Initial type( celestial_body ), private :: primary_body = body_earth the primary body of the frame real(kind=wp), private :: et = zero epoch at which the frame is defined [sec] Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine procedure( c_cdot_func ), private, deferred :: get_c_cdot to get the rotating matrix for the frame orientation type, public, abstract, extends( reference_frame ) :: inertial_frame_class a non-rotating frame (a frame where the orientation axes are time invariant) Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine type, public, abstract, extends( reference_frame ) :: rotating_frame_class a rotating frame (a frame where the orientation axes vary with time) Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine type, public, abstract, extends( rotating_frame_class ) :: iau_rotating_frame_class frame defined by the orientation of a celestial body using the IAU models. Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine type, public, extends( rotating_frame_class ) :: two_body_rotating_frame The two-body rotating frame is constructed from the states\nof two celestial bodies. Components Type Visibility Attributes Name Initial type( celestial_body ), public :: secondary_body = body_moon the secondary body used to construct the frame integer, public :: center = center_at_barycenter the frame center (can be primary_body,secondary_body, or barycenter) real(kind=wp), public, dimension(6) :: rv12 = zero [r,v] of secondary body w.r.t. primary body logical, public :: inertial = .false. to make it a quasi-inertial frame (cdot is zero) Constructor private\n\n                    pure\n                    function two_body_rotating_frame_constructor (primary_body, secondary_body, center, et, inertial) Constructor for a two_body_rotating_frame Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine procedure, public :: from_primary_to_center procedure, public :: get_c_cdot => get_c_cdot_two_body_rotating type, public, extends( two_body_rotating_frame ) :: two_body_rotating_pulsating_frame This frame is an extension of the two-body rotating frame, where\na scale factor is used to scale the position and velocity of the state\nbased on the distance between the primary and secondary bodies. Components Type Visibility Attributes Name Initial type( celestial_body ), public :: secondary_body = body_moon the secondary body used to construct the frame integer, public :: center = center_at_barycenter the frame center (can be primary_body,secondary_body, or barycenter) real(kind=wp), public, dimension(6) :: rv12 = zero [r,v] of secondary body w.r.t. primary body logical, public :: inertial = .false. to make it a quasi-inertial frame (cdot is zero) real(kind=wp), public :: scale = zero scale factor Constructor private\n\n                    pure\n                    function two_body_rotating_pulsating_frame_constructor (primary_body, secondary_body, center, scale, et) Constructor for a two_body_rotating_pulsating_frame Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine procedure, public :: from_primary_to_center procedure, public :: get_c_cdot => get_c_cdot_two_body_rotating_pulsating type, public, extends( iau_rotating_frame_class ) :: iau_earth_rotating_frame IAU Earth frame Constructor private\n\n                    pure\n                    function iau_earth_rotating_frame_constructor (b, et) Constructor for a iau_earth_rotating_frame Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine procedure, public :: get_c_cdot => get_c_cdot_iau_earth type, public, extends( iau_rotating_frame_class ) :: iau_moon_rotating_frame IAU Moon frame Constructor private\n\n                    pure\n                    function iau_moon_rotating_frame_constructor (b, et) Constructor for a iau_moon_rotating_frame Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine procedure, public :: get_c_cdot => get_c_cdot_iau_moon type, public, extends( inertial_frame_class ) :: icrf_frame the fundamental inertial frame\nfor the ephemeris (i.e., J2000). Constructor private\n\n                    pure\n                    function icrf_frame_constructor (b) Constructor for a icrf_frame Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine procedure, public :: get_c_cdot => get_c_cdot_icrf type, public, extends( inertial_frame_class ) :: ecliptic_frame Mean ecliptic frame. Constructor private\n\n                    pure\n                    function ecliptic_frame_constructor (b) Constructor for a ecliptic_frame Type-Bound Procedures procedure, public, pass(from) :: transform coordinate transformation routine procedure, public :: get_c_cdot => get_c_cdot_ecliptic Functions private pure function two_body_rotating_frame_constructor (primary_body, secondary_body, center, et, inertial) result(f) Constructor for a two_body_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: primary_body the primary body of\nthe frame type( celestial_body ), intent(in) :: secondary_body the secondary body used\nto construct the frame integer, intent(in) :: center the frame center (can\nbe primary_body , secondary_body , or barycenter ) real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] logical, intent(in), optional :: inertial if true, it's a quasi-inertial frame\n[default is false] Return Value type( two_body_rotating_frame ) private pure function two_body_rotating_pulsating_frame_constructor (primary_body, secondary_body, center, scale, et) result(f) Constructor for a two_body_rotating_pulsating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: primary_body the primary body of\nthe frame type( celestial_body ), intent(in) :: secondary_body the secondary body used\nto construct the frame integer, intent(in) :: center the frame center (can\nbe primary_body , secondary_body , or barycenter ) real(kind=wp), intent(in) :: scale scale factor real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( two_body_rotating_pulsating_frame ) private pure function iau_earth_rotating_frame_constructor (b, et) result(f) Constructor for a iau_earth_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( iau_earth_rotating_frame ) private pure function iau_moon_rotating_frame_constructor (b, et) result(f) Constructor for a iau_moon_rotating_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body real(kind=wp), intent(in) :: et epoch at which the\nframe is defined [sec] Return Value type( iau_earth_rotating_frame ) private pure function icrf_frame_constructor (b) result(f) Constructor for a icrf_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body Return Value type( icrf_frame ) private pure function ecliptic_frame_constructor (b) result(f) Constructor for a ecliptic_frame Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b the central body Return Value type( ecliptic_frame ) Subroutines private  subroutine transform (from, rv, to, et, eph, rv_out, status_ok) Transform a Cartesian state from one reference frame to another at\na specified epoch. The from and to reference_frame s may each\nbe defined at a different epoch. The et ephemeris time is the time\nthe transformation is to be done, and accounts for the motion of the two\nframe centers from from%et and to%et to et . Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(inout) :: from real(kind=wp), intent(in), dimension(6) :: rv class( reference_frame ), intent(inout) :: to real(kind=wp), intent(in) :: et the time of the transformation [sec] class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(out), dimension(6) :: rv_out logical, intent(out) :: status_ok private  subroutine rvcto_rvcfrom_icrf (from, to, eph, et, rc21, vc21, status_ok) Returns the state of the from frame center w.r.t. the to frame center,\nat the specified ephemeris time et . Arguments Type Intent Optional Attributes Name class( reference_frame ), intent(in) :: from class( reference_frame ), intent(in) :: to class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(in) :: et ephemeris time [sec] real(kind=wp), intent(out), dimension(3) :: rc21 position of from frame center w.r.t. to frame center real(kind=wp), intent(out), dimension(3) :: vc21 velocity of from frame center w.r.t. to frame center logical, intent(out) :: status_ok true if there were no errors private  subroutine from_primary_to_center (me, eph, et, rc, status_ok) returns the state of the frame center w.r.t. the frame primary body. Arguments Type Intent Optional Attributes Name class( two_body_rotating_frame ), intent(in) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) real(kind=wp), intent(in) :: et ephemeris time [sec] real(kind=wp), intent(out), dimension(6) :: rc state of frame center w.r.t. primary body [inertial] logical, intent(out) :: status_ok true if no errors. private  subroutine get_c_cdot_two_body_rotating (me, eph, to_icrf, c, cdot, status_ok) rotation matrix for ROTATING <-> ICRF Arguments Type Intent Optional Attributes Name class( two_body_rotating_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok private  subroutine get_c_cdot_two_body_rotating_pulsating (me, eph, to_icrf, c, cdot, status_ok) rotation matrix for ROTATING_PULSATING <-> ICRF Arguments Type Intent Optional Attributes Name class( two_body_rotating_pulsating_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok private  subroutine get_c_cdot_icrf (me, eph, to_icrf, c, cdot, status_ok) rotation matrix for ICRF <-> ICRF Arguments Type Intent Optional Attributes Name class( icrf_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok private  subroutine get_c_cdot_ecliptic (me, eph, to_icrf, c, cdot, status_ok) rotation matrix for ICRF <-> Mean Ecliptic Arguments Type Intent Optional Attributes Name class( ecliptic_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok private  subroutine get_c_cdot_iau_earth (me, eph, to_icrf, c, cdot, status_ok) rotation matrix for IAU_EARTH <-> ICRF Arguments Type Intent Optional Attributes Name class( iau_earth_rotating_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok private  subroutine get_c_cdot_iau_moon (me, eph, to_icrf, c, cdot, status_ok) rotation matrix for IAU_MOON <-> ICRF Arguments Type Intent Optional Attributes Name class( iau_moon_rotating_frame ), intent(inout) :: me class( ephemeris_class ), intent(inout) :: eph for ephemeris computations (assumed to have already been initialized) logical, intent(in) :: to_icrf real(kind=wp), intent(out), dimension(3,3) :: c real(kind=wp), intent(out), optional, dimension(3,3) :: cdot logical, intent(out) :: status_ok public  subroutine transformation_module_test () Transformation units test Arguments None","tags":"","url":"module/transformation_module.html"},{"title":"kepler_module – fortran-astrodynamics-toolkit","text":"Kepler propagation routines. Uses numbers_module kind_module iso_fortran_env module~~kepler_module~~UsesGraph module~kepler_module kepler_module iso_fortran_env iso_fortran_env module~kepler_module->iso_fortran_env module~kind_module kind_module module~kepler_module->module~kind_module module~numbers_module numbers_module module~kepler_module->module~numbers_module module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~kepler_module~~UsedByGraph module~kepler_module kepler_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~kepler_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions private pure function kepe (e, m, ecc) Elliptic Kepler's equation Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: e eccentric anomaly real(kind=wp), intent(in) :: m mean anomaly real(kind=wp), intent(in) :: ecc eccentricity Return Value real(kind=wp) private pure function d_kepe (e, ecc) Derivative of kepe w.r.t. e Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: e eccentric anomaly real(kind=wp), intent(in) :: ecc eccentricity Return Value real(kind=wp) private pure function kepde (de, dm, sigma0, sqrta, a, r) Elliptic Kepler's equation written in terms of the\neccentric anomaly difference.  See Battin, eqn 4.43. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: de eccentric anomaly difference real(kind=wp), intent(in) :: dm mean anomaly difference real(kind=wp), intent(in) :: sigma0 real(kind=wp), intent(in) :: sqrta real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: r Return Value real(kind=wp) private pure function d_kepde (de, sigma0, sqrta, a, r) Derivative of kepde w.r.t de . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: de eccentric anomaly difference real(kind=wp), intent(in) :: sigma0 real(kind=wp), intent(in) :: sqrta real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: r Return Value real(kind=wp) private pure function kepdh (dh, dn, sigma0, sqrta, a, r) Battin, eqn. 4.64. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: dh hyperbolic anomaly difference real(kind=wp), intent(in) :: dn real(kind=wp), intent(in) :: sigma0 real(kind=wp), intent(in) :: sqrta real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: r Return Value real(kind=wp) private pure function d_kepdh (dh, sigma0, sqrta, a, r) Derivative of kepdh w.r.t dh . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: dh hyperbolic anomaly difference real(kind=wp), intent(in) :: sigma0 real(kind=wp), intent(in) :: sqrta real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: r Return Value real(kind=wp) private pure function barker (r1, r2, mu) Barker time of flight equation Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r1 real(kind=wp), intent(in), dimension(3) :: r2 real(kind=wp), intent(in) :: mu Return Value real(kind=wp) private pure function kepds (ds, dt, r0, vr0, alpha, mu) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ds universal anomaly difference real(kind=wp), intent(in) :: dt real(kind=wp), intent(in) :: r0 real(kind=wp), intent(in) :: vr0 real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: mu Return Value real(kind=wp) private pure function d_kepds (ds, r0, vr0, alpha, mu) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ds real(kind=wp), intent(in) :: r0 real(kind=wp), intent(in) :: vr0 real(kind=wp), intent(in) :: alpha real(kind=wp), intent(in) :: mu Return Value real(kind=wp) private pure function stumpff_s (z) result(s) Stumpff function S(z) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: z Return Value real(kind=wp) private pure function stumpff_c (z) result(c) Stumpff function C(z) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: z Return Value real(kind=wp) Subroutines public  subroutine kepler_classical (x0, dt, mu, xf) Classical Kepler propagator for elliptical and hyperbolic orbits.\n  Uses Lagrange formulations from Battin & Newton's method. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: x0 initial position,velocity vector real(kind=wp), intent(in) :: dt propagation time real(kind=wp), intent(in) :: mu central body gravitational parameter real(kind=wp), intent(out), dimension(6) :: xf final position,velocity vector public  subroutine kepler_shepperd (mu, rv1, dt, rv2, istat) Kepler propagation using Shepperd's method. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter real(kind=wp), intent(in), dimension(6) :: rv1 initial position,velocity vector real(kind=wp), intent(in) :: dt time step real(kind=wp), intent(out), dimension(6) :: rv2 final position,velocity vector integer, intent(out), optional :: istat status flag (if not present, warnings are printed):\nLinear combination of : Read more… public  subroutine kepler_goodyear_stienon_klumpp (rv0, tau, mu, accy, rvf) Kepler propagator based on the Goodyear code with\n  modifications by Stienon and Klumpp. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: rv0 state vector at reference\ntime T0 [km,km/s] real(kind=wp), intent(in) :: tau Time interval T-T0 [sec] real(kind=wp), intent(in) :: mu Central body gravitational\nconstant [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: accy Fractional accuracy required\n[0->0.1] real(kind=wp), intent(out), dimension(6) :: rvf state vector at solution time\nT [km,km/s]","tags":"","url":"module/kepler_module.html"},{"title":"crtbp_module – fortran-astrodynamics-toolkit","text":"This module contains various routines related to the\nCircular Restricted Three-Body Problem (CRTBP). Uses numbers_module kind_module module~~crtbp_module~~UsesGraph module~crtbp_module crtbp_module module~kind_module kind_module module~crtbp_module->module~kind_module module~numbers_module numbers_module module~crtbp_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~crtbp_module~~UsedByGraph module~crtbp_module crtbp_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~crtbp_module module~halo_orbit_module halo_orbit_module module~fortran_astrodynamics_toolkit->module~halo_orbit_module module~halo_orbit_module->module~crtbp_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public pure function compute_crtpb_parameter (mu1, mu2) result(mu) Compute , the normalized CRTBP parameter.\nIt is equal to . Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu1 grav param for body 1 real(kind=wp), intent(in) :: mu2 grav param for body 2 Return Value real(kind=wp) CRTBP parameter public pure function compute_jacobi_constant (mu, x) result(c) Compute the CRTBP Jacobi constant, given the state. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu CRTBP parameter (See compute_crtpb_parameter ) real(kind=wp), intent(in), dimension(6) :: x normalized state vector Return Value real(kind=wp) Jacobi constant Subroutines public  subroutine normalize_variables (mu1, mu2, d12, x, m, t, x_crtbp, m_crtbp, t_crtbp) Convert state in km, km/s units to normalized CRTBP state. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu1 grav. param. of body 1 real(kind=wp), intent(in) :: mu2 grav. param. of body 2 real(kind=wp), intent(in) :: d12 distance between body 1 and body 2 [km] real(kind=wp), intent(in), optional, dimension(6) :: x unnormalized state w.r.t. barycenter [km,km/s] real(kind=wp), intent(in), optional :: m unnormalized mass [kg] real(kind=wp), intent(in), optional :: t unnormalized time [sec] real(kind=wp), intent(out), optional, dimension(6) :: x_crtbp CRTBP normalized state real(kind=wp), intent(out), optional :: m_crtbp CRTBP normalized mass real(kind=wp), intent(out), optional :: t_crtbp CRTBP normalized time public  subroutine unnormalize_variables (mu1, mu2, d12, x_crtbp, m_crtbp, t_crtbp, x, m, t) Convert normalized CRTBP state to km, km/s units. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu1 grav. param. of body 1 real(kind=wp), intent(in) :: mu2 grav. param. of body 2 real(kind=wp), intent(in) :: d12 distance between body 1 and body 2 [km] real(kind=wp), intent(in), optional, dimension(6) :: x_crtbp CRTBP normalized state real(kind=wp), intent(in), optional :: m_crtbp CRTBP normalized mass real(kind=wp), intent(in), optional :: t_crtbp CRTBP normalized time real(kind=wp), intent(out), optional, dimension(6) :: x unnormalized state w.r.t. barycenter [km,km/s] real(kind=wp), intent(out), optional :: m unnormalized mass [kg] real(kind=wp), intent(out), optional :: t unnormalized time [sec] public  subroutine compute_libration_points (mu, r1, r2, r3, r4, r5) Compute the coordinates of the libration points (L1,L2,L3,L4,L5).\nL1-L3 are computed using Newton's method. L4-L5 are known analytically. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu CRTBP parameter real(kind=wp), intent(out), optional :: r1 L1 x coordinate real(kind=wp), intent(out), optional :: r2 L2 x coordinate real(kind=wp), intent(out), optional :: r3 L3 x coordinate real(kind=wp), intent(out), optional, dimension(2) :: r4 L4 [x,y] coordinates real(kind=wp), intent(out), optional, dimension(2) :: r5 L5 [x,y] coordinates public  subroutine compute_libration_points_v2 (mu, r1, r2, r3, r4, r5) Compute the coordinates of the libration points (L1,L2,L3,L4,L5). Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu CRTBP parameter real(kind=wp), intent(out), optional :: r1 L1 x coordinate real(kind=wp), intent(out), optional :: r2 L2 x coordinate real(kind=wp), intent(out), optional :: r3 L3 x coordinate real(kind=wp), intent(out), optional, dimension(2) :: r4 L4 [x,y] coordinates real(kind=wp), intent(out), optional, dimension(2) :: r5 L5 [x,y] coordinates public  subroutine crtbp_derivs (mu, x, dx) CRTBP derivatives: state only. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu CRTBP parameter (See compute_crtpb_parameter ) real(kind=wp), intent(in), dimension(6) :: x normalized state real(kind=wp), intent(out), dimension(6) :: dx normalized state derivative public  subroutine crtbp_derivs_with_stm (mu, x, dx) CRTBP derivatives: state + state transition matrix. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu CRTBP parameter (See compute_crtpb_parameter ) real(kind=wp), intent(in), dimension(42) :: x normalized state and STM real(kind=wp), intent(out), dimension(42) :: dx normalized state and STM derivative public  subroutine crtbp_test () Unit tests for CRTBP routines. Arguments None","tags":"","url":"module/crtbp_module.html"},{"title":"gooding_module – fortran-astrodynamics-toolkit","text":"Gooding's Kepler and universal elements conversion routines. Notes The Gooding universal elements are: alpha - mu/a [km&#94;2/s&#94;2] rp - periapsis radius [km] inc - inclination [rad] raan - right ascension of the ascending node [rad] w - argument of periapsis [rad] tau - time since last periapsis passage [sec] References A. W. Odell, R. H. Gooding, \"Procedures for solving Kepler's equation\"\n     Celestial Mechanics 38 (1986), 307-334. R. H. Gooding, \"On universal elements, and conversion procedures\n     to and from position and velocity\"\n     Celestial Mechanics 44 (1988), 283-298. R. H. Gooding, A. W. Odell. \"The hyperbolic Kepler equation\n     (and the elliptic equation revisited)\"\n     Celestial Mechanics 44 (1988), 267-282. Uses numbers_module kind_module module~~gooding_module~~UsesGraph module~gooding_module gooding_module module~kind_module kind_module module~gooding_module->module~kind_module module~numbers_module numbers_module module~gooding_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~gooding_module~~UsedByGraph module~gooding_module gooding_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~gooding_module proc~lambert_test lambert_test proc~lambert_test->module~gooding_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=wp), private, parameter :: ntwo = -two real(kind=wp), private, parameter :: pineg = -pi real(kind=wp), private, parameter :: half = 0.5_wp real(kind=wp), private, parameter :: athird = one/three real(kind=wp), private, parameter :: asixth = one/six Functions public pure function ekepl (em, e1) Kepler's equation, em = ekepl - (1 - e1)*sin(ekepl) ,\nwith e1 in range 1 to 0 inclusive, solved accurately\n(based on ekepl3, but entering e1 , not e ) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: em real(kind=wp), intent(in) :: e1 Return Value real(kind=wp) public pure function ekepl1 (em, e) Solve kepler's equation, em = ekepl - e*sin(ekepl) ,\nwith legendre-based starter and halley iterator\n(function has also been used under the name eafkep) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: em real(kind=wp), intent(in) :: e Return Value real(kind=wp) public pure function ekepl2 (em, e) Kepler's equation, em = ekepl - e*sin(ekepl) with\ne in range 0 to 1 inclusive, solved accurately Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: em real(kind=wp), intent(in) :: e Return Value real(kind=wp) public pure function emkepl (e, ee) Accurate computation of ee - e*sin(ee) when (e, ee) is close to (1, 0) Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: e real(kind=wp), intent(in) :: ee Return Value real(kind=wp) public pure function emkep (e1, ee) Similar to emkepl, except input is 1-e . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: e1 real(kind=wp), intent(in) :: ee Return Value real(kind=wp) public pure function shkepl (el, g1) Equation el = shkepl + (g1 - 1)*asinh(shkepl) ,\nwith g1 in range 0 to 1 inclusive, solved accurately. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: el real(kind=wp), intent(in) :: g1 Return Value real(kind=wp) public pure function shmkep (g1, s) Accurate computation of s - (1 - g1)*asinh(s) when (g1, s) is close to (0, 0) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: g1 real(kind=wp), intent(in) :: s Return Value real(kind=wp) private pure function dcbsol (a, b, c) result(x) Solution to a*x**3 + 3*b*x - 2c = 0 , where a and b**3 + a*c**2 are both non-negative\n(zero generated, in lieu of infinity, if a = b = 0 ) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a real(kind=wp), intent(in) :: b real(kind=wp), intent(in) :: c Return Value real(kind=wp) private pure function dcubrt (x) result(c) Cube root computed accurately, by incorporating\none Newton-Raphson iteration. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x Return Value real(kind=wp) Subroutines public pure subroutine propagate (mu, rv0, dt, rvf) Author Jacob Williams Basic two-body propagator using the Gooding universal element routines. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu grav. parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(6) :: rv0 initial state [km, km/s] real(kind=wp), intent(in) :: dt time step [sec] real(kind=wp), intent(out), dimension(6) :: rvf final state [km, km/s] private pure subroutine els2pv (gm, al, q, om, tau, r, u, vr, vt) Algorithm for two-dimensional conversion\nfrom orbital elements to position and velocity. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: gm grav. parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: al alpha [km&#94;2/s&#94;2] real(kind=wp), intent(in) :: q periapsis distance [km] real(kind=wp), intent(in) :: om argument of periapsis relative to assumed reference direction [rad] real(kind=wp), intent(in) :: tau time from periapsis [sec] real(kind=wp), intent(out) :: r radial distance [km] real(kind=wp), intent(out) :: u angle from reference direction [rad] real(kind=wp), intent(out) :: vr radial velocity [km/2] real(kind=wp), intent(out) :: vt transverse velocity >=0 [km/s] public pure subroutine els3pv (gm, e, pv) Algorithm for three-dimensional conversion\nfrom orbital elements to position and velocity Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: gm grav. parameter [km&#94;3/sec&#94;2] real(kind=wp), intent(in), dimension(6) :: e [al, q, ei, bom, om, tau] real(kind=wp), intent(out), dimension(6) :: pv [x, y, z, xdot, ydot, zdot] private pure subroutine pv2els (gm, r, u, vr, vt, al, q, om, tau) Algorithm for two-dimensional conversion\nfrom position and velocity to orbital elements. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: gm grav. parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in) :: r radial distance [km] real(kind=wp), intent(in) :: u angle from assumed reference direction [rad] real(kind=wp), intent(in) :: vr radial velocity [km/2] real(kind=wp), intent(in) :: vt transverse velocity >=0 [km/s] real(kind=wp), intent(out) :: al alpha: gm/a [km&#94;2/s&#94;2] real(kind=wp), intent(out) :: q periapsis distance [km] real(kind=wp), intent(out) :: om argument of periapsis relative to reference direction [rad] real(kind=wp), intent(out) :: tau time from periapsis [sec] public pure subroutine pv3els (gm, pv, e) Algorithm for three-dimensional conversion\nfrom position and velocity to orbital elements. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: gm grav. parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(6) :: pv [x, y, z, xdot, ydot, zdot] real(kind=wp), intent(out), dimension(6) :: e [al, q, ei, bom, om, tau]","tags":"","url":"module/gooding_module.html"},{"title":"lighting_module – fortran-astrodynamics-toolkit","text":"Routines for computing solar fraction, lighting, eclipses, etc. Uses math_module kind_module numbers_module conversion_module transformation_module celestial_body_module ephemeris_module vector_module module~~lighting_module~~UsesGraph module~lighting_module lighting_module module~celestial_body_module celestial_body_module module~lighting_module->module~celestial_body_module module~conversion_module conversion_module module~lighting_module->module~conversion_module module~ephemeris_module ephemeris_module module~lighting_module->module~ephemeris_module module~kind_module kind_module module~lighting_module->module~kind_module module~math_module math_module module~lighting_module->module~math_module module~numbers_module numbers_module module~lighting_module->module~numbers_module module~transformation_module transformation_module module~lighting_module->module~transformation_module module~vector_module vector_module module~lighting_module->module~vector_module module~celestial_body_module->module~kind_module module~celestial_body_module->module~numbers_module module~base_class_module base_class_module module~celestial_body_module->module~base_class_module module~conversion_module->module~kind_module module~conversion_module->module~numbers_module module~ephemeris_module->module~celestial_body_module module~ephemeris_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~math_module->module~kind_module module~math_module->module~numbers_module module~numbers_module->module~kind_module module~transformation_module->module~celestial_body_module module~transformation_module->module~ephemeris_module module~transformation_module->module~kind_module module~transformation_module->module~numbers_module module~transformation_module->module~vector_module module~transformation_module->iso_fortran_env module~iau_orientation_module iau_orientation_module module~transformation_module->module~iau_orientation_module module~time_module time_module module~transformation_module->module~time_module module~vector_module->module~kind_module module~vector_module->module~numbers_module module~iau_orientation_module->module~conversion_module module~iau_orientation_module->module~kind_module module~iau_orientation_module->module~numbers_module module~time_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~lighting_module~~UsedByGraph module~lighting_module lighting_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~lighting_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public  function solar_radiation_pressure (area, cr, r_sc_sun, sunfrac) result(srp) Compute the solar radiation pressure force vector on a spacecraft. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: area cross-sectional area of spacecraft [m&#94;2] real(kind=wp), intent(in) :: cr coefficient of reflectivity real(kind=wp), intent(in), dimension(3) :: r_sc_sun vector from spacecraft to sun [km] real(kind=wp), intent(in) :: sunfrac sun fraction [0=total eclipse, 1=no eclipse] Return Value real(kind=wp), dimension(3) solar radiation pressure force vector [N] public  function get_sun_fraction (b, rad_body, rad_sun, eph, et, rv, model, rbubble, use_geometric, info) result(phi) Compute the \"sun fraction\" using the selected shadow model. Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b eclipsing body real(kind=wp), intent(in) :: rad_body radius of the eclipsing body [km] real(kind=wp), intent(in) :: rad_sun radius of the Sun [km] class( ephemeris_class ), intent(inout) :: eph the ephemeris to use for sun and ssb (if necessary) real(kind=wp), intent(in) :: et observer ephemeris time (sec) real(kind=wp), intent(in), dimension(6) :: rv state of the spacecraft (j2000-body frame) integer, intent(in) :: model algorithm to use: Read more… real(kind=wp), intent(in) :: rbubble eclipse bubble [km]. see the reference.\nif rbubble=0, then no bubble is used.\nonly used if model=1 logical, intent(in), optional :: use_geometric if true, use geometric positions\n(no light time or stellar aberration correction)\ndefault = false character(len=:), intent(out), optional, allocatable :: info info string Return Value real(kind=wp) solar fraction returned: if model=1 , circular cubic sun frac value: >0 no eclipse <0 eclipse =0 on the eclipse line if model=2 , true solar fraction value [0=total eclipse, 1=no eclipse],\n   with model of umbra/penumbra/antumbra (Wertz, 1978) if model=3 , alternate version of solar fraction (Montenbruck and Gill) if model=4 , alternate version of solar fraction (nyxspace) Subroutines public  subroutine solar_fraction (d_s, rs, d_p, rp, fraction, info) Compute the solar fraction visible due to an eclipse by another body. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: d_s vector from the spacecraft to the Sun real(kind=wp), intent(in) :: rs radius of the Sun real(kind=wp), intent(in), dimension(3) :: d_p vector from the spacecraft to the planet real(kind=wp), intent(in) :: rp radius of the planet real(kind=wp), intent(out) :: fraction fraction of the Sun visible [0=total eclipse, 1=no eclipse] character(len=:), intent(out), optional, allocatable :: info info string public  subroutine from_j2000body_to_j2000ssb (b, eph, et, rv, rv_ssb) convert from a j2000-body frame to a j2000-ssb frame. Arguments Type Intent Optional Attributes Name type( celestial_body ), intent(in) :: b eclipsing body class( ephemeris_class ), intent(inout) :: eph the ephemeris to use for body and ssb real(kind=wp), intent(in) :: et ephemeris time (sec) real(kind=wp), intent(in), dimension(6) :: rv j2000-body state (km, km/s) real(kind=wp), intent(out), dimension(6) :: rv_ssb j2000-ssb state (km, km/s) public  subroutine apparent_position (eph, b_target, et, rv_obs_ssb, r_target, status_ok) Return the position of a target body relative to an observer,\ncorrected for light time and stellar aberration. Read more… Arguments Type Intent Optional Attributes Name class( ephemeris_class ), intent(inout) :: eph the ephemeris type( celestial_body ), intent(in) :: b_target target body real(kind=wp), intent(in) :: et observer ephemeris time (sec) real(kind=wp), intent(in), dimension(6) :: rv_obs_ssb state of the observer\n(j2000 frame w.r.t. solar system barycenter) real(kind=wp), intent(out), dimension(3) :: r_target apparant state of the target (j2000 frame)\nCorrected for one-way light time and stellar aberration logical, intent(out) :: status_ok true if no problems public  subroutine cubic_shadow_model (rsun, radsun, rplanet, radplanet, sunfrac, rbubble) The \"circular cubic\" shadow model. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: rsun apparent position vector of sun wrt spacecraft [km] real(kind=wp), intent(in) :: radsun radius of sun [km] real(kind=wp), intent(in), dimension(3) :: rplanet apparent position vector of eclipsing body wrt spacecraft [km] real(kind=wp), intent(in) :: radplanet radius of the eclipsing body [km] real(kind=wp), intent(out) :: sunfrac value of the function (>0 no eclipse,\n<0 eclipse, =0 on the shadow line) real(kind=wp), intent(in), optional :: rbubble eclipse bubble radius. if present, then sunfrac is\nthe value along an arc length of rbubble in the direction of the max eclipse line. public  subroutine solar_fraction_alt (d_s, rs, d_p, rp, percentsun, info) Another eclipse model, using circular area assumptions. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: d_s vector from the spacecraft to the Sun real(kind=wp), intent(in) :: rs radius of the Sun real(kind=wp), intent(in), dimension(3) :: d_p vector from the spacecraft to the planet real(kind=wp), intent(in) :: rp radius of the planet real(kind=wp), intent(out) :: percentsun fraction of the Sun visible [0=total eclipse, 1=no eclipse] character(len=:), intent(out), optional, allocatable :: info info string public  subroutine solar_fraction_alt2 (r_l, Rl, r_e, Re, percentsun, info) Another eclipse model, using circular area assumptions,\n  coded up based on the nixspace documentation.\n  The results are very similar to solar_fraction_alt . Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: r_l vector from the spacecraft to the Sun real(kind=wp), intent(in) :: Rl radius of the Sun real(kind=wp), intent(in), dimension(3) :: r_e vector from the spacecraft to the planet real(kind=wp), intent(in) :: Re radius of the planet real(kind=wp), intent(out) :: percentsun fraction of the Sun visible [0=total eclipse, 1=no eclipse] character(len=:), intent(out), optional, allocatable :: info info string public  subroutine lighting_module_test () Unit tests for the listing module. Arguments None","tags":"","url":"module/lighting_module.html"},{"title":"jpl_ephemeris_module – fortran-astrodynamics-toolkit","text":"For reading the JPL planetary and lunar ephemerides.\n  This is an extensively modified version of the original FORTRAN 77 code from JPL. Ephemeris files Note that this module uses the JPL binary ephemeris files, which\n  can be obtained using the instructions here .\n  See also the comments in ephemeris_test for more details. License Original JPL License THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE\n  CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.\n  GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE\n  ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE\n  PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED \"AS-IS\"\n  TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY\n  WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A\n  PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC\n  SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE\n  SOFTWARE AND RELATED MATERIALS, HOWEVER USED. IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA\n  BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT\n  LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,\n  INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,\n  REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE\n  REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY. RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF\n  THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY\n  CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE\n  ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE. Modifications Modifications for the Fortran Astrodynamics Toolkit are covered\n  under the following license . History Original code from JPL Version : March 25, 2013 Extensive modifications by Jacob Williams for the Fortran Astrodynamics Toolkit. the state is just copied into a 128-bit variable. Perhaps we should do the interpolations\n  in 128-bit? (the data from the file must be read as 64-bit) Uses kind_module ephemeris_module iso_fortran_env module~~jpl_ephemeris_module~~UsesGraph module~jpl_ephemeris_module jpl_ephemeris_module iso_fortran_env iso_fortran_env module~jpl_ephemeris_module->iso_fortran_env module~ephemeris_module ephemeris_module module~jpl_ephemeris_module->module~ephemeris_module module~kind_module kind_module module~jpl_ephemeris_module->module~kind_module module~ephemeris_module->module~kind_module module~celestial_body_module celestial_body_module module~ephemeris_module->module~celestial_body_module module~kind_module->iso_fortran_env module~celestial_body_module->module~kind_module module~base_class_module base_class_module module~celestial_body_module->module~base_class_module module~numbers_module numbers_module module~celestial_body_module->module~numbers_module module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~jpl_ephemeris_module~~UsedByGraph module~jpl_ephemeris_module jpl_ephemeris_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~jpl_ephemeris_module proc~transformation_module_test transformation_module_test proc~transformation_module_test->module~jpl_ephemeris_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, private, parameter :: wp = real64 using double precision reals since that is how the ephemeris is stored. integer, public, parameter :: nmax = 1000 Current maximum number of ephemeris constants\nused in the integration and listed\nin the header.xxx file for the ephemeris. integer, private, parameter :: oldmax = 400 For earlier versions of the code, the maximum\nnumber of ephemeris constants used in the\nintegration and listed in the header.xxx file for the ephemeris. integer, private, parameter :: nrecl = 4 nrecl=1 if recl in the open statement is the record length in s.p. words nrecl=4 if recl in the open statement is the record length in bytes character(len=*), private, parameter,               dimension(15) :: list_of_bodies = ['mercury                ', 'venus                  ', 'earth                  ', 'mars                   ', 'jupiter                ', 'saturn                 ', 'uranus                 ', 'neptune                ', 'pluto                  ', 'moon                   ', 'sun                    ', 'solar-system barycenter', 'earth-moon barycenter  ', 'nutations              ', 'librations             '] These correspond to the numbering convention for 'ntarg' and 'ncent' in get_state : Derived Types type, public, extends( ephemeris_class ) :: jpl_ephemeris Main class for accessing a JPL ephemeris file. Components Type Visibility Attributes Name Initial character(len=:), public, allocatable :: namfil name of the binary ephemeris file integer, public :: ksize = 2036 ksize must be set by the user according to the ephemeris to be read:\n  for de200 , set ksize=1652 ,\n  for de405 , set ksize=2036 ,\n  for de406 , set ksize=1456 ,\n  for de414 , set ksize=2036 ,\n  for de418 , set ksize=2036 ,\n  for de421 , set ksize=2036 ,\n  for de422 , set ksize=2036 ,\n  for de423 , set ksize=2036 ,\n  for de424 , set ksize=2036 ,\n  for de430 , set ksize=2036 . integer, public, dimension(3,13) :: ipt = 0 ipt(39) real(kind=wp), public, dimension(nmax) :: cval = 0.0_wp real(kind=wp), public, dimension(3) :: ss = 0.0_wp real(kind=wp), public :: au = 0.0_wp real(kind=wp), public :: emrat = 0.0_wp integer, public :: ncon = 0 integer, public :: numde = 0 real(kind=wp), public, dimension(6) :: pvsun = 0.0_wp dp 6-word array containing the barycentric position and\nvelocity of the sun. logical, public :: km = .true. logical flag defining physical units of the output states.\n  km = .true.  : km and km/sec\n  km = .false. : au and au/day\nfor nutations and librations.  angle unit is always radians. logical, public :: bary = .false. logical flag defining output center.\nonly the 9 planets are affected.\n  bary = .true.  : center is solar-system barycenter\n  bary = .false. : center is sun character(len=6), public, dimension(14,3) :: ttl = '' character(len=6), public, dimension(nmax) :: cnam = '' logical, public :: initialized = .false. is the ephemeris initialized? integer, public :: nrfile = 0 file unit for the ephemeris file integer, public :: nrl = -1 this was formerly in state integer, public :: ncoeffs = 0 real(kind=wp), public, dimension(1500) :: buf = 0.0_wp real(kind=wp), public, dimension(18) :: pc = 0.0_wp real(kind=wp), public, dimension(18) :: vc = 0.0_wp integer, public :: np = 2 integer, public :: nv = 3 real(kind=wp), public :: twot = 0.0_wp Type-Bound Procedures procedure, public :: get_rv => get_rv_from_jpl_ephemeris procedure, public :: get_r => get_r_from_jpl_ephemeris procedure, public :: initialize => initialize_ephemeris procedure, public :: get_state procedure, public :: get_constants procedure, public :: close => close_ephemeris procedure, public :: interp procedure, public :: state Functions private pure function spice_id_to_old_id (spice_id) result(old_id) Author Jacob Williams Date 3/20/2016 Convert the NAIF SPICE ID code to the old one used by the JPL ephemeris.\nReturns 0 if the body was not found. Arguments Type Intent Optional Attributes Name integer, intent(in) :: spice_id the ID code used by SPICE Return Value integer the ID code used by this module (old JPL ephemeris code) Subroutines private  subroutine get_rv_from_jpl_ephemeris (me, et, targ, obs, rv, status_ok) Interface for the ephemeris_module . Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=fat_wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=fat_wp), intent(out), dimension(6) :: rv state of targ w.r.t. obs [km,km/s] in ICRF frame logical, intent(out) :: status_ok true if there were no problems private  subroutine get_r_from_jpl_ephemeris (me, et, targ, obs, r, status_ok) Interface for the ephemeris_module . Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=fat_wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=fat_wp), intent(out), dimension(3) :: r position of targ w.r.t. obs [km] in ICRF frame logical, intent(out) :: status_ok true if there were no problems private  subroutine get_state (me, jd, ntarg, ncent, rrd, status_ok, pos_only) This subroutine reads the JPL planetary ephemeris\n  and gives the position and velocity of the point ntarg with respect to ncent . Read more… Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=wp), intent(in) :: jd d.p. Julian ephemeris date at which interpolation is wanted. integer, intent(in) :: ntarg integer number of 'target' point. integer, intent(in) :: ncent integer number of 'center' point. real(kind=wp), intent(out), dimension(6) :: rrd output 6-word d.p. array containing position and velocity\nof point ntarg relative to ncent .\nthe units are AU and AU/day (or km and km/sec if me%km=.true. ).\nFor librations the units are radians and radians\nper day. In the case of nutations the first four words of rrd will be set to nutations and rates, having units of\nradians and radians/day. logical, intent(out) :: status_ok true if there were no problems logical, intent(in), optional :: pos_only if .true. only the position components are returned, not the velocity. [doesn't work yet] private  subroutine interp (me, buf, t, ncf, ncm, na, ifl, pv) this subroutine differentiates and interpolates a\nset of chebyshev coefficients to give position and velocity. Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=wp), dimension(ncf,ncm,*) :: buf 1st location of array of d.p. chebyshev coefficients of position real(kind=wp), intent(in), dimension(2) :: t integer, intent(in) :: ncf Read more… integer, intent(in) :: ncm Read more… integer, intent(in) :: na (i.e., # of sub-intervals in full interval) Read more… integer, intent(in) :: ifl integer flag\n= 1 for positions only\n= 2 for pos and vel real(kind=wp), dimension(ncm,*) :: pv interpolated quantities requested.  dimension\nexpected is pv(ncm,ifl), dp. private  subroutine split (tt, fr) this subroutine breaks a d.p. number into a d.p. integer\nand a d.p. fractional part. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: tt d.p. input number real(kind=wp), intent(out), dimension(2) :: fr d.p. 2-word output array.\nfr(1) contains integer part\nfr(2) contains fractional part\nfor negative input numbers, fr(1) contains the next\nmore negative integer; fr(2) contains a positive fraction. private  subroutine initialize_ephemeris (me, filename, ksize, km, bary, status_ok) Initialize the ephemeris.\n  This routine may be called to load a different ephemeris file.\n  Otherwise, it is called on the first call to get_state, and loads\n  the file specified in the module header. Read more… Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me character(len=*), intent(in) :: filename ephemeris file name integer, intent(in), optional :: ksize corresponding ksize logical, intent(in), optional :: km defining physical units of the output states. km = .true. : km and km/sec [default], km = .false. : au and au/day. logical, intent(in), optional :: bary logical flag defining output center.\nonly the 9 planets are affected. bary = .true. : center is solar-system barycenter, bary = .false. : center is sun [default]. logical, intent(out) :: status_ok true if there were not problems. private  subroutine close_ephemeris (me) Close the ephemeris. Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me private  subroutine state (me, et2, list, pv, pnut, status_ok) This subroutine reads and interpolates the JPL planetary ephemeris file. Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me real(kind=wp), intent(in), dimension(2) :: et2 2-word Julian ephemeris epoch at which interpolation\nis wanted.  any combination of et2(1)+et2(2) which falls\nwithin the time span on the file is a permissible epoch. Read more… integer, intent(in), dimension(12) :: list 12-word integer array specifying what interpolation\nis wanted for each of the bodies on the file. list(i) = 0 : no interpolation for body i, list(i) = 1 : position only, list(i) = 2 : position and velocity. Read more… real(kind=wp), intent(out), dimension(6,11) :: pv dp 6 x 11 array that will contain requested interpolated\nquantities (other than nutation, stored in pnut ).\nthe body specified by list(i) will have its\nstate in the array starting at pv(1,i) .\n(on any given call, only those words in pv which are\naffected by the first 10 list entries, and by list(12) if librations are on the file, are set.\nthe rest of the pv array is untouched.)\nthe order of components starting in pv(1,i) is: x , y , z , dx , dy , dz . Read more… real(kind=wp), intent(out), dimension(4) :: pnut dp 4-word array that will contain nutations and rates,\ndepending on the setting of list(11) .  the order of\nquantities in pnut is: Read more… logical, intent(out) :: status_ok true if there were no problems private  subroutine get_constants (me, nam, val, sss, n) Obtain the constants from the ephemeris file. Arguments Type Intent Optional Attributes Name class( jpl_ephemeris ), intent(inout) :: me character(len=6), intent(out), dimension(:) :: nam array of constant names real(kind=wp), intent(out), dimension(:) :: val array of values of constants real(kind=wp), intent(out), dimension(3) :: sss jd start, jd stop, step of ephemeris integer, intent(out) :: n number of entries in nam and val arrays public  subroutine ephemeris_test () Ephemeris test routine. Read more… Arguments None","tags":"","url":"module/jpl_ephemeris_module.html"},{"title":"time_module – fortran-astrodynamics-toolkit","text":"Time conversion routines. Uses kind_module module~~time_module~~UsesGraph module~time_module time_module module~kind_module kind_module module~time_module->module~kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~time_module~~UsedByGraph module~time_module time_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~time_module module~standish_module standish_module module~fortran_astrodynamics_toolkit->module~standish_module module~transformation_module transformation_module module~fortran_astrodynamics_toolkit->module~transformation_module module~lighting_module lighting_module module~fortran_astrodynamics_toolkit->module~lighting_module module~standish_module->module~time_module module~transformation_module->module~time_module proc~ephemeris_test ephemeris_test proc~ephemeris_test->module~time_module proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~get_r_from_jpl_ephemeris->module~time_module proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~get_rv_from_jpl_ephemeris->module~time_module module~lighting_module->module~transformation_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=wp), private, parameter :: jd_j2000 = 2451545.0_wp julian date of J2000 epoch Interfaces public        interface julian_date calendar date to julian date private pure function julian_date_realsec (y, m, d, hour, minute, second) result(julian_date) Author Jacob Williams Date 1/21/2015 Returns the Julian date for the specified YEAR, MONTH, DAY, HR, MIN, SEC. Valid for any Gregorian calendar date producing a\n  Julian date greater than zero. History JW : 10/4/2017 : made second a real value & renamed routine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: y integer, intent(in) :: m integer, intent(in) :: d integer, intent(in) :: hour integer, intent(in) :: minute real(kind=wp), intent(in) :: second Return Value real(kind=wp) private pure function julian_date_intsec (y, m, d, hour, minute, second) result(julian_date) Author Jacob Williams Date 1/21/2015 Returns the Julian date for the specified YEAR, MONTH, DAY, HR, MIN, SEC. Valid for any Gregorian calendar date producing a\n  Julian date greater than zero. History JW : 10/4/2017 : moved main code to julian_date_realsec routine. Arguments Type Intent Optional Attributes Name integer, intent(in) :: y integer, intent(in) :: m integer, intent(in) :: d integer, intent(in) :: hour integer, intent(in) :: minute integer, intent(in) :: second Return Value real(kind=wp) public        interface julian_date_to_calendar_date private pure subroutine calendar_date_realsec (julian_date, year, month, day, hrs, min, sec) Author Jacob Williams Returns the year, month, day, hr, min, sec for the specified Julian date. See also https://aa.usno.navy.mil/faq/JD_formula.html http://www.davidgsimpson.com/software/jd2greg_f90.txt Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: julian_date julian date integer, intent(out) :: year integer, intent(out) :: month integer, intent(out) :: day integer, intent(out) :: hrs integer, intent(out) :: min real(kind=wp), intent(out) :: sec Functions public pure function et_to_jd (et) result(jd) Author Jacob Williams Date 2/3/2015 Convert ephemeris time (seconds from J2000 epoch) to Julian date. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: et ephemeris time [sec from J2000 epoch] Return Value real(kind=wp) Julian date [days] public pure function jd_to_et (jd) result(et) Author Jacob Williams Date 3/19/2016 Convert Julian date to ephemeris time (seconds from J2000 epoch). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: jd Julian date [days] Return Value real(kind=wp) ephemeris time [sec from J2000 epoch] public pure function jd_to_mjd (jd) result(mjd) Author Jacob Williams Date 3/15/2015 Converts Julian date to Modified Julian date. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: jd julian date Return Value real(kind=wp) modified julian date public pure function mjd_to_jd (mjd) result(jd) Author Jacob Williams Date 3/15/2015 Converts Modified Julian date to Julian date. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mjd modified julian date Return Value real(kind=wp) julian date public pure function julian_day (y, m, d) Author Jacob Williams Returns the Julian day number (i.e., the Julian date at Greenwich noon)\n  on the specified YEAR, MONTH, and DAY. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: y year (YYYY) integer, intent(in) :: m month (MM) integer, intent(in) :: d day (DD) Return Value integer private pure function julian_date_intsec (y, m, d, hour, minute, second) result(julian_date) Author Jacob Williams Date 1/21/2015 Returns the Julian date for the specified YEAR, MONTH, DAY, HR, MIN, SEC. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: y integer, intent(in) :: m integer, intent(in) :: d integer, intent(in) :: hour integer, intent(in) :: minute integer, intent(in) :: second Return Value real(kind=wp) private pure function julian_date_realsec (y, m, d, hour, minute, second) result(julian_date) Author Jacob Williams Date 1/21/2015 Returns the Julian date for the specified YEAR, MONTH, DAY, HR, MIN, SEC. Read more… Arguments Type Intent Optional Attributes Name integer, intent(in) :: y integer, intent(in) :: m integer, intent(in) :: d integer, intent(in) :: hour integer, intent(in) :: minute real(kind=wp), intent(in) :: second Return Value real(kind=wp) public pure function is_leap_year (y) Return true if the specified year is a leap year. Arguments Type Intent Optional Attributes Name integer, intent(in) :: y year Return Value logical public  function calendar_date_to_et (year, month, day, hour, minute, second) result(et) Directly converts a calendar date to seconds since the J2000 epoch. Arguments Type Intent Optional Attributes Name integer, intent(in) :: year integer, intent(in) :: month integer, intent(in) :: day integer, intent(in) :: hour integer, intent(in) :: minute real(kind=wp), intent(in) :: second Return Value real(kind=wp) Subroutines private pure subroutine calendar_date_realsec (julian_date, year, month, day, hrs, min, sec) Author Jacob Williams Returns the year, month, day, hr, min, sec for the specified Julian date. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: julian_date julian date integer, intent(out) :: year integer, intent(out) :: month integer, intent(out) :: day integer, intent(out) :: hrs integer, intent(out) :: min real(kind=wp), intent(out) :: sec public  subroutine time_module_test () Author Jacob Williams Date 1/21/2015 Test routine for the Julian date routines. Arguments None","tags":"","url":"module/time_module.html"},{"title":"relative_motion_module – fortran-astrodynamics-toolkit","text":"This module contains various routines related to relative motion. Axis systems Three different axis systems are used here.  They are: The IJK frame The LVLH frame, defined by: x-axis : completes the right handed system\n   (for a perfectly-circular orbit, the x-axis is ) y-axis : z-axis : The RSW frame, defined by: x-axis : y-axis : completes the right handed system\n   (for a perfectly-circular orbit, the y-axis is ) z-axis : The VUW frame, defined by: x-axis : y-axis : completes the right handed system z-axis : Uses numbers_module kind_module module~~relative_motion_module~~UsesGraph module~relative_motion_module relative_motion_module module~kind_module kind_module module~relative_motion_module->module~kind_module module~numbers_module numbers_module module~relative_motion_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~relative_motion_module~~UsedByGraph module~relative_motion_module relative_motion_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~relative_motion_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Interfaces public        interface from_ijk_to_lvlh Conversion from IJK to LVLH private  subroutine from_ijk_to_lvlh_mat (mu, r, v, a, c, cdot) Author Jacob Williams Date 4/19/2014 Compute the transformation matrices to convert IJK to LVLH. See also LVLH Transformations Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_ijk_to_lvlh_rv (mu, rt_ijk, vt_ijk, r_ijk, v_ijk, dr_lvlh, dv_lvlh) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from IJK to LVLH. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: v_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km] public        interface from_lvlh_to_ijk Conversion from LVLH to IJK private  subroutine from_lvlh_to_ijk_mat (mu, r, v, a, c, cdot) Author Jacob Williams Date 4/19/2014 Compute the transformation matrices to convert LVLH to IJK. See also LVLH Transformations Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_lvlh_to_ijk_rv (mu, rt_ijk, vt_ijk, dr_lvlh, dv_lvlh, r_ijk, v_ijk) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from LVLH to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), optional, dimension(3) :: v_ijk Chaser IJK absolute position vector [km] public        interface from_ijk_to_rsw Conversion from IJK to RSW private  subroutine from_ijk_to_rsw_mat (mu, r, v, a, c, cdot) Author Jacob Williams Date 4/19/2014 Compute the transformation matrices to convert IJK to RSW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_ijk_to_rsw_rv (mu, rt_ijk, vt_ijk, r_ijk, v_ijk, dr_rsw, dv_rsw) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from IJK to RSW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: v_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), dimension(3) :: dr_rsw Chaser RSW position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_rsw Chaser RSW position vector relative to target [km] public        interface from_rsw_to_ijk Conversion from RSW to IJK private  subroutine from_rsw_to_ijk_mat (mu, r, v, a, c, cdot) Author Jacob Williams Date 4/19/2014 Compute the transformation matrices to convert RSW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_rsw_to_ijk_rv (mu, rt_ijk, vt_ijk, dr_rsw, dv_rsw, r_ijk, v_ijk) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from RSW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: dr_rsw Chaser RSW position vector [km] real(kind=wp), intent(in), dimension(3) :: dv_rsw Chaser RSW velocity vector [km/s] real(kind=wp), intent(out), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), optional, dimension(3) :: v_ijk Chaser IJK absolute velocity vector [km/s] public        interface from_lvlh_to_rsw Conversion from LVLH to RSW private  subroutine from_lvlh_to_rsw_rv (dr_lvlh, dv_lvlh, dr_rsw, dv_rsw) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from LVLH to RSW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), dimension(3) :: dr_rsw Chaser RSW position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_rsw Chaser RSW velocity vector relative to target [km/s] public        interface from_rsw_to_lvlh Conversion from RSW to LVLH private  subroutine from_rsw_to_lvlh_rv (dr_rsw, dv_rsw, dr_lvlh, dv_lvlh) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from RSW to LVLH. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: dr_rsw Chaser RSW position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_rsw Chaser RSW velocity vector relative to target [km/s] real(kind=wp), intent(out), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km] public        interface from_ijk_to_vuw Conversion from IJK to vuw private  subroutine from_ijk_to_vuw_mat (mu, r, v, a, c, cdot) Compute the transformation matrices to convert IJK to vuw. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2]\nthis is used here to assume instantaneous conic motion if a is not present. real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_ijk_to_vuw_rv (mu, rt_ijk, vt_ijk, r_ijk, v_ijk, dr_vuw, dv_vuw) Transform a position (and optionally velocity) vector from IJK to VUW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: v_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), dimension(3) :: dr_vuw Chaser vuw position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_vuw Chaser vuw position vector relative to target [km] public        interface from_vuw_to_ijk Conversion from vuw to IJK private  subroutine from_vuw_to_ijk_mat (mu, r, v, a, c, cdot) Compute the transformation matrices to convert VUW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_vuw_to_ijk_rv (mu, rt_ijk, vt_ijk, dr_vuw, dv_vuw, r_ijk, v_ijk) Transform a position (and optionally velocity) vector from VUW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: dr_vuw Chaser vuw position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_vuw Chaser vuw position vector relative to target [km] real(kind=wp), intent(out), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), optional, dimension(3) :: v_ijk Chaser IJK absolute position vector [km] Abstract Interfaces abstract interface private  subroutine report_func(t, rv) for reporting the points in the cw_propagator . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t time [sec] real(kind=wp), intent(in), dimension(6) :: rv state [km,km/s] abstract interface private  subroutine frame_transform_func(mu, r, v, a, c, cdot) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] [not used by all algorithms] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix Functions public  function cw_equations (x0, dt, n) result(x) Author Jacob Williams Date 6/14/2015 Clohessy-Wiltshire equations for relative motion. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(6) :: x0 initial state [r,v] of chaser (at t0) [km, km/s] real(kind=wp), intent(in) :: dt elapsed time from t0 [sec] real(kind=wp), intent(in) :: n mean motion of target orbit ( sqrt(mu/a**3) ) [1/sec] Return Value real(kind=wp), dimension(6) final state [r,v] of chaser [km, km/s] Subroutines public  subroutine cw_propagator (t0, x0, h, n, tf, xf, report) Author Jacob Williams Date 8/23/2015 Clohessy-Wiltshire propagation routine. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: t0 initialize time [sec] real(kind=wp), intent(in), dimension(6) :: x0 initial state in RST coordinates [km,km/s] real(kind=wp), intent(in) :: h abs(time step) [sec] real(kind=wp), intent(in) :: n mean motion of target orbit ( sqrt(mu/a**3) ) [1/sec] real(kind=wp), intent(in) :: tf final time [sec] real(kind=wp), intent(out), dimension(6) :: xf final state in RST coordinates [km,km/s] procedure( report_func ), optional :: report to report each point private  subroutine from_ijk_to_frame_rv (mu, from_ijk_to_frame, rt_ijk, vt_ijk, r_ijk, v_ijk, dr_frame, dv_frame) Transform a position (and optionally velocity) vector from IJK to a specified relative frame. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] procedure( frame_transform_func ) :: from_ijk_to_frame function to compute the transformation matrices real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: v_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), dimension(3) :: dr_frame Chaser frame position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_frame Chaser frame position vector relative to target [km] private  subroutine from_frame_to_ijk_rv (mu, from_frame_to_ijk, rt_ijk, vt_ijk, dr_frame, dv_frame, r_ijk, v_ijk) Transform a position (and optionally velocity) vector from a specified relative frame to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] procedure( frame_transform_func ) :: from_frame_to_ijk function to compute the transformation matrices real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: dr_frame Chaser frame position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_frame Chaser frame position vector relative to target [km] real(kind=wp), intent(out), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), optional, dimension(3) :: v_ijk Chaser IJK absolute position vector [km] private  subroutine from_ijk_to_lvlh_mat (mu, r, v, a, c, cdot) Author Jacob Williams Date 4/19/2014 Compute the transformation matrices to convert IJK to LVLH. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_ijk_to_lvlh_rv (mu, rt_ijk, vt_ijk, r_ijk, v_ijk, dr_lvlh, dv_lvlh) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from IJK to LVLH. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: v_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km] private  subroutine from_lvlh_to_ijk_mat (mu, r, v, a, c, cdot) Author Jacob Williams Date 4/19/2014 Compute the transformation matrices to convert LVLH to IJK. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_lvlh_to_ijk_rv (mu, rt_ijk, vt_ijk, dr_lvlh, dv_lvlh, r_ijk, v_ijk) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from LVLH to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), optional, dimension(3) :: v_ijk Chaser IJK absolute position vector [km] private  subroutine from_ijk_to_vuw_mat (mu, r, v, a, c, cdot) Compute the transformation matrices to convert IJK to vuw. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2]\nthis is used here to assume instantaneous conic motion if a is not present. real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_ijk_to_vuw_rv (mu, rt_ijk, vt_ijk, r_ijk, v_ijk, dr_vuw, dv_vuw) Transform a position (and optionally velocity) vector from IJK to VUW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: v_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), dimension(3) :: dr_vuw Chaser vuw position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_vuw Chaser vuw position vector relative to target [km] private  subroutine from_vuw_to_ijk_mat (mu, r, v, a, c, cdot) Compute the transformation matrices to convert VUW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_vuw_to_ijk_rv (mu, rt_ijk, vt_ijk, dr_vuw, dv_vuw, r_ijk, v_ijk) Transform a position (and optionally velocity) vector from VUW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: dr_vuw Chaser vuw position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_vuw Chaser vuw position vector relative to target [km] real(kind=wp), intent(out), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), optional, dimension(3) :: v_ijk Chaser IJK absolute position vector [km] private  subroutine from_ijk_to_rsw_mat (mu, r, v, a, c, cdot) Author Jacob Williams Date 4/19/2014 Compute the transformation matrices to convert IJK to RSW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_ijk_to_rsw_rv (mu, rt_ijk, vt_ijk, r_ijk, v_ijk, dr_rsw, dv_rsw) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from IJK to RSW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: v_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), dimension(3) :: dr_rsw Chaser RSW position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_rsw Chaser RSW position vector relative to target [km] private  subroutine from_rsw_to_ijk_mat (mu, r, v, a, c, cdot) Author Jacob Williams Date 4/19/2014 Compute the transformation matrices to convert RSW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: r position vector of target [km] real(kind=wp), intent(in), dimension(3) :: v velocity vector of target [km/s] real(kind=wp), intent(in), optional, dimension(3) :: a acceleration vector of target [km/s&#94;2]\n(if not present, then a torque-free force model is assumed) real(kind=wp), intent(out), dimension(3,3) :: c C transformation matrix real(kind=wp), intent(out), optional, dimension(3,3) :: cdot CDOT transformation matrix private  subroutine from_rsw_to_ijk_rv (mu, rt_ijk, vt_ijk, dr_rsw, dv_rsw, r_ijk, v_ijk) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from RSW to IJK. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu gravitational parameter [km&#94;3/s&#94;2] real(kind=wp), intent(in), dimension(3) :: rt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: vt_ijk Target IJK absolute position vector [km] real(kind=wp), intent(in), dimension(3) :: dr_rsw Chaser RSW position vector [km] real(kind=wp), intent(in), dimension(3) :: dv_rsw Chaser RSW velocity vector [km/s] real(kind=wp), intent(out), dimension(3) :: r_ijk Chaser IJK absolute position vector [km] real(kind=wp), intent(out), optional, dimension(3) :: v_ijk Chaser IJK absolute velocity vector [km/s] private  subroutine from_rsw_to_lvlh_rv (dr_rsw, dv_rsw, dr_lvlh, dv_lvlh) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from RSW to LVLH. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: dr_rsw Chaser RSW position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_rsw Chaser RSW velocity vector relative to target [km/s] real(kind=wp), intent(out), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km] private  subroutine from_lvlh_to_rsw_rv (dr_lvlh, dv_lvlh, dr_rsw, dv_rsw) Author Jacob Williams Date 8/23/2014 Transform a position (and optionally velocity) vector from LVLH to RSW. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: dr_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(in), dimension(3) :: dv_lvlh Chaser LVLH position vector relative to target [km] real(kind=wp), intent(out), dimension(3) :: dr_rsw Chaser RSW position vector relative to target [km] real(kind=wp), intent(out), optional, dimension(3) :: dv_rsw Chaser RSW velocity vector relative to target [km/s] public  subroutine relative_motion_test () Author Jacob Williams Date 8/22/2015 Unit tests for the relative_motion_module . Arguments None","tags":"","url":"module/relative_motion_module.html"},{"title":"brent_module – fortran-astrodynamics-toolkit","text":"Brent algorithms for minimization and root solving without derivatives. See also R. Brent, \"Algorithms for Minimization Without Derivatives\",\n     Prentice-Hall, Inc., 1973. Uses numbers_module kind_module module~~brent_module~~UsesGraph module~brent_module brent_module module~kind_module kind_module module~brent_module->module~kind_module module~numbers_module numbers_module module~brent_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~brent_module~~UsedByGraph module~brent_module brent_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~brent_module proc~integrate_to_event rk_class%integrate_to_event proc~integrate_to_event->module~brent_module proc~integrate_to_event~2 rk_variable_step_class%integrate_to_event proc~integrate_to_event~2->module~brent_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  function func(me, x) result(f) Interface to the function to be minimized.\nIt should evaluate f(x) for any x in the interval (ax,bx) Arguments Type Intent Optional Attributes Name class( brent_class ), intent(inout) :: me real(kind=wp), intent(in) :: x Return Value real(kind=wp) Derived Types type, public :: brent_class the main class Components Type Visibility Attributes Name Initial procedure( func ), public, pointer :: f => null() function to be minimized Type-Bound Procedures procedure, public :: set_function procedure, public :: minimize => fmin procedure, public :: find_zero => zeroin Functions private  function fmin (me, ax, bx, tol) result(xmin) An approximation x to the point where f attains a minimum on\n  the interval (ax,bx) is determined. Read more… Arguments Type Intent Optional Attributes Name class( brent_class ), intent(inout) :: me real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp), intent(in) :: tol desired length of the interval of\nuncertainty of the final result (>=0) Return Value real(kind=wp) abcissa approximating the point where\nf attains a minimum Subroutines private  subroutine set_function (me, f) Author Jacob Williams Date 7/19/2014 Set the function to be minimized. Arguments Type Intent Optional Attributes Name class( brent_class ), intent(inout) :: me procedure( func ) :: f private  subroutine zeroin (me, ax, bx, tol, xzero, fzero, iflag, fax, fbx) Find a zero of the function in the given interval to within a tolerance ,\n  where is the relative machine precision defined as\n  the smallest representable number such that . Read more… Arguments Type Intent Optional Attributes Name class( brent_class ), intent(inout) :: me real(kind=wp), intent(in) :: ax left endpoint of initial interval real(kind=wp), intent(in) :: bx right endpoint of initial interval real(kind=wp), intent(in) :: tol desired length of the interval of uncertainty of the final result (>=0) real(kind=wp), intent(out) :: xzero abscissa approximating a zero of f in the interval ax , bx real(kind=wp), intent(out) :: fzero value of f at the root ( f(xzero) ) integer, intent(out) :: iflag status flag ( -1 =error, 0 =root found) real(kind=wp), intent(in), optional :: fax if f(ax) is already known, it can be input here real(kind=wp), intent(in), optional :: fbx if f(ax) is already known, it can be input here public  subroutine brent_test () Author Jacob Williams Date 7/16/2014 Test of the fmin and zeroin functions. Arguments None","tags":"","url":"module/brent_module.html"},{"title":"conversion_module – fortran-astrodynamics-toolkit","text":"Conversion factors. See also A. Thompson and B. N. Taylor, \"NIST Special Publication 811:\n     Guide for the use of the International System of Units\".\n     http://www.nist.gov/pml/pubs/sp811/ Uses numbers_module kind_module module~~conversion_module~~UsesGraph module~conversion_module conversion_module module~kind_module kind_module module~conversion_module->module~kind_module module~numbers_module numbers_module module~conversion_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~conversion_module~~UsedByGraph module~conversion_module conversion_module module~analytical_ephemeris_module analytical_ephemeris_module module~analytical_ephemeris_module->module~conversion_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~conversion_module module~fortran_astrodynamics_toolkit->module~analytical_ephemeris_module module~iau_orientation_module iau_orientation_module module~fortran_astrodynamics_toolkit->module~iau_orientation_module module~lighting_module lighting_module module~fortran_astrodynamics_toolkit->module~lighting_module module~obliquity_module obliquity_module module~fortran_astrodynamics_toolkit->module~obliquity_module module~standish_module standish_module module~fortran_astrodynamics_toolkit->module~standish_module module~transformation_module transformation_module module~fortran_astrodynamics_toolkit->module~transformation_module module~iau_orientation_module->module~conversion_module module~lighting_module->module~conversion_module module~lighting_module->module~transformation_module module~obliquity_module->module~conversion_module module~standish_module->module~conversion_module proc~calendar_date_to_et calendar_date_to_et proc~calendar_date_to_et->module~conversion_module proc~et_to_jd et_to_jd proc~et_to_jd->module~conversion_module proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->module~conversion_module proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~get_r_from_jpl_ephemeris->module~conversion_module proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~get_rv_from_jpl_ephemeris->module~conversion_module proc~jd_to_et jd_to_et proc~jd_to_et->module~conversion_module proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->module~conversion_module module~transformation_module->module~iau_orientation_module proc~get_c_cdot_ecliptic ecliptic_frame%get_c_cdot_ecliptic proc~get_c_cdot_ecliptic->module~obliquity_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial real(kind=wp), public, parameter :: lbm2kg = 0.45359237_wp exact real(kind=wp), public, parameter :: lbf2N = 4.4482216152605_wp exact real(kind=wp), public, parameter :: ft2m = 0.3048_wp exact real(kind=wp), public, parameter :: mile2km = 1.609344_wp exact real(kind=wp), public, parameter :: nmi2km = 1.852_wp exact real(kind=wp), public, parameter :: slug2kg = lbf2N/ft2m approximately 14.593902937206362 real(kind=wp), public, parameter :: kg2lbm = one/lbm2kg approximately 2.2046226218487757 real(kind=wp), public, parameter :: N2lbf = one/lbf2N approximately 0.2248089430997105 real(kind=wp), public, parameter :: m2ft = one/ft2m approximately 3.280839895013123 real(kind=wp), public, parameter :: km2mile = one/mile2km approximately 0.621371192237334 real(kind=wp), public, parameter :: km2nmi = one/nmi2km approximately 0.5399568034557235 real(kind=wp), public, parameter :: kg2slug = ft2m/lbf2N approximately 0.06852176585679176 real(kind=wp), public, parameter :: deg2rad = pi/180.0_wp real(kind=wp), public, parameter :: rad2deg = 180.0_wp/pi real(kind=wp), public, parameter :: km2m = 1000.0_wp real(kind=wp), public, parameter :: m2km = one/km2m real(kind=wp), public, parameter :: au2m = 149597870700.0_wp IAU 2012 defined value real(kind=wp), public, parameter :: min2sec = 60.0_wp real(kind=wp), public, parameter :: hr2min = 60.0_wp real(kind=wp), public, parameter :: day2hr = 24.0_wp real(kind=wp), public, parameter :: year2day = 365.25_wp julian year real(kind=wp), public, parameter :: century2day = year2day*100.0_wp julian century real(kind=wp), public, parameter :: deg2arcmin = 60.0_wp real(kind=wp), public, parameter :: deg2arcsec = 3600.0_wp real(kind=wp), public, parameter :: hr2sec = hr2min*min2sec real(kind=wp), public, parameter :: day2min = day2hr*hr2min real(kind=wp), public, parameter :: day2sec = day2min*min2sec real(kind=wp), public, parameter :: century2sec = century2day*day2sec real(kind=wp), public, parameter :: day2year = one/year2day real(kind=wp), public, parameter :: day2century = one/century2day real(kind=wp), public, parameter :: hr2day = one/day2hr real(kind=wp), public, parameter :: sec2hr = one/hr2sec real(kind=wp), public, parameter :: sec2day = one/day2sec real(kind=wp), public, parameter :: sec2century = one/century2sec real(kind=wp), public, parameter :: arcmin2deg = one/deg2arcmin real(kind=wp), public, parameter :: arcsec2deg = one/deg2arcsec","tags":"","url":"module/conversion_module.html"},{"title":"celestial_body_module – fortran-astrodynamics-toolkit","text":"Celestial body definitions Uses numbers_module kind_module base_class_module module~~celestial_body_module~~UsesGraph module~celestial_body_module celestial_body_module module~base_class_module base_class_module module~celestial_body_module->module~base_class_module module~kind_module kind_module module~celestial_body_module->module~kind_module module~numbers_module numbers_module module~celestial_body_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~celestial_body_module~~UsedByGraph module~celestial_body_module celestial_body_module module~ephemeris_module ephemeris_module module~ephemeris_module->module~celestial_body_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~celestial_body_module module~fortran_astrodynamics_toolkit->module~ephemeris_module module~lighting_module lighting_module module~fortran_astrodynamics_toolkit->module~lighting_module module~standish_module standish_module module~fortran_astrodynamics_toolkit->module~standish_module module~transformation_module transformation_module module~fortran_astrodynamics_toolkit->module~transformation_module module~jpl_ephemeris_module jpl_ephemeris_module module~fortran_astrodynamics_toolkit->module~jpl_ephemeris_module module~lighting_module->module~celestial_body_module module~lighting_module->module~ephemeris_module module~lighting_module->module~transformation_module module~standish_module->module~celestial_body_module module~standish_module->module~ephemeris_module module~transformation_module->module~celestial_body_module module~transformation_module->module~ephemeris_module proc~crtbp_test crtbp_test proc~crtbp_test->module~celestial_body_module proc~ephemeris_test ephemeris_test proc~ephemeris_test->module~celestial_body_module proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~get_r_from_jpl_ephemeris->module~celestial_body_module proc~get_r_from_spice_ephemeris spice_ephemeris%get_r_from_spice_ephemeris proc~get_r_from_spice_ephemeris->module~celestial_body_module proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~get_rv_from_jpl_ephemeris->module~celestial_body_module proc~get_rv_from_spice_ephemeris spice_ephemeris%get_rv_from_spice_ephemeris proc~get_rv_from_spice_ephemeris->module~celestial_body_module proc~halo_orbit_test halo_orbit_test proc~halo_orbit_test->module~celestial_body_module module~jpl_ephemeris_module->module~ephemeris_module module~spice_ephemeris_module spice_ephemeris_module module~spice_ephemeris_module->module~ephemeris_module proc~transformation_module_test transformation_module_test proc~transformation_module_test->module~jpl_ephemeris_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial type( celestial_body ), public, parameter :: body_ssb = celestial_body(0, 'SSB', 0.0_wp) solar-system barycenter [note: don't have mu defined here yet] type( celestial_body ), public, parameter :: body_sun = celestial_body(10, 'Sun', 1.3271244004193938E+11_wp) type( celestial_body ), public, parameter :: body_mercury = celestial_body(199, 'Mercury', 2.2031780000000021E+04_wp) type( celestial_body ), public, parameter :: body_venus = celestial_body(299, 'Venus', 3.2485859200000006E+05_wp) type( celestial_body ), public, parameter :: body_earth = celestial_body(399, 'Earth', 3.9860043543609598E+05_wp) type( celestial_body ), public, parameter :: body_earth_moon_barycenter = celestial_body(3, 'Earth-Moon Barycenter', 4.0350323550225981E+05_wp) type( celestial_body ), public, parameter :: body_moon = celestial_body(301, 'Moon', 4.9028000661637961E+03_wp) type( celestial_body ), public, parameter :: body_mars = celestial_body(499, 'Mars', 4.282837362069909E+04_wp) type( celestial_body ), public, parameter :: body_jupiter = celestial_body(599, 'Jupiter', 1.266865349218008E+08_wp) type( celestial_body ), public, parameter :: body_saturn = celestial_body(699, 'Saturn', 3.793120749865224E+07_wp) type( celestial_body ), public, parameter :: body_uranus = celestial_body(799, 'Uranus', 5.793951322279009E+06_wp) type( celestial_body ), public, parameter :: body_neptune = celestial_body(899, 'Neptune', 6.835099502439672E+06_wp) type( celestial_body ), public, parameter :: body_pluto = celestial_body(999, 'Pluto', 8.696138177608748E+02_wp) Derived Types type, public, extends( base_class ) :: celestial_body A celestial body (Planet, moon, etc.)\nThe ID from the base_class is the NAIF SPICE ID code for the body Components Type Visibility Attributes Name Initial integer, public :: id = 0 a unique ID code that distinguishes a\nvariable from other variables of the same type. character(len=name_len), public :: name = '' the variable name real(kind=wp), public :: mu = zero gravitational parameter [ ] Type-Bound Procedures generic, public :: operator(==) => base_class_equal generic, public :: operator(/=) => base_class_not_equal","tags":"","url":"module/celestial_body_module.html"},{"title":"base_class_module – fortran-astrodynamics-toolkit","text":"A base class for defining other classes. Used by module~~base_class_module~~UsedByGraph module~base_class_module base_class_module module~celestial_body_module celestial_body_module module~celestial_body_module->module~base_class_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~base_class_module module~fortran_astrodynamics_toolkit->module~celestial_body_module module~standish_module standish_module module~fortran_astrodynamics_toolkit->module~standish_module module~ephemeris_module ephemeris_module module~fortran_astrodynamics_toolkit->module~ephemeris_module module~lighting_module lighting_module module~fortran_astrodynamics_toolkit->module~lighting_module module~transformation_module transformation_module module~fortran_astrodynamics_toolkit->module~transformation_module module~jpl_ephemeris_module jpl_ephemeris_module module~fortran_astrodynamics_toolkit->module~jpl_ephemeris_module module~standish_module->module~base_class_module module~standish_module->module~celestial_body_module module~standish_module->module~ephemeris_module module~ephemeris_module->module~celestial_body_module module~lighting_module->module~celestial_body_module module~lighting_module->module~ephemeris_module module~lighting_module->module~transformation_module module~transformation_module->module~celestial_body_module module~transformation_module->module~ephemeris_module proc~crtbp_test crtbp_test proc~crtbp_test->module~celestial_body_module proc~ephemeris_test ephemeris_test proc~ephemeris_test->module~celestial_body_module proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~get_r_from_jpl_ephemeris->module~celestial_body_module proc~get_r_from_spice_ephemeris spice_ephemeris%get_r_from_spice_ephemeris proc~get_r_from_spice_ephemeris->module~celestial_body_module proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~get_rv_from_jpl_ephemeris->module~celestial_body_module proc~get_rv_from_spice_ephemeris spice_ephemeris%get_rv_from_spice_ephemeris proc~get_rv_from_spice_ephemeris->module~celestial_body_module proc~halo_orbit_test halo_orbit_test proc~halo_orbit_test->module~celestial_body_module module~jpl_ephemeris_module->module~ephemeris_module module~spice_ephemeris_module spice_ephemeris_module module~spice_ephemeris_module->module~ephemeris_module proc~transformation_module_test transformation_module_test proc~transformation_module_test->module~jpl_ephemeris_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: name_len = 100 length of name strings Derived Types type, public, abstract :: base_class A base class for defining other classes. Components Type Visibility Attributes Name Initial integer, public :: id = 0 a unique ID code that distinguishes a\nvariable from other variables of the same type. character(len=name_len), public :: name = '' the variable name Type-Bound Procedures generic, public :: operator(==) => base_class_equal generic, public :: operator(/=) => base_class_not_equal procedure, private :: base_class_equal procedure, private :: base_class_not_equal Functions public pure elemental function base_class_equal (b1, b2) result(is_equal) == operator for base_class variables.\nTo be equal, they must be the same type and have the same ID . Arguments Type Intent Optional Attributes Name class( base_class ), intent(in) :: b1 class( base_class ), intent(in) :: b2 Return Value logical public pure elemental function base_class_not_equal (b1, b2) result(not_equal) /= operator for base_class variables.\nTo be equal, they must be the same type and have the same ID . Arguments Type Intent Optional Attributes Name class( base_class ), intent(in) :: b1 class( base_class ), intent(in) :: b2 Return Value logical","tags":"","url":"module/base_class_module.html"},{"title":"geodesy_module – fortran-astrodynamics-toolkit","text":"Geodesy routines. Uses numbers_module kind_module module~~geodesy_module~~UsesGraph module~geodesy_module geodesy_module module~kind_module kind_module module~geodesy_module->module~kind_module module~numbers_module numbers_module module~geodesy_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~geodesy_module~~UsedByGraph module~geodesy_module geodesy_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~geodesy_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public pure function great_circle_distance (r, long1, lat1, long2, lat2) result(d) Author Jacob Williams Date 7/13/2014 Great circle distance on a spherical body, using the Vincenty algorithm. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: r radius of the body [km] real(kind=wp), intent(in) :: long1 longitude of first site [rad] real(kind=wp), intent(in) :: lat1 latitude of the first site [rad] real(kind=wp), intent(in) :: long2 longitude of the second site [rad] real(kind=wp), intent(in) :: lat2 latitude of the second site [rad] Return Value real(kind=wp) great circle distance from 1 to 2 [km] public pure function geocentric_radius (a, b, lat) result(r) The distance from the center of a celestial body (e.g., the Earth) to a point\n  on the spheroid surface at a specified geodetic latitude. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a equatorial radius (km) real(kind=wp), intent(in) :: b polar radius of point (km) real(kind=wp), intent(in) :: lat geodetic latitude of point (rad) Return Value real(kind=wp) distance from center of body to point (km) private pure function solve_polynomial (B, x0, error) result(x) Numerical solution to polynomial equation using Newton-Raphson method Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(0:6) :: B Polynomial B = B(6) x&#94;6 + B(5) x&#94;5 + ... + B(0) real(kind=wp), intent(in) :: x0 Initial point real(kind=wp), intent(in) :: error Maximum error Return Value real(kind=wp) root found after applying Newton-Raphson method to B The function returns the value when the correction\nis smaller than error. Subroutines public pure subroutine heikkinen (rvec, a, b, h, lon, lat) Author Jacob Williams Heikkinen routine for cartesian to geodetic transformation Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: rvec position vector [km] real(kind=wp), intent(in) :: a geoid semimajor axis [km] real(kind=wp), intent(in) :: b geoid semiminor axis [km] real(kind=wp), intent(out) :: h geodetic altitude [km] real(kind=wp), intent(out) :: lon longitude [rad] real(kind=wp), intent(out) :: lat geodetic latitude [rad] public pure subroutine olson (rvec, a, b, h, long, lat) Author Jacob Williams Olson routine for cartesian to geodetic transformation. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: rvec position vector [km] real(kind=wp), intent(in) :: a geoid semimajor axis [km] real(kind=wp), intent(in) :: b geoid semiminor axis [km] real(kind=wp), intent(out) :: h geodetic altitude [km] real(kind=wp), intent(out) :: long longitude [rad] real(kind=wp), intent(out) :: lat geodetic latitude [rad] public  subroutine direct (a, f, glat1, glon1, faz, s, glat2, glon2, baz) Author Jacob Williams Solve the \"direct\" geodetic problem: given the latitude and longitude of one\n  point and the azimuth and distance to a second point, determine the latitude\n  and longitude of that second point.  The solution is obtained using the\n  algorithm by Vincenty. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a semimajor axis of ellipsoid [m] real(kind=wp), intent(in) :: f flattening of ellipsoid [-] real(kind=wp), intent(in) :: glat1 latitude of 1 [rad] real(kind=wp), intent(in) :: glon1 longitude of 1 [rad] real(kind=wp), intent(in) :: faz forward azimuth 1->2 [rad] real(kind=wp), intent(in) :: s distance from 1->2 [m] real(kind=wp), intent(out) :: glat2 latitude of 2 [rad] real(kind=wp), intent(out) :: glon2 longitude of 2 [rad] real(kind=wp), intent(out) :: baz back azimuth 2->1 [rad] public  subroutine geodetic_to_cartesian (a, b, glat, lon, h, r) Author Jacob Williams Geodetic latitude, longitude, and height to Cartesian position vector. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a geoid semimajor axis [km] real(kind=wp), intent(in) :: b geoid semiminor axis [km] real(kind=wp), intent(in) :: glat geodetic latitude [rad] real(kind=wp), intent(in) :: lon longitude [rad] real(kind=wp), intent(in) :: h geodetic altitude [km] real(kind=wp), intent(out), dimension(3) :: r Cartesian position vector [x,y,z] public  subroutine inverse (a, rf, b1, l1, b2, l2, faz, baz, s, it, sig, lam, kind) INVERSE computes the geodetic azimuth and distance between two points,\n  given their geographic positions. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a Equatorial semimajor axis real(kind=wp), intent(in) :: rf reciprocal flattening (1/f) real(kind=wp), intent(in) :: b1 latitude of point 1 (rad, positive north) real(kind=wp), intent(in) :: l1 longitude of point 1 (rad, positive east) real(kind=wp), intent(in) :: b2 latitude of point 2 (rad, positive north) real(kind=wp), intent(in) :: l2 longitude of point 2 (rad, positive east) real(kind=wp), intent(out) :: faz Forward azimuth (rad, clockwise from north) real(kind=wp), intent(out) :: baz Back azimuth (rad, clockwise from north) real(kind=wp), intent(out) :: s Ellipsoidal distance integer, intent(out) :: it iteration count real(kind=wp), intent(out) :: sig spherical distance on auxiliary sphere real(kind=wp), intent(out) :: lam longitude difference on auxiliary sphere integer, intent(out) :: kind solution flag: kind=1, long-line; kind=2, antipodal public  subroutine geodetic_to_cartesian_triaxial (ax, ay, b, phi, lambda, h, r) Function computes the Cartesian coordinates given the\n  geodetic latitude (phi), longitude (lambda) and\n  height (h) of a point related to an ellipsoid\n  defined by its three semiaxes ax, ay and b Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ax semiaxes (0 < b <= ay <= ax) real(kind=wp), intent(in) :: ay semiaxes (0 < b <= ay <= ax) real(kind=wp), intent(in) :: b semiaxes (0 < b <= ay <= ax) real(kind=wp), intent(in) :: phi geodetic latitude (radians) real(kind=wp), intent(in) :: lambda geodetic longitude (radians) real(kind=wp), intent(in) :: h geodetic height real(kind=wp), intent(out), dimension(3) :: r Cartesian position vector [x,y,z] public pure subroutine geodetic_to_cartesian_triaxial_2 (a, b, c, lat, long, h, r) Geodetic to Cartesian for Triaxial Ellipsoid. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: b ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: c ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: lat latitude (rad) real(kind=wp), intent(in) :: long longitude (rad) real(kind=wp), intent(in) :: h altitude real(kind=wp), intent(out), dimension(3) :: r Cartesian coordinates (x,y,z) public  subroutine cartesian_to_geodetic_triaxial (ax, ay, b, r, tol, phi, lambda, h) Function computes the geodetic latitude (phi), longitude (lambda) and\n  height (h) of a point related to an ellipsoid\n  defined by its three semiaxes ax, ay and b (0 < b <= ay <= ax)\n  given Cartesian coordinates Xi, Yi, Zi and tolerance (tol).\n  Latitude and longitude are returned in radians. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ax semiaxes (0 < b <= ay <= ax) real(kind=wp), intent(in) :: ay semiaxes (0 < b <= ay <= ax) real(kind=wp), intent(in) :: b semiaxes (0 < b <= ay <= ax) real(kind=wp), intent(in), dimension(3) :: r Cartesian coordinates (x,y,z) real(kind=wp), intent(in) :: tol tolerance (may be set to zero) real(kind=wp), intent(out) :: phi geodetic latitude (radians) real(kind=wp), intent(out) :: lambda geodetic longitude (radians) real(kind=wp), intent(out) :: h geodetic height private  subroutine bisection_special_2 (cz, Xo, Yo, tol, n, m, Gm) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: cz real(kind=wp), intent(in) :: Xo real(kind=wp), intent(in) :: Yo real(kind=wp), intent(in) :: tol integer, intent(out) :: n real(kind=wp), intent(out) :: m real(kind=wp), intent(out) :: Gm private  subroutine bisection_special_3 (cx, cy, Xo, Yo, Zo, tol, n, m, Hm) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: cx real(kind=wp), intent(in) :: cy real(kind=wp), intent(in) :: Xo real(kind=wp), intent(in) :: Yo real(kind=wp), intent(in) :: Zo real(kind=wp), intent(in) :: tol integer, intent(out) :: n real(kind=wp), intent(out) :: m real(kind=wp), intent(out) :: Hm private  subroutine philambda_quadrant (x, y, z, phi, lambda) Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(inout) :: phi real(kind=wp), intent(inout) :: lambda private  subroutine xyz2philambda (ax, ay, b, x, y, z, phi, lambda) Determination of the geodetic latitude and longitude Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ax real(kind=wp), intent(in) :: ay real(kind=wp), intent(in) :: b real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(inout) :: phi input is initial guess, output is refined values real(kind=wp), intent(inout) :: lambda input is initial guess, output is refined values private  subroutine xyz2fl (ax, ay, b, x, y, z, latitude, longitude) Computes the transformation of Cartesian to geodetic coordinates on the surface of the ellipsoid\nassuming x,y,z are all non-negative\nAngular coordinates in radians Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ax real(kind=wp), intent(in) :: ay real(kind=wp), intent(in) :: b real(kind=wp), intent(in) :: x real(kind=wp), intent(in) :: y real(kind=wp), intent(in) :: z real(kind=wp), intent(out) :: latitude real(kind=wp), intent(out) :: longitude private pure subroutine horner (B, c, BB) Horner's method to compute B(x-c) in terms of B(x) . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(0:6) :: B Polynomial B = B(6) x&#94;6 + B(5) x&#94;5 + ... + B(0) real(kind=wp), intent(in) :: c real(kind=wp), intent(out), dimension(0:6) :: BB Polynomial BB such that B(x-c) = BB(x) public  subroutine CartesianIntoGeodeticI (ax, ay, az, r, latitude, longitude, altitude, error) Cartesian to Geodetic I Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ax semiaxes of the celestial body: ax>ay>az real(kind=wp), intent(in) :: ay semiaxes of the celestial body: ax>ay>az real(kind=wp), intent(in) :: az semiaxes of the celestial body: ax>ay>az real(kind=wp), intent(in), dimension(3) :: r cartesian coordinates of the considered point\nin the first octant: xG, yG, zG with (xG,yG,zG)<>(0,0,0) real(kind=wp), intent(out) :: latitude geodetic coordinates of the considered point real(kind=wp), intent(out) :: longitude geodetic coordinates of the considered point real(kind=wp), intent(out) :: altitude geodetic coordinates of the considered point real(kind=wp), intent(in) :: error Values smaller than error treated as 0.0 public  subroutine CartesianIntoGeodeticII (ax, ay, az, r, latitude, longitude, altitude, error) Cartesian into Geodetic II Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: ax semiaxes of the celestial body: ax>ay>az real(kind=wp), intent(in) :: ay semiaxes of the celestial body: ax>ay>az real(kind=wp), intent(in) :: az semiaxes of the celestial body: ax>ay>az real(kind=wp), intent(in), dimension(3) :: r cartesian coordinates of the considered point\nin the first octant: xG, yG, zG with (xG,yG,zG)<>(0,0,0) real(kind=wp), intent(out) :: latitude geodetic coordinates of the considered point real(kind=wp), intent(out) :: longitude geodetic coordinates of the considered point real(kind=wp), intent(out) :: altitude geodetic coordinates of the considered point real(kind=wp), intent(in) :: error Values smaller than error treated as 0.0 public  subroutine cartesian_to_geodetic_triaxial_2 (a, b, c, r, eps, phi, lambda, h) Cartesian to geodetic for Triaxial Ellipsoid. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: b ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: c ellipsoid radii a >= b >= c real(kind=wp), intent(in), dimension(3) :: r Cartesian coordinates (x,y,z) real(kind=wp), intent(in) :: eps convergence tolerance real(kind=wp), intent(out) :: phi latitude (rad) real(kind=wp), intent(out) :: lambda longitude (rad) real(kind=wp), intent(out) :: h altitude private  subroutine special_cases (a, b, c, x, y, z, phi, lambda, h, done) Special cases for lat/lon/altitude Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: a ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: b ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: c ellipsoid radii a >= b >= c real(kind=wp), intent(in) :: x Cartesian x coordinate real(kind=wp), intent(in) :: y Cartesian y coordinate real(kind=wp), intent(in) :: z Cartesian z coordinate real(kind=wp), intent(out) :: phi latitude (rad) real(kind=wp), intent(out) :: lambda longitude (rad) real(kind=wp), intent(out) :: h altitude logical, intent(out) :: done true if one of the special cases was computed public  subroutine direct_inverse_test () Unit test for the direct and inverse geodetic routines. Arguments None","tags":"","url":"module/geodesy_module.html"},{"title":"rk_module_variable_step – fortran-astrodynamics-toolkit","text":"High-order variable step size Runge-Kutta integration methods. Currently have four methods:\n * Fehlberg 7(8)\n * Fehlberg 8(9)\n * Verner 8(9)\n * Feagin 8(10)\n * Feagin 12(10)\n * Feagin 14(12) Uses numbers_module kind_module module~~rk_module_variable_step~~UsesGraph module~rk_module_variable_step rk_module_variable_step module~kind_module kind_module module~rk_module_variable_step->module~kind_module module~numbers_module numbers_module module~rk_module_variable_step->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~rk_module_variable_step~~UsedByGraph module~rk_module_variable_step rk_module_variable_step module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~rk_module_variable_step Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private pure function norm_func(x) result(xmag) Vector norm function. Must return a value . Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x a vector Return Value real(kind=wp) the magnitude of the vector abstract interface private pure function order_func(me) result(p) Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(in) :: me Return Value integer order of the method abstract interface private  subroutine deriv_func(me, t, x, xdot) derivative function Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t time real(kind=wp), intent(in), dimension(:) :: x state vector real(kind=wp), intent(out), dimension(:) :: xdot derivative of state vector abstract interface private  subroutine event_func(me, t, x, g) event function Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t time real(kind=wp), intent(in), dimension(:) :: x state vector real(kind=wp), intent(out) :: g g(t,x). The goal is to stop the integration when g=0. abstract interface private  subroutine report_func(me, t, x) report function Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t time real(kind=wp), intent(in), dimension(:) :: x state vector abstract interface private  subroutine step_func(me, t, x, h, xf, terr) rk step function Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state vector real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf final state vector real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate Derived Types type, public :: stepsize_class Algorithms for adjusting the step size for variable-step\nRunge-Kutta integrators. Components Type Visibility Attributes Name Initial real(kind=wp), private :: hmax = huge(one) maximum allowed step size real(kind=wp), private :: hmin = two*epsilon(one) minimum allowed step size real(kind=wp), private :: hfactor_reject = 1.0e-3_wp minimum allowed factor for decreasing step size after rejected step real(kind=wp), private :: hfactor_accept = 100.0_wp maximum allowed factor for increasing step size after accepted step integer, private :: accept_mode = 1 method to determine if step is accepted [1,2] integer, private :: max_attempts = 100 maximum number of attempts to decrease step size before giving up logical, private :: relative_err = .false. to use tol*h in the hfactor equation real(kind=wp), private :: safety_factor = 0.9_wp for hfactor equation (>0) integer, private :: p_exponent_offset = 0 p + this value in the exponent (0 or 1) procedure( norm_func ), private, nopass, pointer :: norm => maxval_func routine for computing the norm of the state Type-Bound Procedures procedure, public :: initialize => stepsize_class_constructor procedure, public :: compute_stepsize procedure, public :: destroy => destroy_stepsize_class type, public, abstract :: rk_variable_step_class Main integration class for variable step size Runge-Kutta methods Components Type Visibility Attributes Name Initial integer, private :: n = 0 user specified number of variables procedure( deriv_func ), private, pointer :: f => null() user-specified derivative function procedure( report_func ), private, pointer :: report => null() user-specified report function procedure( event_func ), private, pointer :: g => null() event function (stop when this is zero) class( stepsize_class ), private, allocatable :: stepsize_method the method for varying the step size real(kind=wp), private, dimension(:), allocatable :: rtol relative tolerance ( size(n) ) real(kind=wp), private, dimension(:), allocatable :: atol absolute tolerance ( size(n) ) integer, private :: p = 0 order of the method integer, private :: hinit_method = 1 if automatically computing the inital step size, which\nmethod to use. 1 = hstart , 2 = hinit . integer, private :: num_rejected_steps = 0 number of rejected steps Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) procedure, public :: destroy destructor procedure, public, non_overridable :: integrate main integration routine procedure, public, non_overridable :: integrate_to_event integration with event finding procedure( step_func ), private, deferred :: step the step routine for the rk method procedure( order_func ), private, deferred :: order returns p , the order of the method procedure, private :: hstart for automatically computing the initial step size [this is from DDEABM] procedure, private :: hinit for automatically computing the initial step size [this is from DOP853] type, public, extends( rk_variable_step_class ) :: rkf78_class Runga-Kutta Fehlberg 7(8) method. Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) procedure, public :: destroy destructor procedure, public, non_overridable :: integrate main integration routine procedure, public, non_overridable :: integrate_to_event integration with event finding procedure, public :: step => rkf78 procedure, public :: order => rkf78_order type, public, extends( rk_variable_step_class ) :: rkf89_class Runga-Kutta Fehlberg 8(9) method. Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) procedure, public :: destroy destructor procedure, public, non_overridable :: integrate main integration routine procedure, public, non_overridable :: integrate_to_event integration with event finding procedure, public :: step => rkf89 procedure, public :: order => rkf89_order type, public, extends( rk_variable_step_class ) :: rkv89_class Runga-Kutta Verner 8(9) method. Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) procedure, public :: destroy destructor procedure, public, non_overridable :: integrate main integration routine procedure, public, non_overridable :: integrate_to_event integration with event finding procedure, public :: step => rkv89 procedure, public :: order => rkv89_order type, public, extends( rk_variable_step_class ) :: rkf108_class Runga-Kutta Feagin 8(10) method. Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) procedure, public :: destroy destructor procedure, public, non_overridable :: integrate main integration routine procedure, public, non_overridable :: integrate_to_event integration with event finding procedure, public :: step => rkf108 procedure, public :: order => rkf108_order type, public, extends( rk_variable_step_class ) :: rkf1210_class Runga-Kutta Feagin 12(10) method. Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) procedure, public :: destroy destructor procedure, public, non_overridable :: integrate main integration routine procedure, public, non_overridable :: integrate_to_event integration with event finding procedure, public :: step => rkf1210 procedure, public :: order => rkf1210_order type, public, extends( rk_variable_step_class ) :: rkf1412_class Runga-Kutta Feagin 14(12) method. Type-Bound Procedures procedure, public :: initialize initialize the class (set n,f, and report) procedure, public :: destroy destructor procedure, public, non_overridable :: integrate main integration routine procedure, public, non_overridable :: integrate_to_event integration with event finding procedure, public :: step => rkf1412 procedure, public :: order => rkf1412_order Functions public pure function norm2_func (x) result(xmag) Use intrinsic norm2(x) for computing the vector norm. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Return Value real(kind=wp) public pure function maxval_func (x) result(xmag) Use maxval(abs(x)) for computing the vector norm. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x Return Value real(kind=wp) private pure function rkf78_order (me) result(p) Returns the order of the rkf78 method. Arguments Type Intent Optional Attributes Name class( rkf78_class ), intent(in) :: me Return Value integer order of the method private pure function rkf89_order (me) result(p) Returns the order of the rkf89 method. Arguments Type Intent Optional Attributes Name class( rkf89_class ), intent(in) :: me Return Value integer order of the method private pure function rkv89_order (me) result(p) Returns the order of the rkv89 method. Arguments Type Intent Optional Attributes Name class( rkv89_class ), intent(in) :: me Return Value integer order of the method private pure function rkf108_order (me) result(p) Returns the order of the rkf108 method. Arguments Type Intent Optional Attributes Name class( rkf108_class ), intent(in) :: me Return Value integer order of the method private pure function rkf1210_order (me) result(p) Returns the order of the rkf1210 method. Arguments Type Intent Optional Attributes Name class( rkf1210_class ), intent(in) :: me Return Value integer order of the method private pure function rkf1412_order (me) result(p) Returns the order of the rkf1412 method. Arguments Type Intent Optional Attributes Name class( rkf1412_class ), intent(in) :: me Return Value integer order of the method private  function hinit (me, x, y, posneg, f0, hmax, atol, rtol) computation of an initial step size guess Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: x real(kind=wp), intent(in), dimension(:) :: y dimension(n) real(kind=wp), intent(in) :: posneg posneg = sign(1.0_wp,xend-x) real(kind=wp), intent(in), dimension(:) :: f0 dimension(n) real(kind=wp), intent(in) :: hmax real(kind=wp), intent(in), dimension(:) :: atol real(kind=wp), intent(in), dimension(:) :: rtol Return Value real(kind=wp) Subroutines private pure subroutine stepsize_class_constructor (me, hmin, hmax, hfactor_reject, hfactor_accept, norm, accept_mode, relative_err, safety_factor, p_exponent_offset, max_attempts) Constructor for a stepsize_class . Read more… Arguments Type Intent Optional Attributes Name class( stepsize_class ), intent(inout) :: me real(kind=wp), intent(in), optional :: hmin minimum allowed step size (>0) real(kind=wp), intent(in), optional :: hmax maximum allowed step size (>0) real(kind=wp), intent(in), optional :: hfactor_reject minimum allowed factor for\ndecreasing step size after\nrejected step (>0) real(kind=wp), intent(in), optional :: hfactor_accept maximum allowed factor for\ndecreasing step size after\naccepted step (>0) procedure( norm_func ), optional :: norm the user-specified function integer, intent(in), optional :: accept_mode method to determine if step\nis accepted [1,2] logical, intent(in), optional :: relative_err to use tol*h in the hfactor equation real(kind=wp), intent(in), optional :: safety_factor for hfactor equation (>0) integer, intent(in), optional :: p_exponent_offset p + this value in the exponent (0 or 1) integer, intent(in), optional :: max_attempts max step size change attempts\nafter rejected step private  subroutine destroy_stepsize_class (me) Destructor for stepsize_class . Arguments Type Intent Optional Attributes Name class( stepsize_class ), intent(out) :: me private pure subroutine compute_stepsize (me, h, tol, err, p, hnew, accept) Compute the new step size using the specific method. Arguments Type Intent Optional Attributes Name class( stepsize_class ), intent(in) :: me real(kind=wp), intent(in) :: h current step size (<>0) real(kind=wp), intent(in) :: tol abs error tolerance (>0) real(kind=wp), intent(in) :: err truncation error estimate (>0) integer, intent(in) :: p order of the method real(kind=wp), intent(out) :: hnew new step size (<>0) logical, intent(out) :: accept if the step is accepted private  subroutine initialize (me, n, f, rtol, atol, stepsize_method, hinit_method, report, g) Initialize the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me integer, intent(in) :: n number of equations procedure( deriv_func ) :: f derivative function real(kind=wp), intent(in), dimension(:) :: rtol relative tolerance (if size=1,\nthen same tol used for all\nequations) real(kind=wp), intent(in), dimension(:) :: atol absolute tolerance (if size=1,\nthen same tol used for all\nequations) class( stepsize_class ), intent(in) :: stepsize_method method for varying the step size integer, intent(in), optional :: hinit_method which method to use for\nautomatic initial step size\ncomputation.\n1 = use hstart , 2 = use hinit . procedure( report_func ), optional :: report for reporting the steps procedure( event_func ), optional :: g for stopping at an event private  subroutine destroy (me) Destructor for rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(out) :: me private  subroutine integrate (me, t0, x0, h, tf, xf, ierr) Main integration routine for the rk_variable_step_class . Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(:) :: x0 initial state real(kind=wp), intent(in) :: h initial abs(time step) real(kind=wp), intent(in) :: tf final time real(kind=wp), intent(out), dimension(:) :: xf final state integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. private  subroutine integrate_to_event (me, t0, x0, h, tmax, tol, tf, xf, gf, ierr) Event-finding integration routine for the rk_variable_step_class .\nIntegrates until g(t,x)=0, or until t=tf (whichever happens first). Read more… Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: t0 initial time real(kind=wp), intent(in), dimension(me%n) :: x0 initial state real(kind=wp), intent(in) :: h abs(time step) real(kind=wp), intent(in) :: tmax max final time if event not located real(kind=wp), intent(in) :: tol function tolerance for root finding real(kind=wp), intent(out) :: tf actual final time reached real(kind=wp), intent(out), dimension(me%n) :: xf final state (at tf) real(kind=wp), intent(out) :: gf g value at tf integer, intent(out), optional :: ierr 0 = no errors,\n<0 = error.\nif not present, an error will stop program. private  subroutine rkf78 (me, t, x, h, xf, terr) Fehlberg's 7(8) algorithm. Read more… Arguments Type Intent Optional Attributes Name class( rkf78_class ), intent(inout) :: me real(kind=wp), intent(in) :: t real(kind=wp), intent(in), dimension(me%n) :: x real(kind=wp), intent(in) :: h real(kind=wp), intent(out), dimension(me%n) :: xf real(kind=wp), intent(out), dimension(me%n) :: terr private  subroutine rkf89 (me, t, x, h, xf, terr) Fehlberg 8(9) method. Read more… Arguments Type Intent Optional Attributes Name class( rkf89_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate private  subroutine rkv89 (me, t, x, h, xf, terr) Runge Kutta Verner 8(9) Read more… Arguments Type Intent Optional Attributes Name class( rkv89_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate private  subroutine rkf108 (me, t, x, h, xf, terr) Feagin's RK8(10) method -- a 10th-order method with an embedded 8th-order method. Read more… Arguments Type Intent Optional Attributes Name class( rkf108_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate private  subroutine rkf1210 (me, t, x, h, xf, terr) Feagin's RK12(10) method -- a 12th-order method with an embedded 10th-order method. Read more… Arguments Type Intent Optional Attributes Name class( rkf1210_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate private  subroutine rkf1412 (me, t, x, h, xf, terr) Feagin's RK14(12) - a 14th-order method with an embedded 12th-order method. Read more… Arguments Type Intent Optional Attributes Name class( rkf1412_class ), intent(inout) :: me real(kind=wp), intent(in) :: t initial time real(kind=wp), intent(in), dimension(me%n) :: x initial state real(kind=wp), intent(in) :: h time step real(kind=wp), intent(out), dimension(me%n) :: xf state at time t+h real(kind=wp), intent(out), dimension(me%n) :: terr truncation error estimate private  subroutine hstart (me, a, b, y, yprime, etol, h) Computes a starting step size to be used in solving initial\n  value problems in ordinary differential equations. Read more… Arguments Type Intent Optional Attributes Name class( rk_variable_step_class ), intent(inout) :: me real(kind=wp), intent(in) :: a the initial point of integration. real(kind=wp), intent(in) :: b a value of the independent variable used to define\nthe direction of integration. a reasonable choice is to\nset b to the first point at which a solution is desired.\nyou can also use b , if necessary, to restrict the length\nof the first integration step because the algorithm will\nnot compute a starting step length which is bigger than abs(b-a) , unless b has been chosen too close to a .\n(it is presumed that hstart has been called with b different from a on the machine being used. also see the\ndiscussion about the parameter small .) real(kind=wp), intent(in), dimension(me%n) :: y the vector of initial values of the neq solution\ncomponents at the initial point a . real(kind=wp), intent(in), dimension(me%n) :: yprime the vector of derivatives of the neq solution components at the initial point a .\n(defined by the differential equations in subroutine me%f ) real(kind=wp), intent(in), dimension(me%n) :: etol the vector of error tolerances corresponding to\nthe neq solution components. it is assumed that all\nelements are positive. following the first integration\nstep, the tolerances are expected to be used by the\nintegrator in an error test which roughly requires that abs(local error) <= etol for each vector component. real(kind=wp), intent(out) :: h appropriate starting step size to be attempted by the\ndifferential equation method. public  subroutine step_size_test () Unit tests for step size adjustment routines. Arguments None public  subroutine rk_test_variable_step () Unit test of the rk_module .\nIntegrate a two-body orbit around the Earth. Arguments None","tags":"","url":"module/rk_module_variable_step.html"},{"title":"kind_module – fortran-astrodynamics-toolkit","text":"Define the numeric kinds. Uses iso_fortran_env module~~kind_module~~UsesGraph module~kind_module kind_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~kind_module~~UsedByGraph module~kind_module kind_module module~analytical_ephemeris_module analytical_ephemeris_module module~analytical_ephemeris_module->module~kind_module module~conversion_module conversion_module module~analytical_ephemeris_module->module~conversion_module module~numbers_module numbers_module module~analytical_ephemeris_module->module~numbers_module module~bplane_module bplane_module module~bplane_module->module~kind_module module~bplane_module->module~numbers_module module~vector_module vector_module module~bplane_module->module~vector_module module~brent_module brent_module module~brent_module->module~kind_module module~brent_module->module~numbers_module module~c_interface_module c_interface_module module~c_interface_module->module~kind_module module~geopotential_module geopotential_module module~c_interface_module->module~geopotential_module module~celestial_body_module celestial_body_module module~celestial_body_module->module~kind_module module~celestial_body_module->module~numbers_module module~complex_step_module complex_step_module module~complex_step_module->module~kind_module module~conversion_module->module~kind_module module~conversion_module->module~numbers_module module~crtbp_module crtbp_module module~crtbp_module->module~kind_module module~crtbp_module->module~numbers_module module~drag_module drag_module module~drag_module->module~kind_module module~eispack_module eispack_module module~eispack_module->module~kind_module module~ephemeris_module ephemeris_module module~ephemeris_module->module~kind_module module~ephemeris_module->module~celestial_body_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~kind_module module~fortran_astrodynamics_toolkit->module~analytical_ephemeris_module module~fortran_astrodynamics_toolkit->module~bplane_module module~fortran_astrodynamics_toolkit->module~brent_module module~fortran_astrodynamics_toolkit->module~c_interface_module module~fortran_astrodynamics_toolkit->module~celestial_body_module module~fortran_astrodynamics_toolkit->module~complex_step_module module~fortran_astrodynamics_toolkit->module~conversion_module module~fortran_astrodynamics_toolkit->module~crtbp_module module~fortran_astrodynamics_toolkit->module~drag_module module~fortran_astrodynamics_toolkit->module~eispack_module module~fortran_astrodynamics_toolkit->module~ephemeris_module module~geodesy_module geodesy_module module~fortran_astrodynamics_toolkit->module~geodesy_module module~geometry_module geometry_module module~fortran_astrodynamics_toolkit->module~geometry_module module~fortran_astrodynamics_toolkit->module~geopotential_module module~gooding_module gooding_module module~fortran_astrodynamics_toolkit->module~gooding_module module~gravity_module gravity_module module~fortran_astrodynamics_toolkit->module~gravity_module module~halo_orbit_module halo_orbit_module module~fortran_astrodynamics_toolkit->module~halo_orbit_module module~iau_orientation_module iau_orientation_module module~fortran_astrodynamics_toolkit->module~iau_orientation_module module~jpl_ephemeris_module jpl_ephemeris_module module~fortran_astrodynamics_toolkit->module~jpl_ephemeris_module module~kepler_module kepler_module module~fortran_astrodynamics_toolkit->module~kepler_module module~lambert_module lambert_module module~fortran_astrodynamics_toolkit->module~lambert_module module~lighting_module lighting_module module~fortran_astrodynamics_toolkit->module~lighting_module module~math_module math_module module~fortran_astrodynamics_toolkit->module~math_module module~matrix_module matrix_module module~fortran_astrodynamics_toolkit->module~matrix_module module~minpack_module minpack_module module~fortran_astrodynamics_toolkit->module~minpack_module module~modified_equinoctial_module modified_equinoctial_module module~fortran_astrodynamics_toolkit->module~modified_equinoctial_module module~fortran_astrodynamics_toolkit->module~numbers_module module~obliquity_module obliquity_module module~fortran_astrodynamics_toolkit->module~obliquity_module module~orbital_mechanics_module orbital_mechanics_module module~fortran_astrodynamics_toolkit->module~orbital_mechanics_module module~random_module random_module module~fortran_astrodynamics_toolkit->module~random_module module~relative_motion_module relative_motion_module module~fortran_astrodynamics_toolkit->module~relative_motion_module module~rk_module rk_module module~fortran_astrodynamics_toolkit->module~rk_module module~rk_module_variable_step rk_module_variable_step module~fortran_astrodynamics_toolkit->module~rk_module_variable_step module~standish_module standish_module module~fortran_astrodynamics_toolkit->module~standish_module module~time_module time_module module~fortran_astrodynamics_toolkit->module~time_module module~transformation_module transformation_module module~fortran_astrodynamics_toolkit->module~transformation_module module~fortran_astrodynamics_toolkit->module~vector_module module~geodesy_module->module~kind_module module~geodesy_module->module~numbers_module module~geometry_module->module~kind_module module~geometry_module->module~vector_module module~geopotential_module->module~kind_module module~geopotential_module->module~numbers_module module~gooding_module->module~kind_module module~gooding_module->module~numbers_module module~gravity_module->module~kind_module module~gravity_module->module~numbers_module module~halo_orbit_module->module~kind_module module~halo_orbit_module->module~crtbp_module module~halo_orbit_module->module~numbers_module module~iau_orientation_module->module~kind_module module~iau_orientation_module->module~conversion_module module~iau_orientation_module->module~numbers_module module~jpl_ephemeris_module->module~kind_module module~jpl_ephemeris_module->module~ephemeris_module module~kepler_module->module~kind_module module~kepler_module->module~numbers_module module~lambert_module->module~kind_module module~lambert_module->module~numbers_module module~lambert_module->module~vector_module module~lighting_module->module~kind_module module~lighting_module->module~celestial_body_module module~lighting_module->module~conversion_module module~lighting_module->module~ephemeris_module module~lighting_module->module~math_module module~lighting_module->module~numbers_module module~lighting_module->module~transformation_module module~lighting_module->module~vector_module module~math_module->module~kind_module module~math_module->module~numbers_module module~matrix_module->module~kind_module module~matrix_module->module~numbers_module module~minpack_module->module~kind_module module~minpack_module->module~numbers_module module~modified_equinoctial_module->module~kind_module module~modified_equinoctial_module->module~numbers_module module~modified_equinoctial_module->module~vector_module module~newton_module newton_module module~newton_module->module~kind_module module~newton_module->module~numbers_module module~numbers_module->module~kind_module module~obliquity_module->module~kind_module module~obliquity_module->module~conversion_module module~orbital_mechanics_module->module~kind_module module~orbital_mechanics_module->module~math_module module~orbital_mechanics_module->module~numbers_module module~orbital_mechanics_module->module~vector_module module~random_module->module~kind_module module~relative_motion_module->module~kind_module module~relative_motion_module->module~numbers_module module~rk_module->module~kind_module module~rk_module->module~numbers_module module~rk_module_variable_step->module~kind_module module~rk_module_variable_step->module~numbers_module module~spice_ephemeris_module spice_ephemeris_module module~spice_ephemeris_module->module~kind_module module~spice_ephemeris_module->module~ephemeris_module module~standish_module->module~kind_module module~standish_module->module~celestial_body_module module~standish_module->module~conversion_module module~standish_module->module~ephemeris_module module~standish_module->module~numbers_module module~standish_module->module~time_module module~time_module->module~kind_module module~transformation_module->module~kind_module module~transformation_module->module~celestial_body_module module~transformation_module->module~ephemeris_module module~transformation_module->module~iau_orientation_module module~transformation_module->module~numbers_module module~transformation_module->module~time_module module~transformation_module->module~vector_module module~vector_module->module~kind_module module~vector_module->module~numbers_module proc~calendar_date_to_et calendar_date_to_et proc~calendar_date_to_et->module~conversion_module proc~compute_eigenvalues_and_eigenvectors compute_eigenvalues_and_eigenvectors proc~compute_eigenvalues_and_eigenvectors->module~numbers_module proc~compute_halo_monodromy_matrix compute_halo_monodromy_matrix proc~compute_halo_monodromy_matrix->module~rk_module proc~compute_libration_points compute_libration_points proc~compute_libration_points->module~math_module proc~compute_libration_points_v2 compute_libration_points_v2 proc~compute_libration_points_v2->module~math_module proc~compute_monodromy_matrix_eigenvalues compute_monodromy_matrix_eigenvalues proc~compute_monodromy_matrix_eigenvalues->module~matrix_module proc~compute_real_eigenvalues_and_normalized_eigenvectors compute_real_eigenvalues_and_normalized_eigenvectors proc~compute_real_eigenvalues_and_normalized_eigenvectors->module~numbers_module proc~crtbp_test crtbp_test proc~crtbp_test->module~celestial_body_module proc~cube_root cube_root proc~cube_root->module~numbers_module proc~ephemeris_test ephemeris_test proc~ephemeris_test->module~celestial_body_module proc~ephemeris_test->module~time_module proc~et_to_jd et_to_jd proc~et_to_jd->module~conversion_module proc~from_ijk_to_lvlh_mat from_ijk_to_lvlh_mat proc~from_ijk_to_lvlh_mat->module~vector_module proc~from_ijk_to_rsw_mat from_ijk_to_rsw_mat proc~from_ijk_to_rsw_mat->module~vector_module proc~from_ijk_to_vuw_mat from_ijk_to_vuw_mat proc~from_ijk_to_vuw_mat->module~vector_module proc~from_lvlh_to_ijk_mat from_lvlh_to_ijk_mat proc~from_lvlh_to_ijk_mat->module~vector_module proc~from_rsw_to_ijk_mat from_rsw_to_ijk_mat proc~from_rsw_to_ijk_mat->module~vector_module proc~from_vuw_to_ijk_mat from_vuw_to_ijk_mat proc~from_vuw_to_ijk_mat->module~vector_module proc~geopotential_module_test geopotential_module_test proc~geopotential_module_test->module~conversion_module proc~geopotential_module_test->module~random_module proc~geopotential_module_test->module~vector_module proc~get_c_cdot_ecliptic ecliptic_frame%get_c_cdot_ecliptic proc~get_c_cdot_ecliptic->module~obliquity_module proc~get_r_from_jpl_ephemeris jpl_ephemeris%get_r_from_jpl_ephemeris proc~get_r_from_jpl_ephemeris->module~celestial_body_module proc~get_r_from_jpl_ephemeris->module~conversion_module proc~get_r_from_jpl_ephemeris->module~numbers_module proc~get_r_from_jpl_ephemeris->module~time_module proc~get_r_from_spice_ephemeris spice_ephemeris%get_r_from_spice_ephemeris proc~get_r_from_spice_ephemeris->module~celestial_body_module proc~get_r_from_spice_ephemeris->module~numbers_module proc~get_rv_from_jpl_ephemeris jpl_ephemeris%get_rv_from_jpl_ephemeris proc~get_rv_from_jpl_ephemeris->module~celestial_body_module proc~get_rv_from_jpl_ephemeris->module~conversion_module proc~get_rv_from_jpl_ephemeris->module~numbers_module proc~get_rv_from_jpl_ephemeris->module~time_module proc~get_rv_from_spice_ephemeris spice_ephemeris%get_rv_from_spice_ephemeris proc~get_rv_from_spice_ephemeris->module~celestial_body_module proc~get_rv_from_spice_ephemeris->module~numbers_module proc~halo_orbit_test halo_orbit_test proc~halo_orbit_test->module~celestial_body_module proc~halo_to_rv_diffcorr halo_to_rv_diffcorr proc~halo_to_rv_diffcorr->module~math_module proc~halo_to_rv_diffcorr->module~minpack_module proc~halo_to_rv_diffcorr->module~rk_module proc~iau_rotation_matrix iau_rotation_matrix proc~iau_rotation_matrix->module~vector_module proc~integrate_to_event rk_class%integrate_to_event proc~integrate_to_event->module~brent_module proc~integrate_to_event~2 rk_variable_step_class%integrate_to_event proc~integrate_to_event~2->module~brent_module proc~jd_to_et jd_to_et proc~jd_to_et->module~conversion_module proc~kepler_classical kepler_classical proc~kepler_classical->module~newton_module proc~lambert_test lambert_test proc~lambert_test->module~gooding_module proc~lambert_test->module~random_module proc~rk_test_variable_step rk_test_variable_step proc~rk_test_variable_step->module~conversion_module proc~rk_test_variable_step->module~orbital_mechanics_module proc~transformation_module_test transformation_module_test proc~transformation_module_test->module~jpl_ephemeris_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Variables Type Visibility Attributes Name Initial integer, public, parameter :: wp = real64 real kind used by this module [8 bytes]","tags":"","url":"module/kind_module.html"},{"title":"geometry_module – fortran-astrodynamics-toolkit","text":"Geometry routines. Uses kind_module vector_module module~~geometry_module~~UsesGraph module~geometry_module geometry_module module~kind_module kind_module module~geometry_module->module~kind_module module~vector_module vector_module module~geometry_module->module~vector_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~vector_module->module~kind_module module~numbers_module numbers_module module~vector_module->module~numbers_module module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~geometry_module~~UsedByGraph module~geometry_module geometry_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~geometry_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public pure function distance_from_point_to_line (x1, x2, x) result(d) Author Jacob Williams Date 8/2012 Compute the distance between the point X and the line defined\n  by the two points X1 and X2. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(3) :: x1 real(kind=wp), intent(in), dimension(3) :: x2 real(kind=wp), intent(in), dimension(3) :: x Return Value real(kind=wp) public pure function distance_from_point_to_line_segment (x1, x2, x) result(d) Author Jacob Williams Date 8/2012 Compute the distance between a line segment and a point. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in), dimension(:) :: x1 real(kind=wp), intent(in), dimension(:) :: x2 real(kind=wp), intent(in), dimension(:) :: x Return Value real(kind=wp) public  function distance_from_point_to_path (x0, y0, x, y, n) result(d) Author Jacob Williams Date 8/2012 Compute the distance between a point and a polygonal path.\nGiven a point (x0,y0), and a path (x(n),y(n)), the distance\nto the path is the distance to the closest line segment (x(i),y(i)). Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: y0 real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(in), dimension(n) :: y integer, intent(in) :: n Return Value real(kind=wp) Subroutines public pure subroutine locpt (x0, y0, x, y, n, l, m) given a polygonal line connecting the vertices (x(i),y(i))\n  (i = 1,...,n) taken in this order. it is assumed that the\n  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1))\n  or there is an arc from (x(n),y(n)) to (x(1),y(1)). Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: x0 real(kind=wp), intent(in) :: y0 real(kind=wp), intent(in), dimension(n) :: x real(kind=wp), intent(in), dimension(n) :: y integer, intent(in) :: n integer, intent(out) :: l integer, intent(out) :: m public  subroutine geometry_unit_test () Author Jacob Williams Date 8/2012 Unit test routine Read more… Arguments None","tags":"","url":"module/geometry_module.html"},{"title":"ephemeris_module – fortran-astrodynamics-toolkit","text":"Abstract class for celestial body ephemerides. Uses kind_module celestial_body_module module~~ephemeris_module~~UsesGraph module~ephemeris_module ephemeris_module module~celestial_body_module celestial_body_module module~ephemeris_module->module~celestial_body_module module~kind_module kind_module module~ephemeris_module->module~kind_module module~celestial_body_module->module~kind_module module~base_class_module base_class_module module~celestial_body_module->module~base_class_module module~numbers_module numbers_module module~celestial_body_module->module~numbers_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~ephemeris_module~~UsedByGraph module~ephemeris_module ephemeris_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~ephemeris_module module~jpl_ephemeris_module jpl_ephemeris_module module~fortran_astrodynamics_toolkit->module~jpl_ephemeris_module module~lighting_module lighting_module module~fortran_astrodynamics_toolkit->module~lighting_module module~standish_module standish_module module~fortran_astrodynamics_toolkit->module~standish_module module~transformation_module transformation_module module~fortran_astrodynamics_toolkit->module~transformation_module module~jpl_ephemeris_module->module~ephemeris_module module~lighting_module->module~ephemeris_module module~lighting_module->module~transformation_module module~spice_ephemeris_module spice_ephemeris_module module~spice_ephemeris_module->module~ephemeris_module module~standish_module->module~ephemeris_module module~transformation_module->module~ephemeris_module proc~transformation_module_test transformation_module_test proc~transformation_module_test->module~jpl_ephemeris_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Abstract Interfaces abstract interface private  subroutine rv_func(me, et, targ, obs, rv, status_ok) function to return the state of the targ body relative to\nthe obs body, in the inertial frame [ICRF]. Arguments Type Intent Optional Attributes Name class( ephemeris_class ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(6) :: rv state of targ w.r.t. obs logical, intent(out) :: status_ok true if there were no problems abstract interface private  subroutine r_func(me, et, targ, obs, r, status_ok) function to return the position of the targ body relative to\nthe obs body, in the inertial frame [ICRF]. Arguments Type Intent Optional Attributes Name class( ephemeris_class ), intent(inout) :: me real(kind=wp), intent(in) :: et ephemeris time [sec] type( celestial_body ), intent(in) :: targ target body type( celestial_body ), intent(in) :: obs observer body real(kind=wp), intent(out), dimension(3) :: r position vector of targ w.r.t. obs logical, intent(out) :: status_ok true if there were no problems Derived Types type, public, abstract :: ephemeris_class abstract class for interfacing with ephemeris systems. Type-Bound Procedures procedure( rv_func ), public, deferred :: get_rv get the state of one body w.r.t. another body. procedure( r_func ), public, deferred :: get_r get the position of one body w.r.t. another body.","tags":"","url":"module/ephemeris_module.html"},{"title":"bplane_module – fortran-astrodynamics-toolkit","text":"B-plane and hyperbolic routines. Uses numbers_module kind_module vector_module module~~bplane_module~~UsesGraph module~bplane_module bplane_module module~kind_module kind_module module~bplane_module->module~kind_module module~numbers_module numbers_module module~bplane_module->module~numbers_module module~vector_module vector_module module~bplane_module->module~vector_module iso_fortran_env iso_fortran_env module~kind_module->iso_fortran_env module~numbers_module->module~kind_module module~vector_module->module~kind_module module~vector_module->module~numbers_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Used by module~~bplane_module~~UsedByGraph module~bplane_module bplane_module module~fortran_astrodynamics_toolkit fortran_astrodynamics_toolkit module~fortran_astrodynamics_toolkit->module~bplane_module Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Functions public pure function hyperbolic_turning_angle (e) result(delta) Author Jacob Williams Date 3/6/2016 Compute the hyperbolic turning angle from the eccentricity. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: e eccentricity [--] Return Value real(kind=wp) turning angle [rad] public pure function vinf_to_energy (vinfmag) result(energy) Author Jacob Williams Date 3/6/2016 Convert V-infinity magnitude to energy. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: vinfmag vector magnitude [km/s] Return Value real(kind=wp) two-body orbital energy [km&#94;2/s&#94;2] Subroutines public  subroutine bplane (mu, rv, vinfvec, bmag, theta, BdotT, BdotR, status_ok) Compute B-plane parameters from position and velocity. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu central body grav parameter real(kind=wp), intent(in), dimension(6) :: rv state vector (km,km/s) real(kind=wp), intent(out), dimension(3) :: vinfvec incoming V-infinity vector (km/s) real(kind=wp), intent(out) :: bmag magnitude of B vector (km) real(kind=wp), intent(out) :: theta aim point orientation [rad] real(kind=wp), intent(out) :: BdotT (km) real(kind=wp), intent(out) :: BdotR (km) logical, intent(out) :: status_ok false if there were errors (non-hyperbolic or degenerate state) public  subroutine calculate_bplane_data (mu, state, bdotr, bdott, bmag, theta, istat) Compute B-plane parameters from position and velocity -- alternate version. Read more… Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu central body grav parameter real(kind=wp), intent(in), dimension(6) :: state state vector (km,km/s) real(kind=wp), intent(out) :: bdotr (km) real(kind=wp), intent(out) :: bdott (km) real(kind=wp), intent(out) :: bmag magnitude of B vector (km) real(kind=wp), intent(out) :: theta aim point orientation [rad] integer, intent(out) :: istat status flag: Read more… private  subroutine compute_vinf_vectors (mu, rv, vinfin, vinfout) Compute the incoming and/or outgoing v-infinity vectors, given\nthe position and velocity of a hyperbola. Arguments Type Intent Optional Attributes Name real(kind=wp), intent(in) :: mu central body gravitational parameter real(kind=wp), intent(in), dimension(6) :: rv position,velocity vector real(kind=wp), intent(out), optional, dimension(3) :: vinfin incoming v-infinity vector real(kind=wp), intent(out), optional, dimension(3) :: vinfout outgoing v-infinity vector public  subroutine bplane_test () Unit test for bplane_module . Arguments None","tags":"","url":"module/bplane_module.html"},{"title":"random_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~random_module.f90~~EfferentGraph sourcefile~random_module.f90 random_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~random_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~random_module.f90~~AfferentGraph sourcefile~random_module.f90 random_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~random_module.f90 sourcefile~geopotential_module.f90 geopotential_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geopotential_module.f90 sourcefile~lambert_module.f90 lambert_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lambert_module.f90 sourcefile~c_interface_module.f90 c_interface_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~c_interface_module.f90 sourcefile~geopotential_module.f90->sourcefile~random_module.f90 sourcefile~lambert_module.f90->sourcefile~random_module.f90 sourcefile~c_interface_module.f90->sourcefile~geopotential_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Random number generation. module random_module use kind_module , only : wp implicit none private !public routines: public :: get_random_number contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Returns a uniform random number `x`, such that: `a <= x < b`. function get_random_number ( a , b ) result ( x ) implicit none real ( wp ) :: x real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ) :: b call random_number ( x ) x = a + ( b - a ) * x end function get_random_number !***************************************************************************************** !***************************************************************************************** end module random_module !*****************************************************************************************","tags":"","url":"sourcefile/random_module.f90.html"},{"title":"standish_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~standish_module.f90~~EfferentGraph sourcefile~standish_module.f90 standish_module.f90 sourcefile~base_class_module.f90 base_class_module.f90 sourcefile~standish_module.f90->sourcefile~base_class_module.f90 sourcefile~celestial_body_module.f90 celestial_body_module.f90 sourcefile~standish_module.f90->sourcefile~celestial_body_module.f90 sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~standish_module.f90->sourcefile~conversion_module.f90 sourcefile~ephemeris_module.f90 ephemeris_module.f90 sourcefile~standish_module.f90->sourcefile~ephemeris_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~standish_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~standish_module.f90->sourcefile~numbers_module.f90 sourcefile~time_module.f90 time_module.f90 sourcefile~standish_module.f90->sourcefile~time_module.f90 sourcefile~celestial_body_module.f90->sourcefile~base_class_module.f90 sourcefile~celestial_body_module.f90->sourcefile~kind_module.f90 sourcefile~celestial_body_module.f90->sourcefile~numbers_module.f90 sourcefile~conversion_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 sourcefile~ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~time_module.f90->sourcefile~conversion_module.f90 sourcefile~time_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~standish_module.f90~~AfferentGraph sourcefile~standish_module.f90 standish_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~standish_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Approximate positions of the major planets. ! !### See also !  * [[analytical_ephemeris_module]] -- analytical ephemeris for Earth's Moon. ! !### Reference !  * E.M. Standish, Solar System Dynamics Group, JPL/Caltech, !    \"[Keplerian Elements for Approximate Positions of the Major Planets](http://ssd.jpl.nasa.gov/txt/aprx_pos_planets.pdf)\" ! !### History !  * Original version copyright 2018 [https://github.com/CumuloEpsilon](CumuloEpsilon) !    [BSD License](https://github.com/CumuloEpsilon/Standish-Ephemeris). !  * Jacob Williams, extensive refactoring with some modifications, !    and integration into the FAT ephemeris module. ! !### Original license ! !``` !   Copyright (c) 2018, CumuloEpsilon !   All rights reserved. ! !   Redistribution and use in source and binary forms, with or without !   modification, are permitted provided that the following conditions are met: ! !   * Redistributions of source code must retain the above copyright notice, this !     list of conditions and the following disclaimer. ! !   * Redistributions in binary form must reproduce the above copyright notice, !     this list of conditions and the following disclaimer in the documentation !     and/or other materials provided with the distribution. ! !   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" !   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE !   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE !   DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE !   FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL !   DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR !   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER !   CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, !   OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE !   OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. !``` module standish_module use celestial_body_module use kind_module , only : wp use conversion_module , only : deg2rad , rad2deg , year2day ,& day2sec , au2m , m2km , day2century use numbers_module , only : zero , one , two , twopi use ephemeris_module , only : ephemeris_class use time_module , only : et_to_jd use base_class_module , only : base_class implicit none private type , extends ( ephemeris_class ), public :: standish_ephemeris !! Standish ephemeris class for computing the !! approximate positions of the major planets. contains procedure , public :: get_rv => standish_rv_func procedure , public :: get_r => standish_r_func end type standish_ephemeris ! constants real ( wp ), parameter :: obliquity = 2 3.43928_wp !! obliquity at J2000 [deg] real ( wp ), parameter :: s_sobl = sin ( obliquity * deg2rad ) !! sin of j2000 obliquity real ( wp ), parameter :: s_cobl = cos ( obliquity * deg2rad ) !! cos of j2000 obliquity real ( wp ), parameter :: epoch = 245154 5.0_wp !! Julian date of J2000 epoch type , extends ( base_class ) :: ephem !! an ephemeris defined using a date range !! and a set of elements from the reference. !! !! There are two that can be used. !! !!@note This should probably be merged into [[standish_ephemeris]] real ( wp ), dimension ( 2 ) :: jd_range = zero !! valid julian date range real ( wp ), dimension ( 16 , 9 ) :: o = zero !! keplerian elements terms end type ephem !> !  The first ephemeris data table (this is standish's table 1). !  keplerian elements valid 1800 ad - 2050 ad type ( ephem ), parameter :: eph1 = ephem ( 1 ,& ! id 'Keplerian Elements Valid 1800AD-2050AD' ,& ! name [ 237849 7.0_wp , 247017 2.0_wp ],& ! jd range reshape ([ & ! element table (in au and radians). perturbations are zero. 0.38709927_wp , 0.20563594_wp , 0.12225995_wp , 4.4025989_wp , 1.3518935_wp , & 0.84353095_wp , 3.70000009e-07_wp , 1.90600003e-05_wp , - 1.03803286e-04_wp , & 260 8.7903_wp , 2.80085020e-03_wp , - 2.18760967e-03_wp , 0.0_wp , & 0.0_wp , 0.0_wp , 0.0_wp , 0.72333568_wp , 6.77671982e-03_wp , & 5.92482723e-02_wp , 3.1761343_wp , 2.2968962_wp , 1.3383157_wp , 3.90000014e-06_wp , & - 4.10700013e-05_wp , - 1.37689030e-05_wp , 102 1.3286_wp , 4.68322469e-05_wp , - & 4.84667765e-03_wp , 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , & 1.0000026_wp , 1.67112295e-02_wp , - 2.67209913e-07_wp , 1.7534375_wp , & 1.7966015_wp , 0.0_wp , 5.62000014e-06_wp , - 4.39200012e-05_wp , - & 2.25962198e-04_wp , 62 8.30756_wp , 5.64218918e-03_wp , 0.0_wp , 0.0_wp , & 0.0_wp , 0.0_wp , 0.0_wp , 1.5237104_wp , 9.33941007e-02_wp , & 3.22832055e-02_wp , - 7.94723779e-02_wp , - 0.41789517_wp , 0.86497712_wp , & 1.84700002e-05_wp , 7.88199977e-05_wp , - 1.41918135e-04_wp , 33 4.06131_wp , & 7.75643345e-03_wp , - 5.10636950e-03_wp , 0.0_wp , 0.0_wp , & 0.0_wp , 0.0_wp , 5.2028871_wp , 4.83862385e-02_wp , 2.27660220e-02_wp , & 0.60033119_wp , 0.25706047_wp , 1.7536005_wp , - 1.16069998e-04_wp , - & 1.32529996e-04_wp , - 3.20641411e-05_wp , 5 2.966312_wp , 3.70929041e-03_wp , & 3.57253314e-03_wp , 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , & 9.5366764_wp , 5.38617894e-02_wp , 4.33887430e-02_wp , 0.87186599_wp , & 1.6161553_wp , 1.9837835_wp , - 1.25059998e-03_wp , - 5.09909994e-04_wp , & 3.37911442e-05_wp , 2 1.336540_wp , - 7.31244357e-03_wp , - 5.03838016e-03_wp , & 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , 1 9.189165_wp , & 4.72574383e-02_wp , 1.34850740e-02_wp , 5.4670362_wp , 2.9837148_wp , 1.2918390_wp , & - 1.96175999e-03_wp , - 4.39700016e-05_wp , - 4.24008576e-05_wp , 7.4784222_wp , & 7.12186471e-03_wp , 7.40122399e-04_wp , 0.0_wp , 0.0_wp , 0.0_wp , & 0.0_wp , 3 0.069923_wp , 8.59048031e-03_wp , 3.08930874e-02_wp , - & 0.96202600_wp , 0.78478318_wp , 2.3000686_wp , 2.62910005e-04_wp , & 5.10499995e-05_wp , 6.17357864e-06_wp , 3.8128369_wp , - 5.62719675e-03_wp , - & 8.87786155e-05_wp , 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , & 3 9.482117_wp , 0.24882729_wp , 0.29914966_wp , 4.1700983_wp , 3.9107401_wp , & 1.9251670_wp , - 3.15960002e-04_wp , 5.17000008e-05_wp , 8.40899645e-07_wp , & 2.5343544_wp , - 7.09117157e-04_wp , - 2.06556579e-04_wp , 0.0_wp , & 0.0_wp , 0.0_wp , 0.0_wp ], [ 16 , 9 ])& ) !> !  The first ephemeris data table (this is standish's table 2). !  keplerian elements valid 3000 bc - 3000 ad type ( ephem ), parameter :: eph2 = ephem ( 2 ,& ! id 'Keplerian Elements Valid 3000BC-3000AD' ,& ! name [ 62567 4.0_wp , 281678 8.0_wp ],& ! jd range reshape ([ & ! element table (in au and radians). perturbations are not zero. 0.38709843_wp , 0.20563661_wp , 0.12227069_wp , 4.4026222_wp , 1.3518922_wp , & 0.84368551_wp , 0.0_wp , 2.12300001e-05_wp , - 1.03002007e-04_wp , & 260 8.7903_wp , 2.78205727e-03_wp , - 2.13177688e-03_wp , 0.0_wp , & 0.0_wp , 0.0_wp , 0.0_wp , 0.72332102_wp , 6.76399004e-03_wp , & 5.93023673e-02_wp , 3.1761451_wp , 2.2997777_wp , 1.3381896_wp , - & 2.60000007e-07_wp , - 5.10700011e-05_wp , 7.59113527e-06_wp , 102 1.3286_wp , & 9.91285546e-04_wp , - 4.76024114e-03_wp , 0.0_wp , 0.0_wp , & 0.0_wp , 0.0_wp , 1.0000002_wp , 1.67316291e-02_wp , - & 9.48516663e-06_wp , 1.7534785_wp , 1.7964685_wp , - 8.92317668e-02_wp , - & 2.99999989e-08_wp , - 3.66099994e-05_wp , - 2.33381579e-04_wp , 62 8.30762_wp , & 5.54932002e-03_wp , - 4.21040738e-03_wp , 0.0_wp , 0.0_wp , & 0.0_wp , 0.0_wp , 1.5237124_wp , 9.33651105e-02_wp , 3.23203318e-02_wp , & - 7.97289312e-02_wp , - 0.41743821_wp , 0.86765921_wp , 9.69999974e-07_wp , & 9.14900011e-05_wp , - 1.26493964e-04_wp , 33 4.06125_wp , 7.89301097e-03_wp , - & 4.68663359e-03_wp , 0.0_wp , 0.0_wp , 0.0_wp , 0.0_wp , & 5.2024803_wp , 4.85358983e-02_wp , 2.26650927e-02_wp , 0.59925520_wp , & 0.24914493_wp , 1.7504400_wp , - 2.86400009e-05_wp , 1.80260002e-04_wp , - & 5.63216017e-05_wp , 5 2.969063_wp , 3.17635899e-03_wp , 2.27322499e-03_wp , - & 2.17328397e-06_wp , 1.05837814e-03_wp , - 6.21955749e-03_wp , 0.66935557_wp , & 9.5414991_wp , 5.55082485e-02_wp , 4.35327180e-02_wp , 0.87398607_wp , & 1.6207365_wp , 1.9833919_wp , - 3.06500006e-05_wp , - 3.20440013e-04_wp , & 7.88834659e-05_wp , 2 1.329931_wp , 9.45610274e-03_wp , - 4.36594151e-03_wp , & 4.52022823e-06_wp , - 2.34475732e-03_wp , 1.52402408e-02_wp , 0.66935557_wp , & 1 9.187979_wp , 4.68574017e-02_wp , 1.34910680e-02_wp , 5.4838729_wp , 3.0095420_wp , & 1.2908891_wp , - 2.04550000e-04_wp , - 1.54999998e-05_wp , - 3.14429781e-05_wp , & 7.4786506_wp , 1.61739404e-03_wp , 1.00176642e-03_wp , 1.01806800e-05_wp , - & 1.70574244e-02_wp , 3.08735552e-03_wp , 0.13387112_wp , 3 0.069527_wp , & 8.95438995e-03_wp , 3.08932904e-02_wp , 5.3096914_wp , 0.81474739_wp , & 2.3001058_wp , 6.44699976e-05_wp , 8.17999990e-06_wp , 3.90953755e-06_wp , & 3.8129361_wp , 1.76267436e-04_wp , - 1.05819658e-04_wp , - 7.21658762e-06_wp , & 1.19286822e-02_wp , - 1.77369907e-03_wp , 0.13387112_wp , 3 9.486862_wp , & 0.24885239_wp , 0.29916763_wp , 4.1707320_wp , 3.9112310_wp , 1.9251275_wp , & 4.49750992e-03_wp , 6.01600004e-05_wp , 8.74410020e-08_wp , 2.5338767_wp , - & 1.69092222e-04_wp , - 1.41368364e-04_wp , - 2.20386923e-04_wp , 0.0_wp , & 0.0_wp , 0.0_wp ], [ 16 , 9 ])& ) type ( ephem ), dimension ( 2 ), parameter :: eph_set = [ eph1 , eph2 ] !! the set of [[ephem]] options !! that are available. public :: standish_module_test ! unit test contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 3/4/2018 ! !  Convert the NAIF SPICE ID code to the one used by the standish ephemeris. !  Returns `0` if the body was not found. ! !### See also !  * [[spice_id_to_old_id]] pure function spice_id_to_standish_id ( spice_id ) result ( old_id ) implicit none integer , intent ( in ) :: spice_id !! the ID code used by SPICE integer :: old_id !! the ID code used by this module integer :: i !! counter !> !  The index of this array is the ID code. The value is the NAIF code. !  See: [NAIF Integer ID codes](http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/req/naif_ids.html) integer , parameter , dimension ( 9 ) :: new_ids = & [ 199 ,& ! mercury 299 ,& ! venus 3 , & ! earth-moon barycenter 499 ,& ! mars 599 ,& ! jupiter 699 ,& ! saturn 799 ,& ! uranus 899 ,& ! neptune 999 ] ! pluto !just a simple search of the list: ! [small enough that bisection search probably not worth it] do i = 1 , size ( new_ids ) if ( new_ids ( i ) == spice_id ) then old_id = i return end if end do !not found: old_id = 0 end function spice_id_to_standish_id !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 3/4/2018 ! !  Return the state of the `targ` body relative to !  the `obs` body, in the inertial frame [ICRF]. ! !  This is the function that can be used in the [[ephemeris_class]]. subroutine standish_rv_func ( me , et , targ , obs , rv , status_ok ) implicit none class ( standish_ephemeris ), intent ( inout ) :: me real ( wp ), intent ( in ) :: et !! ephemeris time [sec] type ( celestial_body ), intent ( in ) :: targ !! target body type ( celestial_body ), intent ( in ) :: obs !! observer body real ( wp ), dimension ( 6 ), intent ( out ) :: rv !! state of targ w.r.t. obs [km, km/s] logical , intent ( out ) :: status_ok !! true if there were no problems real ( wp ) :: jd integer :: itbl_targ , itbl_obs integer :: itarg integer :: iobs real ( wp ), dimension ( 6 ) :: targ_rv_au real ( wp ), dimension ( 6 ) :: obs_rv_au real ( wp ), dimension ( 6 ) :: rv_ecliptic integer , parameter :: naif_id_sun = 10 !! NAIF ID for the Sun if ( targ == obs ) then rv = zero return end if jd = et_to_jd ( et ) if ( targ % id == naif_id_sun ) then itarg = - 1 ! dummy else itarg = spice_id_to_standish_id ( targ % id ) end if if ( obs % id == naif_id_sun ) then iobs = - 1 ! dummy else iobs = spice_id_to_standish_id ( obs % id ) end if if ( itarg == 0 . or . iobs == 0 ) then ! if the bodies were not found in this ephemeris rv = zero status_ok = . false . else if ( targ % id /= naif_id_sun ) then ! targ w.r.t sun [j2000 ecliptic] call helio ( itarg , jd , targ_rv_au , itbl_targ ) else targ_rv_au = zero itbl_targ = 3 ! dummy value end if if ( obs % id /= naif_id_sun ) then ! obs w.r.t sun [j2000 ecliptic] call helio ( iobs , jd , obs_rv_au , itbl_obs ) else obs_rv_au = zero itbl_obs = 3 ! dummy value end if if ( itbl_targ > 0 . and . itbl_obs > 0 ) then ! vector from obs to targ [j2000 ecliptic] rv_ecliptic = targ_rv_au - obs_rv_au ! convert to ICRF: call ec2eq ( rv_ecliptic , rv ) ! Convert to km, km/s: rv = rv * au2m * m2km rv ( 4 : 6 ) = rv ( 4 : 6 ) / ( year2day * day2sec ) status_ok = . true . else ! out of range of the ephemeris: rv = zero status_ok = . false . end if end if end subroutine standish_rv_func !***************************************************************************************** !***************************************************************************************** !> !  Return the position of the `targ` body relative to !  the `obs` body, in the inertial frame [ICRF]. ! !  This is the function that can be used in the [[ephemeris_class]]. subroutine standish_r_func ( me , et , targ , obs , r , status_ok ) implicit none class ( standish_ephemeris ), intent ( inout ) :: me real ( wp ), intent ( in ) :: et !! ephemeris time [sec] type ( celestial_body ), intent ( in ) :: targ !! target body type ( celestial_body ), intent ( in ) :: obs !! observer body real ( wp ), dimension ( 3 ), intent ( out ) :: r !! position of targ w.r.t. obs [km] logical , intent ( out ) :: status_ok !! true if there were no problems real ( wp ), dimension ( 6 ) :: rv !! full state vector [km, km/s] call me % get_rv ( et , targ , obs , rv , status_ok ) if ( status_ok ) then r = rv ( 1 : 3 ) !! position of targ w.r.t. obs [km] else r = zero end if end subroutine standish_r_func !***************************************************************************************** !***************************************************************************************** !> !  For planet np and julian date jd and using using table `itbl`, !  return j2000 ecliptic position (au) and velocity (au/yr). !  in cartesian coordinates (p(1)-p(6)). pure subroutine helio ( np , jd , p , itbl ) implicit none integer , intent ( in ) :: np !! planet 1-9 real ( wp ), intent ( in ) :: jd !! julian date real ( wp ), dimension ( 6 ), intent ( out ) :: p !! position (au)/velocity (au/yr) integer , intent ( out ) :: itbl !! table used or error if zero real ( wp ), dimension ( 8 ) :: z !! elements [a, e, i, l, w, o, ma, ea] real ( wp ), dimension ( 8 ) :: po z = zero po = zero itbl = tbl ( jd ) if ( itbl > 0 ) then call calcelements ( np , jd , itbl , z ) call el2op ( z , po ) call op2ec ( z , po , p ) end if end subroutine helio !***************************************************************************************** !***************************************************************************************** !> !  solve kepler's equation ma = ea + ec*sin(ea) pure real ( wp ) function kepler ( ma , ec ) implicit none real ( wp ), intent ( in ) :: ma !! eccentricity real ( wp ), intent ( in ) :: ec !! mean anomaly in rad real ( wp ) :: r , ea integer :: i ! acceptable accuracy for this calculation real ( wp ), parameter :: tol = 1.0e-08_wp !! max error in eccentric anomaly `ea` in rad integer , parameter :: maxit = 12 !! max iterations (1-4 typical for `ec<0.3`) ea = ma + ec * sin ( ma ) ! starting value do i = 1 , maxit ! newton(-raphson) iterations r = ( ma - ea + ec * sin ( ea )) / ( one - ec * cos ( ea )) ea = ea + r if ( abs ( r ) <= tol ) exit end do kepler = modulo ( ea , twopi ) ! eccentric anomaly adjusted 0-2pi end function kepler !***************************************************************************************** !***************************************************************************************** !> !  Determine which data set to use for highest accuracy for the given julian date. ! !@note There was a typo in the original routine. ! !@note Assumes that [[eph_set]] has only two elements. pure function tbl ( jd ) result ( itbl ) implicit none real ( wp ), intent ( in ) :: jd !! julian date (eg 2451545.0) integer :: itbl !! Which data set to use: !! !! * itbl=1 jd in range of table 1 !!   (1800ad-2050ad) - highest accuracy !! * itbl=2 jd outside range of table 1 !!   but in range of table 2 (3000bc-3000ad) !! * itbl=0 3000bc<jd or jd>3000ad  julian !!   date out of range for ephemeris. if (( jd > eph_set ( 1 )% jd_range ( 1 )) . and . ( jd < eph_set ( 1 )% jd_range ( 2 ))) then itbl = 1 else if (( jd > eph_set ( 2 )% jd_range ( 1 )) . and . ( jd < eph_set ( 2 )% jd_range ( 2 ))) then itbl = 2 else itbl = 0 end if end if end function tbl !***************************************************************************************** !***************************************************************************************** !> !  Calculate current elements `z(jd)` for planet `j` from jpl data pure subroutine calcelements ( np , jd , itbl , z ) implicit none integer , intent ( in ) :: np !! planet number (1-9) integer , intent ( in ) :: itbl !! which table to use (1-2) real ( wp ), intent ( in ) :: jd !! julian date real ( wp ), dimension ( 8 ), intent ( out ) :: z !! elements for `jd` !! !!  * a = semi major axis (au) !!  * e = eccentricity (rad) !!  * i = inclination (rad) !!  * l = mean longitude (rad) !!  * w = longitude of perihelion (rad) !!  * o = longitude of ascending mode (rad) !!  * ma = mean anomaly (rad) !!  * ea = eccentric anomaly (rad) integer :: i !! counter real ( wp ) :: t !! centuries since epoch real ( wp ) :: tz !! perturbation term t = ( jd - epoch ) * day2century do i = 1 , 6 ! a,e,i,l,w,o z ( i ) = eph_set ( itbl )% o ( i , np ) + eph_set ( itbl )% o ( i + 6 , np ) * t ! if (i>2) z(i) = modulo(z(i), twopi)  !optional scaling end do if ( itbl == 2 ) then ! perturbation term nonzero for planets 5-9 if table 2 used tz = eph_set ( itbl )% o ( 13 , np ) * t ** 2 + & eph_set ( itbl )% o ( 14 , np ) * cos ( eph_set ( itbl )% o ( 16 , np ) * t ) + & eph_set ( itbl )% o ( 15 , np ) * sin ( eph_set ( itbl )% o ( 16 , np ) * t ) else tz = zero end if z ( 7 ) = modulo (( z ( 4 ) - z ( 5 ) + tz ), twopi ) ! mean anomaly z ( 8 ) = kepler ( z ( 7 ), z ( 2 )) ! eccentric anomaly end subroutine calcelements !***************************************************************************************** !***************************************************************************************** !> !  heliocentric coordinates for orbital plane from elements pure subroutine el2op ( z , po ) implicit none real ( wp ), dimension ( 8 ), intent ( in ) :: z !! elements [a,e,i,l,w,o,ma,ea] real ( wp ), dimension ( 6 ), intent ( out ) :: po !! coordinates and velocities real ( wp ) :: v , s1 , c1 , s2 ! heliocentric orbital plane po = zero s1 = sin ( z ( 8 )) c1 = cos ( z ( 8 )) s2 = sqrt ( one - z ( 2 ) * z ( 2 )) v = twopi / ( sqrt ( z ( 1 )) * ( one - z ( 2 ) * c1 )) ! velocity au/yr po ( 1 ) = z ( 1 ) * ( c1 - z ( 2 )) ! xp (plane of orbit) po ( 2 ) = z ( 1 ) * s1 * s2 ! yp po ( 4 ) = - v * s1 ! vxp po ( 5 ) = v * c1 * s2 ! vyp end subroutine el2op !***************************************************************************************** !***************************************************************************************** !> !  heliocentric coordinates j2000 ecliptic plane from orbital plane pure subroutine op2ec ( z , po , pe ) implicit none real ( wp ), dimension ( 8 ), intent ( in ) :: z !! elements a,e,i,l,w,o,ma,ea real ( wp ), dimension ( 6 ), intent ( in ) :: po !! orbital plane coordinates real ( wp ), dimension ( 6 ), intent ( out ) :: pe !! j2000 ecliptic plane coordinates real ( wp ) :: s1 , s2 , s3 , c1 , c2 , c3 ! heliocentric au, au/yr s1 = sin ( z ( 5 ) - z ( 6 )) s2 = sin ( z ( 3 )) s3 = sin ( z ( 6 )) c1 = cos ( z ( 5 ) - z ( 6 )) c2 = cos ( z ( 3 )) c3 = cos ( z ( 6 )) pe ( 1 ) = ( c1 * c3 - s1 * s3 * c2 ) * po ( 1 ) - ( s1 * c3 + c1 * s3 * c2 ) * po ( 2 ) ! xec pe ( 2 ) = ( c1 * s3 + s1 * c3 * c2 ) * po ( 1 ) - ( s1 * s3 - c1 * c3 * c2 ) * po ( 2 ) ! yec pe ( 3 ) = s1 * s2 * po ( 1 ) + c1 * s2 * po ( 2 ) ! zec pe ( 4 ) = ( c1 * c3 - s1 * s3 * c2 ) * po ( 4 ) - ( s1 * c3 + c1 * s3 * c2 ) * po ( 5 ) ! vxec pe ( 5 ) = ( c1 * s3 + s1 * c3 * c2 ) * po ( 4 ) - ( s1 * s3 - c1 * c3 * c2 ) * po ( 5 ) ! vyec pe ( 6 ) = s1 * s2 * po ( 4 ) + c1 * s2 * po ( 5 ) ! vzec end subroutine op2ec !***************************************************************************************** !***************************************************************************************** !> !  converts cartesian heliocentric j2000 ecliptic to equatorial pure subroutine ec2eq ( pe , pq ) implicit none real ( wp ), dimension ( 6 ), intent ( in ) :: pe !! ecliptic real ( wp ), dimension ( 6 ), intent ( out ) :: pq !! equatorial pq ( 1 ) = pe ( 1 ) ! xeq same as xec pq ( 2 ) = s_cobl * pe ( 2 ) - s_sobl * pe ( 3 ) ! yeq pq ( 3 ) = s_sobl * pe ( 2 ) + s_cobl * pe ( 3 ) ! zeq pq ( 4 ) = pe ( 4 ) ! vxeq same as vxec pq ( 5 ) = s_cobl * pe ( 5 ) - s_sobl * pe ( 6 ) ! vyeq pq ( 6 ) = s_sobl * pe ( 5 ) + s_cobl * pe ( 6 ) ! vzeq end subroutine ec2eq !***************************************************************************************** ! the following two aren't used: !***************************************************************************************** !> !  converts cartesian heliocentric equatorial to ecliptic pure subroutine eq2ec ( pq , pe ) implicit none real ( wp ), dimension ( 6 ), intent ( out ) :: pe !! ecliptic real ( wp ), dimension ( 6 ), intent ( in ) :: pq !! equatorial pe ( 1 ) = pq ( 1 ) ! xec same as xeq pe ( 2 ) = s_cobl * pq ( 2 ) + s_sobl * pq ( 3 ) ! yec pe ( 3 ) = - s_sobl * pq ( 2 ) + s_cobl * pq ( 3 ) ! zec pe ( 4 ) = pq ( 4 ) ! vxec same as vxeq pe ( 5 ) = s_cobl * pq ( 5 ) + s_sobl * pq ( 6 ) ! vyec pe ( 6 ) = - s_sobl * pq ( 5 ) + s_cobl * pq ( 6 ) ! vzec end subroutine eq2ec !***************************************************************************************** !***************************************************************************************** !> !  cartesian to spherical coordinates (angles in radians) pure subroutine sphere ( x , y , z , rho , theta , phi ) implicit none real ( wp ), intent ( in ) :: x !! x = r cos(phi) cos (theta) real ( wp ), intent ( in ) :: y !! y = r cos(phi) sin(theta) real ( wp ), intent ( in ) :: z !! z = r sin(phi) real ( wp ), intent ( out ) :: rho !! distance real ( wp ), intent ( out ) :: theta !! longitude real ( wp ), intent ( out ) :: phi !! latitude real ( wp ) :: r theta = zero phi = zero rho = sqrt ( x * x + y * y + z * z ) r = sqrt ( x * x + y * y ) if ( r /= zero ) then theta = modulo ( atan2 ( y , x ), twopi ) phi = atan2 ( z , r ) end if end subroutine sphere !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 3/4/2018 ! !  Test routine for the standish_module routines. subroutine standish_module_test () implicit none type ( standish_ephemeris ) :: eph real ( wp ) :: et !! ephemeris time (sec) real ( wp ) :: jd !! julian date real ( wp ), dimension ( 6 ) :: rv !! state of targ w.r.t. obs logical :: status_ok !! true if there were no problems integer :: itbl !> !  State of Earth w.r.t. Sun from SPICE !  See: http://wgc.jpl.nasa.gov:8080/webgeocalc/#NewCalculation real ( wp ), dimension ( 6 ), parameter :: rv_from_spice = [ - 2650257 6.96907434_wp ,& 13275417 6.58943012_wp ,& 5755579 3.70952077_wp ,& - 2 9.78644078_wp ,& - 5.02614568_wp ,& - 2.17905509_wp ] write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' standish_module_test' write ( * , * ) '---------------' write ( * , * ) '' et = 0.0_wp ! J2000 ! get earth w.r.t. sun in J2000 frame: call eph % get_rv ( et , body_earth_moon_barycenter , body_sun , rv , status_ok ) if ( status_ok ) then write ( * , * ) '' write ( * , * ) 'State of Earth wrt Sun @ J2000' write ( * , '(A,1X,*(E26.16,1X))' ) 'standish:' , rv write ( * , '(A,1X,*(E26.16,1X))' ) 'SPICE:   ' , rv_from_spice write ( * , '(A,1X,*(E26.16,1X))' ) 'diff:    ' , rv - rv_from_spice write ( * , * ) '' else error stop 'error calling standish_ephemeris' end if ! low-level routine tests: write ( * , * ) 'helio:' jd = et_to_jd ( et ) call helio ( 3 , jd , rv , itbl ) write ( * , * ) '' write ( * , * ) 'State of Earth wrt Sun [ecliptic]' write ( * , '(*(E26.16,1X))' ) rv write ( * , * ) '' end subroutine standish_module_test !***************************************************************************************** !***************************************************************************************** end module standish_module !*****************************************************************************************","tags":"","url":"sourcefile/standish_module.f90.html"},{"title":"obliquity_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~obliquity_module.f90~~EfferentGraph sourcefile~obliquity_module.f90 obliquity_module.f90 sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~obliquity_module.f90->sourcefile~conversion_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~obliquity_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~obliquity_module.f90~~AfferentGraph sourcefile~obliquity_module.f90 obliquity_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~obliquity_module.f90 sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~transformation_module.f90 sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 sourcefile~transformation_module.f90->sourcefile~obliquity_module.f90 sourcefile~lighting_module.f90->sourcefile~transformation_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  For computing the obliquity of the ecliptic. ! !### Notes !  * Mean obliquity does not include the short-period terms !    due to nutation. True obliquity includes these terms. module obliquity_module use conversion_module use kind_module implicit none private abstract interface pure function mean_obliquity_func ( et ) result ( e ) !! a function for computing the mean obliquity of the ecliptic. import :: wp implicit none real ( wp ), intent ( in ) :: et !! ephemeris time (sec) real ( wp ) :: e !! obliquity of ecliptic (deg) end function mean_obliquity_func end interface public :: mean_ecliptic_to_equatorial_rotmat public :: equatorial_to_mean_ecliptic_rotmat public :: mean_obliquity_of_ecliptic_iau1980 public :: mean_obliquity_of_ecliptic_iau2006 contains !***************************************************************************************** !***************************************************************************************** !> !  Rotation matrix from Mean Ecliptic to J2000. ! !### Reference ! * https://en.wikipedia.org/wiki/Ecliptic_coordinate_system pure function mean_ecliptic_to_equatorial_rotmat ( obliquity_func ) result ( rot ) implicit none real ( wp ), dimension ( 3 , 3 ) :: rot !! rotation matrix procedure ( mean_obliquity_func ), optional :: obliquity_func !! optional function to compute !! the mean obliquity. If not !! present, then !! [[mean_obliquity_of_ecliptic_iau1980]] !! is used. real ( wp ) :: e !! mean obliquity at J2000 (rad) real ( wp ) :: s , c if ( present ( obliquity_func )) then e = obliquity_func ( 0.0_wp ) else e = mean_obliquity_of_ecliptic_iau1980 ( 0.0_wp ) end if e = e * deg2rad s = sin ( e ) c = cos ( e ) rot (:, 1 ) = [ 1.0_wp , 0.0_wp , 0.0_wp ] rot (:, 2 ) = [ 0.0_wp , c , s ] rot (:, 3 ) = [ 0.0_wp , - s , c ] end function mean_ecliptic_to_equatorial_rotmat !***************************************************************************************** !***************************************************************************************** !> !  Rotation matrix from J2000 to Mean Ecliptic. pure function equatorial_to_mean_ecliptic_rotmat ( obliquity_func ) result ( rot ) implicit none real ( wp ), dimension ( 3 , 3 ) :: rot !! rotation matrix procedure ( mean_obliquity_func ), optional :: obliquity_func !! optional function to compute !! the mean obliquity. If not !! present, then !! [[mean_obliquity_of_ecliptic_iau1980]] !! is used. rot = transpose ( mean_ecliptic_to_equatorial_rotmat ( obliquity_func )) end function equatorial_to_mean_ecliptic_rotmat !***************************************************************************************** !***************************************************************************************** !> !  Mean obliquity of the ecliptic, IAU 2006 formula. pure function mean_obliquity_of_ecliptic_iau2006 ( et ) result ( e ) implicit none real ( wp ), intent ( in ) :: et !! ephemeris time (sec) real ( wp ) :: e !! obliquity of ecliptic (deg) real ( wp ) :: t !! time in centuries from the J2000 epoch real ( wp ), parameter , dimension ( 6 ) :: c = [ 8438 1.406_wp ,& - 4 6.836769_wp ,& - 0.0001831_wp ,& 0.00200340_wp ,& - 0.000000576_wp ,& - 0.0000000434_wp ] !! coefficients ! convert input time to centuries: t = et * sec2day * day2century ! use horner's rule: e = ( c ( 1 ) + t * ( c ( 2 ) + t * ( c ( 3 ) + t * ( c ( 4 ) + t * ( c ( 5 ) + t * c ( 6 )))))) * arcsec2deg end function mean_obliquity_of_ecliptic_iau2006 !***************************************************************************************** !***************************************************************************************** !> !  Mean obliquity of the ecliptic, IAU 1980 formula. ! !@note This equation is consistent with the one from the SPICE `zzmobliq` routine. pure function mean_obliquity_of_ecliptic_iau1980 ( et ) result ( e ) implicit none real ( wp ), intent ( in ) :: et !! ephemeris time (sec) real ( wp ) :: e !! obliquity of ecliptic (deg) real ( wp ) :: t !! time in centuries from the J2000 epoch real ( wp ), dimension ( 0 : 3 ), parameter :: c = [ 8438 1.448_wp ,& - 4 6.8150_wp ,& - 0.00059_wp ,& + 0.001813_wp ] !! coefficients ! convert input time to centuries: t = et * sec2day * day2century ! use horner's rule: e = ( c ( 0 ) + t * ( c ( 1 ) + t * ( c ( 2 ) + t * c ( 3 )))) * arcsec2deg end function mean_obliquity_of_ecliptic_iau1980 !***************************************************************************************** !***************************************************************************************** end module obliquity_module !*****************************************************************************************","tags":"","url":"sourcefile/obliquity_module.f90.html"},{"title":"newton_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~newton_module.f90~~EfferentGraph sourcefile~newton_module.f90 newton_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~newton_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~newton_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~newton_module.f90~~AfferentGraph sourcefile~newton_module.f90 newton_module.f90 sourcefile~kepler_module.f90 kepler_module.f90 sourcefile~kepler_module.f90->sourcefile~newton_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~kepler_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  Basic Newton solver. module newton_module use kind_module , only : wp use numbers_module implicit none private public :: newton abstract interface subroutine func ( x , f ) !! interface for the function and derivative import :: wp implicit none real ( wp ), intent ( in ) :: x real ( wp ), intent ( out ) :: f end subroutine func end interface contains !******************************************************************************* !******************************************************************************* !> !  Newton's method for root finding of scalar function f(x) subroutine newton ( x , f , dfdx , ftol , xtol , max_iter , xs , fx , iflag ) implicit none real ( wp ), intent ( in ) :: x !! initial point (initial guess) procedure ( func ) :: f !! function f(x) procedure ( func ) :: dfdx !! first derivative function f'(x) real ( wp ), intent ( in ) :: ftol !! convergence tolerance for f(x) real ( wp ), intent ( in ) :: xtol !! convergence tolerance for x integer , intent ( in ) :: max_iter !! the maximum number of iterations real ( wp ), intent ( out ) :: xs !! the value where f(x) is zero real ( wp ), intent ( out ) :: fx !! the value of f(x) at the root xs integer , intent ( out ) :: iflag !! status flag: !!  0 : absolute convergence in f !!  1 : relative convergence in x !! -1 : Error: derivative is zero !! -2 : Error: max iterations exceeded real ( wp ) :: f1 , df1 , x1 , x1_prev integer :: iter real ( wp ), parameter :: alpha = one !! step factor x1 = x do iter = 1 , max_iter call f ( x1 , f1 ) if ( abs ( f1 ) <= ftol ) then iflag = 0 exit end if call dfdx ( x1 , df1 ) if ( df1 == zero ) then iflag = - 1 exit end if x1_prev = x1 x1 = x1 - alpha * ( f1 / df1 ) if ( abs ( x1_prev - x1 ) <= xtol ) then iflag = 1 exit end if end do ! max iterations exceeded if ( iter > max_iter ) iflag = - 2 !return results: xs = x1 fx = f1 end subroutine newton !******************************************************************************* !******************************************************************************* end module newton_module !*******************************************************************************","tags":"","url":"sourcefile/newton_module.f90.html"},{"title":"fortran_astrodynamics_toolkit.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~fortran_astrodynamics_toolkit.f90~~EfferentGraph sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~analytical_ephemeris_module.f90 analytical_ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~analytical_ephemeris_module.f90 sourcefile~base_class_module.f90 base_class_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~base_class_module.f90 sourcefile~bplane_module.f90 bplane_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~bplane_module.f90 sourcefile~brent_module.f90 brent_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~brent_module.f90 sourcefile~c_interface_module.f90 c_interface_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~c_interface_module.f90 sourcefile~celestial_body_module.f90 celestial_body_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~celestial_body_module.f90 sourcefile~complex_step.f90 complex_step.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~complex_step.f90 sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~conversion_module.f90 sourcefile~crtbp_module.f90 crtbp_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~crtbp_module.f90 sourcefile~drag_module.f90 drag_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~drag_module.f90 sourcefile~eispack_module.f90 eispack_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~eispack_module.f90 sourcefile~ephemeris_module.f90 ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~ephemeris_module.f90 sourcefile~geodesy_module.f90 geodesy_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geodesy_module.f90 sourcefile~geometry_module.f90 geometry_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geometry_module.f90 sourcefile~geopotential_module.f90 geopotential_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geopotential_module.f90 sourcefile~gooding_module.f90 gooding_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~gooding_module.f90 sourcefile~gravity_module.f90 gravity_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~gravity_module.f90 sourcefile~halo_orbit_module.f90 halo_orbit_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~halo_orbit_module.f90 sourcefile~iau_orientation_module.f90 iau_orientation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~iau_orientation_module.f90 sourcefile~jpl_ephemeris_module.f90 jpl_ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~kepler_module.f90 kepler_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~kepler_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~kind_module.f90 sourcefile~lambert_module.f90 lambert_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lambert_module.f90 sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 sourcefile~math_module.f90 math_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~math_module.f90 sourcefile~matrix_module.f90 matrix_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~matrix_module.f90 sourcefile~minpack_module.f90 minpack_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~minpack_module.f90 sourcefile~modified_equinoctial_module.f90 modified_equinoctial_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~modified_equinoctial_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~numbers_module.f90 sourcefile~obliquity_module.f90 obliquity_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~obliquity_module.f90 sourcefile~orbital_mechanics_module.f90 orbital_mechanics_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~orbital_mechanics_module.f90 sourcefile~random_module.f90 random_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~random_module.f90 sourcefile~relative_motion_module.f90 relative_motion_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~relative_motion_module.f90 sourcefile~rk_module.f90 rk_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~rk_module.f90 sourcefile~rk_module_variable_step.f90 rk_module_variable_step.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~rk_module_variable_step.f90 sourcefile~standish_module.f90 standish_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~standish_module.f90 sourcefile~string_module.f90 string_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~string_module.f90 sourcefile~time_module.f90 time_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~time_module.f90 sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~transformation_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~vector_module.f90 sourcefile~analytical_ephemeris_module.f90->sourcefile~conversion_module.f90 sourcefile~analytical_ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~analytical_ephemeris_module.f90->sourcefile~numbers_module.f90 sourcefile~bplane_module.f90->sourcefile~kind_module.f90 sourcefile~bplane_module.f90->sourcefile~numbers_module.f90 sourcefile~bplane_module.f90->sourcefile~vector_module.f90 sourcefile~brent_module.f90->sourcefile~kind_module.f90 sourcefile~brent_module.f90->sourcefile~numbers_module.f90 sourcefile~c_interface_module.f90->sourcefile~geopotential_module.f90 sourcefile~c_interface_module.f90->sourcefile~kind_module.f90 sourcefile~celestial_body_module.f90->sourcefile~base_class_module.f90 sourcefile~celestial_body_module.f90->sourcefile~kind_module.f90 sourcefile~celestial_body_module.f90->sourcefile~numbers_module.f90 sourcefile~complex_step.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 sourcefile~crtbp_module.f90->sourcefile~celestial_body_module.f90 sourcefile~crtbp_module.f90->sourcefile~kind_module.f90 sourcefile~crtbp_module.f90->sourcefile~math_module.f90 sourcefile~crtbp_module.f90->sourcefile~numbers_module.f90 sourcefile~drag_module.f90->sourcefile~kind_module.f90 sourcefile~eispack_module.f90->sourcefile~kind_module.f90 sourcefile~eispack_module.f90->sourcefile~numbers_module.f90 sourcefile~ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~geodesy_module.f90->sourcefile~kind_module.f90 sourcefile~geodesy_module.f90->sourcefile~numbers_module.f90 sourcefile~geometry_module.f90->sourcefile~kind_module.f90 sourcefile~geometry_module.f90->sourcefile~vector_module.f90 sourcefile~geopotential_module.f90->sourcefile~conversion_module.f90 sourcefile~geopotential_module.f90->sourcefile~kind_module.f90 sourcefile~geopotential_module.f90->sourcefile~numbers_module.f90 sourcefile~geopotential_module.f90->sourcefile~random_module.f90 sourcefile~geopotential_module.f90->sourcefile~vector_module.f90 sourcefile~gooding_module.f90->sourcefile~kind_module.f90 sourcefile~gooding_module.f90->sourcefile~numbers_module.f90 sourcefile~gravity_module.f90->sourcefile~kind_module.f90 sourcefile~gravity_module.f90->sourcefile~numbers_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~celestial_body_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~crtbp_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~kind_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~math_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~matrix_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~minpack_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~numbers_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~rk_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~conversion_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~kind_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~numbers_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~vector_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~conversion_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~numbers_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~time_module.f90 sourcefile~kepler_module.f90->sourcefile~kind_module.f90 sourcefile~kepler_module.f90->sourcefile~numbers_module.f90 sourcefile~newton_module.f90 newton_module.f90 sourcefile~kepler_module.f90->sourcefile~newton_module.f90 sourcefile~lambert_module.f90->sourcefile~gooding_module.f90 sourcefile~lambert_module.f90->sourcefile~kind_module.f90 sourcefile~lambert_module.f90->sourcefile~numbers_module.f90 sourcefile~lambert_module.f90->sourcefile~random_module.f90 sourcefile~lambert_module.f90->sourcefile~vector_module.f90 sourcefile~lighting_module.f90->sourcefile~celestial_body_module.f90 sourcefile~lighting_module.f90->sourcefile~conversion_module.f90 sourcefile~lighting_module.f90->sourcefile~ephemeris_module.f90 sourcefile~lighting_module.f90->sourcefile~kind_module.f90 sourcefile~lighting_module.f90->sourcefile~math_module.f90 sourcefile~lighting_module.f90->sourcefile~numbers_module.f90 sourcefile~lighting_module.f90->sourcefile~transformation_module.f90 sourcefile~lighting_module.f90->sourcefile~vector_module.f90 sourcefile~math_module.f90->sourcefile~kind_module.f90 sourcefile~math_module.f90->sourcefile~numbers_module.f90 sourcefile~matrix_module.f90->sourcefile~kind_module.f90 sourcefile~matrix_module.f90->sourcefile~numbers_module.f90 sourcefile~minpack_module.f90->sourcefile~kind_module.f90 sourcefile~minpack_module.f90->sourcefile~numbers_module.f90 sourcefile~modified_equinoctial_module.f90->sourcefile~kind_module.f90 sourcefile~modified_equinoctial_module.f90->sourcefile~numbers_module.f90 sourcefile~modified_equinoctial_module.f90->sourcefile~vector_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~obliquity_module.f90->sourcefile~conversion_module.f90 sourcefile~obliquity_module.f90->sourcefile~kind_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~kind_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~math_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~numbers_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~vector_module.f90 sourcefile~random_module.f90->sourcefile~kind_module.f90 sourcefile~relative_motion_module.f90->sourcefile~kind_module.f90 sourcefile~relative_motion_module.f90->sourcefile~numbers_module.f90 sourcefile~relative_motion_module.f90->sourcefile~vector_module.f90 sourcefile~rk_module.f90->sourcefile~brent_module.f90 sourcefile~rk_module.f90->sourcefile~kind_module.f90 sourcefile~rk_module.f90->sourcefile~numbers_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~brent_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~conversion_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~kind_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~numbers_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~orbital_mechanics_module.f90 sourcefile~standish_module.f90->sourcefile~base_class_module.f90 sourcefile~standish_module.f90->sourcefile~celestial_body_module.f90 sourcefile~standish_module.f90->sourcefile~conversion_module.f90 sourcefile~standish_module.f90->sourcefile~ephemeris_module.f90 sourcefile~standish_module.f90->sourcefile~kind_module.f90 sourcefile~standish_module.f90->sourcefile~numbers_module.f90 sourcefile~standish_module.f90->sourcefile~time_module.f90 sourcefile~time_module.f90->sourcefile~conversion_module.f90 sourcefile~time_module.f90->sourcefile~kind_module.f90 sourcefile~transformation_module.f90->sourcefile~celestial_body_module.f90 sourcefile~transformation_module.f90->sourcefile~ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~iau_orientation_module.f90 sourcefile~transformation_module.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~kind_module.f90 sourcefile~transformation_module.f90->sourcefile~numbers_module.f90 sourcefile~transformation_module.f90->sourcefile~obliquity_module.f90 sourcefile~transformation_module.f90->sourcefile~time_module.f90 sourcefile~transformation_module.f90->sourcefile~vector_module.f90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 sourcefile~newton_module.f90->sourcefile~kind_module.f90 sourcefile~newton_module.f90->sourcefile~numbers_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams !  license: BSD ! !  The main module that uses all the other modules. !  Allows for a single `use fortran_astrodynamics_toolkit` !  to access the entire library. module fortran_astrodynamics_toolkit use analytical_ephemeris_module use base_class_module use bplane_module use brent_module use celestial_body_module use complex_step_module use conversion_module use crtbp_module use drag_module use eispack_module use ephemeris_module use geodesy_module use geometry_module use geopotential_module use gooding_module use gravity_module use halo_orbit_module use iau_orientation_module use jpl_ephemeris_module use kepler_module use kind_module use lambert_module use lighting_module use math_module use matrix_module use minpack_module use modified_equinoctial_module use numbers_module use obliquity_module use orbital_mechanics_module use random_module use relative_motion_module use rk_module use rk_module_variable_step use standish_module use string_module use time_module use transformation_module use vector_module use c_interface_module implicit none public private :: wp integer , parameter , public :: fat_wp = wp !! default real kind end module fortran_astrodynamics_toolkit !*****************************************************************************************","tags":"","url":"sourcefile/fortran_astrodynamics_toolkit.f90.html"},{"title":"complex_step.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~complex_step.f90~~EfferentGraph sourcefile~complex_step.f90 complex_step.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~complex_step.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~complex_step.f90~~AfferentGraph sourcefile~complex_step.f90 complex_step.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~complex_step.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Complex-step differentiation routines. ! !# See also !  1. J.R.R.A. Martins, P. Sturdza, J.J. Alonso, !     \"The Complex-Step Derivative Approximation\", !     ACM Transactions on Mathematical Software, !     Vol. 29, No. 3, September 2003, Pages 245262. module complex_step_module use kind_module , only : wp implicit none private interface function func ( x ) result ( f ) import :: wp implicit none complex ( wp ), intent ( in ) :: x complex ( wp ) :: f end function func end interface public :: complex_step_derivative public :: complex_step_test !for testing contains !***************************************************************************************** !***************************************************************************************** !> !  Compute the first derivative using the complex-step method. !  This is Equation 6 from Reference [1]. subroutine complex_step_derivative ( f , x , h , dfdx ) implicit none procedure ( func ) :: f complex ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: h real ( wp ), intent ( out ) :: dfdx dfdx = AIMAG ( f ( cmplx ( real ( x , wp ), AIMAG ( x ) + h , wp ))) / h end subroutine complex_step_derivative !***************************************************************************************** !***************************************************************************************** !> !  Compute the first derivative using a forward difference. !  This is Equation 1 from Reference [1]. subroutine forward_diff ( f , x , h , dfdx ) implicit none procedure ( func ) :: f complex ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: h real ( wp ), intent ( out ) :: dfdx dfdx = ( f ( x + h ) - f ( x )) / h end subroutine forward_diff !***************************************************************************************** !***************************************************************************************** !> !  Compute the first derivative using a 2-point central difference [-h,h]. subroutine central_diff ( f , x , h , dfdx ) implicit none procedure ( func ) :: f complex ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: h real ( wp ), intent ( out ) :: dfdx dfdx = ( f ( x + h ) - f ( x - h )) / ( 2.0_wp * h ) end subroutine central_diff !***************************************************************************************** !***************************************************************************************** !> !  Compute the first derivative using a 4-point central difference [-2h,-h,h,2h]. subroutine central_diff_4 ( f , x , h , dfdx ) implicit none procedure ( func ) :: f complex ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: h real ( wp ), intent ( out ) :: dfdx real ( wp ) :: h2 h2 = 2.0_wp * h dfdx = ( f ( x - h2 ) - 8.0_wp * f ( x - h ) + 8.0_wp * f ( x + h ) - f ( x + h2 )) / ( 1 2.0_wp * h ) end subroutine central_diff_4 !***************************************************************************************** !***************************************************************************************** !> !  Unit test for the complex_step module. subroutine complex_step_test () implicit none integer :: i complex ( wp ) :: x real ( wp ) :: h , dfdx , dfdx2 , dfdx3 , dfdx4 , err , err2 , err3 , err4 write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' complex_step_test' write ( * , * ) '---------------' write ( * , * ) '' x = cmplx ( 2.0_wp , 0.0_wp , wp ) h = 1.0e-10_wp call complex_step_derivative ( test_func , x , h , dfdx ) !write(*,*) '' !write(*,*) 'x     :',x !write(*,*) 'dfdx  :',dfdx !write(*,*) 'error :',real(test_deriv(x),wp) - dfdx !write(*,*) '' write ( * , '(*(A30))' ) 'h' , 'forward diff err' , 'central diff err' , 'central diff 4 err' , 'complex step err' do i = 1 , 200 h = 1 0.0_wp ** ( - i / 1 0.0_wp ) call complex_step_derivative ( test_func , x , h , dfdx ) call forward_diff ( test_func , x , h , dfdx2 ) call central_diff ( test_func , x , h , dfdx3 ) call central_diff_4 ( test_func , x , h , dfdx4 ) err = real ( test_deriv ( x ), wp ) - dfdx err2 = real ( test_deriv ( x ), wp ) - dfdx2 err3 = real ( test_deriv ( x ), wp ) - dfdx3 err4 = real ( test_deriv ( x ), wp ) - dfdx4 write ( * , '(*(E30.16,1X))' ) h , err2 , err3 , err4 , err end do contains !***************************************************************************************** !**************************************** function test_func ( x ) result ( f ) implicit none complex ( wp ), intent ( in ) :: x complex ( wp ) :: f f = exp ( x ) + sin ( x ) end function test_func !**************************************** !**************************************** function test_deriv ( x ) result ( f ) implicit none complex ( wp ), intent ( in ) :: x complex ( wp ) :: f f = exp ( x ) + cos ( x ) end function test_deriv !**************************************** end subroutine complex_step_test !***************************************************************************************** !***************************************************************************************** end module complex_step_module !*****************************************************************************************","tags":"","url":"sourcefile/complex_step.f90.html"},{"title":"gravity_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~gravity_module.f90~~EfferentGraph sourcefile~gravity_module.f90 gravity_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~gravity_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~gravity_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~gravity_module.f90~~AfferentGraph sourcefile~gravity_module.f90 gravity_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~gravity_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Gravity model ! !### See also !  * [[geopotential_module]] module gravity_module use kind_module use numbers_module use iso_fortran_env , only : output_unit implicit none private public :: third_body_gravity public :: third_body_gravity_alt public :: gravity_j2_j3_j4 contains !***************************************************************************************** !***************************************************************************************** !> !  Third-body (pointmass) gravitational acceleration. subroutine third_body_gravity ( r , rb , mu , acc ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r !! satellite position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: rb !! third-body position vector [km] real ( wp ), intent ( in ) :: mu !! third-body gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( out ) :: acc !! gravity acceleration vector [km/s&#94;2] real ( wp ), dimension ( 3 ) :: r_sc_b !! vector from third-body to spacecraft [km] real ( wp ) :: rb_mag !! distance between origin and third-body [km] real ( wp ) :: r_sc_b_mag !! distance between spacecraft and third-body [km] r_sc_b = rb - r r_sc_b_mag = norm2 ( r_sc_b ) rb_mag = norm2 ( rb ) acc = ( mu / r_sc_b_mag ** 3 ) * r_sc_b - ( mu / rb_mag ** 3 ) * rb end subroutine third_body_gravity !***************************************************************************************** !***************************************************************************************** !> !  Third-body (pointmass) gravitational acceleration (alternate Battin formulation). !  See Equation 8.61 in Battin. subroutine third_body_gravity_alt ( r , rb , mu , acc ) real ( wp ), dimension ( 3 ), intent ( in ) :: r !! satellite position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: rb !! third-body position vector [km] real ( wp ), intent ( in ) :: mu !! third-body gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( out ) :: acc !! gravity acceleration vector [km/s&#94;2] real ( wp ) :: rb2 , q , f , tmp rb2 = dot_product ( rb , rb ) q = dot_product ( r , r - two * rb ) / rb2 tmp = ( one + q ) ** 1.5_wp f = q * ( three + three * q + q * q ) / ( one + tmp ) acc = - mu * ( r + f * rb ) / tmp / rb2 ** 1.5_wp end subroutine third_body_gravity_alt !***************************************************************************************** !***************************************************************************************** !> !  Gravitational acceleration due to simplified spherical harmonic !  expansion (only the J2-J4 terms are used). ! !### Reference !  * http://www.ni.com/pdf/manuals/370762a.pdf subroutine gravity_j2_j3_j4 ( r , mu , req , j2 , j3 , j4 , acc ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r !! satellite position vector [km] real ( wp ), intent ( in ) :: mu !! central body gravitational parameter [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: req !! body equatorial radius [km] real ( wp ), intent ( in ) :: j2 !! j2 coefficient real ( wp ), intent ( in ) :: j3 !! j3 coefficient real ( wp ), intent ( in ) :: j4 !! j4 coefficient real ( wp ), dimension ( 3 ), intent ( out ) :: acc !! gravity acceleration vector [km/s&#94;2] real ( wp ) :: mmor3 , reqor , reqor2 , reqor3 , reqor4 ,& rmag , rmag2 , rmag3 , rzor , rzor2 , rzor3 , rzor4 , c , d rmag2 = dot_product ( r , r ) rmag = sqrt ( rmag2 ) if ( rmag == zero ) then write ( output_unit , '(A)' ) 'Error in gravity_j2_j3_j4: spacecraft at center of body.' acc = zero else rmag3 = rmag * rmag2 mmor3 = - mu / rmag3 reqor = req / rmag reqor2 = reqor * reqor reqor3 = reqor2 * reqor reqor4 = reqor3 * reqor rzor = r ( 3 ) / rmag rzor2 = rzor * rzor rzor3 = rzor2 * rzor rzor4 = rzor3 * rzor c = mmor3 * ( 1.0_wp - 1.5_wp * J2 * reqor2 * ( 5.0_wp * rzor2 - 1.0_wp ) + & 2.5_wp * J3 * reqor3 * ( 3.0_wp * rzor - 7.0_wp * rzor3 ) - & 0.625_wp * J4 * reqor4 * ( 3.0_wp - 4 2.0_wp * rzor2 + 6 3.0_wp * rzor4 )) d = mmor3 * ( r ( 3 ) + 1.5_wp * J2 * reqor2 * ( 3.0_wp - 5.0_wp * rzor2 ) * r ( 3 ) + & 0.5_wp * J3 * reqor3 * ( 3 0.0_wp * rzor * r ( 3 ) - 3 5.0_wp * rzor3 * r ( 3 ) - 3.0_wp * rmag ) - & 0.625_wp * J4 * reqor4 * ( 1 5.0_wp - 7 0.0_wp * rzor2 + 6 3.0_wp * rzor4 ) * r ( 3 )) acc ( 1 ) = c * r ( 1 ) acc ( 2 ) = c * r ( 2 ) acc ( 3 ) = d end if end subroutine gravity_J2_J3_J4 !***************************************************************************************** !***************************************************************************************** end module gravity_module !*****************************************************************************************","tags":"","url":"sourcefile/gravity_module.f90.html"},{"title":"modified_equinoctial_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~modified_equinoctial_module.f90~~EfferentGraph sourcefile~modified_equinoctial_module.f90 modified_equinoctial_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~modified_equinoctial_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~modified_equinoctial_module.f90->sourcefile~numbers_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~modified_equinoctial_module.f90->sourcefile~vector_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~modified_equinoctial_module.f90~~AfferentGraph sourcefile~modified_equinoctial_module.f90 modified_equinoctial_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~modified_equinoctial_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 11/27/2015 ! !  Modified equinoctial elements routines. ! !  The modified equinoctial elements are applicable to all orbits !  and have non-singular equations of motion (except for a singularity !  at  i = \\pi  ). They are defined as: ! !   \\begin{array}{rcl} !      p & = & a (1 - e&#94;2) \\\\ !      f & = & e \\cos (\\omega + \\Omega) \\\\ !      g & = & e \\sin (\\omega + \\Omega)  \\\\ !      h & = & \\tan (i/2) \\cos \\Omega \\\\ !      k & = & \\tan (i/2) \\sin \\Omega \\\\ !      L & = & \\Omega + \\omega + \\nu \\\\ !  \\end{array}  ! !  Where L is the true longitude, p is the semi-latus rectum, !  and \\nu is the true anomaly. ! !### References !  * Broucke, R. A. & Cefola, P. J., \"On the Equinoctial Orbit Elements\" !    Celestial Mechanics, Volume 5, Issue 3, p 303-310. (1972) !  * M. J. H. Walker, B. Ireland, Joyce Owens, !    \"A Set of Modified Equinoctial Orbit Elements\" !    Celestial Mechanics, Volume 36, Issue 4, p 409-419. (1985) !  * Walker, M. J. H, \"Erratum - a Set of Modified Equinoctial Orbit Elements\" !    Celestial Mechanics, Volume 38, Issue 4, p 391-392. (1986) module modified_equinoctial_module use kind_module , only : wp use numbers_module use vector_module , only : unit , cross implicit none private public :: cartesian_to_equinoctial public :: equinoctial_to_cartesian public :: modified_equinoctial_derivs public :: modified_equinoctial_test ! for testing contains !***************************************************************************************** !***************************************************************************************** !> !  Convert Cartesian coordinates to modified equinoctial elements (posigrade formulation). subroutine cartesian_to_equinoctial ( mu , rv , evec ) implicit none real ( wp ), intent ( in ) :: mu !! central body gravitational parameter (km&#94;3/s&#94;2) real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! Cartesian state vector real ( wp ), dimension ( 6 ), intent ( out ) :: evec !! Modified equinoctial element vector real ( wp ), dimension ( 3 ) :: r , v , hvec , hhat , ecc , fhat , ghat , rhat , vhat real ( wp ) :: hmag , rmag , p , f , g , h , k , L , kk , hh , s2 , tkh , rdv r = rv ( 1 : 3 ) v = rv ( 4 : 6 ) rdv = dot_product ( r , v ) rhat = unit ( r ) rmag = norm2 ( r ) hvec = cross ( r , v ) hmag = norm2 ( hvec ) hhat = unit ( hvec ) vhat = ( rmag * v - rdv * rhat ) / hmag p = hmag * hmag / mu k = hhat ( 1 ) / ( one + hhat ( 3 )) h = - hhat ( 2 ) / ( one + hhat ( 3 )) kk = k * k hh = h * h s2 = one + hh + kk tkh = two * k * h ecc = cross ( v , hvec ) / mu - rhat fhat ( 1 ) = one - kk + hh fhat ( 2 ) = tkh fhat ( 3 ) = - two * k ghat ( 1 ) = tkh ghat ( 2 ) = one + kk - hh ghat ( 3 ) = two * h fhat = fhat / s2 ghat = ghat / s2 f = dot_product ( ecc , fhat ) g = dot_product ( ecc , ghat ) L = atan2 ( rhat ( 2 ) - vhat ( 1 ), rhat ( 1 ) + vhat ( 2 )) evec = [ p , f , g , h , k , L ] end subroutine cartesian_to_equinoctial !***************************************************************************************** !***************************************************************************************** !> !  Convert modified equinoctial elements (posigrade formulation) to Cartesian coordinates. subroutine equinoctial_to_cartesian ( mu , evec , rv ) implicit none real ( wp ), intent ( in ) :: mu !! central body gravitational parameter (km&#94;3/s&#94;2) real ( wp ), dimension ( 6 ), intent ( in ) :: evec !! Modified equinoctial element vector real ( wp ), dimension ( 6 ), intent ( out ) :: rv !! Cartesian state vector real ( wp ) :: p , f , g , h , k , L , s2 , r , w , cL , sL , smp , hh , kk , tkh real ( wp ) :: x , y , xdot , ydot real ( wp ), dimension ( 3 ) :: fhat , ghat p = evec ( 1 ) f = evec ( 2 ) g = evec ( 3 ) h = evec ( 4 ) k = evec ( 5 ) L = evec ( 6 ) kk = k * k hh = h * h tkh = two * k * h s2 = one + hh + kk cL = cos ( L ) sL = sin ( L ) w = one + f * cL + g * sL r = p / w smp = sqrt ( mu / p ) fhat ( 1 ) = one - kk + hh fhat ( 2 ) = tkh fhat ( 3 ) = - two * k ghat ( 1 ) = tkh ghat ( 2 ) = one + kk - hh ghat ( 3 ) = two * h fhat = fhat / s2 ghat = ghat / s2 x = r * cL y = r * sL xdot = - smp * ( g + sL ) ydot = smp * ( f + cL ) rv ( 1 : 3 ) = x * fhat + y * ghat rv ( 4 : 6 ) = xdot * fhat + ydot * ghat end subroutine equinoctial_to_cartesian !***************************************************************************************** !***************************************************************************************** !> !  Modified equinoctial elements (posigrade formulation) equations of motion. subroutine modified_equinoctial_derivs ( mu , evec , scn , evecd ) implicit none real ( wp ), intent ( in ) :: mu !! central body gravitational parameter (km&#94;3/s&#94;2) real ( wp ), dimension ( 6 ), intent ( in ) :: evec !! modified equinoctial element vector real ( wp ), dimension ( 3 ), intent ( in ) :: scn !! Perturbation (in the RSW frame) real ( wp ), dimension ( 6 ), intent ( out ) :: evecd !! derivative of `evec` real ( wp ) :: p , f , g , h , k , L , c , s , n , sqrtpm , sl , cl , s2no2w , s2 , w p = evec ( 1 ) f = evec ( 2 ) g = evec ( 3 ) h = evec ( 4 ) k = evec ( 5 ) L = evec ( 6 ) s = scn ( 1 ) c = scn ( 2 ) n = scn ( 3 ) sqrtpm = sqrt ( p / mu ) sl = sin ( L ) cl = cos ( L ) s2 = one + h * h + k * k w = one + f * cl + g * sl s2no2w = s2 * n / ( two * w ) evecd ( 1 ) = ( two * p * c / w ) * sqrtpm evecd ( 2 ) = sqrtpm * ( s * sl + (( w + one ) * cl + f ) * c / w - g * n * ( h * sl - k * cl ) / w ) evecd ( 3 ) = sqrtpm * ( - s * cl + (( w + one ) * sl + g ) * c / w + f * n * ( h * sl - k * cl ) / w ) evecd ( 4 ) = sqrtpm * s2no2w * cl evecd ( 5 ) = sqrtpm * s2no2w * sl evecd ( 6 ) = sqrt ( mu * p ) * ( w / p ) ** 2 + sqrtpm * (( h * sl - k * cl ) * n ) / w end subroutine modified_equinoctial_derivs !***************************************************************************************** !***************************************************************************************** !> !  Unit tests for the modified_equinoctial_module. subroutine modified_equinoctial_test () implicit none real ( wp ), parameter :: mu = 39860 0.436233_wp !! central body grav. parameter real ( wp ), dimension ( 6 ), parameter :: x0 = [ - 230 1.67224489839_wp , & - 537 1.07610250925_wp , & - 342 1.14671530212_wp , & 6.1338624555516_wp , & . 306265184163608_wp , & - 4.59713439017524_wp ] !! state vector real ( wp ), dimension ( 3 ), parameter :: scn = [ zero , zero , zero ] !! perturbation real ( wp ), dimension ( 6 ) :: e , ed , x2 write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' modified_equinoctial_test' write ( * , * ) '---------------' write ( * , * ) '' call cartesian_to_equinoctial ( mu , x0 , e ) call equinoctial_to_cartesian ( mu , e , x2 ) call modified_equinoctial_derivs ( mu , e , scn , ed ) write ( * , '(A,1X,*(F20.6,1X))' ) 'x:       ' , x0 write ( * , '(A,1X,*(F20.6,1X))' ) 'x2:      ' , x2 write ( * , '(A,1X,*(F20.6,1X))' ) 'x error: ' , x2 - x0 write ( * , '(A,1X,*(F20.6,1X))' ) 'e:       ' , e write ( * , '(A,1X,*(F20.6,1X))' ) 'ed:      ' , ed end subroutine modified_equinoctial_test !***************************************************************************************** !***************************************************************************************** end module modified_equinoctial_module !*****************************************************************************************","tags":"","url":"sourcefile/modified_equinoctial_module.f90.html"},{"title":"vector_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~vector_module.f90~~EfferentGraph sourcefile~vector_module.f90 vector_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~vector_module.f90~~AfferentGraph sourcefile~vector_module.f90 vector_module.f90 sourcefile~bplane_module.f90 bplane_module.f90 sourcefile~bplane_module.f90->sourcefile~vector_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~vector_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~bplane_module.f90 sourcefile~geometry_module.f90 geometry_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geometry_module.f90 sourcefile~geopotential_module.f90 geopotential_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geopotential_module.f90 sourcefile~iau_orientation_module.f90 iau_orientation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~iau_orientation_module.f90 sourcefile~lambert_module.f90 lambert_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lambert_module.f90 sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 sourcefile~modified_equinoctial_module.f90 modified_equinoctial_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~modified_equinoctial_module.f90 sourcefile~orbital_mechanics_module.f90 orbital_mechanics_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~orbital_mechanics_module.f90 sourcefile~relative_motion_module.f90 relative_motion_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~relative_motion_module.f90 sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~transformation_module.f90 sourcefile~c_interface_module.f90 c_interface_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~c_interface_module.f90 sourcefile~rk_module_variable_step.f90 rk_module_variable_step.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~rk_module_variable_step.f90 sourcefile~geometry_module.f90->sourcefile~vector_module.f90 sourcefile~geopotential_module.f90->sourcefile~vector_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~vector_module.f90 sourcefile~lambert_module.f90->sourcefile~vector_module.f90 sourcefile~lighting_module.f90->sourcefile~vector_module.f90 sourcefile~lighting_module.f90->sourcefile~transformation_module.f90 sourcefile~modified_equinoctial_module.f90->sourcefile~vector_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~vector_module.f90 sourcefile~relative_motion_module.f90->sourcefile~vector_module.f90 sourcefile~transformation_module.f90->sourcefile~vector_module.f90 sourcefile~transformation_module.f90->sourcefile~iau_orientation_module.f90 sourcefile~c_interface_module.f90->sourcefile~geopotential_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~orbital_mechanics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Routines for the manipulation of vectors. module vector_module use kind_module , only : wp use numbers_module , only : one , zero , pi implicit none private integer , parameter , public :: x_axis = 1 integer , parameter , public :: y_axis = 2 integer , parameter , public :: z_axis = 3 real ( wp ), dimension ( 3 ), parameter , public :: x_unit = [ one , zero , zero ] !! x-axis unit vector real ( wp ), dimension ( 3 ), parameter , public :: y_unit = [ zero , one , zero ] !! y-axis unit vector real ( wp ), dimension ( 3 ), parameter , public :: z_unit = [ zero , zero , one ] !! z-axis unit vector public :: cross public :: unit public :: uhat_dot public :: ucross public :: axis_angle_rotation public :: cross_matrix public :: outer_product public :: box_product public :: vector_projection public :: vector_projection_on_plane public :: axis_angle_rotation_to_rotation_matrix public :: spherical_to_cartesian public :: cartesian_to_spherical public :: rotation_matrix public :: rotation_matrix_dot public :: angle_between_vectors interface fill_vector module procedure :: fill_vector_with_vector , fill_vector_with_scalar , & fill_char_vector_with_vector , fill_char_vector_with_scalar end interface public :: fill_vector interface extract_vector module procedure :: extract_vector_from_vector , extract_scalar_from_vector end interface public :: extract_vector !test routine: public :: vector_test contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Cross product of two 3x1 vectors pure function cross ( r , v ) result ( rxv ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r real ( wp ), dimension ( 3 ), intent ( in ) :: v real ( wp ), dimension ( 3 ) :: rxv rxv = [ r ( 2 ) * v ( 3 ) - v ( 2 ) * r ( 3 ), & r ( 3 ) * v ( 1 ) - v ( 3 ) * r ( 1 ), & r ( 1 ) * v ( 2 ) - v ( 1 ) * r ( 2 ) ] end function cross !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Unit vector pure function unit ( r ) result ( u ) implicit none real ( wp ), dimension (:), intent ( in ) :: r real ( wp ), dimension ( size ( r )) :: u real ( wp ) :: rmag rmag = norm2 ( r ) if ( rmag == zero ) then u = zero else u = r / rmag end if end function unit !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Time derivative of a unit vector. pure function uhat_dot ( u , udot ) result ( uhatd ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: u !! vector [`u`] real ( wp ), dimension ( 3 ), intent ( in ) :: udot !! derivative of vector [`du/dt`] real ( wp ), dimension ( 3 ) :: uhatd !! derivative of unit vector [`d(uhat)/dt`] real ( wp ) :: umag !! vector magnitude real ( wp ), dimension ( 3 ) :: uhat !! unit vector umag = norm2 ( u ) if ( umag == zero ) then !singularity uhatd = zero else uhat = u / umag uhatd = ( udot - dot_product ( uhat , udot ) * uhat ) / umag end if end function uhat_dot !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Unit vector of the cross product of two 3x1 vectors pure function ucross ( v1 , v2 ) result ( u ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: v1 real ( wp ), dimension ( 3 ), intent ( in ) :: v2 real ( wp ), dimension ( 3 ) :: u u = unit ( cross ( v1 , v2 )) end function ucross !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 7/20/2014 ! !  Rotate a 3x1 vector in space, given an axis and angle of rotation. ! !# Reference !   * [Wikipedia](http://en.wikipedia.org/wiki/Rodrigues%27_rotation_formula) pure subroutine axis_angle_rotation ( v , k , theta , vrot ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: v !! vector to rotate real ( wp ), dimension ( 3 ), intent ( in ) :: k !! rotation axis real ( wp ), intent ( in ) :: theta !! rotation angle [rad] real ( wp ), dimension ( 3 ), intent ( out ) :: vrot !! result real ( wp ), dimension ( 3 ) :: khat real ( wp ) :: ct , st ct = cos ( theta ) st = sin ( theta ) khat = unit ( k ) !rotation axis unit vector vrot = v * ct + cross ( khat , v ) * st + khat * dot_product ( khat , v ) * ( one - ct ) end subroutine axis_angle_rotation !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 7/20/2014 ! !  Computes the cross product matrix, where: !  ``cross(a,b) == matmul(cross_matrix(a),b)`` pure function cross_matrix ( r ) result ( rcross ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r real ( wp ), dimension ( 3 , 3 ) :: rcross rcross (:, 1 ) = [ zero , r ( 3 ), - r ( 2 )] rcross (:, 2 ) = [ - r ( 3 ), zero , r ( 1 )] rcross (:, 3 ) = [ r ( 2 ), - r ( 1 ), zero ] end function cross_matrix !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 7/21/2014 ! !  Computes the outer product of the two vectors. pure function outer_product ( a , b ) result ( c ) implicit none real ( wp ), dimension (:), intent ( in ) :: a real ( wp ), dimension (:), intent ( in ) :: b real ( wp ), dimension ( size ( a ), size ( b )) :: c integer :: i do i = 1 , size ( b ) c (:, i ) = a * b ( i ) end do end function outer_product !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 7/21/2014 ! !  Computes the box product (scalar triple product) of the three vectors. pure function box_product ( a , b , c ) result ( d ) implicit none real ( wp ), dimension (:), intent ( in ) :: a real ( wp ), dimension (:), intent ( in ) :: b real ( wp ), dimension (:), intent ( in ) :: c real ( wp ) :: d d = dot_product ( a , cross ( b , c )) end function box_product !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 7/21/2014 ! !  The projection of one vector onto another vector. ! !# Reference !   * [Wikipedia](http://en.wikipedia.org/wiki/Gram-Schmidt_process) pure function vector_projection ( a , b ) result ( c ) implicit none real ( wp ), dimension (:), intent ( in ) :: a !! the original vector real ( wp ), dimension ( size ( a )), intent ( in ) :: b !! the vector to project on to real ( wp ), dimension ( size ( a )) :: c !! the projection of a onto b real ( wp ) :: bmag2 bmag2 = dot_product ( b , b ) if ( bmag2 == zero ) then c = zero else c = b * dot_product ( a , b ) / bmag2 end if end function vector_projection !***************************************************************************************** !***************************************************************************************** !> !  Project a vector onto a plane. ! !# Reference !   * [Projection of a Vector onto a Plane](http://www.maplesoft.com/support/help/Maple/view.aspx?path=MathApps/ProjectionOfVectorOntoPlane) pure subroutine vector_projection_on_plane ( a , b , c ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: a !! the original vector real ( wp ), dimension ( 3 ), intent ( in ) :: b !! the plane to project on to (a normal vector) real ( wp ), dimension ( 3 ), intent ( out ) :: c !! the projection of a onto the b plane c = a - vector_projection ( a , b ) end subroutine vector_projection_on_plane !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 7/20/2014 ! !  Computes the rotation matrix that corresponds to a !  rotation about the axis `k` by an angle `theta`. pure subroutine axis_angle_rotation_to_rotation_matrix ( k , theta , rotmat ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: k !! rotation axis real ( wp ), intent ( in ) :: theta !! rotation angle [rad] real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: rotmat !! rotation matrix real ( wp ), dimension ( 3 , 3 ), parameter :: I = & reshape ([ one , zero , zero , zero , one , zero , zero , zero , one ],[ 3 , 3 ]) !! 3x3 identity matrix real ( wp ), dimension ( 3 , 3 ) :: w real ( wp ), dimension ( 3 ) :: khat real ( wp ) :: ct , st ct = cos ( theta ) st = sin ( theta ) khat = unit ( k ) w = cross_matrix ( khat ) rotmat = I + w * st + matmul ( w , w ) * ( one - ct ) end subroutine axis_angle_rotation_to_rotation_matrix !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 9/24/2014 ! !  Convert spherical (r,alpha,beta) to Cartesian (x,y,z). pure function spherical_to_cartesian ( r , alpha , beta ) result ( rvec ) implicit none real ( wp ), intent ( in ) :: r !! magnitude real ( wp ), intent ( in ) :: alpha !! right ascension [rad] real ( wp ), intent ( in ) :: beta !! declination [rad] real ( wp ), dimension ( 3 ) :: rvec !! [x,y,z] vector rvec ( 1 ) = r * cos ( alpha ) * cos ( beta ) rvec ( 2 ) = r * sin ( alpha ) * cos ( beta ) rvec ( 3 ) = r * sin ( beta ) end function spherical_to_cartesian !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 3/6/2016 ! !  Convert Cartesian (x,y,z) to spherical (r,alpha,beta). pure subroutine cartesian_to_spherical ( rvec , r , alpha , beta ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: rvec !! [x,y,z] vector real ( wp ), intent ( out ) :: r !! magnitude real ( wp ), intent ( out ) :: alpha !! right ascension [rad] real ( wp ), intent ( out ) :: beta !! declination [rad] real ( wp ) :: r1 r1 = rvec ( 1 ) * rvec ( 1 ) + rvec ( 2 ) * rvec ( 2 ) r = sqrt ( r1 + rvec ( 3 ) * rvec ( 3 )) if ( r /= zero ) then beta = atan2 ( rvec ( 3 ), sqrt ( r1 )) if ( r1 /= zero ) then alpha = atan2 ( rvec ( 2 ), rvec ( 1 )) else alpha = zero end if else alpha = zero beta = zero end if end subroutine cartesian_to_spherical !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/3/2015 ! !  The 3x3 rotation matrix for a rotation about the x, y, or z-axis. ! !  EXAMPLE !```Fortran !    real(wp),dimension(3,3) :: rotmat !    real(wp),dimension(3) :: vec,vec2 !    real(wp) :: ang !    ang = pi / 4.0_wp !    vec = [1.414_wp, 0.0_wp, 0.0_wp] !    rotmat = rotation_matrix(z_axis,ang) !    vec2 = matmul(rotmat,vec) !``` pure function rotation_matrix ( axis , angle ) result ( rotmat ) implicit none real ( wp ), dimension ( 3 , 3 ) :: rotmat !! the rotation matrix integer , intent ( in ) :: axis !! x_axis, y_axis, or z_axis real ( wp ), intent ( in ) :: angle !! angle in radians real ( wp ) :: c , s !precompute these: c = cos ( angle ) s = sin ( angle ) select case ( axis ) case ( x_axis ); rotmat = reshape ([ one , zero , zero , zero , c , - s , zero , s , c ],[ 3 , 3 ]) case ( y_axis ); rotmat = reshape ([ c , zero , s , zero , one , zero , - s , zero , c ],[ 3 , 3 ]) case ( z_axis ); rotmat = reshape ([ c , - s , zero , s , c , zero , zero , zero , one ],[ 3 , 3 ]) case default ; rotmat = zero end select end function rotation_matrix !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 3/19/2016 ! !  Time derivative of the 3x3 rotation matrix !  for a rotation about the x, y, or z-axis. pure function rotation_matrix_dot ( axis , angle , angledot ) result ( rotmatdot ) implicit none real ( wp ), dimension ( 3 , 3 ) :: rotmatdot !! the rotation matrix derivative  d \\mathbf{C} / d t  integer , intent ( in ) :: axis !! x_axis, y_axis, or z_axis real ( wp ), intent ( in ) :: angle !! angle in radians real ( wp ), intent ( in ) :: angledot !! time derivative of angle in radians/sec real ( wp ) :: c , s !precompute these: c = cos ( angle ) s = sin ( angle ) !first compute d[C]/da (time derivate w.r.t. the angle): select case ( axis ) case ( x_axis ); rotmatdot = reshape ([ zero , zero , zero , zero , - s , - c , zero , c , - s ],[ 3 , 3 ]) case ( y_axis ); rotmatdot = reshape ([ - s , zero , c , zero , zero , zero , - c , zero , - s ],[ 3 , 3 ]) case ( z_axis ); rotmatdot = reshape ([ - s , - c , zero , c , - s , zero , zero , zero , zero ],[ 3 , 3 ]) case default rotmatdot = zero return end select rotmatdot = rotmatdot * angledot ! d[C]/dt = d[C]/da * da/dt end function rotation_matrix_dot !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 3/13/2015 ! !  The angle between two vectors (in radians). pure function angle_between_vectors ( v1 , v2 ) result ( ang ) implicit none real ( wp ) :: ang !! [rad] real ( wp ), dimension ( 3 ), intent ( in ) :: v1 real ( wp ), dimension ( 3 ), intent ( in ) :: v2 real ( wp ) :: d , c d = dot_product ( v1 , v2 ) c = norm2 ( cross ( v1 , v2 )) ang = atan2 ( c , d ) end function angle_between_vectors !***************************************************************************************** !***************************************************************************************** !> !  Put the vector in the vector and update the index subroutine fill_vector_with_vector ( x , vals , i ) implicit none real ( wp ), dimension (:), intent ( inout ) :: x real ( wp ), dimension (:), intent ( in ) :: vals integer , intent ( inout ) :: i !! should be initialized to 0 before the first call integer :: j !! counter do j = 1 , size ( vals ) call fill_vector ( x , vals ( j ), i ) end do end subroutine fill_vector_with_vector !***************************************************************************************** !***************************************************************************************** !> !  Put the value in the vector and update the index subroutine fill_vector_with_scalar ( x , val , i ) implicit none real ( wp ), dimension (:), intent ( inout ) :: x real ( wp ), intent ( in ) :: val integer , intent ( inout ) :: i !! should be initialized to 0 before the first call i = i + 1 if ( i > size ( x )) error stop 'error in fill_vector: x is not large enough.' x ( i ) = val end subroutine fill_vector_with_scalar !***************************************************************************************** !***************************************************************************************** !> !  Put the vector in the vector and update the index (character version) subroutine fill_char_vector_with_vector ( x , vals , i ) implicit none character ( len =* ), dimension (:), intent ( inout ) :: x character ( len =* ), dimension (:), intent ( in ) :: vals integer , intent ( inout ) :: i !! should be initialized to 0 before the first call integer :: j !! counter do j = 1 , size ( vals ) call fill_vector ( x , vals ( j ), i ) end do end subroutine fill_char_vector_with_vector !***************************************************************************************** !***************************************************************************************** !> !  Put the value in the vector and update the index (character version) subroutine fill_char_vector_with_scalar ( x , val , i ) implicit none character ( len =* ), dimension (:), intent ( inout ) :: x character ( len =* ), intent ( in ) :: val integer , intent ( inout ) :: i !! should be initialized to 0 before the first call i = i + 1 if ( i > size ( x )) error stop 'error in fill_vector: x is not large enough.' x ( i ) = val end subroutine fill_char_vector_with_scalar !***************************************************************************************** !***************************************************************************************** !> !  Extract a vector from the vector and update the index subroutine extract_vector_from_vector ( vals , x , i ) implicit none real ( wp ), dimension (:), intent ( out ) :: vals real ( wp ), dimension (:), intent ( in ) :: x integer , intent ( inout ) :: i !! should be initialized to 0 before the first call integer :: j !! counter do j = 1 , size ( vals ) call extract_vector ( vals ( j ), x , i ) end do end subroutine extract_vector_from_vector !***************************************************************************************** !***************************************************************************************** !> !  Extract the value from the vector and update the index subroutine extract_scalar_from_vector ( val , x , i ) implicit none real ( wp ), intent ( out ) :: val real ( wp ), dimension (:), intent ( in ) :: x integer , intent ( inout ) :: i !! should be initialized to 0 before the first call i = i + 1 if ( i > size ( x )) error stop 'error in extract_vector: x is not large enough.' val = x ( i ) end subroutine extract_scalar_from_vector !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 7/20/2014 ! !  Unit test routine for the [[vector_module]]. subroutine vector_test () implicit none integer :: i real ( wp ) :: theta real ( wp ), dimension ( 3 ) :: v , k , v2 , v3 real ( wp ), dimension ( 3 , 3 ) :: rotmat write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' vector_test' write ( * , * ) '---------------' write ( * , * ) '' v = [ 1.2_wp , 3.0_wp , - 5.0_wp ] k = [ - 0.1_wp , 1 6.2_wp , 2.1_wp ] theta = 0.123_wp call axis_angle_rotation ( v , k , theta , v2 ) call axis_angle_rotation_to_rotation_matrix ( k , theta , rotmat ) v3 = matmul ( rotmat , v ) write ( * , * ) 'Single test:' write ( * , * ) '' write ( * , * ) '  v1   :' , v write ( * , * ) '  v2   :' , v2 write ( * , * ) '  v3   :' , v3 write ( * , * ) '  Error:' , v3 - v2 write ( * , * ) '' write ( * , * ) '0-360 test:' write ( * , * ) '' do i = 0 , 360 , 10 theta = i * 18 0.0_wp / pi call axis_angle_rotation ( v , k , theta , v2 ) call axis_angle_rotation_to_rotation_matrix ( k , theta , rotmat ) v3 = matmul ( rotmat , v ) write ( * , * ) 'Error:' , norm2 ( v3 - v2 ) end do !z-axis rotation test: theta = pi / 4.0_wp v = [ one / cos ( theta ), 0.0_wp , 0.0_wp ] rotmat = rotation_matrix ( z_axis , theta ) v2 = matmul ( rotmat , v ) write ( * , * ) v2 !should be [1, -1, 0] end subroutine vector_test !**************************************************************************************** !***************************************************************************************** end module vector_module !*****************************************************************************************","tags":"","url":"sourcefile/vector_module.f90.html"},{"title":"math_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~math_module.f90~~EfferentGraph sourcefile~math_module.f90 math_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~math_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~math_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~math_module.f90~~AfferentGraph sourcefile~math_module.f90 math_module.f90 sourcefile~crtbp_module.f90 crtbp_module.f90 sourcefile~crtbp_module.f90->sourcefile~math_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~math_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~crtbp_module.f90 sourcefile~halo_orbit_module.f90 halo_orbit_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~halo_orbit_module.f90 sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 sourcefile~orbital_mechanics_module.f90 orbital_mechanics_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~orbital_mechanics_module.f90 sourcefile~rk_module_variable_step.f90 rk_module_variable_step.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~rk_module_variable_step.f90 sourcefile~halo_orbit_module.f90->sourcefile~math_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~crtbp_module.f90 sourcefile~lighting_module.f90->sourcefile~math_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~math_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~orbital_mechanics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  General math routines module math_module use kind_module , only : wp use numbers_module , only : pi , twopi implicit none private public :: cube_root public :: wrap_angle public :: magnitude contains !***************************************************************************************** !***************************************************************************************** !> !  Returns a positive number the same magnitude as the input, !  with only one significant digit. ! !  If `mina` is present, then `max(mina,mag(a))` is returned ! !  Examples: !``` !     mag(1234.56)  -> 1000.0 !     mag(-999.99)  -> 900.0 !     mag(1.456e-4) -> 0.0001 !``` pure elemental function magnitude ( a , mina ) result ( m ) implicit none real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ), optional :: mina real ( wp ) :: m real ( wp ) :: x , tmp x = abs ( a ) if ( x == 0.0_wp ) then if (. not . present ( mina )) then m = 1.0_wp else m = mina end if else tmp = 1 0.0_wp ** floor ( log10 ( x )) m = tmp * floor ( x / tmp ) if ( present ( mina )) m = max ( mina , m ) end if end function magnitude !***************************************************************************************** !***************************************************************************************** !> !  Wrap an angle (in rad) from -pi to pi. pure elemental function wrap_angle ( a ) result ( r ) implicit none real ( wp ), intent ( in ) :: a real ( wp ) :: r r = mod ( a , twopi ) if ( abs ( r ) > pi ) r = r - sign ( twopi , r ) end function wrap_angle !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Cube root of a number (real solution only). pure elemental function cube_root ( x ) result ( y ) use numbers_module , only : one , three implicit none real ( wp ), intent ( in ) :: x real ( wp ) :: y real ( wp ), parameter :: one_third = one / three y = sign ( abs ( x ) ** one_third , x ) end function cube_root !***************************************************************************************** !***************************************************************************************** end module math_module !*****************************************************************************************","tags":"","url":"sourcefile/math_module.f90.html"},{"title":"minpack_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~minpack_module.f90~~EfferentGraph sourcefile~minpack_module.f90 minpack_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~minpack_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~minpack_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~minpack_module.f90~~AfferentGraph sourcefile~minpack_module.f90 minpack_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~minpack_module.f90 sourcefile~halo_orbit_module.f90 halo_orbit_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~halo_orbit_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~minpack_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Minpack routines for solving a set of nonlinear equations. !  The two main routines here are [[hybrj]] (user-provided Jacobian) and !  [[hybrd]] (estimates the Jacobian using finite differences). ! !### License ! !  *** Original Minpack License *** ! !     Minpack Copyright Notice (1999) University of Chicago.  All rights reserved ! !     Redistribution and use in source and binary forms, with or !     without modification, are permitted provided that the !     following conditions are met: ! !     1. Redistributions of source code must retain the above !     copyright notice, this list of conditions and the following !     disclaimer. ! !     2. Redistributions in binary form must reproduce the above !     copyright notice, this list of conditions and the following !     disclaimer in the documentation and/or other materials !     provided with the distribution. ! !     3. The end-user documentation included with the !     redistribution, if any, must include the following !     acknowledgment: ! !        \"This product includes software developed by the !        University of Chicago, as Operator of Argonne National !        Laboratory. ! !     Alternately, this acknowledgment may appear in the software !     itself, if and wherever such third-party acknowledgments !     normally appear. ! !     4. WARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\" !     WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE !     UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND !     THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR !     IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES !     OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE !     OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY !     OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR !     USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF !     THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) !     DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION !     UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL !     BE CORRECTED. ! !     5. LIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT !     HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF !     ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, !     INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF !     ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF !     PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER !     SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT !     (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, !     EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE !     POSSIBILITY OF SUCH LOSS OR DAMAGES. ! !  *** Modifications *** ! !  Modifications for the Fortran Astrodynamics Toolkit are covered !  under the [following license](https://github.com/jacobwilliams/Fortran-Astrodynamics-Toolkit/blob/master/LICENSE). ! !### History !  * Argonne National Laboratory. minpack project. march 1980. !    burton s. garbow, kenneth e. hillstrom, jorge j. more, john l. nazareth !  * Jacob Williams, Jan 2016, extensive refactoring into modern Fortran. module minpack_module use kind_module , only : wp use numbers_module implicit none abstract interface subroutine fcn_hybrd ( n , x , fvec , iflag ) !! function for [[hybrd]]. !! calculate the functions at `x` and !! return this vector in `fvec`. import :: wp implicit none integer , intent ( in ) :: n real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension ( n ), intent ( out ) :: fvec integer , intent ( inout ) :: iflag !! the value of `iflag` should not be changed by fcn unless !! the user wants to terminate execution of [[hybrd]]. !! in this case set `iflag` to a negative integer. end subroutine fcn_hybrd subroutine fcn_hybrj ( n , x , fvec , fjac , ldfjac , iflag ) !! function for [[hybrj]] import :: wp implicit none integer , intent ( in ) :: n real ( wp ), dimension ( n ), intent ( in ) :: x integer , intent ( in ) :: ldfjac real ( wp ), dimension ( n ), intent ( out ) :: fvec real ( wp ), dimension ( ldfjac , n ), intent ( out ) :: fjac integer , intent ( inout ) :: iflag end subroutine fcn_hybrj end interface public :: hybrd , hybrd1 public :: hybrj , hybrj1 contains !***************************************************************************************** !***************************************************************************************** !> !     given an m by n matrix a, an n by n nonsingular diagonal !     matrix d, an m-vector b, and a positive number delta, the !     problem is to determine the convex combination x of the !     gauss-newton and scaled gradient directions that minimizes !     (a*x - b) in the least squares sense, subject to the !     restriction that the euclidean norm of d*x be at most delta. ! !     this subroutine completes the solution of the problem !     if it is provided with the necessary information from the !     qr factorization of a. that is, if a = q*r, where q has !     orthogonal columns and r is an upper triangular matrix, !     then dogleg expects the full upper triangle of r and !     the first n components of (q transpose)*b. ! !     the subroutine statement is ! !       subroutine dogleg(n,r,lr,diag,qtb,delta,x,wa1,wa2) ! !     where ! !       n is a positive integer input variable set to the order of r. ! !       r is an input array of length lr which must contain the upper !         triangular matrix r stored by rows. ! !       lr is a positive integer input variable not less than !         (n*(n+1))/2. ! !       diag is an input array of length n which must contain the !         diagonal elements of the matrix d. ! !       qtb is an input array of length n which must contain the first !         n elements of the vector (q transpose)*b. ! !       delta is a positive input variable which specifies an upper !         bound on the euclidean norm of d*x. ! !       x is an output array of length n which contains the desired !         convex combination of the gauss-newton direction and the !         scaled gradient direction. ! !       wa1 and wa2 are work arrays of length n. subroutine dogleg ( n , r , lr , diag , qtb , delta , x , wa1 , wa2 ) implicit none integer n , lr real ( wp ) delta real ( wp ) r ( lr ) , diag ( n ) , qtb ( n ) , x ( n ) , wa1 ( n ) , wa2 ( n ) integer i , j , jj , jp1 , k , l real ( wp ) alpha , bnorm , epsmch , gnorm , qnorm , sgnorm , sum , temp epsmch = dpmpar ( 1 ) ! the machine precision ! !     first, calculate the gauss-newton direction. ! jj = ( n * ( n + 1 )) / 2 + 1 do k = 1 , n j = n - k + 1 jp1 = j + 1 jj = jj - k l = jj + 1 sum = zero if ( n >= jp1 ) then do i = jp1 , n sum = sum + r ( l ) * x ( i ) l = l + 1 enddo endif temp = r ( jj ) if ( temp == zero ) then l = j do i = 1 , j temp = max ( temp , abs ( r ( l ))) l = l + n - i enddo temp = epsmch * temp if ( temp == zero ) temp = epsmch endif x ( j ) = ( qtb ( j ) - sum ) / temp enddo ! !     test whether the gauss-newton direction is acceptable. ! do j = 1 , n wa1 ( j ) = zero wa2 ( j ) = diag ( j ) * x ( j ) enddo qnorm = enorm ( n , wa2 ) if ( qnorm > delta ) then ! !     the gauss-newton direction is not acceptable. !     next, calculate the scaled gradient direction. ! l = 1 do j = 1 , n temp = qtb ( j ) do i = j , n wa1 ( i ) = wa1 ( i ) + r ( l ) * temp l = l + 1 enddo wa1 ( j ) = wa1 ( j ) / diag ( j ) enddo ! !     calculate the norm of the scaled gradient and test for !     the special case in which the scaled gradient is zero. ! gnorm = enorm ( n , wa1 ) sgnorm = zero alpha = delta / qnorm if ( gnorm /= zero ) then ! !     calculate the point along the scaled gradient !     at which the quadratic is minimized. ! do j = 1 , n wa1 ( j ) = ( wa1 ( j ) / gnorm ) / diag ( j ) enddo l = 1 do j = 1 , n sum = zero do i = j , n sum = sum + r ( l ) * wa1 ( i ) l = l + 1 enddo wa2 ( j ) = sum enddo temp = enorm ( n , wa2 ) sgnorm = ( gnorm / temp ) / temp ! !     test whether the scaled gradient direction is acceptable. ! alpha = zero if ( sgnorm < delta ) then ! !     the scaled gradient direction is not acceptable. !     finally, calculate the point along the dogleg !     at which the quadratic is minimized. ! bnorm = enorm ( n , qtb ) temp = ( bnorm / gnorm ) * ( bnorm / qnorm ) * ( sgnorm / delta ) temp = temp - ( delta / qnorm ) * ( sgnorm / delta ) ** 2 + & sqrt (( temp - ( delta / qnorm )) ** 2 + & ( one - ( delta / qnorm ) ** 2 ) * ( one - ( sgnorm / delta ) ** 2 )) alpha = (( delta / qnorm ) * ( one - ( sgnorm / delta ) ** 2 )) / temp endif endif ! !     form appropriate convex combination of the gauss-newton !     direction and the scaled gradient direction. ! temp = ( one - alpha ) * min ( sgnorm , delta ) do j = 1 , n x ( j ) = temp * wa1 ( j ) + alpha * x ( j ) enddo endif end subroutine dogleg !***************************************************************************************** !***************************************************************************************** !> !  Replacement for the original Minpack routine. real ( wp ) function dpmpar ( i ) implicit none integer , intent ( in ) :: i real ( wp ), dimension ( 3 ), parameter :: dmach = [ epsilon ( 1.0_wp ),& tiny ( 1.0_wp ),& huge ( 1.0_wp )] dpmpar = dmach ( i ) end function dpmpar !***************************************************************************************** !***************************************************************************************** !> !     given an n-vector x, this function calculates the !     euclidean norm of x. ! !     the euclidean norm is computed by accumulating the sum of !     squares in three different sums. the sums of squares for the !     small and large components are scaled so that no overflows !     occur. non-destructive underflows are permitted. underflows !     and overflows do not occur in the computation of the unscaled !     sum of squares for the intermediate components. !     the definitions of small, intermediate and large components !     depend on two constants, rdwarf and rgiant. the main !     restrictions on these constants are that rdwarf**2 not !     underflow and rgiant**2 not overflow. the constants !     given here are suitable for every known computer. real ( wp ) function enorm ( n , x ) implicit none integer , intent ( in ) :: n !! size of `x` real ( wp ), dimension ( n ), intent ( in ) :: x !! input array integer i real ( wp ) agiant , floatn , s1 , s2 , s3 , xabs , x1max , x3max real ( wp ), parameter :: rdwarf = 3.834e-20_wp real ( wp ), parameter :: rgiant = 1.304e19_wp s1 = zero s2 = zero s3 = zero x1max = zero x3max = zero floatn = n agiant = rgiant / floatn do i = 1 , n xabs = abs ( x ( i )) if ( xabs > rdwarf . and . xabs < agiant ) then ! !           sum for intermediate components. ! s2 = s2 + xabs ** 2 elseif ( xabs <= rdwarf ) then ! !              sum for small components. ! if ( xabs <= x3max ) then if ( xabs /= zero ) s3 = s3 + ( xabs / x3max ) ** 2 else s3 = one + s3 * ( x3max / xabs ) ** 2 x3max = xabs endif ! !              sum for large components. ! elseif ( xabs <= x1max ) then s1 = s1 + ( xabs / x1max ) ** 2 else s1 = one + s1 * ( x1max / xabs ) ** 2 x1max = xabs endif enddo ! !     calculation of norm. ! if ( s1 /= zero ) then enorm = x1max * sqrt ( s1 + ( s2 / x1max ) / x1max ) elseif ( s2 == zero ) then enorm = x3max * sqrt ( s3 ) else if ( s2 >= x3max ) enorm = sqrt ( s2 * ( one + ( x3max / s2 ) * ( x3max * s3 ))) if ( s2 < x3max ) enorm = sqrt ( x3max * (( s2 / x3max ) + ( x3max * s3 ))) endif end function enorm !***************************************************************************************** !***************************************************************************************** !> !     this subroutine computes a forward-difference approximation !     to the n by n jacobian matrix associated with a specified !     problem of n functions in n variables. if the jacobian has !     a banded form, then function evaluations are saved by only !     approximating the nonzero terms. ! !     the subroutine statement is ! !       subroutine fdjac1(fcn,n,x,fvec,fjac,ldfjac,iflag,ml,mu,epsfcn,wa1,wa2) ! !     where ! !       fcn is the name of the user-supplied subroutine which !         calculates the functions. fcn must be declared !         in an external statement in the user calling !         program, and should be written as follows. ! !         subroutine fcn(n,x,fvec,iflag) !         integer n,iflag !         real(wp) x(n),fvec(n) !         ---------- !         calculate the functions at x and !         return this vector in fvec. !         ---------- !         return !         end ! !         the value of iflag should not be changed by fcn unless !         the user wants to terminate execution of fdjac1. !         in this case set iflag to a negative integer. ! !       n is a positive integer input variable set to the number !         of functions and variables. ! !       x is an input array of length n. ! !       fvec is an input array of length n which must contain the !         functions evaluated at x. ! !       fjac is an output n by n array which contains the !         approximation to the jacobian matrix evaluated at x. ! !       ldfjac is a positive integer input variable not less than n !         which specifies the leading dimension of the array fjac. ! !       iflag is an integer variable which can be used to terminate !         the execution of fdjac1. see description of fcn. ! !       ml is a nonnegative integer input variable which specifies !         the number of subdiagonals within the band of the !         jacobian matrix. if the jacobian is not banded, set !         ml to at least n - 1. ! !       epsfcn is an input variable used in determining a suitable !         step length for the forward-difference approximation. this !         approximation assumes that the relative errors in the !         functions are of the order of epsfcn. if epsfcn is less !         than the machine precision, it is assumed that the relative !         errors in the functions are of the order of the machine !         precision. ! !       mu is a nonnegative integer input variable which specifies !         the number of superdiagonals within the band of the !         jacobian matrix. if the jacobian is not banded, set !         mu to at least n - 1. ! !       wa1 and wa2 are work arrays of length n. if ml + mu + 1 is at !         least n, then the jacobian is considered dense, and wa2 is !         not referenced. subroutine fdjac1 ( fcn , n , x , fvec , fjac , ldfjac , iflag , ml , mu , epsfcn , wa1 , wa2 ) implicit none integer n , ldfjac , iflag , ml , mu real ( wp ) epsfcn real ( wp ) x ( n ) , fvec ( n ) , fjac ( ldfjac , n ) , wa1 ( n ) , wa2 ( n ) procedure ( fcn_hybrd ) :: fcn integer i , j , k , msum real ( wp ) eps , epsmch , h , temp epsmch = dpmpar ( 1 ) ! the machine precision ! eps = sqrt ( max ( epsfcn , epsmch )) msum = ml + mu + 1 if ( msum < n ) then ! !        computation of banded approximate jacobian. ! do k = 1 , msum do j = k , n , msum wa2 ( j ) = x ( j ) h = eps * abs ( wa2 ( j )) if ( h == zero ) h = eps x ( j ) = wa2 ( j ) + h enddo call fcn ( n , x , wa1 , iflag ) if ( iflag < 0 ) return do j = k , n , msum x ( j ) = wa2 ( j ) h = eps * abs ( wa2 ( j )) if ( h == zero ) h = eps do i = 1 , n fjac ( i , j ) = zero if ( i >= j - mu . and . i <= j + ml ) fjac ( i , j ) = ( wa1 ( i ) - fvec ( i )) / h enddo enddo enddo else ! !        computation of dense approximate jacobian. ! do j = 1 , n temp = x ( j ) h = eps * abs ( temp ) if ( h == zero ) h = eps x ( j ) = temp + h call fcn ( n , x , wa1 , iflag ) if ( iflag < 0 ) return x ( j ) = temp do i = 1 , n fjac ( i , j ) = ( wa1 ( i ) - fvec ( i )) / h enddo enddo endif end subroutine fdjac1 !***************************************************************************************** !***************************************************************************************** !> !  The purpose of hybrd is to find a zero of a system of !  n nonlinear functions in n variables by a modification !  of the powell hybrid method. the user must provide a !  subroutine which calculates the functions. the jacobian is !  then calculated by a forward-difference approximation. ! !### Characteristics of the algorithm. !  HYBRD is a modification of the Powell hybrid method.  Two of its !  main characteristics involve the choice of the correction as a !  convex combination of the Newton and scaled gradient directions !  and the updating of the Jacobian by the rank-1 method of Broy- !  den.  The choice of the correction guarantees (under reasonable !  conditions) global convergence for starting points far from the !  solution and a fast rate of convergence.  The Jacobian is !  approximated by forward differences at the starting point, but !  forward differences are not used again until the rank-1 method !  fails to produce satisfactory progress. ! !### References !  * M. J. D. Powell, A Hybrid Method for Nonlinear Equations. !    Numerical Methods for Nonlinear Algebraic Equations, !    P. Rabinowitz, editor. Gordon and Breach, 1970. subroutine hybrd ( fcn , n , x , fvec , xtol , maxfev , ml , mu , epsfcn , diag , mode , & factor , nprint , info , nfev , fjac , ldfjac , r , lr , qtf , wa1 ,& wa2 , wa3 , wa4 ) implicit none procedure ( fcn_hybrd ) :: fcn !! user-supplied subroutine which calculates the functions integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of functions and variables. integer , intent ( in ) :: maxfev !! a positive integer input variable. termination !! occurs when the number of calls to `fcn` is at least `maxfev` !! by the end of an iteration. integer , intent ( in ) :: ml !! a nonnegative integer input variable which specifies !! the number of subdiagonals within the band of the !! jacobian matrix. if the jacobian is not banded, set !! `ml` to at least `n - 1`. integer , intent ( in ) :: mu !! a nonnegative integer input variable which specifies !! the number of superdiagonals within the band of the !! jacobian matrix. if the jacobian is not banded, set !! `mu` to at least` n - 1`. integer , intent ( in ) :: mode !! if `mode = 1`, the !! variables will be scaled internally. if `mode = 2`, !! the scaling is specified by the input `diag`. other !! values of `mode` are equivalent to `mode = 1`. integer , intent ( in ) :: nprint !! an integer input variable that enables controlled !! printing of iterates if it is positive. in this case, !! `fcn` is called with `iflag = 0` at the beginning of the first !! iteration and every `nprint` iterations thereafter and !! immediately prior to return, with `x` and `fvec` available !! for printing. if `nprint` is not positive, no special calls !! of `fcn` with `iflag = 0` are made. integer , intent ( out ) :: info !! an integer output variable. if the user has !! terminated execution, `info` is set to the (negative) !! value of `iflag`. see description of `fcn`. otherwise, !! `info` is set as follows: !!  * ***info = 0*** improper input parameters. !!  * ***info = 1*** relative error between two consecutive iterates !!    is at most `xtol`. !!  * ***info = 2*** number of calls to `fcn` has reached or exceeded !!    `maxfev`. !!  * ***info = 3*** `xtol` is too small. no further improvement in !!    the approximate solution `x` is possible. !!  * ***info = 4*** iteration is not making good progress, as !!    measured by the improvement from the last !!    five jacobian evaluations. !!  * ***info = 5*** iteration is not making good progress, as !!    measured by the improvement from the last !!    ten iterations. integer , intent ( out ) :: nfev !! output variable set to the number of calls to `fcn`. integer , intent ( in ) :: ldfjac !! a positive integer input variable not less than `n` !! which specifies the leading dimension of the array `fjac`. integer , intent ( in ) :: lr !! a positive integer input variable not less than `(n*(n+1))/2`. real ( wp ), intent ( in ) :: xtol !! a nonnegative input variable. termination !! occurs when the relative error between two consecutive !! iterates is at most `xtol`. real ( wp ), intent ( in ) :: epsfcn !! an input variable used in determining a suitable !! step length for the forward-difference approximation. this !! approximation assumes that the relative errors in the !! functions are of the order of `epsfcn`. if `epsfcn` is less !! than the machine precision, it is assumed that the relative !! errors in the functions are of the order of the machine !! precision. real ( wp ), intent ( in ) :: factor !! a positive input variable used in determining the !! initial step bound. this bound is set to the product of !! `factor` and the euclidean norm of `diag*x` if nonzero, or else !! to `factor` itself. in most cases factor should lie in the !! interval (.1,100.). 100. is a generally recommended value. real ( wp ), intent ( inout ) :: x ( n ) !! array of length n. on input `x` must contain !! an initial estimate of the solution vector. on output `x` !! contains the final estimate of the solution vector. real ( wp ), intent ( out ) :: fvec ( n ) !! an output array of length `n` which contains !! the functions evaluated at the output `x`. real ( wp ), intent ( inout ) :: diag ( n ) !! an array of length `n`. if `mode = 1` (see !! below), `diag` is internally set. if `mode = 2`, `diag` !! must contain positive entries that serve as !! multiplicative scale factors for the variables. real ( wp ), intent ( out ) :: fjac ( ldfjac , n ) !! array which contains the !! orthogonal matrix `q` produced by the QR factorization !! of the final approximate jacobian. real ( wp ), intent ( out ) :: r ( lr ) !! an output array which contains the !! upper triangular matrix produced by the QR factorization !! of the final approximate jacobian, stored rowwise. real ( wp ), intent ( out ) :: qtf ( n ) !! an output array of length `n` which contains !! the vector `(q transpose)*fvec`. real ( wp ), intent ( inout ) :: wa1 ( n ) !! work array real ( wp ), intent ( inout ) :: wa2 ( n ) !! work array real ( wp ), intent ( inout ) :: wa3 ( n ) !! work array real ( wp ), intent ( inout ) :: wa4 ( n ) !! work array integer :: i , iflag , iter , j , jm1 , l , msum , ncfail , ncsuc , nslow1 , nslow2 integer :: iwa ( 1 ) logical :: jeval , sing real ( wp ) :: actred , delta , epsmch , fnorm , fnorm1 , & pnorm , prered , ratio ,& sum , temp , xnorm real ( wp ), parameter :: p1 = 1.0e-1_wp real ( wp ), parameter :: p5 = 5.0e-1_wp real ( wp ), parameter :: p001 = 1.0e-3_wp real ( wp ), parameter :: p0001 = 1.0e-4_wp epsmch = dpmpar ( 1 ) ! the machine precision info = 0 iflag = 0 nfev = 0 ! !     check the input parameters for errors. ! if ( n <= 0 . or . xtol < zero . or . maxfev <= 0 . or . ml < 0 . or . mu < 0 . or . & factor <= zero . or . ldfjac < n . or . lr < ( n * ( n + 1 )) / 2 ) goto 300 if ( mode == 2 ) then do j = 1 , n if ( diag ( j ) <= zero ) goto 300 enddo endif ! !     evaluate the function at the starting point !     and calculate its norm. ! iflag = 1 call fcn ( n , x , fvec , iflag ) nfev = 1 if ( iflag < 0 ) goto 300 fnorm = enorm ( n , fvec ) ! !     determine the number of calls to fcn needed to compute !     the jacobian matrix. ! msum = min0 ( ml + mu + 1 , n ) ! !     initialize iteration counter and monitors. ! iter = 1 ncsuc = 0 ncfail = 0 nslow1 = 0 nslow2 = 0 ! !     beginning of the outer loop. ! 100 jeval = . true . ! !        calculate the jacobian matrix. ! iflag = 2 call fdjac1 ( fcn , n , x , fvec , fjac , ldfjac , iflag , ml , mu , epsfcn , wa1 , wa2 ) nfev = nfev + msum if ( iflag < 0 ) goto 300 ! !        compute the qr factorization of the jacobian. ! call qrfac ( n , n , fjac , ldfjac ,. false ., iwa , 1 , wa1 , wa2 , wa3 ) ! !        on the first iteration and if mode is 1, scale according !        to the norms of the columns of the initial jacobian. ! if ( iter == 1 ) then if ( mode /= 2 ) then do j = 1 , n diag ( j ) = wa2 ( j ) if ( wa2 ( j ) == zero ) diag ( j ) = one enddo endif ! !        on the first iteration, calculate the norm of the scaled x !        and initialize the step bound delta. ! do j = 1 , n wa3 ( j ) = diag ( j ) * x ( j ) enddo xnorm = enorm ( n , wa3 ) delta = factor * xnorm if ( delta == zero ) delta = factor endif ! !        form (q transpose)*fvec and store in qtf. ! do i = 1 , n qtf ( i ) = fvec ( i ) enddo do j = 1 , n if ( fjac ( j , j ) /= zero ) then sum = zero do i = j , n sum = sum + fjac ( i , j ) * qtf ( i ) enddo temp = - sum / fjac ( j , j ) do i = j , n qtf ( i ) = qtf ( i ) + fjac ( i , j ) * temp enddo endif enddo ! !        copy the triangular factor of the qr factorization into r. ! sing = . false . do j = 1 , n l = j jm1 = j - 1 if ( jm1 >= 1 ) then do i = 1 , jm1 r ( l ) = fjac ( i , j ) l = l + n - i enddo endif r ( l ) = wa1 ( j ) if ( wa1 ( j ) == zero ) sing = . true . enddo ! !        accumulate the orthogonal factor in fjac. ! call qform ( n , n , fjac , ldfjac , wa1 ) ! !        rescale if necessary. ! if ( mode /= 2 ) then do j = 1 , n diag ( j ) = dmax1 ( diag ( j ), wa2 ( j )) enddo endif ! !        beginning of the inner loop. ! ! !           if requested, call fcn to enable printing of iterates. ! 200 if ( nprint > 0 ) then iflag = 0 if ( mod ( iter - 1 , nprint ) == 0 ) call fcn ( n , x , fvec , iflag ) if ( iflag < 0 ) goto 300 endif ! !           determine the direction p. ! call dogleg ( n , r , lr , diag , qtf , delta , wa1 , wa2 , wa3 ) ! !           store the direction p and x + p. calculate the norm of p. ! do j = 1 , n wa1 ( j ) = - wa1 ( j ) wa2 ( j ) = x ( j ) + wa1 ( j ) wa3 ( j ) = diag ( j ) * wa1 ( j ) enddo pnorm = enorm ( n , wa3 ) ! !           on the first iteration, adjust the initial step bound. ! if ( iter == 1 ) delta = dmin1 ( delta , pnorm ) ! !           evaluate the function at x + p and calculate its norm. ! iflag = 1 call fcn ( n , wa2 , wa4 , iflag ) nfev = nfev + 1 if ( iflag >= 0 ) then fnorm1 = enorm ( n , wa4 ) ! !           compute the scaled actual reduction. ! actred = - one if ( fnorm1 < fnorm ) actred = one - ( fnorm1 / fnorm ) ** 2 ! !           compute the scaled predicted reduction. ! l = 1 do i = 1 , n sum = zero do j = i , n sum = sum + r ( l ) * wa1 ( j ) l = l + 1 enddo wa3 ( i ) = qtf ( i ) + sum enddo temp = enorm ( n , wa3 ) prered = zero if ( temp < fnorm ) prered = one - ( temp / fnorm ) ** 2 ! !           compute the ratio of the actual to the predicted !           reduction. ! ratio = zero if ( prered > zero ) ratio = actred / prered ! !           update the step bound. ! if ( ratio >= p1 ) then ncfail = 0 ncsuc = ncsuc + 1 if ( ratio >= p5 . or . ncsuc > 1 ) delta = dmax1 ( delta , pnorm / p5 ) if ( abs ( ratio - one ) <= p1 ) delta = pnorm / p5 else ncsuc = 0 ncfail = ncfail + 1 delta = p5 * delta endif ! !           test for successful iteration. ! if ( ratio >= p0001 ) then ! !           successful iteration. update x, fvec, and their norms. ! do j = 1 , n x ( j ) = wa2 ( j ) wa2 ( j ) = diag ( j ) * x ( j ) fvec ( j ) = wa4 ( j ) enddo xnorm = enorm ( n , wa2 ) fnorm = fnorm1 iter = iter + 1 endif ! !           determine the progress of the iteration. ! nslow1 = nslow1 + 1 if ( actred >= p001 ) nslow1 = 0 if ( jeval ) nslow2 = nslow2 + 1 if ( actred >= p1 ) nslow2 = 0 ! !           test for convergence. ! if ( delta <= xtol * xnorm . or . fnorm == zero ) info = 1 if ( info == 0 ) then ! !           tests for termination and stringent tolerances. ! if ( nfev >= maxfev ) info = 2 if ( p1 * dmax1 ( p1 * delta , pnorm ) <= epsmch * xnorm ) info = 3 if ( nslow2 == 5 ) info = 4 if ( nslow1 == 10 ) info = 5 if ( info == 0 ) then ! !           criterion for recalculating jacobian approximation !           by forward differences. ! if ( ncfail == 2 ) goto 100 ! !           calculate the rank one modification to the jacobian !           and update qtf if necessary. ! do j = 1 , n sum = zero do i = 1 , n sum = sum + fjac ( i , j ) * wa4 ( i ) enddo wa2 ( j ) = ( sum - wa3 ( j )) / pnorm wa1 ( j ) = diag ( j ) * (( diag ( j ) * wa1 ( j )) / pnorm ) if ( ratio >= p0001 ) qtf ( j ) = sum enddo ! !           compute the qr factorization of the updated jacobian. ! call r1updt ( n , n , r , lr , wa1 , wa2 , wa3 , sing ) call r1mpyq ( n , n , fjac , ldfjac , wa2 , wa3 ) call r1mpyq ( 1 , n , qtf , 1 , wa2 , wa3 ) ! !           end of the inner loop. ! jeval = . false . ! !        end of the outer loop. ! goto 200 endif endif endif ! !     termination, either normal or user imposed. ! 300 if ( iflag < 0 ) info = iflag iflag = 0 if ( nprint > 0 ) call fcn ( n , x , fvec , iflag ) end subroutine hybrd !***************************************************************************************** !***************************************************************************************** !> !  the purpose of `hybrd1` is to find a zero of a system of !  `n` nonlinear functions in `n` variables by a modification !  of the powell hybrid method. this is done by using the !  more general nonlinear equation solver [[hybrd]]. the user !  must provide a subroutine which calculates the functions. !  the jacobian is then calculated by a forward-difference !  approximation. subroutine hybrd1 ( fcn , n , x , fvec , tol , info ) implicit none procedure ( fcn_hybrd ) :: fcn !! user-supplied subroutine which calculates the functions integer , intent ( in ) :: n !! a positive integer input variable set to the number !! of functions and variables. integer , intent ( out ) :: info !! an integer output variable. if the user has !! terminated execution, info is set to the (negative) !! value of `iflag`. see description of `fcn`. otherwise, !! `info` is set as follows: !!  ***info = 0*** improper input parameters. !!  ***info = 1*** algorithm estimates that the relative error !!  between `x` and the solution is at most `tol`. !!  ***info = 2*** number of calls to `fcn` has reached or exceeded !!  `200*(n+1)`. !!  ***info = 3*** `tol` is too small. no further improvement in !!  the approximate solution `x` is possible. !!  ***info = 4*** iteration is not making good progress. real ( wp ), intent ( in ) :: tol !! a nonnegative input variable. termination occurs !! when the algorithm estimates that the relative error !! between `x` and the solution is at most `tol`. real ( wp ), dimension ( n ), intent ( inout ) :: x !! an array of length `n`. on input `x` must contain !! an initial estimate of the solution vector. on output `x` !! contains the final estimate of the solution vector. real ( wp ), dimension ( n ), intent ( out ) :: fvec !! an output array of length `n` which contains !! the functions evaluated at the output `x`. integer :: lwa !! length of `wa` work array real ( wp ), dimension (:), allocatable :: wa !! work array integer :: index , j , lr , maxfev , ml , mode , mu , nfev , nprint real ( wp ) :: epsfcn , xtol real ( wp ), dimension ( n ) :: diag real ( wp ), parameter :: factor = 10 0.0_wp info = 0 ! check the input parameters for errors. if ( n > 0 . and . tol >= zero ) then !set up inputs: lwa = ( n * ( 3 * n + 13 )) / 2 ! the work array was formerly an input allocate ( wa ( lwa )) ! wa = 0.0_wp ! maxfev = 200 * ( n + 1 ) xtol = tol ml = n - 1 mu = n - 1 epsfcn = zero mode = 2 diag = one nprint = 0 lr = ( n * ( n + 1 )) / 2 index = 6 * n + lr ! call hybrd: call hybrd ( fcn , n , x , fvec , xtol , maxfev , ml , mu , epsfcn , diag , mode ,& factor , nprint , info , nfev , wa ( index + 1 ), n , wa ( 6 * n + 1 ), lr ,& wa ( n + 1 ), wa ( 2 * n + 1 ), wa ( 3 * n + 1 ), wa ( 4 * n + 1 ), wa ( 5 * n + 1 )) if ( info == 5 ) info = 4 deallocate ( wa ) endif end subroutine hybrd1 !***************************************************************************************** !***************************************************************************************** !> !  the purpose of hybrj is to find a zero of a system of !  n nonlinear functions in n variables by a modification !  of the powell hybrid method. the user must provide a !  subroutine which calculates the functions and the jacobian. ! !       fcn is the name of the user-supplied subroutine which !         calculates the functions and the jacobian. fcn must !         be declared in an external statement in the user !         calling program, and should be written as follows. ! !         subroutine fcn(n,x,fvec,fjac,ldfjac,iflag) !         integer n,ldfjac,iflag !         real(wp) x(n),fvec(n),fjac(ldfjac,n) !         ---------- !         if iflag = 1 calculate the functions at x and !         return this vector in fvec. do not alter fjac. !         if iflag = 2 calculate the jacobian at x and !         return this matrix in fjac. do not alter fvec. !         --------- !         return !         end ! !         the value of iflag should not be changed by fcn unless !         the user wants to terminate execution of hybrj. !         in this case set iflag to a negative integer. ! !       n is a positive integer input variable set to the number !         of functions and variables. ! !       x is an array of length n. on input x must contain !         an initial estimate of the solution vector. on output x !         contains the final estimate of the solution vector. ! !       fvec is an output array of length n which contains !         the functions evaluated at the output x. ! !       fjac is an output n by n array which contains the !         orthogonal matrix q produced by the qr factorization !         of the final approximate jacobian. ! !       ldfjac is a positive integer input variable not less than n !         which specifies the leading dimension of the array fjac. ! !       xtol is a nonnegative input variable. termination !         occurs when the relative error between two consecutive !         iterates is at most xtol. ! !       maxfev is a positive integer input variable. termination !         occurs when the number of calls to fcn with iflag = 1 !         has reached maxfev. ! !       diag is an array of length n. if mode = 1 (see !         below), diag is internally set. if mode = 2, diag !         must contain positive entries that serve as !         multiplicative scale factors for the variables. ! !       mode is an integer input variable. if mode = 1, the !         variables will be scaled internally. if mode = 2, !         the scaling is specified by the input diag. other !         values of mode are equivalent to mode = 1. ! !       factor is a positive input variable used in determining the !         initial step bound. this bound is set to the product of !         factor and the euclidean norm of diag*x if nonzero, or else !         to factor itself. in most cases factor should lie in the !         interval (.1,100.). 100. is a generally recommended value. ! !       nprint is an integer input variable that enables controlled !         printing of iterates if it is positive. in this case, !         fcn is called with iflag = 0 at the beginning of the first !         iteration and every nprint iterations thereafter and !         immediately prior to return, with x and fvec available !         for printing. fvec and fjac should not be altered. !         if nprint is not positive, no special calls of fcn !         with iflag = 0 are made. ! !       info is an integer output variable. if the user has !         terminated execution, info is set to the (negative) !         value of iflag. see description of fcn. otherwise, !         info is set as follows. ! !         info = 0   improper input parameters. ! !         info = 1   relative error between two consecutive iterates !                    is at most xtol. ! !         info = 2   number of calls to fcn with iflag = 1 has !                    reached maxfev. ! !         info = 3   xtol is too small. no further improvement in !                    the approximate solution x is possible. ! !         info = 4   iteration is not making good progress, as !                    measured by the improvement from the last !                    five jacobian evaluations. ! !         info = 5   iteration is not making good progress, as !                    measured by the improvement from the last !                    ten iterations. ! !       nfev is an integer output variable set to the number of !         calls to fcn with iflag = 1. ! !       njev is an integer output variable set to the number of !         calls to fcn with iflag = 2. ! !       r is an output array of length lr which contains the !         upper triangular matrix produced by the qr factorization !         of the final approximate jacobian, stored rowwise. ! !       lr is a positive integer input variable not less than !         (n*(n+1))/2. ! !       qtf is an output array of length n which contains !         the vector (q transpose)*fvec. ! !       wa1, wa2, wa3, and wa4 are work arrays of length n. ! !### Characteristics of the algorithm !  HYBRJ is a modification of the Powell hybrid method.  Two of its !  main characteristics involve the choice of the correction as a !  convex combination of the Newton and scaled gradient directions !  and the updating of the Jacobian by the rank-1 method of Broy- !  den.  The choice of the correction guarantees (under reasonable !  conditions) global convergence for starting points far from the !  solution and a fast rate of convergence.  The Jacobian is calcu- !  lated at the starting point, but it is not recalculated until !  the rank-1 method fails to produce satisfactory progress. ! !### References. !  * M. J. D. Powell, A Hybrid Method for Nonlinear Equations. !   Numerical Methods for Nonlinear Algebraic Equations, !   P. Rabinowitz, editor. Gordon and Breach, 1970. subroutine hybrj ( fcn , n , x , fvec , fjac , ldfjac , xtol , maxfev , diag , mode , & & factor , nprint , info , nfev , njev , r , lr , qtf , wa1 , wa2 , & & wa3 , wa4 ) implicit none procedure ( fcn_hybrj ) :: fcn integer n , ldfjac , maxfev , mode , nprint , info , nfev , njev , lr real ( wp ) xtol , factor real ( wp ) x ( n ) , fvec ( n ) , fjac ( ldfjac , n ) , diag ( n ) , & r ( lr ) , qtf ( n ) , wa1 ( n ) , wa2 ( n ) , wa3 ( n ) , & wa4 ( n ) integer i , iflag , iter , j , jm1 , l , ncfail , ncsuc , nslow1 , nslow2 integer iwa ( 1 ) logical jeval , sing real ( wp ) actred , delta , epsmch , fnorm , fnorm1 , & pnorm , prered , ratio ,& sum , temp , xnorm real ( wp ), parameter :: p1 = 1.0e-1_wp real ( wp ), parameter :: p5 = 5.0e-1_wp real ( wp ), parameter :: p001 = 1.0e-3_wp real ( wp ), parameter :: p0001 = 1.0e-4_wp epsmch = dpmpar ( 1 ) ! the machine precision ! info = 0 iflag = 0 nfev = 0 njev = 0 ! !     check the input parameters for errors. ! if ( n <= 0 . or . ldfjac < n . or . xtol < zero . or . maxfev <= 0 . or . & factor <= zero . or . lr < ( n * ( n + 1 )) / 2 ) goto 300 if ( mode == 2 ) then do j = 1 , n if ( diag ( j ) <= zero ) goto 300 enddo endif ! !     evaluate the function at the starting point !     and calculate its norm. ! iflag = 1 call fcn ( n , x , fvec , fjac , ldfjac , iflag ) nfev = 1 if ( iflag < 0 ) goto 300 fnorm = enorm ( n , fvec ) ! !     initialize iteration counter and monitors. ! iter = 1 ncsuc = 0 ncfail = 0 nslow1 = 0 nslow2 = 0 ! !     beginning of the outer loop. ! 100 jeval = . true . ! !        calculate the jacobian matrix. ! iflag = 2 call fcn ( n , x , fvec , fjac , ldfjac , iflag ) njev = njev + 1 if ( iflag < 0 ) goto 300 ! !        compute the qr factorization of the jacobian. ! call qrfac ( n , n , fjac , ldfjac ,. false ., iwa , 1 , wa1 , wa2 , wa3 ) ! !        on the first iteration and if mode is 1, scale according !        to the norms of the columns of the initial jacobian. ! if ( iter == 1 ) then if ( mode /= 2 ) then do j = 1 , n diag ( j ) = wa2 ( j ) if ( wa2 ( j ) == zero ) diag ( j ) = one enddo endif ! !        on the first iteration, calculate the norm of the scaled x !        and initialize the step bound delta. ! do j = 1 , n wa3 ( j ) = diag ( j ) * x ( j ) enddo xnorm = enorm ( n , wa3 ) delta = factor * xnorm if ( delta == zero ) delta = factor endif ! !        form (q transpose)*fvec and store in qtf. ! do i = 1 , n qtf ( i ) = fvec ( i ) enddo do j = 1 , n if ( fjac ( j , j ) /= zero ) then sum = zero do i = j , n sum = sum + fjac ( i , j ) * qtf ( i ) enddo temp = - sum / fjac ( j , j ) do i = j , n qtf ( i ) = qtf ( i ) + fjac ( i , j ) * temp enddo endif enddo ! !        copy the triangular factor of the qr factorization into r. ! sing = . false . do j = 1 , n l = j jm1 = j - 1 if ( jm1 >= 1 ) then do i = 1 , jm1 r ( l ) = fjac ( i , j ) l = l + n - i enddo endif r ( l ) = wa1 ( j ) if ( wa1 ( j ) == zero ) sing = . true . enddo ! !        accumulate the orthogonal factor in fjac. ! call qform ( n , n , fjac , ldfjac , wa1 ) ! !        rescale if necessary. ! if ( mode /= 2 ) then do j = 1 , n diag ( j ) = max ( diag ( j ), wa2 ( j )) enddo endif ! !        beginning of the inner loop. ! ! !           if requested, call fcn to enable printing of iterates. ! 200 if ( nprint > 0 ) then iflag = 0 if ( mod ( iter - 1 , nprint ) == 0 ) & & call fcn ( n , x , fvec , fjac , ldfjac , iflag ) if ( iflag < 0 ) goto 300 endif ! !           determine the direction p. ! call dogleg ( n , r , lr , diag , qtf , delta , wa1 , wa2 , wa3 ) ! !           store the direction p and x + p. calculate the norm of p. ! do j = 1 , n wa1 ( j ) = - wa1 ( j ) wa2 ( j ) = x ( j ) + wa1 ( j ) wa3 ( j ) = diag ( j ) * wa1 ( j ) enddo pnorm = enorm ( n , wa3 ) ! !           on the first iteration, adjust the initial step bound. ! if ( iter == 1 ) delta = min ( delta , pnorm ) ! !           evaluate the function at x + p and calculate its norm. ! iflag = 1 call fcn ( n , wa2 , wa4 , fjac , ldfjac , iflag ) nfev = nfev + 1 if ( iflag >= 0 ) then fnorm1 = enorm ( n , wa4 ) ! !           compute the scaled actual reduction. ! actred = - one if ( fnorm1 < fnorm ) actred = one - ( fnorm1 / fnorm ) ** 2 ! !           compute the scaled predicted reduction. ! l = 1 do i = 1 , n sum = zero do j = i , n sum = sum + r ( l ) * wa1 ( j ) l = l + 1 enddo wa3 ( i ) = qtf ( i ) + sum enddo temp = enorm ( n , wa3 ) prered = zero if ( temp < fnorm ) prered = one - ( temp / fnorm ) ** 2 ! !           compute the ratio of the actual to the predicted !           reduction. ! ratio = zero if ( prered > zero ) ratio = actred / prered ! !           update the step bound. ! if ( ratio >= p1 ) then ncfail = 0 ncsuc = ncsuc + 1 if ( ratio >= p5 . or . ncsuc > 1 ) delta = max ( delta , pnorm / p5 ) if ( abs ( ratio - one ) <= p1 ) delta = pnorm / p5 else ncsuc = 0 ncfail = ncfail + 1 delta = p5 * delta endif ! !           test for successful iteration. ! if ( ratio >= p0001 ) then ! !           successful iteration. update x, fvec, and their norms. ! do j = 1 , n x ( j ) = wa2 ( j ) wa2 ( j ) = diag ( j ) * x ( j ) fvec ( j ) = wa4 ( j ) enddo xnorm = enorm ( n , wa2 ) fnorm = fnorm1 iter = iter + 1 endif ! !           determine the progress of the iteration. ! nslow1 = nslow1 + 1 if ( actred >= p001 ) nslow1 = 0 if ( jeval ) nslow2 = nslow2 + 1 if ( actred >= p1 ) nslow2 = 0 ! !           test for convergence. ! if ( delta <= xtol * xnorm . or . fnorm == zero ) info = 1 if ( info == 0 ) then ! !           tests for termination and stringent tolerances. ! if ( nfev >= maxfev ) info = 2 if ( p1 * max ( p1 * delta , pnorm ) <= epsmch * xnorm ) info = 3 if ( nslow2 == 5 ) info = 4 if ( nslow1 == 10 ) info = 5 if ( info == 0 ) then ! !           criterion for recalculating jacobian. ! if ( ncfail == 2 ) goto 100 ! !           calculate the rank one modification to the jacobian !           and update qtf if necessary. ! do j = 1 , n sum = zero do i = 1 , n sum = sum + fjac ( i , j ) * wa4 ( i ) enddo wa2 ( j ) = ( sum - wa3 ( j )) / pnorm wa1 ( j ) = diag ( j ) * (( diag ( j ) * wa1 ( j )) / pnorm ) if ( ratio >= p0001 ) qtf ( j ) = sum enddo ! !           compute the qr factorization of the updated jacobian. ! call r1updt ( n , n , r , lr , wa1 , wa2 , wa3 , sing ) call r1mpyq ( n , n , fjac , ldfjac , wa2 , wa3 ) call r1mpyq ( 1 , n , qtf , 1 , wa2 , wa3 ) ! !           end of the inner loop. ! jeval = . false . ! !        end of the outer loop. ! goto 200 endif endif endif ! !     termination, either normal or user imposed. ! 300 if ( iflag < 0 ) info = iflag iflag = 0 if ( nprint > 0 ) call fcn ( n , x , fvec , fjac , ldfjac , iflag ) end subroutine hybrj !***************************************************************************************** !***************************************************************************************** !> !     the purpose of hybrj1 is to find a zero of a system of !     n nonlinear functions in n variables by a modification !     of the powell hybrid method. this is done by using the !     more general nonlinear equation solver hybrj. the user !     must provide a subroutine which calculates the functions !     and the jacobian. ! !     the subroutine statement is ! !       subroutine hybrj1(fcn,n,x,fvec,fjac,ldfjac,tol,info,wa,lwa) ! !     where ! !       fcn is the name of the user-supplied subroutine which !         calculates the functions and the jacobian. fcn must !         be declared in an external statement in the user !         calling program, and should be written as follows. ! !         subroutine fcn(n,x,fvec,fjac,ldfjac,iflag) !         integer n,ldfjac,iflag !         real(wp) x(n),fvec(n),fjac(ldfjac,n) !         ---------- !         if iflag = 1 calculate the functions at x and !         return this vector in fvec. do not alter fjac. !         if iflag = 2 calculate the jacobian at x and !         return this matrix in fjac. do not alter fvec. !         --------- !         return !         end ! !         the value of iflag should not be changed by fcn unless !         the user wants to terminate execution of hybrj1. !         in this case set iflag to a negative integer. ! !       n is a positive integer input variable set to the number !         of functions and variables. ! !       x is an array of length n. on input x must contain !         an initial estimate of the solution vector. on output x !         contains the final estimate of the solution vector. ! !       fvec is an output array of length n which contains !         the functions evaluated at the output x. ! !       fjac is an output n by n array which contains the !         orthogonal matrix q produced by the qr factorization !         of the final approximate jacobian. ! !       ldfjac is a positive integer input variable not less than n !         which specifies the leading dimension of the array fjac. ! !       tol is a nonnegative input variable. termination occurs !         when the algorithm estimates that the relative error !         between x and the solution is at most tol. ! !       info is an integer output variable. if the user has !         terminated execution, info is set to the (negative) !         value of iflag. see description of fcn. otherwise, !         info is set as follows. ! !         info = 0   improper input parameters. ! !         info = 1   algorithm estimates that the relative error !                    between x and the solution is at most tol. ! !         info = 2   number of calls to fcn with iflag = 1 has !                    reached 100*(n+1). ! !         info = 3   tol is too small. no further improvement in !                    the approximate solution x is possible. ! !         info = 4   iteration is not making good progress. ! !       wa is a work array of length lwa. ! !       lwa is a positive integer input variable not less than !         (n*(n+13))/2. subroutine hybrj1 ( fcn , n , x , fvec , fjac , ldfjac , tol , info , wa , lwa ) implicit none procedure ( fcn_hybrj ) :: fcn integer n , ldfjac , info , lwa real ( wp ) tol real ( wp ) x ( n ) , fvec ( n ) , fjac ( ldfjac , n ) , wa ( lwa ) integer j , lr , maxfev , mode , nfev , njev , nprint real ( wp ) xtol real ( wp ), parameter :: factor = 10 0.0_wp info = 0 ! check the input parameters for errors. if ( n > 0 . and . ldfjac >= n . and . tol >= zero . and . lwa >= ( n * ( n + 13 )) / 2 ) then ! call hybrj. maxfev = 100 * ( n + 1 ) xtol = tol mode = 2 do j = 1 , n wa ( j ) = one enddo nprint = 0 lr = ( n * ( n + 1 )) / 2 call hybrj ( fcn , n , x , fvec , fjac , ldfjac , xtol , maxfev , wa ( 1 ), mode , & factor , nprint , info , nfev , njev , wa ( 6 * n + 1 ), lr , wa ( n + 1 ), & wa ( 2 * n + 1 ), wa ( 3 * n + 1 ), wa ( 4 * n + 1 ), wa ( 5 * n + 1 )) if ( info == 5 ) info = 4 endif end subroutine hybrj1 !***************************************************************************************** !***************************************************************************************** !> !     this subroutine proceeds from the computed qr factorization of !     an m by n matrix a to accumulate the m by m orthogonal matrix !     q from its factored form. ! !     the subroutine statement is ! !       subroutine qform(m,n,q,ldq,wa) ! !     where ! !       m is a positive integer input variable set to the number !         of rows of a and the order of q. ! !       n is a positive integer input variable set to the number !         of columns of a. ! !       q is an m by m array. on input the full lower trapezoid in !         the first min(m,n) columns of q contains the factored form. !         on output q has been accumulated into a square matrix. ! !       ldq is a positive integer input variable not less than m !         which specifies the leading dimension of the array q. ! !       wa is a work array of length m. subroutine qform ( m , n , q , ldq , wa ) implicit none integer m , n , ldq real ( wp ) q ( ldq , m ) , wa ( m ) integer i , j , jm1 , k , l , minmn , np1 real ( wp ) sum , temp ! !     zero out upper triangle of q in the first min(m,n) columns. ! minmn = min ( m , n ) if ( minmn >= 2 ) then do j = 2 , minmn jm1 = j - 1 do i = 1 , jm1 q ( i , j ) = zero enddo enddo endif ! !     initialize remaining columns to those of the identity matrix. ! np1 = n + 1 if ( m >= np1 ) then do j = np1 , m do i = 1 , m q ( i , j ) = zero enddo q ( j , j ) = one enddo endif ! !     accumulate q from its factored form. ! do l = 1 , minmn k = minmn - l + 1 do i = k , m wa ( i ) = q ( i , k ) q ( i , k ) = zero enddo q ( k , k ) = one if ( wa ( k ) /= zero ) then do j = k , m sum = zero do i = k , m sum = sum + q ( i , j ) * wa ( i ) enddo temp = sum / wa ( k ) do i = k , m q ( i , j ) = q ( i , j ) - temp * wa ( i ) enddo enddo endif enddo end subroutine qform !***************************************************************************************** !***************************************************************************************** !> !     this subroutine uses householder transformations with column !     pivoting (optional) to compute a qr factorization of the !     m by n matrix a. that is, qrfac determines an orthogonal !     matrix q, a permutation matrix p, and an upper trapezoidal !     matrix r with diagonal elements of nonincreasing magnitude, !     such that a*p = q*r. the householder transformation for !     column k, k = 1,2,...,min(m,n), is of the form ! !                           t !           i - (1/u(k))*u*u ! !     where u has zeros in the first k-1 positions. the form of !     this transformation and the method of pivoting first !     appeared in the corresponding linpack subroutine. ! !     the subroutine statement is ! !       subroutine qrfac(m,n,a,lda,pivot,ipvt,lipvt,rdiag,acnorm,wa) ! !     where ! !       m is a positive integer input variable set to the number !         of rows of a. ! !       n is a positive integer input variable set to the number !         of columns of a. ! !       a is an m by n array. on input a contains the matrix for !         which the qr factorization is to be computed. on output !         the strict upper trapezoidal part of a contains the strict !         upper trapezoidal part of r, and the lower trapezoidal !         part of a contains a factored form of q (the non-trivial !         elements of the u vectors described above). ! !       lda is a positive integer input variable not less than m !         which specifies the leading dimension of the array a. ! !       pivot is a logical input variable. if pivot is set true, !         then column pivoting is enforced. if pivot is set false, !         then no column pivoting is done. ! !       ipvt is an integer output array of length lipvt. ipvt !         defines the permutation matrix p such that a*p = q*r. !         column j of p is column ipvt(j) of the identity matrix. !         if pivot is false, ipvt is not referenced. ! !       lipvt is a positive integer input variable. if pivot is false, !         then lipvt may be as small as 1. if pivot is true, then !         lipvt must be at least n. ! !       rdiag is an output array of length n which contains the !         diagonal elements of r. ! !       acnorm is an output array of length n which contains the !         norms of the corresponding columns of the input matrix a. !         if this information is not needed, then acnorm can coincide !         with rdiag. ! !       wa is a work array of length n. if pivot is false, then wa !         can coincide with rdiag. subroutine qrfac ( m , n , a , lda , pivot , ipvt , lipvt , rdiag , acnorm , wa ) implicit none integer m , n , lda , lipvt integer ipvt ( lipvt ) logical pivot real ( wp ) a ( lda , n ) , rdiag ( n ) , acnorm ( n ) , wa ( n ) integer i , j , jp1 , k , kmax , minmn real ( wp ) ajnorm , epsmch , sum , temp real ( wp ), parameter :: p05 = 5.0e-2_wp epsmch = dpmpar ( 1 ) ! the machine precision ! !     compute the initial column norms and initialize several arrays. ! do j = 1 , n acnorm ( j ) = enorm ( m , a ( 1 , j )) rdiag ( j ) = acnorm ( j ) wa ( j ) = rdiag ( j ) if ( pivot ) ipvt ( j ) = j enddo ! !     reduce a to r with householder transformations. ! minmn = min ( m , n ) do j = 1 , minmn if ( pivot ) then ! !        bring the column of largest norm into the pivot position. ! kmax = j do k = j , n if ( rdiag ( k ) > rdiag ( kmax ) ) kmax = k enddo if ( kmax /= j ) then do i = 1 , m temp = a ( i , j ) a ( i , j ) = a ( i , kmax ) a ( i , kmax ) = temp enddo rdiag ( kmax ) = rdiag ( j ) wa ( kmax ) = wa ( j ) k = ipvt ( j ) ipvt ( j ) = ipvt ( kmax ) ipvt ( kmax ) = k endif endif ! !        compute the householder transformation to reduce the !        j-th column of a to a multiple of the j-th unit vector. ! ajnorm = enorm ( m - j + 1 , a ( j , j )) if ( ajnorm /= zero ) then if ( a ( j , j ) < zero ) ajnorm = - ajnorm do i = j , m a ( i , j ) = a ( i , j ) / ajnorm enddo a ( j , j ) = a ( j , j ) + one ! !        apply the transformation to the remaining columns !        and update the norms. ! jp1 = j + 1 if ( n >= jp1 ) then do k = jp1 , n sum = zero do i = j , m sum = sum + a ( i , j ) * a ( i , k ) enddo temp = sum / a ( j , j ) do i = j , m a ( i , k ) = a ( i , k ) - temp * a ( i , j ) enddo if ( . not .(. not . pivot . or . rdiag ( k ) == zero ) ) then temp = a ( j , k ) / rdiag ( k ) rdiag ( k ) = rdiag ( k ) * sqrt ( max ( zero , one - temp ** 2 )) if ( p05 * ( rdiag ( k ) / wa ( k )) ** 2 <= epsmch ) then rdiag ( k ) = enorm ( m - j , a ( jp1 , k )) wa ( k ) = rdiag ( k ) endif endif enddo endif endif rdiag ( j ) = - ajnorm enddo end subroutine qrfac !***************************************************************************************** !***************************************************************************************** !> !     given an m by n matrix a, this subroutine computes a*q where !     q is the product of 2*(n - 1) transformations ! !           gv(n-1)*...*gv(1)*gw(1)*...*gw(n-1) ! !     and gv(i), gw(i) are givens rotations in the (i,n) plane which !     eliminate elements in the i-th and n-th planes, respectively. !     q itself is not given, rather the information to recover the !     gv, gw rotations is supplied. ! !     the subroutine statement is ! !       subroutine r1mpyq(m,n,a,lda,v,w) ! !     where ! !       m is a positive integer input variable set to the number !         of rows of a. ! !       n is a positive integer input variable set to the number !         of columns of a. ! !       a is an m by n array. on input a must contain the matrix !         to be postmultiplied by the orthogonal matrix q !         described above. on output a*q has replaced a. ! !       lda is a positive integer input variable not less than m !         which specifies the leading dimension of the array a. ! !       v is an input array of length n. v(i) must contain the !         information necessary to recover the givens rotation gv(i) !         described above. ! !       w is an input array of length n. w(i) must contain the !         information necessary to recover the givens rotation gw(i) !         described above. subroutine r1mpyq ( m , n , a , lda , v , w ) implicit none integer m , n , lda real ( wp ) a ( lda , n ) , v ( n ) , w ( n ) integer i , j , nmj , nm1 real ( wp ) cos , sin , temp ! !     apply the first set of givens rotations to a. ! nm1 = n - 1 if ( nm1 >= 1 ) then do nmj = 1 , nm1 j = n - nmj if ( abs ( v ( j )) > one ) cos = one / v ( j ) if ( abs ( v ( j )) > one ) sin = sqrt ( one - cos ** 2 ) if ( abs ( v ( j )) <= one ) sin = v ( j ) if ( abs ( v ( j )) <= one ) cos = sqrt ( one - sin ** 2 ) do i = 1 , m temp = cos * a ( i , j ) - sin * a ( i , n ) a ( i , n ) = sin * a ( i , j ) + cos * a ( i , n ) a ( i , j ) = temp enddo enddo ! !     apply the second set of givens rotations to a. ! do j = 1 , nm1 if ( abs ( w ( j )) > one ) cos = one / w ( j ) if ( abs ( w ( j )) > one ) sin = sqrt ( one - cos ** 2 ) if ( abs ( w ( j )) <= one ) sin = w ( j ) if ( abs ( w ( j )) <= one ) cos = sqrt ( one - sin ** 2 ) do i = 1 , m temp = cos * a ( i , j ) + sin * a ( i , n ) a ( i , n ) = - sin * a ( i , j ) + cos * a ( i , n ) a ( i , j ) = temp enddo enddo endif end subroutine r1mpyq !***************************************************************************************** !***************************************************************************************** !> !     given an m by n lower trapezoidal matrix s, an m-vector u, !     and an n-vector v, the problem is to determine an !     orthogonal matrix q such that ! !                   t !           (s + u*v )*q ! !     is again lower trapezoidal. ! !     this subroutine determines q as the product of 2*(n - 1) !     transformations ! !           gv(n-1)*...*gv(1)*gw(1)*...*gw(n-1) ! !     where gv(i), gw(i) are givens rotations in the (i,n) plane !     which eliminate elements in the i-th and n-th planes, !     respectively. q itself is not accumulated, rather the !     information to recover the gv, gw rotations is returned. ! !     the subroutine statement is ! !       subroutine r1updt(m,n,s,ls,u,v,w,sing) ! !     where ! !       m is a positive integer input variable set to the number !         of rows of s. ! !       n is a positive integer input variable set to the number !         of columns of s. n must not exceed m. ! !       s is an array of length ls. on input s must contain the lower !         trapezoidal matrix s stored by columns. on output s contains !         the lower trapezoidal matrix produced as described above. ! !       ls is a positive integer input variable not less than !         (n*(2*m-n+1))/2. ! !       u is an input array of length m which must contain the !         vector u. ! !       v is an array of length n. on input v must contain the vector !         v. on output v(i) contains the information necessary to !         recover the givens rotation gv(i) described above. ! !       w is an output array of length m. w(i) contains information !         necessary to recover the givens rotation gw(i) described !         above. ! !       sing is a logical output variable. sing is set true if any !         of the diagonal elements of the output s are zero. otherwise !         sing is set false. subroutine r1updt ( m , n , s , ls , u , v , w , sing ) implicit none integer m , n , ls logical sing real ( wp ) s ( ls ) , u ( m ) , v ( n ) , w ( m ) integer i , j , jj , l , nmj , nm1 real ( wp ) cos , cotan , giant , sin , & & tan , tau , temp real ( wp ), parameter :: p5 = 5.0e-1_wp real ( wp ), parameter :: p25 = 2.5e-1_wp ! !     giant is the largest magnitude. ! giant = dpmpar ( 3 ) ! !     initialize the diagonal element pointer. ! jj = ( n * ( 2 * m - n + 1 )) / 2 - ( m - n ) ! !     move the nontrivial part of the last column of s into w. ! l = jj do i = n , m w ( i ) = s ( l ) l = l + 1 enddo ! !     rotate the vector v into a multiple of the n-th unit vector !     in such a way that a spike is introduced into w. ! nm1 = n - 1 if ( nm1 >= 1 ) then do nmj = 1 , nm1 j = n - nmj jj = jj - ( m - j + 1 ) w ( j ) = zero if ( v ( j ) /= zero ) then ! !        determine a givens rotation which eliminates the !        j-th element of v. ! if ( abs ( v ( n )) >= abs ( v ( j )) ) then tan = v ( j ) / v ( n ) cos = p5 / sqrt ( p25 + p25 * tan ** 2 ) sin = cos * tan tau = sin else cotan = v ( n ) / v ( j ) sin = p5 / sqrt ( p25 + p25 * cotan ** 2 ) cos = sin * cotan tau = one if ( abs ( cos ) * giant > one ) tau = one / cos endif ! !        apply the transformation to v and store the information !        necessary to recover the givens rotation. ! v ( n ) = sin * v ( j ) + cos * v ( n ) v ( j ) = tau ! !        apply the transformation to s and extend the spike in w. ! l = jj do i = j , m temp = cos * s ( l ) - sin * w ( i ) w ( i ) = sin * s ( l ) + cos * w ( i ) s ( l ) = temp l = l + 1 enddo endif enddo endif ! !     add the spike from the rank 1 update to w. ! do i = 1 , m w ( i ) = w ( i ) + v ( n ) * u ( i ) enddo ! !     eliminate the spike. ! sing = . false . if ( nm1 >= 1 ) then do j = 1 , nm1 if ( w ( j ) /= zero ) then ! !        determine a givens rotation which eliminates the !        j-th element of the spike. ! if ( abs ( s ( jj )) >= abs ( w ( j )) ) then tan = w ( j ) / s ( jj ) cos = p5 / sqrt ( p25 + p25 * tan ** 2 ) sin = cos * tan tau = sin else cotan = s ( jj ) / w ( j ) sin = p5 / sqrt ( p25 + p25 * cotan ** 2 ) cos = sin * cotan tau = one if ( abs ( cos ) * giant > one ) tau = one / cos endif ! !        apply the transformation to s and reduce the spike in w. ! l = jj do i = j , m temp = cos * s ( l ) + sin * w ( i ) w ( i ) = - sin * s ( l ) + cos * w ( i ) s ( l ) = temp l = l + 1 enddo ! !        store the information necessary to recover the !        givens rotation. ! w ( j ) = tau endif ! !        test for zero diagonal elements in the output s. ! if ( s ( jj ) == zero ) sing = . true . jj = jj + ( m - j + 1 ) enddo endif ! !     move w back into the last column of the output s. ! l = jj do i = n , m s ( l ) = w ( i ) l = l + 1 enddo if ( s ( jj ) == zero ) sing = . true . end subroutine r1updt !***************************************************************************************** !***************************************************************************************** end module minpack_module !*****************************************************************************************","tags":"","url":"sourcefile/minpack_module.f90.html"},{"title":"lambert_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~lambert_module.f90~~EfferentGraph sourcefile~lambert_module.f90 lambert_module.f90 sourcefile~gooding_module.f90 gooding_module.f90 sourcefile~lambert_module.f90->sourcefile~gooding_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~lambert_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~lambert_module.f90->sourcefile~numbers_module.f90 sourcefile~random_module.f90 random_module.f90 sourcefile~lambert_module.f90->sourcefile~random_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~lambert_module.f90->sourcefile~vector_module.f90 sourcefile~gooding_module.f90->sourcefile~kind_module.f90 sourcefile~gooding_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~random_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~lambert_module.f90~~AfferentGraph sourcefile~lambert_module.f90 lambert_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lambert_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  This module contains the Izzo and Gooding algorithms for solving Lambert's problem. module lambert_module use kind_module , only : wp use numbers_module use vector_module , only : cross , unit , ucross implicit none private !constants: real ( wp ), parameter :: log2 = log ( two ) real ( wp ), parameter :: two_third = two / three real ( wp ), parameter :: four_third = four / three real ( wp ), parameter :: five_half = five / two real ( wp ), parameter :: three_half = three / two abstract interface function func ( t ) result ( f ) !! interface to the [[zeroin]] input function import :: wp implicit none real ( wp ), intent ( in ) :: t !! Independant variable for the function. real ( wp ) :: f !! The function evaluated at `t`. end function func end interface !public routines: public :: solve_lambert_izzo public :: solve_lambert_gooding public :: solve_lambert_arorarussell public :: lambert_test contains !***************************************************************************************** !***************************************************************************************** !> !  Solve Lambert's problem using Izzo's method. ! !# References ! !  1. D. Izzo, [Revisiting Lambert's Problem](http://arxiv-web3.library.cornell.edu/abs/1403.2705) !     [v2] Tue, 24 Jun 2014 13:08:37 GMT (606kb,D) !  2. [PyKEP](https://github.com/esa/pykep) !  3. R. A. Battin, \"An Introduction to the Mathematics and Methods of !     Astrodynamics (Revised Edition)\", AIAA Education Series, 1999. subroutine solve_lambert_izzo ( r1 , r2 , tof , mu , long_way , multi_revs , v1 , v2 , status_ok ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r1 !! first cartesian position [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r2 !! second cartesian position [km] real ( wp ), intent ( in ) :: tof !! time of flight [sec] real ( wp ), intent ( in ) :: mu !! gravity parameter [km&#94;3/s&#94;2] logical , intent ( in ) :: long_way !! when true, do \"long way\" (>pi) transfers integer , intent ( in ) :: multi_revs !! maximum number of multi-rev solutions to compute real ( wp ), dimension (:,:), allocatable , intent ( out ) :: v1 !! vector containing 3d arrays with the cartesian components of the velocities at r1 real ( wp ), dimension (:,:), allocatable , intent ( out ) :: v2 !! vector containing 3d arrays with the cartesian components of the velocities at r2 logical , intent ( out ) :: status_ok !! true if everything is OK !local variables: real ( wp ), dimension (:), allocatable :: x real ( wp ), dimension ( 3 ) :: r1_hat , r2_hat , h_hat , it1 , it2 , c real ( wp ) :: s , cmag , lambda2 , lambda3 , lambda5 , t , t00 , t0 , t1 , r1mag , r2mag ,& d3t , d2t , dt , err , t_min , x_old , x_new , term , lambda ,& gamma , rho , sigma , vr1 , vt1 , vr2 , vt2 , y , vt , ly integer :: n_solutions , it , m_nmax , i , iter !tolerances are from [2] integer , parameter :: max_halley_iters = 12 !! for halley iterations real ( wp ), parameter :: halley_tol = 1e-13_wp !! for halley iterations real ( wp ), parameter :: htol_singlerev = 1e-5_wp !! for householder iterations real ( wp ), parameter :: htol_multirev = 1e-8_wp !! for householder iterations !======= Begin Algorithm 1 in [1] ======= r1mag = norm2 ( r1 ) r2mag = norm2 ( r2 ) !check for valid inputs: if ( tof <= zero . or . mu <= zero . or . r1mag == zero . or . r2mag == zero ) then write ( * , * ) 'Error in solve_lambert_izzo: invalid input' status_ok = . false . return end if status_ok = . true . c = r2 - r1 cmag = norm2 ( c ) s = ( cmag + r1mag + r2mag ) / two t = sqrt ( two * mu / ( s * s * s )) * tof r1_hat = unit ( r1 ) r2_hat = unit ( r2 ) h_hat = ucross ( r1_hat , r2_hat ) lambda2 = one - cmag / s lambda = sqrt ( lambda2 ) if ( all ( h_hat == zero ) ) then write ( * , * ) 'Warning: pi transfer in solve_lambert_izzo' !arbitrarily choose the transfer plane: h_hat = [ zero , zero , one ] end if it1 = ucross ( h_hat , r1_hat ) it2 = ucross ( h_hat , r2_hat ) if ( long_way ) then lambda = - lambda it1 = - it1 it2 = - it2 end if lambda3 = lambda * lambda2 lambda5 = lambda2 * lambda3 t1 = two_third * ( one - lambda3 ) !======= Begin Algorithm 2 in [1] ======= ![xlist, ylist] = findxy(lambda, tof) ! maximum number of revolutions for which a solution exists: m_nmax = floor ( t / pi ) t00 = acos ( lambda ) + lambda * sqrt ( one - lambda2 ) t0 = t00 + m_nmax * pi if ( t < t0 . and . m_nmax > 0 ) then ! Compute xm and tm using Halley dt = zero d2t = zero d3t = zero it = 0 err = one t_min = t0 x_old = zero x_new = zero do call dtdx ( dt , d2t , d3t , x_old , t_min ) if ( dt /= zero ) x_new = x_old - dt * d2t / ( d2t * d2t - dt * d3t / two ) err = abs ( x_old - x_new ) if ( ( err < halley_tol ) . or . ( it > max_halley_iters ) ) exit call compute_tof ( x_new , m_nmax , t_min ) x_old = x_new it = it + 1 end do if ( t_min > t ) m_nmax = m_nmax - 1 end if !======= End Algorithm 2 ======= !mmax is the maximum number of revolutions. !Truncate to user-input multi_revs value if it is larger. m_nmax = min ( multi_revs , m_nmax ) !the number of solutions to the problem: n_solutions = m_nmax * 2 + 1 !allocate output arrays: allocate ( v1 ( 3 , n_solutions )) allocate ( v2 ( 3 , n_solutions )) allocate ( x ( n_solutions )) ! Find the x value for each solution: ! initial guess for 0 rev solution: if ( t >= t00 ) then x ( 1 ) = - ( t - t00 ) / ( t - t00 + four ) !from [2] elseif ( t <= t1 ) then x ( 1 ) = five_half * ( t1 * ( t1 - t )) / ( t * ( one - lambda5 )) + one else x ( 1 ) = ( t / t00 ) ** ( log2 / log ( t1 / t00 ) ) - one !from [2] end if ! 0 rev solution: iter = householder ( t , x ( 1 ), 0 , htol_singlerev ) ! multi-rev solutions: do i = 1 , m_nmax !Eqn 31: ! left solution: term = (( i * pi + pi ) / ( eight * t )) ** two_third x ( 2 * i ) = ( term - one ) / ( term + one ) iter = householder ( t , x ( 2 * i ), i , htol_multirev ) ! right solution: term = (( eight * t ) / ( i * pi )) ** two_third x ( 2 * i + 1 ) = ( term - one ) / ( term + one ) iter = householder ( t , x ( 2 * i + 1 ), i , htol_multirev ) end do ! construct terminal velocity vectors using each x: gamma = sqrt ( mu * s / two ) rho = ( r1mag - r2mag ) / cmag sigma = sqrt ( one - rho * rho ) do i = 1 , n_solutions y = sqrt ( one - lambda2 + lambda2 * x ( i ) * x ( i )) ly = lambda * y vr1 = gamma * (( ly - x ( i )) - rho * ( ly + x ( i ))) / r1mag vr2 = - gamma * (( ly - x ( i )) + rho * ( ly + x ( i ))) / r2mag vt = gamma * sigma * ( y + lambda * x ( i )) vt1 = vt / r1mag vt2 = vt / r2mag v1 (:, i ) = vr1 * r1_hat + vt1 * it1 !terminal velocity vectors v2 (:, i ) = vr2 * r2_hat + vt2 * it2 ! end do deallocate ( x ) contains !***************************************************************************************** !************************************************************************************* function householder ( t , x , n , eps ) result ( it ) !! Householder root solver for x. implicit none integer :: it real ( wp ), intent ( in ) :: t real ( wp ), intent ( inout ) :: x !! input is initial guess integer , intent ( in ) :: n real ( wp ), intent ( in ) :: eps real ( wp ) :: xnew , tof , delta , dt , d2t , d3t , dt2 , term integer , parameter :: max_iters = 15 do it = 1 , max_iters call compute_tof ( x , n , tof ) call dtdx ( dt , d2t , d3t , x , tof ) delta = tof - t dt2 = dt * dt term = delta * ( dt2 - delta * d2t / two ) / & ( dt * ( dt2 - delta * d2t ) + d3t * delta * delta / six ) xnew = x - term ! Ref. [1], p. 12. x = xnew if ( abs ( term ) <= eps ) exit end do end function householder !************************************************************************************* !************************************************************************************* subroutine dtdx ( dt , d2t , d3t , x , t ) !! Compute 1st-3rd derivatives for the Householder iterations. implicit none real ( wp ), intent ( out ) :: dt real ( wp ), intent ( out ) :: d2t real ( wp ), intent ( out ) :: d3t real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: t real ( wp ) :: umx2 , y , y2 , y3 , y5 , umx2_inv umx2 = one - x * x umx2_inv = one / umx2 y = sqrt ( one - lambda2 * umx2 ) !Ref [1], p. 6 y2 = y * y y3 = y2 * y y5 = y3 * y2 !Ref [1], Eqn. 22: dt = umx2_inv * ( three * t * x - two + two * lambda3 * x / y ) d2t = umx2_inv * ( three * t + five * x * dt + two * ( one - lambda2 ) * lambda3 / y3 ) d3t = umx2_inv * ( seven * x * d2t + eight * dt - six * ( one - lambda2 ) * lambda5 * x / y5 ) end subroutine dtdx !************************************************************************************* !************************************************************************************* subroutine compute_tof ( x , n , tof ) !!  Compute time of flight from x implicit none real ( wp ), intent ( in ) :: x integer , intent ( in ) :: n real ( wp ), intent ( out ) :: tof real ( wp ), parameter :: battin = 0.01_wp real ( wp ), parameter :: lagrange = 0.2_wp real ( wp ) :: dist , k , e , rho , z , eta , s1 , q , y , g , d , l , f , a , alpha , beta dist = abs ( x - one ) if ( dist < lagrange . and . dist > battin ) then !use lagrange tof expression !See Ref. [1], Eqn. 9 a = one / ( one - x * x ) if ( a > zero ) then !ellipse alpha = two * acos ( x ) beta = two * asin ( sqrt ( lambda2 / a )) if ( lambda < zero ) beta = - beta tof = (( a * sqrt ( a ) * (( alpha - sin ( alpha )) - ( beta - sin ( beta )) + two * pi * n )) / two ) else !hyperbola alpha = two * acosh ( x ) beta = two * asinh ( sqrt ( - lambda2 / a )) if ( lambda < zero ) beta = - beta tof = ( - a * sqrt ( - a ) * (( beta - sinh ( beta )) - ( alpha - sinh ( alpha ))) / two ) end if else k = lambda2 e = x * x - one rho = abs ( e ) z = sqrt ( one + k * e ) if ( dist < battin ) then ! use battin series tof expression !Equation 20 in [1]: ! !See also: Ref. [3], Eqn. 7.30, p. 304. eta = z - lambda * x s1 = ( one - lambda - x * eta ) / two q = four_third * hypergeo ( s1 ) tof = ( eta * eta * eta * q + four * lambda * eta ) / two + n * pi / ( rho ** three_half ) else ! use lancaster tof expresion y = sqrt ( rho ) g = x * z - lambda * e d = zero if ( e < zero ) then l = acos ( g ) d = n * pi + l else f = y * ( z - lambda * x ) d = log ( f + g ) end if tof = ( x - lambda * z - d / y ) / e end if end if end subroutine compute_tof !************************************************************************************* !************************************************************************************* pure function hypergeo ( x ) result ( f ) !!  Evaluate the Gaussian (or ordinary) hypergeometric function: F(3,1,5/2,x) !!  See Ref. [3], p. 34. implicit none real ( wp ) :: f real ( wp ), intent ( in ) :: x real ( wp ) :: term integer :: i real ( wp ), parameter :: tol = 1e-11_wp integer , parameter :: max_iters = 10000 !initialize: f = one term = one !compute the series until the last term is within convergence tolerance: do i = 0 , max_iters term = term * ( three + i ) * ( one + i ) / ( five_half + i ) * x / ( i + one ) f = f + term if ( abs ( term ) <= tol ) exit end do end function hypergeo !************************************************************************************* end subroutine solve_lambert_izzo !***************************************************************************************** !***************************************************************************************** !> !  Solve Lambert's problem using Gooding's method. ! !# References ! !  1. R. H, Gooding. \"[A procedure for the solution of Lambert's orbital !     boundary-value problem](http://adsabs.harvard.edu/abs/1990CeMDA..48..145G)\" !     Celestial Mechanics and Dynamical Astronomy, !     vol. 48, no. 2, 1990, p. 145-165. !  2. A. Klumpp, \"Performance Comparision of Lambert and Kepler Algorithms\", !     JPL Interoffice Memorandum, 314.1-0426-ARK, Jan 2, 1991. !     [Zip](http://derastrodynamics.com/docs/lambert_papers_v1.zip) subroutine solve_lambert_gooding ( r1 , r2 , tof , mu , long_way , multi_revs , v1 , v2 , status_ok ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r1 !! first cartesian position [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r2 !! second cartesian position [km] real ( wp ), intent ( in ) :: tof !! time of flight [sec] real ( wp ), intent ( in ) :: mu !! gravity parameter [km&#94;3/s&#94;2] logical , intent ( in ) :: long_way !! when true, do \"long way\" (>pi) transfers integer , intent ( in ) :: multi_revs !! maximum number of multi-rev solutions to compute real ( wp ), dimension (:,:), allocatable , intent ( out ) :: v1 !! vector containing 3d arrays with the cartesian components of the velocities at r1 real ( wp ), dimension (:,:), allocatable , intent ( out ) :: v2 !! vector containing 3d arrays with the cartesian components of the velocities at r2 logical , intent ( out ) :: status_ok !! true if everything is OK integer :: i , j , k , n , n_solutions real ( wp ) :: num_revs , pa , ta , r1mag , r2mag , dr , r1r2 real ( wp ), dimension ( 3 , 2 ) :: vt1 , vt2 real ( wp ), dimension ( 3 ) :: r1hat , r2hat , r1xr2 , rho , r1xr2_hat , etai , etaf real ( wp ), dimension ( 2 ) :: vri , vti , vrf , vtf !temp arrays to hold all the solutions: ! they will be packed into the output arrays logical , dimension ( 2 * multi_revs + 1 ) :: solution_exists real ( wp ), dimension ( 3 , 1 + 2 * multi_revs ) :: all_vt1 , all_vt2 r1mag = norm2 ( r1 ) r2mag = norm2 ( r2 ) if ( r1mag == 0.0_wp . or . r2mag == 0.0_wp . or . mu <= 0.0_wp . or . tof <= 0.0_wp ) then write ( * , * ) 'Error in solve_lambert_gooding: invalid input' status_ok = . false . return end if !initialize: solution_exists = . false . status_ok = . true . dr = r1mag - r2mag r1r2 = r1mag * r2mag r1hat = r1 / r1mag r2hat = r2 / r2mag r1xr2 = cross ( r1 , r2 ) if ( all ( r1xr2 == 0.0_wp )) then !the vectors are parallel, ! so the transfer plane is undefined write ( * , * ) 'Warning: pi transfer in solve_lambert_gooding' r1xr2 = [ 0.0_wp , 0.0_wp , 1.0_wp ] !degenerate conic...choose the x-y plane end if r1xr2_hat = unit ( r1xr2 ) !a trick to make sure argument is between [-1 and 1]: pa = acos ( max ( - 1.0_wp , min ( 1.0_wp , dot_product ( r1hat , r2hat )))) do i = 0 , multi_revs num_revs = real ( i , wp ) !number of complete revs for this case !transfer angle and normal vector: if ( long_way ) then ! greater than pi ta = num_revs * twopi + ( twopi - pa ) rho = - r1xr2_hat else ! less than pi ta = num_revs * twopi + pa rho = r1xr2_hat end if etai = cross ( rho , r1hat ) etaf = cross ( rho , r2hat ) !Gooding routine: call vlamb ( mu , r1mag , r2mag , ta , tof , n , vri , vti , vrf , vtf ) select case ( n ) !number of solutions case ( 1 ) vt1 (:, 1 ) = vri ( 1 ) * r1hat + vti ( 1 ) * etai vt2 (:, 1 ) = vrf ( 1 ) * r2hat + vtf ( 1 ) * etaf case ( 2 ) vt1 (:, 1 ) = vri ( 1 ) * r1hat + vti ( 1 ) * etai vt2 (:, 1 ) = vrf ( 1 ) * r2hat + vtf ( 1 ) * etaf vt1 (:, 2 ) = vri ( 2 ) * r1hat + vti ( 2 ) * etai vt2 (:, 2 ) = vrf ( 2 ) * r2hat + vtf ( 2 ) * etaf end select if ( i == 0 . and . n == 1 ) then !there can be only one solution all_vt1 (:, 1 ) = vt1 (:, 1 ) all_vt2 (:, 1 ) = vt2 (:, 1 ) solution_exists ( 1 ) = . true . else select case ( n ) case ( 1 ) all_vt1 (:, 2 * i ) = vt1 (:, 1 ) all_vt2 (:, 2 * i ) = vt2 (:, 1 ) solution_exists ( 2 * i ) = . true . case ( 2 ) all_vt1 (:, 2 * i ) = vt1 (:, 1 ) all_vt2 (:, 2 * i ) = vt2 (:, 1 ) solution_exists ( 2 * i ) = . true . all_vt1 (:, 2 * i + 1 ) = vt1 (:, 2 ) all_vt2 (:, 2 * i + 1 ) = vt2 (:, 2 ) solution_exists ( 2 * i + 1 ) = . true . end select end if end do !return all the solutions: n_solutions = count ( solution_exists ) allocate ( v1 ( 3 , n_solutions )) allocate ( v2 ( 3 , n_solutions )) k = 0 do i = 1 , size ( solution_exists ) if ( solution_exists ( i )) then k = k + 1 v1 (:, k ) = all_vt1 (:, i ) v2 (:, k ) = all_vt2 (:, i ) end if end do contains !***************************************************************************************** !************************************************************************************* subroutine vlamb ( gm , r1 , r2 , th , tdelt , n , vri , vti , vrf , vtf ) !!  Gooding support routine !!  Note: this contains the modification from [2] implicit none real ( wp ), intent ( in ) :: gm real ( wp ), intent ( in ) :: r1 real ( wp ), intent ( in ) :: r2 real ( wp ), intent ( in ) :: th real ( wp ), intent ( in ) :: tdelt integer , intent ( out ) :: n real ( wp ), dimension ( 2 ), intent ( out ) :: vri real ( wp ), dimension ( 2 ), intent ( out ) :: vti real ( wp ), dimension ( 2 ), intent ( out ) :: vrf real ( wp ), dimension ( 2 ), intent ( out ) :: vtf integer :: m , i real ( wp ) :: thr2 , r1r2th , csq , c , s , gms , qsqfm1 , q , rho , sig , t , x1 , x2 , x , unused ,& qzminx , qzplx , zplqx , vt2 , vr1 , vt1 , vr2 !the following yields m = 0 when th = 2 pi exactly ! neither this nor the original code works for th < 0.0 thr2 = th m = 0 do while ( thr2 > twopi ) thr2 = thr2 - twopi m = m + 1 end do thr2 = thr2 / 2.0_wp !note: dr and r1r2 are computed in the calling routine r1r2th = 4.0_wp * r1r2 * sin ( thr2 ) ** 2 csq = dr * dr + r1r2th c = sqrt ( csq ) s = ( r1 + r2 + c ) / 2.0_wp gms = sqrt ( gm * s / 2.0_wp ) qsqfm1 = c / s q = sqrt ( r1r2 ) * cos ( thr2 ) / s if ( c /= 0.0_wp ) then rho = dr / c sig = r1r2th / csq else rho = 0.0_wp sig = 1.0_wp end if t = 4.0_wp * gms * tdelt / s ** 2 call xlamb ( m , q , qsqfm1 , t , n , x1 , x2 ) !proceed for single solution, or a pair do i = 1 , n if ( i == 1 ) then x = x1 else x = x2 end if call tlamb ( m , q , qsqfm1 , x , - 1 , unused , qzminx , qzplx , zplqx ) vt2 = gms * zplqx * sqrt ( sig ) vr1 = gms * ( qzminx - qzplx * rho ) / r1 vt1 = vt2 / r1 vr2 = - gms * ( qzminx + qzplx * rho ) / r2 vt2 = vt2 / r2 vri ( i ) = vr1 vti ( i ) = vt1 vrf ( i ) = vr2 vtf ( i ) = vt2 end do end subroutine vlamb !************************************************************************************* !************************************************************************************* subroutine tlamb ( m , q , qsqfm1 , x , n , t , dt , d2t , d3t ) !!  Gooding support routine implicit none real ( wp ), intent ( in ) :: q real ( wp ), intent ( in ) :: qsqfm1 real ( wp ), intent ( in ) :: x integer , intent ( in ) :: n real ( wp ), intent ( out ) :: t real ( wp ), intent ( out ) :: dt real ( wp ), intent ( out ) :: d2t real ( wp ), intent ( out ) :: d3t integer :: m , i real ( wp ) :: qsq , xsq , u , y , z ,& qx , a , b , aa , bb , g , f , fg1 , term , fg1sq , twoi1 ,& told , qz , qz2 , u0i , u1i , u2i , u3i , tq , tqsum ,& ttmold , p , tterm , tqterm logical :: lm1 , l1 , l2 , l3 real ( wp ), parameter :: sw = 0.4_wp lm1 = n ==- 1 l1 = n >= 1 l2 = n >= 2 l3 = n == 3 qsq = q * q xsq = x * x u = ( 1.0_wp - x ) * ( 1.0_wp + x ) if (. not . lm1 ) then !(needed if series, and otherwise useful when z = 0) dt = 0.0_wp d2t = 0.0_wp d3t = 0.0_wp end if if ( lm1 . or . m > 0 . or . x < 0.0_wp . or . abs ( u ) > sw ) then !direct computation (not series) y = sqrt ( abs ( u )) z = sqrt ( qsqfm1 + qsq * xsq ) qx = q * x if ( qx <= 0.0_wp ) then a = z - qx b = q * z - x end if if ( qx < 0.0_wp . and . lm1 ) then aa = qsqfm1 / a bb = qsqfm1 * ( qsq * u - xsq ) / b end if if ( qx == 0.0_wp . and . lm1 . or . qx > 0.0_wp ) then aa = z + qx bb = q * z + x end if if ( qx > 0.0_wp ) then a = qsqfm1 / aa b = qsqfm1 * ( qsq * u - xsq ) / bb end if if (. not . lm1 ) then if ( qx * u >= 0.0_wp ) then g = x * z + q * u else g = ( xsq - qsq * u ) / ( x * z - q * u ) end if f = a * y if ( x <= 1.0_wp ) then t = m * pi + atan2 ( f , g ) else if ( f > sw ) then t = log ( f + g ) else fg1 = f / ( g + 1.0_wp ) term = 2.0_wp * fg1 fg1sq = fg1 * fg1 t = term twoi1 = 1.0_wp do twoi1 = twoi1 + 2.0_wp term = term * fg1sq told = t t = t + term / twoi1 if ( t /= told ) cycle exit end do !(continue looping for inverse tanh) end if end if t = 2.0_wp * ( t / y + b ) / u if ( l1 . and . z /= 0.0_wp ) then qz = q / z qz2 = qz * qz qz = qz * qz2 dt = ( 3.0_wp * x * t - 4.0_wp * ( a + qx * qsqfm1 ) / z ) / u if ( l2 ) d2t = ( 3.0_wp * t + 5.0_wp * x * dt + 4.0_wp * qz * qsqfm1 ) / u if ( l3 ) d3t = ( 8.0_wp * dt + 7.0_wp * x * d2t - 1 2.0_wp * qz * qz2 * x * qsqfm1 ) / u end if else dt = b d2t = bb d3t = aa end if else !compute by series u0i = 1.0_wp if ( l1 ) u1i = 1.0_wp if ( l2 ) u2i = 1.0_wp if ( l3 ) u3i = 1.0_wp term = 4.0_wp tq = q * qsqfm1 i = 0 if ( q < 0.5_wp ) tqsum = 1.0_wp - q * qsq if ( q >= 0.5_wp ) tqsum = ( 1.0_wp / ( 1.0_wp + q ) + q ) * qsqfm1 ttmold = term / 3.0_wp t = ttmold * tqsum do i = i + 1 p = i u0i = u0i * u if ( l1 . and . i > 1 ) u1i = u1i * u if ( l2 . and . i > 2 ) u2i = u2i * u if ( l3 . and . i > 3 ) u3i = u3i * u term = term * ( p - 0.5_wp ) / p tq = tq * qsq tqsum = tqsum + tq told = t tterm = term / ( 2.0_wp * p + 3.0_wp ) tqterm = tterm * tqsum t = t - u0i * (( 1.5_wp * p + 0.25_wp ) * tqterm / ( p * p - 0.25_wp ) - ttmold * tq ) ttmold = tterm tqterm = tqterm * p if ( l1 ) dt = dt + tqterm * u1i if ( l2 ) d2t = d2t + tqterm * u2i * ( p - 1.0_wp ) if ( l3 ) d3t = d3t + tqterm * u3i * ( p - 1.0_wp ) * ( p - 2.0_wp ) if ( i < n . or . t /= told ) cycle exit end do if ( l3 ) d3t = 8.0_wp * x * ( 1.5_wp * d2t - xsq * d3t ) if ( l2 ) d2t = 2.0_wp * ( 2.0_wp * xsq * d2t - dt ) if ( l1 ) dt = - 2.0_wp * x * dt t = t / xsq end if end subroutine tlamb !************************************************************************************* !************************************************************************************* pure function d8rt ( x ) !!  8th root function, used by xlamb implicit none real ( wp ) :: d8rt real ( wp ), intent ( in ) :: x d8rt = sqrt ( sqrt ( sqrt ( x ))) end function d8rt !************************************************************************************* !************************************************************************************* subroutine xlamb ( m , q , qsqfm1 , tin , n , x , xpl ) !!  Gooding support routine implicit none integer , intent ( in ) :: m real ( wp ), intent ( in ) :: q real ( wp ), intent ( in ) :: qsqfm1 real ( wp ), intent ( in ) :: tin integer , intent ( out ) :: n real ( wp ), intent ( out ) :: x real ( wp ), intent ( out ) :: xpl integer :: i , ij real ( wp ) :: thr2 , t0 , dt , d2t , d3t , tdiff , w , xm , tmin ,& xmold , xtest , tdiffm , d2t2 , t , tdiff0 real ( wp ), parameter :: tol = 3.0e-7_wp real ( wp ), parameter :: c0 = 1.7_wp real ( wp ), parameter :: c1 = 0.5_wp real ( wp ), parameter :: c2 = 0.03_wp real ( wp ), parameter :: c3 = 0.15_wp real ( wp ), parameter :: c41 = 1.0_wp real ( wp ), parameter :: c42 = 0.24_wp thr2 = atan2 ( qsqfm1 , 2.0_wp * q ) / pi if ( m == 0 ) then !single-rev starter from t (at x = 0) & bilinear (usually) n = 1 call tlamb ( m , q , qsqfm1 , 0.0_wp , 0 , t0 , dt , d2t , d3t ) tdiff = tin - t0 if ( tdiff <= 0.0_wp ) then x = t0 * tdiff / ( - 4.0_wp * tin ) !(-4 is the value of dt, for x = 0) else x = - tdiff / ( tdiff + 4.0_wp ) w = x + c0 * sqrt ( 2.0_wp * ( 1.0_wp - thr2 )) if ( w < 0.0_wp ) x = x - sqrt ( d8rt ( - w )) * ( x + sqrt ( tdiff / ( tdiff + 1.5_wp * t0 ))) w = 4.0_wp / ( 4.0_wp + tdiff ) x = x * ( 1.0_wp + x * ( c1 * w - c2 * x * sqrt ( w ))) end if else !with multirevs, first get t(min) as basis for starter xm = 1.0_wp / ( 1.5_wp * ( m + 0.5_wp ) * pi ) if ( thr2 < 0.5_wp ) xm = d8rt ( 2.0_wp * thr2 ) * xm if ( thr2 > 0.5_wp ) xm = ( 2.0_wp - d8rt ( 2.0_wp - 2.0_wp * thr2 )) * xm !(starter for tmin) do i = 1 , 12 call tlamb ( m , q , qsqfm1 , xm , 3 , tmin , dt , d2t , d3t ) if ( d2t == 0.0_wp ) exit xmold = xm xm = xm - dt * d2t / ( d2t * d2t - dt * d3t / 2.0_wp ) xtest = abs ( xmold / xm - 1.0_wp ) if ( xtest <= tol ) exit end do if ( i > 12 ) then !(break off & exit if tmin not located - should never happen) !now proceed from t(min) to full starter n = - 1 return end if tdiffm = tin - tmin if ( tdiffm < 0.0_wp ) then n = 0 return !(exit if no solution with this m) else if ( tdiffm == 0.0_wp ) then x = xm n = 1 return !(exit if unique solution already from x(tmin)) else n = 3 if ( d2t == 0.0_wp ) d2t = 6.0_wp * m * pi x = sqrt ( tdiffm / ( d2t / 2.0_wp + tdiffm / ( 1.0_wp - xm ) ** 2 )) w = xm + x w = w * 4.0_wp / ( 4.0_wp + tdiffm ) + ( 1.0_wp - w ) ** 2 x = x * ( 1.0_wp - ( 1.0_wp + m + c41 * ( thr2 - 0.5_wp )) / & ( 1.0_wp + c3 * m ) * x * ( c1 * w + c2 * x * sqrt ( w ))) + xm d2t2 = d2t / 2.0_wp if ( x >= 1.0_wp ) then n = 1 goto 3 end if !(no finite solution with x > xm) end if end if !(now have a starter, so proceed by halley) 5 continue do i = 1 , 3 call tlamb ( m , q , qsqfm1 , x , 2 , t , dt , d2t , d3t ) t = tin - t if ( dt /= 0.0_wp ) x = x + t * dt / ( dt * dt + t * d2t / 2.0_wp ) end do if ( n /= 3 ) return !(exit if only one solution, normally when m = 0) n = 2 xpl = x !(second multi-rev starter) 3 call tlamb ( m , q , qsqfm1 , 0.0_wp , 0 , t0 , dt , d2t , d3t ) tdiff0 = t0 - tmin tdiff = tin - t0 if ( tdiff <= 0 ) then x = xm - sqrt ( tdiffm / ( d2t2 - tdiffm * ( d2t2 / tdiff0 - 1.0_wp / xm ** 2 ))) else x = - tdiff / ( tdiff + 4.0_wp ) ij = 200 w = x + c0 * sqrt ( 2.0_wp * ( 1.0_wp - thr2 )) if ( w < 0.0_wp ) x = x - sqrt ( d8rt ( - w )) * ( x + sqrt ( tdiff / ( tdiff + 1.5_wp * t0 ))) w = 4.0_wp / ( 4.0_wp + tdiff ) x = x * ( 1.0_wp + ( 1.0_wp + m + c42 * ( thr2 - 0.5_wp )) / & ( 1.0_wp + c3 * m ) * x * ( c1 * w - c2 * x * sqrt ( w ))) if ( x <=- 1.0_wp ) then n = n - 1 !(no finite solution with x < xm) if ( n == 1 ) x = xpl end if end if goto 5 end subroutine xlamb !************************************************************************************* end subroutine solve_lambert_gooding !***************************************************************************************** !***************************************************************************************** !> !  Solve Lambert's problem using the Arora/Russell method. ! !### Reference ! * Arora and Russell, \"A fast and robust multiple revolution lambert algorithm !   using a cosine transformation\", AAS Hilton Head 2013, AAS 13-728. !   [see also the journal article] ! * `Lambert_AroraRussell.cpp` from [EMTG](https://sourceforge.net/projects/emtg/). subroutine solve_lambert_arorarussell ( r1 , r2 , tofin , mu , lu , nrev , long_way ,& shortperiod , tolerance ,& max_iterations , v1 , v2 ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r1 real ( wp ), dimension ( 3 ), intent ( in ) :: r2 real ( wp ), intent ( in ) :: tofin real ( wp ), intent ( in ) :: mu real ( wp ), intent ( in ) :: lu !! scale factor in km integer , intent ( in ) :: nrev logical , intent ( in ) :: long_way logical , intent ( in ) :: shortperiod real ( wp ), intent ( in ) :: tolerance integer , intent ( in ) :: max_iterations real ( wp ), dimension ( 3 ), intent ( out ) :: v1 real ( wp ), dimension ( 3 ), intent ( out ) :: v2 !integer,parameter  :: max_iterations_bisection = 50         ! original !real(wp),parameter :: bisection_error_tolerance = 1e-8_wp integer , parameter :: max_iterations_bisection = 100 !! modified from original - better match for izzo and gooding real ( wp ), parameter :: bisection_error_tolerance = 1e-14_wp !! modified from original - better match for izzo and gooding real ( wp ), parameter :: sq2 = sqrt ( two ) logical , parameter :: use_zeroin = . false . !! jw test ! precomputed values for for dele_bi0 for first 20 revs ! (deltae_b point where tau crosses zero from arora eqn 55) real ( wp ), dimension ( 0 : 19 ), parameter :: dele_bi0 = [ & 2.848574_wp , 2.969742_wp , 3.019580_wp , 3.046927_wp ,& 3.064234_wp , 3.076182_wp , 3.084929_wp , 3.091610_wp ,& 3.096880_wp , 3.101145_wp , 3.104666_wp , 3.107623_wp ,& 3.110142_wp , 3.112312_wp , 3.114203_wp , 3.115864_wp ,& 3.117335_wp , 3.118646_wp , 3.119824_wp , 3.120886_wp ] real ( wp ) :: cos_transfer_angle , error real ( wp ) :: k , k_n , k_m , deltak , r1mag , r2mag , tu , r1mag_n , r2mag_n , tof , mu_n real ( wp ) :: theta , s , eps , d , tau , r_buff , t_parabolic , m_k , w_k real ( wp ) :: k_i , z , alpha , f_0 , f_1 , f_i , f_star real ( wp ) :: tof20 , tof100 , m_i , w_ki , x_star , w , t0 , t1 , sgn_tau real ( wp ) :: var2 , var1 , dele_biguess , var3 , sgn_var3 , k_biguess real ( wp ) :: m_kbiguess , w_kbiguess , t_biguess , k_bi , t_bi , m_bi , w_bi real ( wp ) :: w_km1 , w_kmp5 , w_k0 , w_kp5 , w_k1 , tof_km1 , tof_kmp5 , tof_k0 , tof_kp5 , tof_k1 real ( wp ) :: m_ki , tof_ki , w_km1p41 , w_km1p38 , w_k1dsq2 real ( wp ) :: tof_km1p41 , tof_km1p38 , tof_k1dsq2 real ( wp ) :: c_1 , c_2 , c_3 , c_4 , f_n , gamma_1 , gamma_2 , gamma_3 real ( wp ) :: k_initialguess , m real ( wp ) :: dw , ddw real ( wp ) :: v , vv , v3 , v4 , v5 , v6 , v7 real ( wp ) :: tofc , c , sqrtctau , dtofc , ddtofc real ( wp ) :: low_k , high_k , middle_k , tof_low_k , tof_high_k , tof_middle_k , l_low_k , l_high_k real ( wp ) :: l_middle_k real ( wp ) :: f , g , gdot real ( wp ) :: lu3 , luptu real ( wp ) :: r1mag_n_plus_r2mag_n , r1mag_n_times_r2mag_n , omkt integer :: sgn_l_middle_k , sgn_l_low_k integer :: iterations , iterations_bisection , iflag real ( wp ), dimension ( 3 ) :: r1_n , r2_n , v1_n , v2_n lu3 = lu * lu * lu k = - one ! iteration variable, initialized to -1. it gets overwritten soon but this prevents an annoying compiler warning. k_n = - sq2 ! lower bound for iteration variable k (will be overwritten based on transfer type) k_m = huge ( one ) ! upper bound for iteration variable k (will be overwritten based on transfer type) deltak = huge ( one ) ! error in current solution for k r1mag = norm2 ( r1 ) ! magnitude of initial position r2mag = norm2 ( r2 ) ! magnitude of initial position tu = sqrt (( one / mu ) * lu3 ) ! time unit set so that mu = 1 luptu = lu / tu ! normalize r1, r2, and mu r1_n = r1 / lu r2_n = r2 / lu r1mag_n = r1mag / lu r2mag_n = r2mag / lu tof = tofin / tu mu_n = mu * ( tu * tu ) / lu3 r1mag_n_plus_r2mag_n = r1mag_n + r2mag_n r1mag_n_times_r2mag_n = r1mag_n * r2mag_n ! define transfer angle based on long_way flag cos_transfer_angle = dot_product ( r1_n , r2_n ) / r1mag_n_times_r2mag_n !cosine of the transfer angle theta = safe_acos ( cos_transfer_angle ) !transfer angle if ( long_way ) then !long_way == 1 theta = twopi - theta else theta = theta end if ! calculate s and tau s = sqrt ( r1mag_n_plus_r2mag_n ** 3 / mu_n ) !semi-perimeter iterations = 0 !iterations counter eps = 2.0e-2_wp !to prevent singularity at k = sqrt(2) !d = theta <= pi ? one : -one if ( theta <= pi ) then d = one else d = - one end if tau = d * sqrt ( r1mag_n_times_r2mag_n * ( one + cos_transfer_angle )) / & r1mag_n_plus_r2mag_n !lambert geometry parameter r_buff = 0.2_wp !user-defined parameter to determine when to skip k_bi root solve !step 1: generate appropriate initial guess !declare some variables that will be used in the initial guess !step 1.1 compare the desired time of flight to the parabolic time of flight t_parabolic = s * sqrt ( one - sq2 * tau ) * ( tau + sq2 ) / three if ( tof <= t_parabolic ) then !a hyperbolic trajectory is desired tof20 = s * sqrt ( one - 2 0.0_wp * tau ) * ( tau + 0.04940968903_wp * ( one - 2 0.0_wp * tau )) tof100 = s * sqrt ( one - 10 0.0_wp * tau ) * ( tau + 0.00999209404_wp * ( one - 10 0.0_wp * tau )) if ( d > zero ) then k_n = sq2 k_m = one / tau k_i = ( k_n + k_m ) / two z = one / sq2 alpha = 0.5_wp f_0 = t_parabolic f_1 = zero m_i = two - k_i * k_i w_ki = compute_w ( k_i , m_i , nrev ) f_i = s * sqrt ( one - k_i * tau ) * ( tau + ( one - k_i * tau ) * w_ki ) f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else if ( tof > tof20 ) then !arora's \"h1\" region k_n = sq2 k_m = 2 0.0_wp k_i = ( two * k_n + k_m ) / three z = one / three alpha = one f_0 = t_parabolic f_1 = tof20 m_i = two - k_i * k_i w = compute_w ( k_i , m_i , nrev ) f_i = s * sqrt ( one - k_i * tau ) * ( tau + ( one - k_i * tau ) * w ) f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else !arora's \"h2\" region k_n = 2 0.0_wp k_m = huge ( 1.0_wp ) t0 = tof20 t1 = tof100 k = (( t1 * ( t0 - tof ) * 1 0.0_wp - & t0 * sqrt ( 2 0.0_wp ) * ( t1 - tof )) / ( tof * ( t0 - t1 ))) * & (( t1 * ( t0 - tof ) * 1 0.0_wp - & t0 * sqrt ( 2 0.0_wp ) * ( t1 - tof )) / ( tof * ( t0 - t1 ))) end if else if ( nrev >= 1 ) then !a multi-revolution elliptical orbit is desired m_k = two - k * k w_k = compute_w ( k , m_k , nrev ) error = tof - compute_tof ( k , s , tau , w_k ) ! calculate estimate for k_bi (k_biguess) !sgn_tau = tau >= 0 ? one : -one sgn_tau = sign ( one , tau ) var2 = dele_bi0 ( nrev - 1 ) ! dummy variable 2 var1 = eight * abs ( tau ) / ( var2 * ( sq2 - two * abs ( tau ))) ! dummy variable 1 dele_biguess = var2 * ( one - sgn_tau ) + var2 * sgn_tau * pow (( one / ( one + var1 )), 0.25_wp ) var3 = pi - dele_biguess !sgn_var3 = var3 >= 0 ? one : -one sgn_var3 = sign ( one , var3 ) k_biguess = sgn_var3 * sqrt ( cos ( dele_biguess ) + one ) ! calculate t_biguess m_kbiguess = two - k_biguess * k_biguess ! m based on k_biguess w_kbiguess = compute_w ( k_biguess , m_kbiguess , nrev ) t_biguess = s * sqrt ( one - k_biguess * tau ) * ( tau + ( one - k_biguess * tau ) * w_kbiguess ) ! root solve to find k_bi and t_bi if ( ( abs ( tof - t_biguess ) > ( r_buff * tof )) . and . ( tof > t_biguess )) then !do not need to root solve k_bi = k_biguess t_bi = t_biguess else ! find k_bi using newton raphson k_bi = compute_kb ( k_biguess , tau , s , nrev , & tolerance , max_iterations , sq2 , eps ) ! solve via newton raphson m_bi = two - k_bi * k_bi w_bi = compute_w ( k_bi , m_bi , nrev ) t_bi = s * sqrt ( one - k_bi * tau ) * ( tau + ( one - k_bi * tau ) * w_bi ) end if if ( tof < t_bi ) then !return - no solution for this nrev write ( * , * ) 'no solution for this nrev' return end if w_km1 = 5.71238898_wp + two * pi * nrev w_kmp5 = 1.95494660_wp + 2.71408094_wp * nrev w_k0 = sq2 / four * ( pi + two * pi * nrev ) w_kp5 = 0.75913433_wp + 2.71408094_wp * nrev w_k1 = 0.57079632_wp + two * pi * nrev tof_km1 = compute_tof ( - one , s , tau , w_km1 ) ! (k,s,tau,w) tof_kmp5 = compute_tof ( - 0.5_wp , s , tau , w_kmp5 ) ! (k,s,tau,w) tof_k0 = compute_tof ( zero , s , tau , w_k0 ) ! (k,s,tau,w) tof_kp5 = compute_tof ( 0.5_wp , s , tau , w_kp5 ) ! (k,s,tau,w) tof_k1 = compute_tof ( one , s , tau , w_k1 ) ! (k,s,tau,w) ! generate initial guess for k (k_star) for long period and short ! period solutions for a given nrev if ( k_bi >= zero ) then if (. not . shortperiod ) then ! long period solution if (( tof >= tof_k1 ) . and . ( k_bi >= one )) then ! use first row of table 5 ! compute intial guess for k k_n = k_bi k_m = sq2 k_i = ( k_bi + sq2 ) * 0.5_wp z = 0.25_wp alpha = two f_0 = one / t_bi f_1 = zero m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = one / tof_ki f_star = one / tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else if (( tof >= tof_k1 ) . and . ( k_bi <= one )) then ! use second row of table 5 ! compute intial guess for k k_n = one k_m = sq2 k_i = ( one + two * sq2 ) / three z = 4.0_wp / 9.0_wp alpha = two f_0 = one / tof_k1 f_1 = zero m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = one / tof_ki f_star = one / tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else !((tof < tof_k1) .and. (k_bi <= one)) ! use third row of table 5 ! compute intial guess for k k_n = k_bi k_m = one k_i = ( one + k_bi ) * 0.5_wp z = 0.25_wp alpha = two f_0 = t_bi f_1 = tof_k1 m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = tof_ki f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + & ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star end if else ! long period solution if ( tof < tof_k0 ) then ! use fourth row of table 5 ! compute intial guess for k k_n = zero k_m = k_bi k_i = k_bi * 0.5_wp z = 0.5_wp ** ( 6.0_wp / 5.0_wp ) alpha = 6.0_wp / 5.0_wp f_0 = tof_k0 f_1 = t_bi m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = tof_ki f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else if (( tof > tof_k0 ) . and . ( tof < tof_km1 )) then ! use fifth row of table 5 ! compute intial guess for k k_n = - one k_m = zero k_i = - 0.5_wp z = 0.5_wp alpha = one f_0 = tof_km1 f_1 = tof_k0 f_i = tof_kmp5 f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else !(tof > tof_km1) ! use sixth row of table 5 ! compute intial guess for k k_n = - one k_m = - one * sq2 k_i = ( - one - two * sq2 ) / three z = 4.0_wp / 9.0_wp alpha = two f_0 = one / tof_km1 f_1 = zero m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = one / tof_ki f_star = one / tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star end if end if else ! k_bi < 0 if ( shortperiod ) then ! short period solution if (( tof >= tof_km1 ) . and . ( k_bi <= - one )) then ! use first row of table 6 ! compute intial guess for k k_n = k_bi k_m = - one * sq2 k_i = ( k_bi - sq2 ) * 0.5_wp z = 0.25_wp alpha = two f_0 = one / t_bi f_1 = zero m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = one / tof_ki f_star = one / tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else if (( tof >= tof_km1 ) . and . ( k_bi >= - one )) then ! use second row of table 6 ! compute intial guess for k k_n = - one k_m = - sq2 k_i = ( - one - two * sq2 ) / three z = 4.0_wp / 9.0_wp alpha = two f_0 = one / tof_km1 f_1 = zero m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = one / tof_ki f_star = one / tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else ! ((tof <= tof_km1) .and. (k_bi >= -one)) ! use third row of table 6 ! compute intial guess for k k_n = k_bi k_m = - one k_i = ( - one + k_bi ) * 0.5_wp z = 0.25_wp alpha = two f_0 = t_bi f_1 = tof_km1 m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = tof_ki f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star end if else ! long period solution if ( tof <= tof_k0 ) then ! use fourth row of table 6 ! compute intial guess for k k_n = k_bi k_m = zero k_i = k_bi * 0.5_wp z = 0.25_wp alpha = two f_0 = t_bi f_1 = tof_k0 m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = tof_ki f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else if (( tof > tof_k0 ) . and . ( tof < tof_k1 )) then ! use fifth row of table 6 ! compute intial guess for k k_n = zero k_m = one k_i = 0.5_wp z = 0.5_wp ** ( 6.0_wp / 5.0_wp ) alpha = 6.0_wp / 5.0_wp f_0 = tof_k0 f_1 = tof_k1 f_i = tof_kp5 f_star = tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star else !(tof > tof_k1) ! use sixth row of table 6 ! compute intial guess for k k_n = one k_m = sq2 k_i = ( one + two * sq2 ) / three z = 4.0_wp / 9.0_wp alpha = two f_0 = one / tof_k1 f_1 = zero m_ki = two - k_i * k_i w_ki = compute_w ( k_i , m_ki , nrev ) tof_ki = compute_tof ( k_i , s , tau , w_ki ) f_i = one / tof_ki f_star = one / tof x_star = pow (( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + ( f_0 - f_i ) * ( f_1 - f_star )), & one / alpha ) k = k_n + ( k_m - k_n ) * x_star end if end if end if else if ( nrev < 1 ) then ! a single-revolution elliptical orbit is desired !determine elliptical region by comparing actual tof (i.e., tstar) with tof(k) function value w_km1 = 5.712388981_wp ! w calculated at k=-1 w_km1p41 = 483 9.684497246_wp ! w calculated at k=-1.41 w_km1p38 = 21 2.087279879_wp ! w calculated at k=-1.38 w_kmp5 = 1.954946607_wp ! w calculated at k=-0.5 w_k1dsq2 = 0.6686397730_wp ! w calculate at k=a/sqrt(2) tof_km1p41 = s * sqrt ( one + 1.41_wp * tau ) * ( tau + ( one + 1.41_wp * tau ) * w_km1p41 ) tof_km1p38 = s * sqrt ( one + 1.38_wp * tau ) * ( tau + ( one + 1.38_wp * tau ) * w_km1p38 ) tof_km1 = s * sqrt ( one + tau ) * ( tau + ( one + tau ) * w_km1 ) tof_k0 = s * ( sq2 / 4.0_wp * pi + tau ) tof_k1dsq2 = s * sqrt ( one - one / sq2 * tau ) * ( tau + ( one - one / sq2 * tau ) * w_k1dsq2 ) tof_kmp5 = s * sqrt ( one + 0.5_wp * tau ) * ( tau + ( one + 0.5_wp * tau ) * w_kmp5 ) if ( tof >= tof_km1p38 ) then ! use region e4 for guess k_n = - 1.38_wp k_m = - sq2 k_i = - 1.41_wp c_1 = 4926 7.0_wp / 2705 9.0_wp c_2 = 6728 6.0_wp / 1789 7.0_wp c_3 = 281 3.0_wp / 28744 3.0_wp c_4 = 443 9.0_wp / 315 6.0_wp alpha = 24 3.0_wp f_n = 1.0_wp / tof_km1p38 f_i = 1.0_wp / tof_km1p41 f_star = 1.0_wp / tof gamma_1 = f_i * ( f_star - f_n ) gamma_2 = f_star * ( f_n - f_i ) gamma_3 = f_n * ( f_star - f_i ) k = - c_4 * pow ((( gamma_1 * c_1 - c_3 * gamma_3 ) * c_2 + c_3 * c_1 * gamma_2 ) / & ( gamma_3 * c_1 - gamma_1 * c_3 - gamma_2 * c_2 ), ( one / alpha )) else if (( tof_km1p38 >= tof ) . and . ( tof >= tof_km1 )) then ! use region e3 for guess k_n = - one k_m = - one * sq2 k_i = - 1.38_wp c_1 = 54064 9.0_wp / 312 5.0_wp c_2 = 25 6.0_wp c_3 = one c_4 = one alpha = 1 6.0_wp f_n = 1.0_wp / tof_km1 f_i = 1.0_wp / tof_km1p38 f_star = 1.0_wp / tof gamma_1 = f_i * ( f_star - f_n ) gamma_2 = f_star * ( f_n - f_i ) gamma_3 = f_n * ( f_star - f_i ) k = - c_4 * pow ((( gamma_1 * c_1 - c_3 * gamma_3 ) * c_2 + c_3 * c_1 * gamma_2 ) / & ( gamma_3 * c_1 - gamma_1 * c_3 - gamma_2 * c_2 ), & ( one / alpha )) else if (( tof_km1 >= tof ) . and . ( tof >= tof_k0 )) then ! use region e2 for guess k_n = zero k_m = - one k_i = - 0.5_wp z = 0.5_wp alpha = one f_0 = tof_k0 f_1 = tof_km1 f_i = tof_kmp5 f_star = tof x_star = ( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + & ( f_0 - f_i ) * ( f_1 - f_star )) k = k_n + ( k_m - k_n ) * x_star else ! use region e1 for guess k_n = zero k_m = sq2 k_i = 1.0_wp / sq2 z = 0.5_wp alpha = one f_0 = tof_k0 f_1 = t_parabolic f_i = tof_k1dsq2 f_star = tof x_star = ( z * ( f_0 - f_star ) * ( f_1 - f_i )) / & (( f_i - f_star ) * ( f_1 - f_0 ) * z + & ( f_0 - f_i ) * ( f_1 - f_star )) k = k_n + ( k_m - k_n ) * x_star end if end if !step 2: iterate to find k k_initialguess = k do while ( abs ( deltak ) > tolerance . and . iterations < max_iterations ) !step 2.1 increment the iterations counter iterations = iterations + 1 !step 2.2 compute w, dw, ddw m = two - k * k !double sgnk = k >= 0 ? one : -one  ! JW : unnecessary w = compute_w ( k , m , nrev ) !dw and ddw if (( k < sq2 - eps ) . or . ( k > sq2 + eps )) then dw = ( - two + three * w * k ) / m ddw = ( five * dw * k + three * w ) / m else v = k - sq2 vv = v * v v3 = v * vv v4 = v3 * v v5 = v4 * v v6 = v5 * v v7 = v6 * v dw = - one / five & + sq2 * v * ( four / 3 5.0_wp ) - vv * ( 6.0_wp / 6 3.0_wp ) & + sq2 * v3 * ( eight / 23 1.0_wp ) - v4 * ( 1 0.0_wp / 42 9.0_wp ) & + sq2 * v5 * ( 4 8.0_wp / 643 5.0_wp ) - v6 * ( 5 6.0_wp / 1215 5.0_wp ) & + sq2 * v7 * ( 6 4.0_wp / 4618 9.0_wp ) ddw = sq2 * ( four / 3 5.0_wp ) - v * ( 1 2.0_wp / 6 3.0_wp ) & + sq2 * vv * ( 2 4.0_wp / 23 1.0_wp ) - v3 * ( 4 0.0_wp / 42 9.0_wp ) & + sq2 * v4 * ( 24 0.0_wp / 643 5.0_wp ) - v5 * ( 33 6.0_wp / 1215 5.0_wp ) & + sq2 * v6 * ( 44 8.0_wp / 4618 9.0_wp ) end if omkt = one - k * tau !step 2.3 compute tofc, dtofc, ddtofc tofc = s * sqrt ( omkt ) * ( tau + ( omkt ) * w ) if ( abs ( tof - tofc ) < tolerance ) exit c = ( one - k * tau ) / tau sqrtctau = sqrt ( omkt ) dtofc = - tofc / ( two * c ) + s * tau * sqrtctau * ( dw * c - w ) ddtofc = - tofc / ( four * c * c ) + s * tau * sqrtctau * ( w / c + c * ddw - three * dw ) !step 2.4 compute deltak deltak = - ( tofc - tof ) / ( dtofc - ( tofc - tof ) * ddtofc / ( two * dtofc )) !step 2.5 update k from deltak k = k + deltak ! step 2.6 bound k ! ensure k is not less than -sqrt(2) if ( k < - sq2 ) k = - sq2 + 1e-12_wp ! ensure k doesn't bleed into to elliptic area when hyperbolic if (( tof < t_parabolic ) . and . ( k < sq2 )) k = sq2 + 1e-12_wp ! ensure k doesn't bleed into to hyperbolic area when elliptic if (( tof > t_parabolic ) . and . ( k > sq2 )) k = sq2 - 1e-12_wp ! ensure tof doesn't become indeterminate when d=1 if (( tof < t_parabolic ) . and . ( d > zero ) . and . & (( one - tau * k ) < zero )) k = one / tau - 1e-5_wp end do m_k = two - k * k w_k = compute_w ( k , m_k , nrev ) error = tof - compute_tof ( k , s , tau , w_k ) ! step 3: if error is too large from halley's method, try bisection method if ( abs ( error ) > 1.0e-4_wp ) then iterations_bisection = 0 ! set initial low and high bounds for bisection method based on k_n and k_m low_k = k_n + 1.0e-14_wp high_k = k_m - 1.0e-14_wp ! calculate initial low value of tof(k) and l(k) m = two - low_k * low_k w = compute_w ( low_k , m , nrev ) tof_low_k = s * sqrt ( one - low_k * tau ) * ( tau + ( one - low_k * tau ) * w ) l_low_k = tof_low_k - tof ! calculate initial high value of tof(k) and l(k) m = two - high_k * high_k w = compute_w ( high_k , m , nrev ) tof_high_k = s * sqrt ( one - high_k * tau ) * ( tau + ( one - high_k * tau ) * w ) l_high_k = tof_high_k - tof if ( use_zeroin ) then !!!!!!!! test: use ZEROIN for the rootfinder rather than bisection call zeroin ( l_func , low_k , high_k , l_low_k , l_high_k ,& bisection_error_tolerance , k , l_middle_k , iflag ) error = abs ( l_middle_k ) else !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! ORIGINAL bisection ! iterate using bisection method until within tolerance or maximum number iterations do while ( iterations_bisection < max_iterations_bisection ) middle_k = ( low_k + high_k ) / two m = two - middle_k * middle_k w = compute_w ( middle_k , m , nrev ) tof_middle_k = s * sqrt ( one - middle_k * tau ) * ( tau + ( one - middle_k * tau ) * w ) l_middle_k = tof_middle_k - tof !! function for root solve: l(k) = tof(k) - t* if ( abs ( l_middle_k ) < bisection_error_tolerance ) exit !sgn_l_middle_k = l_middle_k >= 0 ? 1 : -1 !sgn_l_low_k = l_low_k >= 0 ? 1 : -1 sgn_l_middle_k = sign ( one , l_middle_k ) sgn_l_low_k = sign ( one , l_low_k ) if ( sgn_l_middle_k == sgn_l_low_k ) then low_k = middle_k tof_low_k = tof_middle_k l_low_k = l_middle_k else high_k = middle_k tof_high_k = tof_middle_k l_high_k = l_middle_k end if iterations_bisection = iterations_bisection + 1 end do k = middle_k error = abs ( l_middle_k ) iterations = iterations + iterations_bisection end if end if ! end bisection method error catch ! step 3: calculate f & g (typos in arora-russell 2013 aas paper, fixed in journal paper) omkt = one - k * tau f = one - omkt * r1mag_n_plus_r2mag_n / r1mag_n g = s * tau * sqrt ( omkt * mu_n ) gdot = one - omkt * r1mag_n_plus_r2mag_n / r2mag_n ! step 4: calculate v1 and v2 v1_n = ( r2_n - f * r1_n ) / g v2_n = ( gdot * r2_n - r1_n ) / g !step 5: transform to input length and time units (final output) v1 = v1_n * luptu v2 = v2_n * luptu contains !*************************************************************************** function l_func ( k ) result ( lk ) !! function for root solve: `l(k) = tof(k) - t*` !! interface to the [[zeroin]] input function implicit none real ( wp ), intent ( in ) :: k real ( wp ) :: lk real ( wp ) :: tof_k , omkt omkt = one - k * tau m = two - k * k w = compute_w ( k , m , nrev ) tof_k = s * sqrt ( omkt ) * ( tau + omkt * w ) lk = tof_k - tof end function l_func !*************************************************************************** !*************************************************************************** pure elemental real ( wp ) function acoshar ( b ) !! fast computation of acosh implicit none real ( wp ), intent ( in ) :: b acoshar = log ( b + sqrt ( b * b - one )) end function acoshar !*************************************************************************** !*************************************************************************** pure function compute_kb ( k_bguess , tau , s , nrev , tolerance , max_iterations , sq2 , eps ) result ( k ) !! newton's method to find k_bi given tau, s, nrev, and initial guess for k_bi implicit none real ( wp ), intent ( in ) :: k_bguess real ( wp ), intent ( in ) :: tau real ( wp ), intent ( in ) :: s integer , intent ( in ) :: nrev real ( wp ), intent ( in ) :: tolerance integer , intent ( in ) :: max_iterations !note: was double in original (typo?) real ( wp ), intent ( in ) :: sq2 real ( wp ), intent ( in ) :: eps real ( wp ) :: k integer :: iterations real ( wp ) :: deltak , m , w , dw , ddw , tofc , c , sqrtctau , dtofc , ddtofc , omkt !,sgnk ! initialize iterations = 0 deltak = 1.0e+10_wp k = k_bguess ! perform iteration loop do while ( iterations < max_iterations ) !step 1.1 increment the iterations counter iterations = iterations + 1 ! step 1.2 bound k ! ensure k is not less than -sqrt(2) if ( k < - sq2 ) k = - sq2 + 0.00001_wp if ( k > sq2 ) k = sq2 - 0.00001_wp !step 1.3 compute w, dw, ddw m = two - k * k !sgnk = k >= 0 ? one : -one  ! JW : unnecessary w = compute_w ( k , m , nrev ) dw = ( - two + three * w * k ) / m ddw = ( five * dw * k + three * w ) / m !step 2.3 compute tofc, dtofc, ddtofc omkt = one - k * tau tofc = s * sqrt ( omkt ) * ( tau + omkt * w ) c = ( one - k * tau ) / tau sqrtctau = sqrt ( omkt ) dtofc = - tofc / ( two * c ) + s * tau * sqrtctau * ( dw * c - w ) ! check for convergence if ( abs ( dtofc ) < tolerance ) exit ddtofc = - tofc / ( four * c * c ) + s * tau * sqrtctau * ( w / c + c * ddw - three * dw ) !step 2.4 compute deltak deltak = - one * dtofc / ddtofc !step 2.5 update k from deltak k = k + deltak end do end function compute_kb !*************************************************************************** !*************************************************************************** pure function compute_tof ( k , s , tau , w ) result ( tofc ) !! calculate tof function for a given k, tau, implicit none real ( wp ), intent ( in ) :: k real ( wp ), intent ( in ) :: s real ( wp ), intent ( in ) :: tau real ( wp ), intent ( in ) :: w real ( wp ) :: tofc real ( wp ) :: omkt omkt = one - k * tau tofc = s * sqrt ( omkt ) * ( tau + omkt * w ) end function compute_tof !*************************************************************************** !*************************************************************************** pure elemental real ( wp ) function acosar ( x ) !! fast, rough computation of acos() implicit none real ( wp ), intent ( in ) :: x real ( wp ) :: coeff , fx , sgnx fx = abs ( x ) !sgnx = x >= zero ? one : -one if ( x >= zero ) then sgnx = one else sgnx = - one end if if ( fx <= 0.6_wp ) then coeff = ( 0.000014773722_wp + ( 1.1782782_wp - 0.52020038_wp * fx ) * fx ) / & ( 1.1793469_wp + ( - 0.53277664_wp - 0.14454764_wp * fx ) * fx ) else if ( fx <= 0.97_wp ) then coeff = ( 0.011101554_wp + ( 8.9810074_wp + ( - 1 4.816468_wp + 5.9249913_wp * fx ) * fx ) * fx ) / & ( 9.2299851_wp + ( - 1 6.001036_wp + 6.8381053_wp * fx ) * fx ) else if ( fx <= 0.99_wp ) then coeff = ( - 3 5.750586_wp + ( 10 7.24325_wp - 7 0.780244_wp * fx ) * fx ) / & ( 2 7.105764_wp - 2 6.638535_wp * fx ) else coeff = safe_asin ( fx ) end if acosar = pi / two - sgnx * coeff end function acosar !*************************************************************************** !*************************************************************************** pure function compute_w ( k , m , nrev ) result ( w ) !! function to compute the parameter w implicit none real ( wp ), intent ( in ) :: k real ( wp ), intent ( in ) :: m integer , intent ( in ) :: nrev real ( wp ) :: w real ( wp ), parameter :: sq2 = sqrt ( two ) real ( wp ), parameter :: eps = 2.0e-2_wp real ( wp ) :: sgnk , v , v2 , v3 , v4 , v5 , v6 , v7 , v8 !sgnk = k < zero ? -one : one sgnk = sign ( one , k ) if ( - sq2 <= k . and . k < sq2 - eps ) then !elliptical orbit case w = (( one - sgnk ) * pi + sgnk * acos ( one - m ) + two * pi * nrev ) / sqrt ( m * m * m ) - k / m else if ( k < sq2 . and . nrev > 0 ) then w = (( one - sgnk ) * pi + sgnk * acos ( one - m ) + two * pi * nrev ) / sqrt ( m * m * m ) - k / m else if ( k > sq2 + eps ) then !hyperbolic orbits w = - one * acoshar ( one - m ) / sqrt ( - m * m * m ) - k / m else if ( sq2 - eps <= k . and . k <= sq2 + eps ) then !nrev = 0 case v = k - sq2 v2 = v * v v3 = v * v2 v4 = v3 * v v5 = v4 * v v6 = v5 * v v7 = v6 * v v8 = v7 * v w = sq2 / three - v / five & + sq2 * v2 * ( two / 3 5.0_wp ) - v3 * ( two / 6 3.0_wp ) & + sq2 * v4 * ( two / 23 1.0_wp ) - v5 * ( two / 42 9.0_wp ) & + sq2 * v6 * ( eight / 643 5.0_wp ) - v7 * ( eight / 1215 5.0_wp ) & + sq2 * v8 * ( eight / 4618 9.0_wp ) else !write(*,*) 'error on w compute *************************', k    !!! this needs to set status_ok = .false. w = huge ( 1.0_wp ) end if end function compute_w !*************************************************************************** !*************************************************************************** pure elemental real ( wp ) function safe_acos ( x ) !! return x > one ? zero : (x < -one ? pi : acos(x)) implicit none real ( wp ), intent ( in ) :: x if ( x > one ) then safe_acos = zero else if ( x <- one ) then safe_acos = pi else safe_acos = acos ( x ) end if end if end function safe_acos !*************************************************************************** !*************************************************************************** pure elemental real ( wp ) function safe_asin ( x ) !! safe_asin = x > one ? -piover2 : (x < -one ? piover2 : asin(x)) implicit none real ( wp ), intent ( in ) :: x real ( wp ), parameter :: piover2 = pi / two if ( x > one ) then safe_asin = - piover2 else if ( x < - one ) then safe_asin = piover2 else safe_asin = asin ( x ) end if end if end function safe_asin !*************************************************************************** !*************************************************************************** pure elemental real ( wp ) function pow ( x , y ) !! return x**y implicit none real ( wp ), intent ( in ) :: x real ( wp ), intent ( in ) :: y pow = x ** y end function pow !*************************************************************************** !***************************************************************************************** !> !  Find a zero of the function  f(x)  in the given interval !   [a_x,b_x]  to within a tolerance  4 \\epsilon |x| + tol , !  where  \\epsilon  is the relative machine precision defined as !  the smallest representable number such that  1.0 + \\epsilon > 1.0 . ! !  It is assumed that  f(a_x)  and  f(b_x)  have opposite signs. ! !#References !  * R. P. Brent, \"[An algorithm with guaranteed convergence for !    finding a zero of a function](http://maths-people.anu.edu.au/~brent/pd/rpb005.pdf)\", !    The Computer Journal, Vol 14, No. 4., 1971. !  * R. P. Brent, \"[Algorithms for minimization without derivatives](http://maths-people.anu.edu.au/~brent/pub/pub011.html)\", !    Prentice-Hall, Inc., 1973. ! !# See also !  1. [zeroin.f](http://www.netlib.org/go/zeroin.f) from Netlib subroutine zeroin ( f , ax , bx , fax , fbx , tol , xzero , fzero , iflag ) use iso_fortran_env , only : error_unit implicit none procedure ( func ) :: f !! the function to find the root of real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( in ) :: fax !! `f(ax)` for endpoint real ( wp ), intent ( in ) :: fbx !! `f(ax)` for endpoint real ( wp ), intent ( in ) :: tol !! desired length of the interval of !! uncertainty of the final result (>=0) real ( wp ), intent ( out ) :: xzero !! abscissa approximating a zero of `f` !! in the interval `ax`,`bx` real ( wp ), intent ( out ) :: fzero !! value of `f` at the root (`f(xzero)`) integer , intent ( out ) :: iflag !! status flag (`-1`=error, `0`=root found) real ( wp ) :: a , b , c , d , e , fa , fb , fc , tol1 , xm , p , q , r , s real ( wp ), parameter :: eps = epsilon ( one ) tol1 = eps + one a = ax b = bx fa = fax fb = fbx !check trivial cases first: if ( fa == zero ) then iflag = 0 xzero = a fzero = fa elseif ( fb == zero ) then iflag = 0 xzero = b fzero = fb elseif ( fa * ( fb / abs ( fb )) < zero ) then ! check that f(ax) and f(bx) have different signs c = a fc = fa d = b - a e = d do if ( abs ( fc ) < abs ( fb )) then a = b b = c c = a fa = fb fb = fc fc = fa end if tol1 = two * eps * abs ( b ) + 0.5_wp * tol xm = 0.5_wp * ( c - b ) if (( abs ( xm ) <= tol1 ). or .( fb == zero )) exit ! see if a bisection is forced if (( abs ( e ) >= tol1 ). and .( abs ( fa ) > abs ( fb ))) then s = fb / fa if ( a /= c ) then ! inverse quadratic interpolation q = fa / fc r = fb / fc p = s * ( two * xm * q * ( q - r ) - ( b - a ) * ( r - one )) q = ( q - one ) * ( r - one ) * ( s - one ) else ! linear interpolation p = two * xm * s q = one - s end if if ( p <= zero ) then p =- p else q =- q end if s = e e = d if ((( two * p ) >= ( three * xm * q - abs ( tol1 * q ))) . or . & ( p >= abs ( 0.5_wp * s * q ))) then d = xm e = d else d = p / q end if else d = xm e = d end if a = b fa = fb if ( abs ( d ) <= tol1 ) then if ( xm <= zero ) then b = b - tol1 else b = b + tol1 end if else b = b + d end if fb = f ( b ) if (( fb * ( fc / abs ( fc ))) > zero ) then c = a fc = fa d = b - a e = d end if end do iflag = 0 xzero = b fzero = fb else iflag = - 1 write ( error_unit , '(A)' )& 'Error in zeroin: f(ax) and f(bx) do not have different signs.' end if end subroutine zeroin !***************************************************************************************** end subroutine solve_lambert_arorarussell !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Compare the Lambert routines. subroutine lambert_test () use gooding_module , only : pv3els use random_module , only : get_random_number implicit none real ( wp ), parameter :: tol = 1.0e-11_wp real ( wp ), dimension (:,:), allocatable :: izzo_v1 , izzo_v2 real ( wp ), dimension (:,:), allocatable :: gooding_v1 , gooding_v2 real ( wp ), dimension ( 6 ) :: rv1 , rv2 , pv , e integer :: imeth , icases , i , multi_revs , iway , n_cases real ( wp ) :: tof , err1 , err2 logical :: long_way , status_ok character ( len = 100 ) :: str real :: tstart , tend real ( wp ), dimension ( 3 ) :: arora_v1 , arora_v2 real ( wp ), dimension ( 6 ), parameter :: rv1_base = & [ 1e6_wp , 1e6_wp , 1e6_wp , 1 0.0_wp , 1 0.0_wp , 1 0.0_wp ] real ( wp ), dimension ( 6 ), parameter :: rv2_base = & [ 1e6_wp , 1e6_wp , 1e6_wp , 1 0.0_wp , 1 0.0_wp , 1 0.0_wp ] real ( wp ), parameter :: tof_base = 8640 0.0_wp !sec real ( wp ), parameter :: mu = 3.986004362330e+05_wp !real(wp),parameter :: auora_tol      = 1.0e-14_wp   !  122946 cases/sec real ( wp ), parameter :: auora_tol = 1.0e-9_wp !! 203025 cases/sec integer , parameter :: max_iterations = 100 logical , parameter :: shortperiod = . true . !! \"solution 1\" for mult-rev case. real ( wp ), parameter :: lu = 1.0e5_wp write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' lambert_test' write ( * , * ) '---------------' write ( * , * ) '' write ( * , * ) '' write ( * , * ) '   Test 1' write ( * , * ) '' n_cases = 10 multi_revs = 0 !1 !reseed the random number generator: call random_seed () do icases = 1 , n_cases write ( * , * ) '' do i = 1 , 6 rv1 ( i ) = get_random_number ( - rv1_base ( i ), rv1_base ( i )) end do do i = 1 , 6 rv2 ( i ) = get_random_number ( - rv2_base ( i ), rv2_base ( i )) end do tof = get_random_number ( 100 0.0_wp , tof_base ) do iway = 1 , 2 !short and long way long_way = ( iway == 1 ) do imeth = 1 , 3 ![izzo, gooding, auora] !if (icases==1 .and. imeth==1 .and. iway==1) & !        write(*,'(*(A30,1X))') & !        'case',& !        'x1','y1','z1','vx1','vy1','vz1',& !        'x2','y2','z2','vx2','vy2','vz2','tof' !if (imeth==1) write(*,'(I30,1X,*(F30.6,1X))') icases, rv1, rv2, tof select case ( imeth ) case ( 1 ) call solve_lambert_izzo ( rv1 ( 1 : 3 ), rv2 ( 1 : 3 ), tof , mu , long_way ,& multi_revs , izzo_v1 , izzo_v2 ,& status_ok ) case ( 2 ) call solve_lambert_gooding ( rv1 ( 1 : 3 ), rv2 ( 1 : 3 ), tof , mu , long_way ,& multi_revs , gooding_v1 , gooding_v2 ,& status_ok ) case ( 3 ) call solve_lambert_arorarussell ( rv1 ( 1 : 3 ), rv2 ( 1 : 3 ), tof , mu , lu , multi_revs , long_way ,& shortperiod , auora_tol ,& max_iterations , arora_v1 , arora_v2 ) end select end do !results: if ( size ( izzo_v1 , 2 ) == size ( gooding_v1 , 2 )) then do i = 1 , size ( izzo_v1 , 2 ) !orb. elements of transfer orbit: pv = [ rv1 ( 1 : 3 ), gooding_v1 (:, i )] call pv3els ( mu , pv , e ) err1 = norm2 ( izzo_v1 (:, i ) - gooding_v1 (:, i ) ) err2 = norm2 ( izzo_v2 (:, i ) - gooding_v2 (:, i ) ) if ( err1 > tol ) then str = '*****IZZO-GOODING ERROR*****' else str = '     IZZO-GOODING v1' end if write ( * , '(I5,1X,E25.16,1X,E25.16,1X,E25.16,1X,A)' )& icases , e ( 1 : 2 ), err1 , trim ( str ) if ( err2 > tol ) then str = '*****IZZO-GOODING ERROR*****' else str = '     IZZO-GOODING v2' end if write ( * , '(I5,1X,E25.16,1X,E25.16,1X,E25.16,1X,A)' )& icases , e ( 1 : 2 ), err2 , trim ( str ) err1 = norm2 ( arora_v1 - gooding_v1 (:, i ) ) err2 = norm2 ( arora_v2 - gooding_v2 (:, i ) ) if ( err1 > tol ) then str = '*****ARORA-GOODING ERROR*****' else str = '     ARORA-GOODING v1' end if write ( * , '(I5,1X,E25.16,1X,E25.16,1X,E25.16,1X,A)' )& icases , e ( 1 : 2 ), err1 , trim ( str ) if ( err2 > tol ) then str = '*****ARORA-GOODING ERROR*****' else str = '     ARORA-GOODING v2' end if write ( * , '(I5,1X,E25.16,1X,E25.16,1X,E25.16,1X,A)' )& icases , e ( 1 : 2 ), err2 , trim ( str ) end do else write ( * , * ) icases , 'Error: arrays sizes are not the same' stop end if end do end do write ( * , * ) '' write ( * , * ) '   Test 2: Speed test' write ( * , * ) '' n_cases = 1000000 do imeth = 1 , 3 ![izzo, gooding, auora] !reseed the random number generator: call random_seed () call cpu_time ( tstart ) do icases = 1 , n_cases do i = 1 , 6 rv1 ( i ) = get_random_number ( - rv1_base ( i ), rv1_base ( i )) end do do i = 1 , 6 rv2 ( i ) = get_random_number ( - rv2_base ( i ), rv2_base ( i )) end do tof = get_random_number ( 100 0.0_wp , tof_base ) do iway = 1 , 2 !short and long way long_way = ( iway == 1 ) select case ( imeth ) case ( 1 ) call solve_lambert_izzo ( rv1 ( 1 : 3 ), rv2 ( 1 : 3 ), tof , mu , long_way ,& multi_revs , izzo_v1 , izzo_v2 ,& status_ok ) case ( 2 ) call solve_lambert_gooding ( rv1 ( 1 : 3 ), rv2 ( 1 : 3 ), tof , mu , long_way ,& multi_revs , gooding_v1 , gooding_v2 ,& status_ok ) case ( 3 ) call solve_lambert_arorarussell ( rv1 ( 1 : 3 ), rv2 ( 1 : 3 ), tof , mu , lu , multi_revs , long_way ,& shortperiod , auora_tol ,& max_iterations , arora_v1 , arora_v2 ) end select end do end do call cpu_time ( tend ) select case ( imeth ) case ( 1 ) write ( * , * ) 'run time for Izzo   : ' , tend - tstart , ' sec.  ' , dble ( n_cases ) / ( tend - tstart ), ' cases/sec' case ( 2 ) write ( * , * ) 'run time for Gooding: ' , tend - tstart , ' sec.  ' , dble ( n_cases ) / ( tend - tstart ), ' cases/sec' case ( 3 ) write ( * , * ) 'run time for Arora  : ' , tend - tstart , ' sec.  ' , dble ( n_cases ) / ( tend - tstart ), ' cases/sec' end select write ( * , * ) '' end do end subroutine lambert_test !***************************************************************************************** end module lambert_module !*****************************************************************************************","tags":"","url":"sourcefile/lambert_module.f90.html"},{"title":"drag_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~drag_module.f90~~EfferentGraph sourcefile~drag_module.f90 drag_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~drag_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~drag_module.f90~~AfferentGraph sourcefile~drag_module.f90 drag_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~drag_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Drag model module drag_module use kind_module implicit none private public :: drag_acceleration contains !***************************************************************************************** !***************************************************************************************** !> !  Acceleration due to atmospheric drag. pure subroutine drag_acceleration ( vrel , cd , area , m , rho , acc ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: vrel !! velocity relative to the atmosphere [km/s] real ( wp ), intent ( in ) :: cd !! spacecraft drag coefficient [--] real ( wp ), intent ( in ) :: area !! cross-section area [km&#94;2] real ( wp ), intent ( in ) :: m !! spacecraft mass [kg] real ( wp ), intent ( in ) :: rho !! atmospheric density [kg/km&#94;3] real ( wp ), dimension ( 3 ), intent ( out ) :: acc !! drag acceleration vector [km/s&#94;2] real ( wp ) :: vrel_mag !! magnitude of the relative velocity [km/s] vrel_mag = norm2 ( vrel ) acc = - ( 0.5_wp * rho * cd * area * vrel_mag / m ) * vrel end subroutine drag_acceleration !***************************************************************************************** !***************************************************************************************** end module drag_module !*****************************************************************************************","tags":"","url":"sourcefile/drag_module.f90.html"},{"title":"halo_orbit_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~halo_orbit_module.f90~~EfferentGraph sourcefile~halo_orbit_module.f90 halo_orbit_module.f90 sourcefile~celestial_body_module.f90 celestial_body_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~celestial_body_module.f90 sourcefile~crtbp_module.f90 crtbp_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~crtbp_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~halo_orbit_module.f90->sourcefile~kind_module.f90 sourcefile~math_module.f90 math_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~math_module.f90 sourcefile~matrix_module.f90 matrix_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~matrix_module.f90 sourcefile~minpack_module.f90 minpack_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~minpack_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~numbers_module.f90 sourcefile~rk_module.f90 rk_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~rk_module.f90 sourcefile~celestial_body_module.f90->sourcefile~kind_module.f90 sourcefile~celestial_body_module.f90->sourcefile~numbers_module.f90 sourcefile~base_class_module.f90 base_class_module.f90 sourcefile~celestial_body_module.f90->sourcefile~base_class_module.f90 sourcefile~crtbp_module.f90->sourcefile~celestial_body_module.f90 sourcefile~crtbp_module.f90->sourcefile~kind_module.f90 sourcefile~crtbp_module.f90->sourcefile~math_module.f90 sourcefile~crtbp_module.f90->sourcefile~numbers_module.f90 sourcefile~math_module.f90->sourcefile~kind_module.f90 sourcefile~math_module.f90->sourcefile~numbers_module.f90 sourcefile~matrix_module.f90->sourcefile~kind_module.f90 sourcefile~matrix_module.f90->sourcefile~numbers_module.f90 sourcefile~minpack_module.f90->sourcefile~kind_module.f90 sourcefile~minpack_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~rk_module.f90->sourcefile~kind_module.f90 sourcefile~rk_module.f90->sourcefile~numbers_module.f90 sourcefile~brent_module.f90 brent_module.f90 sourcefile~rk_module.f90->sourcefile~brent_module.f90 sourcefile~brent_module.f90->sourcefile~kind_module.f90 sourcefile~brent_module.f90->sourcefile~numbers_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~halo_orbit_module.f90~~AfferentGraph sourcefile~halo_orbit_module.f90 halo_orbit_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~halo_orbit_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  Halo orbit routines. ! !### References !  * D.L. Richardson, \"Analytic Construction of Periodic !    Orbits About the Collinear Points\", Celestial Mechanics 22 (1980) ! !@todo Add differentially-corrected option using the STM derivatives. module halo_orbit_module use kind_module use iso_fortran_env , only : error_unit use numbers_module use crtbp_module implicit none private public :: halo_to_rv public :: halo_to_rv_diffcorr public :: compute_halo_monodromy_matrix public :: compute_monodromy_matrix_eigenvalues public :: halo_orbit_test ! test routine contains !******************************************************************************* !******************************************************************************* !> !  Compute the state vector for a halo orbit. !  This uses the approximation, which is retargeted in the !  real CR3BP system to produce a periodic orbit. ! !@todo use a variable-step size integrator subroutine halo_to_rv_diffcorr ( libpoint , mu1 , mu2 , dist , A_z , n , t1 , rv , info , period ) use rk_module use minpack_module use math_module , only : wrap_angle implicit none integer , intent ( in ) :: libpoint !! Libration point number: [1,2,3] real ( wp ), intent ( in ) :: mu1 !! grav param for primary body [km3/s2] real ( wp ), intent ( in ) :: mu2 !! grav param for secondary body [km3/s2] real ( wp ), intent ( in ) :: dist !! distance between bodies [km] real ( wp ), intent ( in ) :: A_z !! halo z amplitude [km] integer , intent ( in ) :: n !! halo family: 1, 3 real ( wp ), intent ( in ) :: t1 !! tau1 [rad] real ( wp ), dimension ( 6 ), intent ( out ) :: rv !! cr3bp normalized state vector !! [wrt barycenter] integer , intent ( out ) :: info !! status code (1=no errors) real ( wp ), intent ( out ), optional :: period !! period of halo (normalized time units) integer , parameter :: n_state_vars = 6 !! number of state variables in the equations of motion integer , parameter :: n_opt_vars = 2 !! number of variables in the targeting problem real ( wp ), parameter :: t0 = 0.0_wp !! initial time (normalized) (epoch doesn't matter for cr3bp) real ( wp ), parameter :: tol = 1.0e-8_wp !! tolerance for event finding real ( wp ), parameter :: xtol = 1.0e-6_wp !! tolerance for [[hybrd]] integer , parameter :: maxfev = 1000 !! max number of function evaluations for [[hybrd]] integer , parameter :: n_steps_per_rev = 100 !! number of integration steps per orbit rev type ( rk8_10_class ) :: prop !! integrator real ( wp ), dimension ( n_opt_vars ) :: x_vy0 !! variables in the targeting problem (x0 and vy0) real ( wp ), dimension ( n_opt_vars ) :: vx_vzf !! constraints in the targeting problem (vxf and vzf) real ( wp ), dimension ( n_state_vars ) :: x0 !! halo initial guess from richardson approximation real ( wp ), dimension ( n_state_vars ) :: xf !! state after 1/2 rev (to get the period) real ( wp ) :: tf_actual !! 1/2 period for retargeted orbit (normalized time) real ( wp ) :: actual_period !! actual halo orbit period for retargeted orbit (normalized time) real ( wp ) :: approx_period !! period approximation (normalized time) real ( wp ) :: dt_to_t1 !! time from `t1=0` to input `t1` real ( wp ) :: gf !! function value after 1/2 rev (y-coordinate) real ( wp ) :: tau !! `t1` wrapped from - \\pi  to  \\pi  real ( wp ) :: dt !! time step (normalized) real ( wp ) :: tmax !! max final time for event finding integration real ( wp ) :: mu !! CRTBP parameter ! compute the CRTBP mu parameter: mu = compute_crtpb_parameter ( mu1 , mu2 ) ! first we get the halo state approximation at tau1=0: call halo_to_rv ( libpoint , mu1 , mu2 , dist , A_z , n , zero , x0 , approx_period ) ! for now, fixed number of integration steps per period: dt = approx_period / real ( n_steps_per_rev , wp ) tmax = two * approx_period ! should be enough to find the x-z crossing ! initialize the integrator: call prop % initialize ( n_state_vars , func , g = xz_plane_crossing ) ! now, solve for a halo: x_vy0 = [ x0 ( 1 ), x0 ( 5 )] ! x0 and vy0 call hybrd1 ( halo_fcn , 2 , x_vy0 , vx_vzf , tol = xtol , info = info ) if ( info == 1 ) then ! solution converged ! now have the solution at t1=0: x0 ( 1 ) = x_vy0 ( 1 ) x0 ( 5 ) = x_vy0 ( 2 ) ! this is the t1 we want: tau = wrap_angle ( t1 ) ! if we need the period: if ( present ( period ) . or . tau /= zero ) then ! integrate to the first x-axis crossings (one half rev): ! [need to check output...] call prop % integrate_to_event ( t0 , x0 , dt , tmax , tol , tf_actual , xf , gf ) actual_period = two * tf_actual ! normalized period end if ! now we want to propagate to the input tau1 if ( tau == zero ) then ! already have the solution rv = x0 else ! now, integrate from t1=0 to input t1 to get rv: dt_to_t1 = actual_period * ( tau / twopi ) call prop % integrate ( t0 , x0 , dt , dt_to_t1 , rv ) end if if ( present ( period )) period = actual_period else ! there was an error write ( error_unit , '(A)' ) 'Error: the halo targeting problem did not converge.' rv = x0 end if !call prop%destroy() contains !******************************************************************************* !*************************************************************************** subroutine halo_fcn ( n , xvec , fvec , iflag ) !! Halo function for [[hybrd1]] implicit none integer , intent ( in ) :: n !! `n=2` in this case real ( wp ), dimension ( n ), intent ( in ) :: xvec !! x_vy0 real ( wp ), dimension ( n ), intent ( out ) :: fvec !! [vxf,vzf] integer , intent ( inout ) :: iflag !! status flag (set negative !! to terminate solver) real ( wp ) :: gf real ( wp ), dimension ( 6 ) :: x , x1 , xf x = x0 ! initial guess state (z is held fixed) x ( 1 ) = xvec ( 1 ) ! x0 x ( 5 ) = xvec ( 2 ) ! vy0 !integrate to the next x-z-plane crossing: call prop % integrate_to_event ( t0 , x , dt , tmax , tol , tf_actual , xf , gf ) !want x and z-velocity at the x-z-plane crossing to be zero: fvec = [ xf ( 4 ), xf ( 6 )] end subroutine halo_fcn !*************************************************************************** !*************************************************************************** subroutine func ( me , t , x , xdot ) !! CRTBP derivative function implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension ( me % n ), intent ( in ) :: x real ( wp ), dimension ( me % n ), intent ( out ) :: xdot call crtbp_derivs ( mu , x , xdot ) end subroutine func !************************************************************************** !*************************************************************************** subroutine xz_plane_crossing ( me , t , x , g ) !! x-z-plane crossing event function implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension ( me % n ), intent ( in ) :: x real ( wp ), intent ( out ) :: g g = x ( 2 ) ! y = 0 at x-z-plane crossing end subroutine xz_plane_crossing !*************************************************************************** end subroutine halo_to_rv_diffcorr !******************************************************************************* !******************************************************************************* !> !  Compute the state vector from the halo orbit approximation. !  This will be an approximation of a halo orbit in the CR3BP system, !  and will need to be corrected to produce a real halo orbit. subroutine halo_to_rv ( libpoint , mu1 , mu2 , dist , A_z , n , t1 , rv , period ) implicit none integer , intent ( in ) :: libpoint !! Libration point number: [1,2,3] real ( wp ), intent ( in ) :: mu1 !! grav param for primary body [km3/s2] real ( wp ), intent ( in ) :: mu2 !! grav param for secondary body [km3/s2] real ( wp ), intent ( in ) :: dist !! distance between bodies [km] real ( wp ), intent ( in ) :: A_z !! halo z amplitude [km] integer , intent ( in ) :: n !! halo family: 1, 3 real ( wp ), intent ( in ) :: t1 !! tau1 [rad] real ( wp ), dimension ( 6 ), intent ( out ) :: rv !! cr3bp normalized state vector !! [wrt barycenter] real ( wp ), intent ( out ), optional :: period !! normalized halo orbit period real ( wp ) :: mu !! CRTBP parameter integer :: delta_n !! 2 - n real ( wp ) :: gamma_l !! dimensionless quantity from reference real ( wp ) :: lambda !! linearized frequency real ( wp ) :: Ax , Ay , Az , Ax2 , Az2 real ( wp ) :: x , y , z , vx , vy , vz real ( wp ) :: a1 , a2 , a21 , a22 , a23 , a24 , a31 , a32 , b21 ,& b22 , b31 , b32 , c2 , c3 , c4 , delta , w ,& d1 , d2 , d21 , d3 , d31 , d32 , k , l1 , l2 , s1 , s2 , term real ( wp ), dimension ( 3 ) :: x_libpoint !! x-coordinates of the libration !! point (wrt barycenter, normalized) logical :: ok ! error check: if ( n /= 1 . and . n /= 3 ) then error stop 'invalid n input to halo_to_rv' end if ! compute all the intermediate parameters: mu = compute_crtpb_parameter ( mu1 , mu2 ) ! lib point x-coordinate: wrt to barycenter - normalized select case ( libpoint ) case ( 1 ) call compute_libration_points ( mu , r1 = x_libpoint ( 1 )) gamma_l = ( 1.0_wp - mu ) - x_libpoint ( 1 ) case ( 2 ) call compute_libration_points ( mu , r2 = x_libpoint ( 2 )) gamma_l = x_libpoint ( 2 ) - ( 1.0_wp - mu ) case ( 3 ) call compute_libration_points ( mu , r3 = x_libpoint ( 3 )) gamma_l = - ( x_libpoint ( 3 ) + mu ) case default error stop 'invalid libration point input to halo_to_rv' end select Az = A_z / ( dist * gamma_l ) ! normalized z-Amplitude c2 = c_n ( libpoint , 2 , mu , gamma_l ) c3 = c_n ( libpoint , 3 , mu , gamma_l ) c4 = c_n ( libpoint , 4 , mu , gamma_l ) lambda = sqrt (( - c2 + two + sqrt ( nine * c2 ** 2 - eight * c2 )) / two ) ! root of quartic eqn k = two * lambda / ( lambda ** 2 + one - c2 ) delta = lambda ** 2 - c2 d1 = 1 6.0_wp * lambda ** 4 + four * lambda ** 2 * ( c2 - two ) - two * c2 ** 2 + c2 + one d2 = 8 1.0_wp * lambda ** 4 + nine * lambda ** 2 * ( c2 - two ) - two * c2 ** 2 + c2 + one d3 = two * lambda * ( lambda * ( one + k ** 2 ) - two * k ) a21 = three * c3 * ( k ** 2 - two ) / four / ( one + two * c2 ) a23 = - three * lambda * c3 * ( three * k ** 3 * lambda - six * k * ( k - lambda ) + four ) / four / k / d1 b21 = - three * c3 * lambda * ( three * lambda * k - four ) / two / d1 s1 = (( three / two ) * c3 * ( two * a21 * ( k ** 2 - two ) - a23 * ( k ** 2 + two ) - & two * k * b21 ) - ( three / eight ) * c4 * ( three * k ** 4 - eight * k ** 2 + eight )) / d3 a22 = three * c3 / four / ( one + two * c2 ) a24 = - three * c3 * lambda * ( two + three * lambda * k ) / four / k / d1 b22 = three * lambda * c3 / d1 d21 = - c3 / two / lambda ** 2 s2 = (( three / two ) * c3 * ( two * a22 * ( k ** 2 - two ) + & a24 * ( k ** 2 + two ) + two * k * b22 + five * d21 ) + & ( three / eight ) * c4 * ( 1 2.0_wp - k ** 2 )) / d3 a1 = - ( three / two ) * c3 * ( two * a21 + a23 + five * d21 ) - & ( three / eight ) * c4 * ( 1 2.0_wp - k ** 2 ) a2 = ( three / two ) * c3 * ( a24 - two * a22 ) + ( nine / eight ) * c4 l1 = two * s1 * lambda ** 2 + a1 l2 = two * s2 * lambda ** 2 + a2 Az2 = Az ** 2 ! check if this Az is feasible ok = ( l1 /= zero ) if ( ok ) then term = ( - delta - l2 * Az2 ) / l1 ok = ( term >= zero ) end if if (. not . ok ) then rv = zero if ( present ( period )) period = zero write ( error_unit , '(A)' ) 'Error: infeasible input.' return end if Ax = sqrt ( term ) ! equation 18 Ax2 = Ax ** 2 Ay = k * Ax w = one + s1 * Ax2 + s2 * Az2 ! frequency correction a31 = - nine * lambda * ( c3 * ( k * a23 - b21 ) + k * c4 * ( one + ( one / four ) * k ** 2 )) / d2 + & ( nine * lambda ** 2 + one - c2 ) * ( three * c3 * ( two * a23 - k * b21 ) + & c4 * ( two + three * k ** 2 )) / two / d2 a32 = - nine * lambda * ( four * c3 * ( k * a24 - b22 ) + k * c4 ) / four / d2 - & three * ( nine * lambda ** 2 + one - c2 ) * ( c3 * ( k * b22 + d21 - two * a24 ) - c4 ) / two / d2 b31 = ( three * lambda * ( three * c3 * ( k * b21 - two * a23 ) - c4 * ( two + three * k ** 2 )) + & ( nine * lambda ** 2 + 1 + two * c2 ) * ( 1 2.0_wp * c3 * ( k * a23 - b21 ) + & three * k * c4 * ( four + k ** 2 )) / eight ) / d2 b32 = ( three * lambda * ( three * c3 * ( k * b22 + d21 - two * a24 ) - three * c4 ) + & ( nine * lambda ** 2 + one + two * c2 ) * ( 1 2.0_wp * c3 * ( k * a24 - b22 ) + three * c4 * k ) / eight ) / d2 d31 = three * ( four * c3 * a24 + c4 ) / 6 4.0_wp / lambda ** 2 d32 = three * ( four * c3 * ( a23 - d21 ) + c4 * ( four + k ** 2 )) / 6 4.0_wp / lambda ** 2 delta_n = 2 - n ! equation 21 if ( present ( period )) period = twopi / ( lambda * w ) ! Equations 20a, 20b, 20c (and their derivatives): x = a21 * Ax2 + a22 * Az2 - Ax * cos ( t1 ) + & ( a23 * Ax2 - a24 * Az2 ) * cos ( two * t1 ) + & ( a31 * Ax ** 3 - a32 * Ax * Az2 ) * cos ( three * t1 ) y = k * Ax * sin ( t1 ) + ( b21 * Ax2 - b22 * Az2 ) * sin ( two * t1 ) + & ( b31 * Ax ** 3 - b32 * Ax * Az2 ) * sin ( three * t1 ) z = delta_n * ( Az * cos ( t1 ) + d21 * Ax * Az * ( cos ( two * t1 ) - three ) + & ( d32 * Az * Ax2 - d31 * Az ** 3 ) * cos ( three * t1 )) vx = Ax * sin ( t1 ) - ( a23 * Ax2 - a24 * Az2 ) * sin ( two * t1 ) * two - & ( a31 * Ax ** 3 - a32 * Ax * Az2 ) * sin ( three * t1 ) * three vy = k * Ax * cos ( t1 ) + ( b21 * Ax2 - b22 * Az2 ) * cos ( two * t1 ) * two + & ( b31 * Ax ** 3 - b32 * Ax * Az2 ) * cos ( three * t1 ) * three vz = delta_n * ( - Az * sin ( t1 ) + d21 * Ax * Az * ( - sin ( two * t1 ) * two ) - & ( d32 * Az * Ax2 - d31 * Az ** 3 ) * sin ( three * t1 ) * three ) rv = [ x , y , z , vx , vy , vz ] ! convert from richardson scale, libration point centered to ! standard normalized coordinates wrt barycenter: rv ( 1 : 3 ) = rv ( 1 : 3 ) * gamma_l rv ( 4 : 6 ) = rv ( 4 : 6 ) * gamma_l * ( lambda * w ) rv ( 1 ) = rv ( 1 ) + x_libpoint ( libpoint ) contains !******************************************************************************* !*************************************************************************** pure function c_n ( lib , n , mu , gl ) result ( cn ) !! Equations 8a, 8b in the reference. implicit none integer , intent ( in ) :: lib !! libration point (1,2,3) integer , intent ( in ) :: n !! the n in cn real ( wp ), intent ( in ) :: mu !! cr3bp normalized grav parameter real ( wp ), intent ( in ) :: gl !!  \\gamma_l  real ( wp ) :: cn !! result ! Equation 8a and 8b: select case ( lib ) case ( 1 ); cn = ( mu + ( - 1 ) ** n * ( one - mu ) * ( gl / ( one - gl )) ** ( n + 1 ) ) / gl ** 3 case ( 2 ); cn = (( - 1 ) ** n * ( mu + ( one - mu ) * ( gl / ( one + gl )) ** ( n + 1 ))) / gl ** 3 case ( 3 ); cn = ( one - mu + mu * ( gl / ( one + gl )) ** ( n + 1 ) ) / gl ** 3 end select end function c_n !*************************************************************************** end subroutine halo_to_rv !******************************************************************************* !******************************************************************************* !> !  Compute the halo orbit monodromy matrix !  (which is the state transition matrix propagated for one period) !  The input should be the result from the [[halo_to_rv_diffcorr]] routine. subroutine compute_halo_monodromy_matrix ( mu , rv , period , phi ) use rk_module implicit none real ( wp ), intent ( in ) :: mu !! CRTBP parameter real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! halo orbit state vector !! (normalized) real ( wp ), intent ( in ) :: period !! halo orbit period !! (normalized) real ( wp ), dimension ( 6 , 6 ), intent ( out ) :: phi !! monodromy matrix real ( wp ), parameter :: t0 = zero !! initial time (normalized) !! (epoch doesn't matter for cr3bp) integer , parameter :: n_steps_per_rev = 100 !! number of integration steps !! per orbit rev real ( wp ), dimension ( 42 ) :: x0 !! initial normalized state and STM real ( wp ), dimension ( 42 ) :: xf !! final normalized state and STM real ( wp ), dimension ( 6 , 6 ) :: phi0 !! initial STM integer :: i !! counter type ( rk8_10_class ) :: prop !! integrator real ( wp ) :: dt !! integration time step (normalized) ! initial state: x0 ( 1 : 6 ) = rv ! initial stm is the identity matrix: phi0 = zero do i = 1 , 6 phi0 ( i , i ) = one end do x0 ( 7 : 42 ) = pack ( phi0 , mask = . true .) ! for now, use a fixed time step: ! (same as was used in [[halo_to_rv_diffcorr]]) dt = period / real ( n_steps_per_rev , wp ) ! initialize the integrator: call prop % initialize ( 42 , func ) ! propagate for one period: call prop % integrate ( t0 , x0 , dt , period , xf ) ! extract the STM: phi = reshape ( xf ( 7 : 42 ), shape = [ 6 , 6 ]) contains !******************************************************************************* !*************************************************************************** subroutine func ( me , t , x , xdot ) !! CRTBP derivative function (with STM) implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension ( me % n ), intent ( in ) :: x real ( wp ), dimension ( me % n ), intent ( out ) :: xdot call crtbp_derivs_with_stm ( mu , x , xdot ) end subroutine func !************************************************************************** end subroutine compute_halo_monodromy_matrix !******************************************************************************* !******************************************************************************* !> !  Compute the eigenvalues of the monodromy matrix. ! !### Reference !  * J.S. Parker, R.L. Anderson, \"Low-Energy Lunar Trajectory Design\", !    2014. (p 79) subroutine compute_monodromy_matrix_eigenvalues ( phi , lambda ) use matrix_module , only : matrix_trace implicit none real ( wp ), dimension ( 6 , 6 ), intent ( in ) :: phi !! monodromy matrix complex ( wp ), dimension ( 6 ), intent ( out ) :: lambda !! eigenvalues of `phi` real ( wp ) :: alpha , beta , alpha2 complex ( wp ) :: p , q , a , b , c alpha = two - matrix_trace ( 6 , phi ) alpha2 = alpha * alpha beta = ( alpha2 - matrix_trace ( 6 , matmul ( phi , phi ))) / two + one a = sqrt ( alpha2 - four * beta + eight ) p = ( alpha + a ) / two q = ( alpha - a ) / two b = sqrt ( p * p - four ) c = sqrt ( q * q - four ) ! eigenvalues: lambda ( 1 ) = ( - p + b ) / two lambda ( 2 ) = ( - p - b ) / two lambda ( 3 ) = ( - q + c ) / two lambda ( 4 ) = ( - q - c ) / two lambda ( 5 ) = ( one , zero ) lambda ( 6 ) = ( one , zero ) end subroutine compute_monodromy_matrix_eigenvalues !******************************************************************************* !******************************************************************************* !> !  Unit test for the halo orbit module. subroutine halo_orbit_test () use celestial_body_module implicit none integer :: libpoint !! Libration point number: [1,2,3] real ( wp ) :: mu1 !! grav param for primary body [km3/s2] real ( wp ) :: mu2 !! grav param for secondary body [km3/s2] real ( wp ) :: dist !! distance between bodies [km] real ( wp ) :: Az !! halo z amplitude [km] integer :: n !! halo family: 1, 3 real ( wp ) :: t1 !! tau1 [rad] real ( wp ), dimension ( 6 ) :: rv !! normalized state [wrt barycenter] write ( * , * ) '' write ( * , * ) '----------------' write ( * , * ) ' halo_orbit_test' write ( * , * ) '----------------' write ( * , * ) '' libpoint = 2 mu1 = body_earth % mu mu2 = body_moon % mu dist = 38440 0.0_wp Az = 1000 0.0_wp n = 1 t1 = 0.0_wp call halo_to_rv ( libpoint , mu1 , mu2 , dist , Az , n , t1 , rv ) write ( * , * ) '' write ( * , * ) 'halo orbit state:' write ( * , * ) rv write ( * , * ) '' end subroutine halo_orbit_test !******************************************************************************* !******************************************************************************* end module halo_orbit_module !*******************************************************************************","tags":"","url":"sourcefile/halo_orbit_module.f90.html"},{"title":"string_module.f90 – fortran-astrodynamics-toolkit","text":"Files dependent on this one sourcefile~~string_module.f90~~AfferentGraph sourcefile~string_module.f90 string_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~string_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Module for string manipulation. module string_module implicit none private character ( len =* ), parameter :: lower = 'abcdefghijklmnopqrstuvwxyz' !! lowercase characters character ( len =* ), parameter :: upper = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ' !! uppercase characters public :: lowercase , uppercase public :: replace_char public :: reverse public :: lchop , rchop public :: strip contains !***************************************************************************************** !***************************************************************************************** !> !  Convert the string to uppercase. pure subroutine uppercase ( str ) character ( len =* ), intent ( inout ) :: str integer :: i , idx do i = 1 , len_trim ( str ) idx = index ( lower , str ( i : i )) if ( idx > 0 ) str ( i : i ) = upper ( idx : idx ) end do end subroutine uppercase !***************************************************************************************** !***************************************************************************************** !> !  Convert the string to lowercase. pure subroutine lowercase ( str ) character ( len =* ), intent ( inout ) :: str integer :: i , idx do i = 1 , len_trim ( str ) idx = index ( upper , str ( i : i )) if ( idx > 0 ) str ( i : i ) = lower ( idx : idx ) end do end subroutine lowercase !***************************************************************************************** !***************************************************************************************** !> !  Replace all occurrences of a single character `s1` in `str` with `s2`. pure function replace_char ( str , s1 , s2 ) result ( newstr ) character ( len =* ), intent ( in ) :: str !! original string character ( len = 1 ), intent ( in ) :: s1 !! find all occurrences of this character character ( len = 1 ), intent ( in ) :: s2 !! replace with this character character ( len = :), allocatable :: newstr !! new string integer :: i !! counter newstr = str do i = 1 , len ( newstr ) if ( newstr ( i : i ) == s1 ) newstr ( i : i ) = s2 end do end function replace_char !***************************************************************************************** !***************************************************************************************** !> !  Chop leading `chars` string from `str`. !  Note that trailing spaces are not ignored in either string. pure function lchop ( str , chars ) result ( newstr ) character ( len =* ), intent ( in ) :: str !! original string character ( len =* ), intent ( in ) :: chars !! characters to strip character ( len = :), allocatable :: newstr !! new string ! this logic here is to account for trailing spaces, which we preserve if ( len ( chars ) > len ( str )) then newstr = str ! not possible to chop else if ( str == chars ) then if ( len ( str ) > len ( chars )) then newstr = str ( len ( chars ) + 1 :) ! only trailing spaces remain else newstr = '' ! string is now empty end if else if ( index ( str , chars ) == 1 ) then newstr = str ( len ( chars ) + 1 :) ! chop leading chars, keep rest of string else newstr = str ! original string, noting to chop end if end if end if end function lchop !***************************************************************************************** !***************************************************************************************** !> !  Chop trailing `chars` string from `str`. !  Note that trailing spaces are not ignored in either string. pure function rchop ( str , chars ) result ( newstr ) character ( len =* ), intent ( in ) :: str !! original string character ( len =* ), intent ( in ) :: chars !! characters to strip character ( len = :), allocatable :: newstr !! new string newstr = reverse ( lchop ( reverse ( str ), reverse ( chars ))) end function rchop !***************************************************************************************** !***************************************************************************************** !> !  Reverse a string. pure function reverse ( str ) result ( newstr ) character ( len =* ), intent ( in ) :: str !! original string character ( len = :), allocatable :: newstr !! new string integer :: i , j !! counter integer :: n !! length of `str` n = len ( str ) allocate ( character ( len = n ) :: newstr ) if ( n == 0 ) then newstr = '' else j = 0 do i = n , 1 , - 1 j = j + 1 newstr ( j : j ) = str ( i : i ) end do end if end function reverse !***************************************************************************************** !***************************************************************************************** !> !  Strip all occurances of chars from the beginning and end of the string. pure function strip ( str , chars ) result ( newstr ) character ( len =* ), intent ( in ) :: str !! original string character ( len =* ), intent ( in ), optional :: chars !! characters to strip character ( len = :), allocatable :: newstr !! new string integer :: i !! counter integer :: n !! length of str integer :: idx !! for using scan integer :: start_idx , end_idx !! substring to keep if ( present ( chars )) then if ( chars /= '' ) then ! have to step through manually from beginning and end n = len ( str ) start_idx = 1 end_idx = n ! forward search do i = 1 , n idx = scan ( str ( i : i ), chars ) if ( idx > 0 ) then start_idx = start_idx + 1 else exit end if end do ! backward search do i = n , 1 , - 1 idx = scan ( str ( i : i ), chars ) if ( idx > 0 ) then end_idx = end_idx - 1 else exit end if end do if ( end_idx <= start_idx ) then newstr = '' ! all stripped else newstr = str ( start_idx : end_idx ) ! return substring end if return ! done end if end if ! in this case assuming it's a space, so use intrinsic functions newstr = trim ( adjustl ( str )) end function strip !***************************************************************************************** !***************************************************************************************** end module string_module !*****************************************************************************************","tags":"","url":"sourcefile/string_module.f90.html"},{"title":"iau_orientation_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~iau_orientation_module.f90~~EfferentGraph sourcefile~iau_orientation_module.f90 iau_orientation_module.f90 sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~conversion_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~iau_orientation_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~numbers_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~vector_module.f90 sourcefile~conversion_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~iau_orientation_module.f90~~AfferentGraph sourcefile~iau_orientation_module.f90 iau_orientation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~iau_orientation_module.f90 sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~transformation_module.f90 sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 sourcefile~transformation_module.f90->sourcefile~iau_orientation_module.f90 sourcefile~lighting_module.f90->sourcefile~transformation_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  IAU orientation models for the Earth and planets. ! !# See also !  1. NAIF SPICE pck.html documentation !  2. \"Report of the IAU Working Group on Cartographic Coordinates !     and Rotational Elements: 2009\", Celestial Mechanics and !     Dynamical Astronomy, February 2011, Vol 109, Issue 2, p 101-135. ! !@warning Not Finished. ! !@todo Use a class to provide access to the different models module iau_orientation_module use kind_module use numbers_module use conversion_module implicit none private public :: iau_rotation_matrix !base routine public :: icrf_to_iau_earth public :: icrf_to_iau_moon !test routines: public :: iau_test contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/3/2015 ! !  Returns the rotation matrix for a coordinate transformation from !  the International Celestial Reference Frame (ICRF) frame to the !  IAU rotating frame associated with a body. !  The IAU orientation models use three Euler angles to describe !  the pole and prime meridian location (ra, dec, and w). pure function iau_rotation_matrix ( w , dec , ra ) result ( rotmat ) use vector_module , only : rotation_matrix , x_axis , y_axis , z_axis implicit none real ( wp ), intent ( in ) :: w !! right ascension of the pole [rad] real ( wp ), intent ( in ) :: dec !! declination of the pole [rad] real ( wp ), intent ( in ) :: ra !! prime meridian location [rad] real ( wp ), dimension ( 3 , 3 ) :: rotmat !! the rotation matrix real ( wp ), parameter :: pi2 = pi / two real ( wp ), dimension ( 3 , 3 ) :: tmp !it is a 3-1-3 rotation: tmp = matmul ( rotation_matrix ( x_axis , pi2 - dec ), rotation_matrix ( z_axis , pi2 + ra ) ) rotmat = matmul ( rotation_matrix ( z_axis , w ), tmp ) end function iau_rotation_matrix !***************************************************************************************** ! ! TO DO: !... also need to add computation of rotmatdot ! see: ftp://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/tisbod.html ! !***************************************************************************************** !> author: Jacob Williams !  date: 2/3/2015 ! !  Rotation matrix from ICRF to IAU_EARTH. pure function icrf_to_iau_earth ( et ) result ( rotmat ) implicit none real ( wp ), intent ( in ) :: et !! ephemeris time [sec] real ( wp ), dimension ( 3 , 3 ) :: rotmat !! the rotation matrix real ( wp ) :: w , dec , ra , d , t d = et * sec2day !interval in days from the J2000 epoch t = et * sec2century !interval in Julian centuries (36525 days) from the J2000 epoch ra = ( - 0.641_wp * t ) * deg2rad dec = ( 9 0.0_wp - 0.557_wp * t ) * deg2rad w = ( 19 0.147_wp + 36 0.9856235_wp * d ) * deg2rad rotmat = iau_rotation_matrix ( w , dec , ra ) end function icrf_to_iau_earth !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 3/5/2016 ! !  Rotation matrix from ICRF to IAU_MOON. pure function icrf_to_iau_moon ( et ) result ( rotmat ) implicit none real ( wp ), intent ( in ) :: et !! ephemeris time [sec] real ( wp ), dimension ( 3 , 3 ) :: rotmat !! the rotation matrix real ( wp ) :: w , dec , ra , d , t real ( wp ) :: e1 , e2 , e3 , e4 , e5 , e6 , e7 , e8 , e9 , e10 , e11 , e12 , e13 d = et * sec2day !interval in days from the J2000 epoch t = et * sec2century !interval in Julian centuries (36525 days) from the J2000 epoch ! Nutation/precession angles: e1 = ( 12 5.045_wp - 0.0529921_wp * d ) * deg2rad e2 = ( 25 0.089_wp - 0.1059842_wp * d ) * deg2rad e3 = ( 26 0.008_wp + 1 3.0120009_wp * d ) * deg2rad e4 = ( 17 6.625_wp + 1 3.3407154_wp * d ) * deg2rad e5 = ( 35 7.529_wp + 0.9856003_wp * d ) * deg2rad e6 = ( 31 1.589_wp + 2 6.4057084_wp * d ) * deg2rad e7 = ( 13 4.963_wp + 1 3.0649930_wp * d ) * deg2rad e8 = ( 27 6.617_wp + 0.3287146_wp * d ) * deg2rad e9 = ( 3 4.226_wp + 1.7484877_wp * d ) * deg2rad e10 = ( 1 5.134_wp - 0.1589763_wp * d ) * deg2rad e11 = ( 11 9.743_wp + 0.0036096_wp * d ) * deg2rad e12 = ( 23 9.961_wp + 0.1643573_wp * d ) * deg2rad e13 = ( 2 5.053_wp + 1 2.9590088_wp * d ) * deg2rad ra = ( 26 9.9949_wp + 0.0031_wp * t & - 3.8787_wp * sin ( E1 ) & - 0.1204_wp * sin ( E2 ) & + 0.0700_wp * sin ( E3 ) & - 0.0172_wp * sin ( E4 ) & + 0.0072_wp * sin ( E6 ) & - 0.0052_wp * sin ( E10 ) & + 0.0043_wp * sin ( E13 ) ) * deg2rad dec = ( 6 6.5392_wp + 0.0130_wp * t & + 1.5419_wp * cos ( E1 ) & + 0.0239_wp * cos ( E2 ) & - 0.0278_wp * cos ( E3 ) & + 0.0068_wp * cos ( E4 ) & - 0.0029_wp * cos ( E6 ) & + 0.0009_wp * cos ( E7 ) & + 0.0008_wp * cos ( E10 ) & - 0.0009_wp * cos ( E13 ) ) * deg2rad w = ( 3 8.3213_wp + 1 3.17635815_wp * d - 1.4e-12_wp * d ** 2 & + 3.5610_wp * sin ( E1 ) & + 0.1208_wp * sin ( E2 ) & - 0.0642_wp * sin ( E3 ) & + 0.0158_wp * sin ( E4 ) & + 0.0252_wp * sin ( E5 ) & - 0.0066_wp * sin ( E6 ) & - 0.0047_wp * sin ( E7 ) & - 0.0046_wp * sin ( E8 ) & + 0.0028_wp * sin ( E9 ) & + 0.0052_wp * sin ( E10 ) & + 0.0040_wp * sin ( E11 ) & + 0.0019_wp * sin ( E12 ) & - 0.0044_wp * sin ( E13 ) ) * deg2rad rotmat = iau_rotation_matrix ( w , dec , ra ) end function icrf_to_iau_moon !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/3/2015 ! !  Unit test routine for iau_module. subroutine iau_test () implicit none real ( wp ) :: et real ( wp ), dimension ( 3 , 3 ) :: rotmat integer :: i write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' iau_test' write ( * , * ) '---------------' write ( * , * ) '' et = 100 0.0_wp !epoch [sec from J2000] rotmat = icrf_to_iau_earth ( et ) !rotation matrix from J2000 to IAU_EARTH write ( * , * ) '---icrf_to_iau_earth---' write ( * , * ) 'et    =' , et write ( * , * ) 'rotmat=' do i = 1 , 3 write ( * , * ) rotmat ( i ,:) end do ! ---icrf_to_iau_earth--- ! et    =   1000.0000000000000 ! rotmat= !  0.24742305587604752      -0.96890754534215406       -7.6219971891330182E-010 !  0.96890754534215406       0.24742305587604752       -2.9847705387722482E-009 !  3.0805524797727912E-009  -1.0920940632167532E-017   1.0000000000000000 ! ! Compare to SPICE: ! call PXFORM( 'J2000', 'IAU_EARTH', ET, ROTMAT ) ! rotmat= !  0.24742305587604752      -0.96890754534215406       -7.6219971891330182E-010 !  0.96890754534215406       0.24742305587604752       -2.9847705387722482E-009 !  3.0805524797727912E-009  -1.0920940632167532E-017    1.0000000000000000 et = 100 0.0_wp !epoch [sec from J2000] rotmat = icrf_to_iau_moon ( et ) !rotation matrix from J2000 to IAU_MOON write ( * , * ) '---icrf_to_iau_moon---' write ( * , * ) 'et    =' , et write ( * , * ) 'rotmat=' do i = 1 , 3 write ( * , * ) rotmat ( i ,:) end do ! ---icrf_to_iau_moon--- ! et    =   1000.0000000000000 ! rotmat= !  0.78257369718829173       0.55976292119480831       0.27247730276942850 ! -0.62214729926548507       0.71906872303263469       0.30963350847878057 ! -2.2608548951909870E-002 -0.41183205753276536       0.91097925876642116 ! ! Compare to SPICE: ! call PXFORM( 'J2000', 'IAU_MOON', ET, ROTMAT ) ! rotmat= !  0.78257369718829173       0.55976292119480819       0.27247730276942861 ! -0.62214729926548507       0.71906872303263458       0.30963350847878074 ! -2.2608548951909880E-002 -0.41183205753276558       0.91097925876642105 end subroutine iau_test !***************************************************************************************** !***************************************************************************************** end module iau_orientation_module !*****************************************************************************************","tags":"","url":"sourcefile/iau_orientation_module.f90.html"},{"title":"analytical_ephemeris_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~analytical_ephemeris_module.f90~~EfferentGraph sourcefile~analytical_ephemeris_module.f90 analytical_ephemeris_module.f90 sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~analytical_ephemeris_module.f90->sourcefile~conversion_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~analytical_ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~analytical_ephemeris_module.f90->sourcefile~numbers_module.f90 sourcefile~conversion_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~analytical_ephemeris_module.f90~~AfferentGraph sourcefile~analytical_ephemeris_module.f90 analytical_ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~analytical_ephemeris_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Analytical ephemeris routines for solar system bodies. module analytical_ephemeris_module use numbers_module use kind_module use conversion_module implicit none private public :: simpson_lunar_ephemeris contains !***************************************************************************************** !***************************************************************************************** !> !  A simple analytical lunar ephemeris model. !  Returns Lunar cartesian coordinates !  (mean equator and equinox of epoch J2000). ! !### Reference !  * \"An alternative lunar ephemeris model for on-board flight software use\", !    D. G. Simpson, Proceedings of the 1999 NASA/GSFC Flight Mechanics Symposium, !    p. 175-184). !  * [David G. Simpson Personal Web Site](http://www.davidgsimpson.com/software.html) ! !### Reference code ! !```fortran !  T = (JD - 2451545.0D0)/36525.0D0 !  X =  383.0D3 * SIN( 8399.685D0 * T + 5.381D0)   & !      + 31.5D3 * SIN(   70.990D0 * T + 6.169D0)   & !      + 10.6D3 * SIN(16728.377D0 * T + 1.453D0)   & !      +  6.2D3 * SIN( 1185.622D0 * T + 0.481D0)   & !      +  3.2D3 * SIN( 7143.070D0 * T + 5.017D0)   & !      +  2.3D3 * SIN(15613.745D0 * T + 0.857D0)   & !      +  0.8D3 * SIN( 8467.263D0 * T + 1.010D0) !  Y =  351.0D3 * SIN( 8399.687D0 * T + 3.811D0)   & !      + 28.9D3 * SIN(   70.997D0 * T + 4.596D0)   & !      + 13.7D3 * SIN( 8433.466D0 * T + 4.766D0)   & !      +  9.7D3 * SIN(16728.380D0 * T + 6.165D0)   & !      +  5.7D3 * SIN( 1185.667D0 * T + 5.164D0)   & !      +  2.9D3 * SIN( 7143.058D0 * T + 0.300D0)   & !      +  2.1D3 * SIN(15613.755D0 * T + 5.565D0) !  Z =  153.2D3 * SIN( 8399.672D0 * T + 3.807D0)   & !      + 31.5D3 * SIN( 8433.464D0 * T + 1.629D0)   & !      + 12.5D3 * SIN(   70.996D0 * T + 4.595D0)   & !      +  4.2D3 * SIN(16728.364D0 * T + 6.162D0)   & !      +  2.5D3 * SIN( 1185.645D0 * T + 5.167D0)   & !      +  3.0D3 * SIN(  104.881D0 * T + 2.555D0)   & !      +  1.8D3 * SIN( 8399.116D0 * T + 6.248D0) !``` ! !@note Also added velocity output, which is not present in reference code. subroutine simpson_lunar_ephemeris ( jd , r_moon , v_moon ) implicit none real ( wp ), intent ( in ) :: jd !! Julian date real ( wp ), dimension ( 3 ), intent ( out ) :: r_moon !! Moon position (km) real ( wp ), dimension ( 3 ), intent ( out ), optional :: v_moon !! Moon velocity (km/s) real ( wp ) :: t !! time in Julian centuries from J2000 real ( wp ), dimension ( 7 ) :: xterms , yterms , zterms !coefficients: real ( wp ), dimension ( 7 ), parameter :: xcoeffs = [ 38 3.0e3_wp , 3 1.5e3_wp , & 1 0.6e3_wp , 6.2e3_wp , & 3.2e3_wp , 2.3e3_wp , & 0.8e3_wp ] real ( wp ), dimension ( 7 ), parameter :: ycoeffs = [ 35 1.0e3_wp , 2 8.9e3_wp , & 1 3.7e3_wp , 9.7e3_wp , & 5.7e3_wp , 2.9e3_wp , & 2.1e3_wp ] real ( wp ), dimension ( 7 ), parameter :: zcoeffs = [ 15 3.2e3_wp , 3 1.5e3_wp , & 1 2.5e3_wp , 4.2e3_wp , & 2.5e3_wp , 3.0e3_wp , & 1.8e3_wp ] real ( wp ), dimension ( 7 ), parameter :: xa = [ 839 9.685_wp , 7 0.990_wp , & 1672 8.377_wp , 118 5.622_wp , & 714 3.070_wp , 1561 3.745_wp , & 846 7.263_wp ] real ( wp ), dimension ( 7 ), parameter :: xp = [ 5.381_wp , 6.169_wp , & 1.453_wp , 0.481_wp , & 5.017_wp , 0.857_wp , & 1.010_wp ] real ( wp ), dimension ( 7 ), parameter :: ya = [ 839 9.687_wp , 7 0.997_wp , & 843 3.466_wp , 1672 8.380_wp , & 118 5.667_wp , 714 3.058_wp , & 1561 3.755_wp ] real ( wp ), dimension ( 7 ), parameter :: yp = [ 3.811_wp , 4.596_wp , & 4.766_wp , 6.165_wp , & 5.164_wp , 0.300_wp , & 5.565_wp ] real ( wp ), dimension ( 7 ), parameter :: za = [ 839 9.672_wp , 843 3.464_wp , & 7 0.996_wp , 1672 8.364_wp , & 118 5.645_wp , 10 4.881_wp , & 839 9.116_wp ] real ( wp ), dimension ( 7 ), parameter :: zp = [ 3.807_wp , 1.629_wp , & 4.595_wp , 6.162_wp , & 5.167_wp , 2.555_wp , & 6.248_wp ] real ( wp ), dimension ( 7 ), parameter :: vxcoeffs = xcoeffs * xa real ( wp ), dimension ( 7 ), parameter :: vycoeffs = ycoeffs * ya real ( wp ), dimension ( 7 ), parameter :: vzcoeffs = zcoeffs * za t = ( jd - 245154 5.0_wp ) * day2century xterms = xa * t + xp yterms = ya * t + yp zterms = za * t + zp r_moon ( 1 ) = dot_product ( xcoeffs , sin ( xterms )) r_moon ( 2 ) = dot_product ( ycoeffs , sin ( yterms )) r_moon ( 3 ) = dot_product ( zcoeffs , sin ( zterms )) !v_moon is just d(r_moon)/dt: ! [convert units to km/s] if ( present ( v_moon )) then v_moon ( 1 ) = dot_product ( vxcoeffs , cos ( xterms )) / ( century2day * day2sec ) v_moon ( 2 ) = dot_product ( vycoeffs , cos ( yterms )) / ( century2day * day2sec ) v_moon ( 3 ) = dot_product ( vzcoeffs , cos ( zterms )) / ( century2day * day2sec ) end if end subroutine simpson_lunar_ephemeris !***************************************************************************************** !***************************************************************************************** end module analytical_ephemeris_module !*****************************************************************************************","tags":"","url":"sourcefile/analytical_ephemeris_module.f90.html"},{"title":"numbers_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~numbers_module.f90~~EfferentGraph sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~numbers_module.f90~~AfferentGraph sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~analytical_ephemeris_module.f90 analytical_ephemeris_module.f90 sourcefile~analytical_ephemeris_module.f90->sourcefile~numbers_module.f90 sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~analytical_ephemeris_module.f90->sourcefile~conversion_module.f90 sourcefile~bplane_module.f90 bplane_module.f90 sourcefile~bplane_module.f90->sourcefile~numbers_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~bplane_module.f90->sourcefile~vector_module.f90 sourcefile~brent_module.f90 brent_module.f90 sourcefile~brent_module.f90->sourcefile~numbers_module.f90 sourcefile~celestial_body_module.f90 celestial_body_module.f90 sourcefile~celestial_body_module.f90->sourcefile~numbers_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 sourcefile~crtbp_module.f90 crtbp_module.f90 sourcefile~crtbp_module.f90->sourcefile~numbers_module.f90 sourcefile~crtbp_module.f90->sourcefile~celestial_body_module.f90 sourcefile~math_module.f90 math_module.f90 sourcefile~crtbp_module.f90->sourcefile~math_module.f90 sourcefile~eispack_module.f90 eispack_module.f90 sourcefile~eispack_module.f90->sourcefile~numbers_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~numbers_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~analytical_ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~bplane_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~brent_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~celestial_body_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~conversion_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~crtbp_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~eispack_module.f90 sourcefile~geodesy_module.f90 geodesy_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geodesy_module.f90 sourcefile~geopotential_module.f90 geopotential_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geopotential_module.f90 sourcefile~gooding_module.f90 gooding_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~gooding_module.f90 sourcefile~gravity_module.f90 gravity_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~gravity_module.f90 sourcefile~halo_orbit_module.f90 halo_orbit_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~halo_orbit_module.f90 sourcefile~iau_orientation_module.f90 iau_orientation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~iau_orientation_module.f90 sourcefile~jpl_ephemeris_module.f90 jpl_ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~kepler_module.f90 kepler_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~kepler_module.f90 sourcefile~lambert_module.f90 lambert_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lambert_module.f90 sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~math_module.f90 sourcefile~matrix_module.f90 matrix_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~matrix_module.f90 sourcefile~minpack_module.f90 minpack_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~minpack_module.f90 sourcefile~modified_equinoctial_module.f90 modified_equinoctial_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~modified_equinoctial_module.f90 sourcefile~orbital_mechanics_module.f90 orbital_mechanics_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~orbital_mechanics_module.f90 sourcefile~relative_motion_module.f90 relative_motion_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~relative_motion_module.f90 sourcefile~rk_module.f90 rk_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~rk_module.f90 sourcefile~rk_module_variable_step.f90 rk_module_variable_step.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~rk_module_variable_step.f90 sourcefile~standish_module.f90 standish_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~standish_module.f90 sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~vector_module.f90 sourcefile~c_interface_module.f90 c_interface_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~c_interface_module.f90 sourcefile~ephemeris_module.f90 ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~ephemeris_module.f90 sourcefile~geometry_module.f90 geometry_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geometry_module.f90 sourcefile~obliquity_module.f90 obliquity_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~obliquity_module.f90 sourcefile~time_module.f90 time_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~time_module.f90 sourcefile~geodesy_module.f90->sourcefile~numbers_module.f90 sourcefile~geopotential_module.f90->sourcefile~numbers_module.f90 sourcefile~geopotential_module.f90->sourcefile~conversion_module.f90 sourcefile~geopotential_module.f90->sourcefile~vector_module.f90 sourcefile~gooding_module.f90->sourcefile~numbers_module.f90 sourcefile~gravity_module.f90->sourcefile~numbers_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~numbers_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~celestial_body_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~crtbp_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~math_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~matrix_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~minpack_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~rk_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~numbers_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~conversion_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~vector_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~numbers_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~conversion_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~time_module.f90 sourcefile~kepler_module.f90->sourcefile~numbers_module.f90 sourcefile~newton_module.f90 newton_module.f90 sourcefile~kepler_module.f90->sourcefile~newton_module.f90 sourcefile~lambert_module.f90->sourcefile~numbers_module.f90 sourcefile~lambert_module.f90->sourcefile~gooding_module.f90 sourcefile~lambert_module.f90->sourcefile~vector_module.f90 sourcefile~lighting_module.f90->sourcefile~numbers_module.f90 sourcefile~lighting_module.f90->sourcefile~celestial_body_module.f90 sourcefile~lighting_module.f90->sourcefile~conversion_module.f90 sourcefile~lighting_module.f90->sourcefile~math_module.f90 sourcefile~lighting_module.f90->sourcefile~transformation_module.f90 sourcefile~lighting_module.f90->sourcefile~vector_module.f90 sourcefile~lighting_module.f90->sourcefile~ephemeris_module.f90 sourcefile~math_module.f90->sourcefile~numbers_module.f90 sourcefile~matrix_module.f90->sourcefile~numbers_module.f90 sourcefile~minpack_module.f90->sourcefile~numbers_module.f90 sourcefile~modified_equinoctial_module.f90->sourcefile~numbers_module.f90 sourcefile~modified_equinoctial_module.f90->sourcefile~vector_module.f90 sourcefile~newton_module.f90->sourcefile~numbers_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~numbers_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~math_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~vector_module.f90 sourcefile~relative_motion_module.f90->sourcefile~numbers_module.f90 sourcefile~relative_motion_module.f90->sourcefile~vector_module.f90 sourcefile~rk_module.f90->sourcefile~numbers_module.f90 sourcefile~rk_module.f90->sourcefile~brent_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~numbers_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~brent_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~conversion_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~orbital_mechanics_module.f90 sourcefile~spice_ephemeris_module.f90 spice_ephemeris_module.F90 sourcefile~spice_ephemeris_module.f90->sourcefile~numbers_module.f90 sourcefile~spice_ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~spice_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~standish_module.f90->sourcefile~numbers_module.f90 sourcefile~standish_module.f90->sourcefile~celestial_body_module.f90 sourcefile~standish_module.f90->sourcefile~conversion_module.f90 sourcefile~standish_module.f90->sourcefile~ephemeris_module.f90 sourcefile~standish_module.f90->sourcefile~time_module.f90 sourcefile~transformation_module.f90->sourcefile~numbers_module.f90 sourcefile~transformation_module.f90->sourcefile~celestial_body_module.f90 sourcefile~transformation_module.f90->sourcefile~iau_orientation_module.f90 sourcefile~transformation_module.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~vector_module.f90 sourcefile~transformation_module.f90->sourcefile~ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~obliquity_module.f90 sourcefile~transformation_module.f90->sourcefile~time_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 sourcefile~c_interface_module.f90->sourcefile~geopotential_module.f90 sourcefile~ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~geometry_module.f90->sourcefile~vector_module.f90 sourcefile~obliquity_module.f90->sourcefile~conversion_module.f90 sourcefile~time_module.f90->sourcefile~conversion_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Defines some numeric parameters. module numbers_module use kind_module , only : wp private real ( wp ), parameter , public :: zero = 0.0_wp real ( wp ), parameter , public :: one = 1.0_wp real ( wp ), parameter , public :: two = 2.0_wp real ( wp ), parameter , public :: three = 3.0_wp real ( wp ), parameter , public :: four = 4.0_wp real ( wp ), parameter , public :: five = 5.0_wp real ( wp ), parameter , public :: six = 6.0_wp real ( wp ), parameter , public :: seven = 7.0_wp real ( wp ), parameter , public :: eight = 8.0_wp real ( wp ), parameter , public :: nine = 9.0_wp real ( wp ), parameter , public :: ten = 1 0.0_wp real ( wp ), parameter , public :: pi = acos ( - one ) real ( wp ), parameter , public :: twopi = two * pi real ( wp ), parameter , public :: fourpi = four * pi real ( wp ), parameter , public :: halfpi = 0.5_wp * pi real ( wp ), parameter , public :: universal_grav_constant = 6.67408e-20_wp !! CODATA-recommended universal gravitational !! constant  km&#94;3/kg-s&#94;2   real ( wp ), parameter , public :: c_light = 29979 2.458_wp !! speed of light in km/s real ( wp ), parameter , public :: solar_luminosity = 3.828 + 26_wp !! nominal solar luminosity (W) !! see: \"Resolution B3 on recommended nominal conversion constants for selected solar and planetary properties\". IAU. 2015 !> 3x3 identity matrix: real ( wp ), dimension ( 3 , 3 ), parameter , public :: identity_3x3 = reshape (& [[ one , zero , zero ],& [ zero , one , zero ],& [ zero , zero , one ]],[ 3 , 3 ]) !> 6x6 identity matrix: real ( wp ), dimension ( 6 , 6 ), parameter , public :: identity_6x6 = reshape (& [[ one , zero , zero , zero , zero , zero ],& [ zero , one , zero , zero , zero , zero ],& [ zero , zero , one , zero , zero , zero ],& [ zero , zero , zero , one , zero , zero ],& [ zero , zero , zero , zero , one , zero ],& [ zero , zero , zero , zero , zero , one ] ],[ 6 , 6 ]) end module numbers_module !*****************************************************************************************","tags":"","url":"sourcefile/numbers_module.f90.html"},{"title":"matrix_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~matrix_module.f90~~EfferentGraph sourcefile~matrix_module.f90 matrix_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~matrix_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~matrix_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~matrix_module.f90~~AfferentGraph sourcefile~matrix_module.f90 matrix_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~matrix_module.f90 sourcefile~halo_orbit_module.f90 halo_orbit_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~halo_orbit_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~matrix_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Various matrix routines module matrix_module use kind_module , only : wp use numbers_module , only : zero , one implicit none private public :: print_matrix public :: matrix_trace public :: matrix_determinant public :: matrix_cofactor contains !***************************************************************************************** !******************************************************************************* !> !  Matrix determinant of an  n \\times n  matrix (recursive formulation). ! !### Reference !  * https://rosettacode.org/wiki/Matrix_arithmetic#Fortran pure recursive function matrix_determinant ( n , a ) result ( det ) implicit none integer , intent ( in ) :: n !! size of `a` matrix real ( wp ), dimension ( n , n ), intent ( in ) :: a !! the matrix real ( wp ) :: det !! the determinant of `a` matrix integer :: i !! counter integer :: sgn !! `(-1)**(i-1)` term real ( wp ), dimension ( n - 1 , n - 1 ) :: b !! temp matrix if ( n == 1 ) then det = a ( 1 , 1 ) else det = zero sgn = 1 do i = 1 , n b (:, :( i - 1 )) = a ( 2 :, : i - 1 ) b (:, i :) = a ( 2 :, i + 1 :) det = det + sgn * a ( 1 , i ) * matrix_determinant ( n - 1 , b ) sgn = - sgn end do end if end function matrix_determinant !******************************************************************************* !******************************************************************************* !> !  Compute the cofactors matrix (the transpose of the adjugate matrix). ! !### References !  * https://warwick.ac.uk/fac/sci/physics/research/condensedmatt/imr_cdt/students/david_goodwin/teaching/cis008-2/determinant_algorithm_cis008-2_lec_21.pdf !  * https://groups.google.com/forum/#!topic/comp.lang.fortran/Y6jCv-QdDhc pure function matrix_cofactor ( n , a ) result ( c ) implicit none integer , intent ( in ) :: n !! size of `a` matrix real ( wp ), dimension ( n , n ), intent ( in ) :: a !! the matrix real ( wp ), dimension ( n , n ) :: c !! the cofactors of `a` matrix integer :: i !! counter integer :: j !! counter real ( wp ), dimension ( n - 1 , n - 1 ) :: c_temp !! temp matrix logical , dimension ( n , n ) :: m !! mask for row/col removal if ( n == 1 ) then c ( 1 , 1 ) = one else do i = 1 , n do j = 1 , n ! remove the ith row and jth col from a: m = . true . m (:, j ) = . false . m ( i ,:) = . false . c_temp = reshape ( pack ( a , m ),[ n - 1 , n - 1 ]) c ( i , j ) = ( ( - 1 ) ** ( i + j ) ) * matrix_determinant ( n - 1 , c_temp ) end do end do end if end function matrix_cofactor !******************************************************************************* !***************************************************************************************** !> !  Print a matrix to the console. subroutine print_matrix ( mat , unit ) use iso_fortran_env , only : output_unit implicit none real ( wp ), dimension (:,:), intent ( in ) :: mat !! the matrix to print integer , intent ( in ), optional :: unit !! unit number (assumed to be an open file). !! if not present, then the standard output is used. integer :: i !! counter integer :: n !! number of rows in the matrix integer :: iunit !! the file unit to print to integer :: istat !! `iostat` flag for write statement character ( len =* ), parameter :: fmt = 'E26.16' !! real number format statement if ( present ( unit )) then iunit = unit else iunit = output_unit end if n = size ( mat , 1 ) do i = 1 , n write ( iunit , fmt = '(*(' // fmt // ',1X))' , iostat = istat ) mat ( i ,:) end do end subroutine print_matrix !***************************************************************************************** !***************************************************************************************** !> !  Compute the matrix trace (sum of the diagonal elements). pure function matrix_trace ( n , mat ) result ( trace ) implicit none integer , intent ( in ) :: n !! size of the matrix real ( wp ), dimension ( n , n ), intent ( in ) :: mat !! the matrix real ( wp ) :: trace !! the matrix trace integer :: i !! counter trace = zero do i = 1 , n trace = trace + mat ( i , i ) end do end function matrix_trace !***************************************************************************************** !***************************************************************************************** end module matrix_module !*****************************************************************************************","tags":"","url":"sourcefile/matrix_module.f90.html"},{"title":"spice_ephemeris_module.F90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~spice_ephemeris_module.f90~~EfferentGraph sourcefile~spice_ephemeris_module.f90 spice_ephemeris_module.F90 sourcefile~celestial_body_module.f90 celestial_body_module.f90 sourcefile~spice_ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~ephemeris_module.f90 ephemeris_module.f90 sourcefile~spice_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~spice_ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~spice_ephemeris_module.f90->sourcefile~numbers_module.f90 sourcefile~celestial_body_module.f90->sourcefile~kind_module.f90 sourcefile~celestial_body_module.f90->sourcefile~numbers_module.f90 sourcefile~base_class_module.f90 base_class_module.f90 sourcefile~celestial_body_module.f90->sourcefile~base_class_module.f90 sourcefile~ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Interface to the SPICE ephemeris library. ! !  Not a standard part of FAT. If used, it requires linking with the Fortran !  [SPICELIB SPICE Toolkit](https://naif.jpl.nasa.gov/naif/toolkit.html). ! !@note Haven't validated this yet. module spice_ephemeris_module use , intrinsic :: iso_fortran_env , only : error_unit use ephemeris_module use kind_module implicit none private type , extends ( ephemeris_class ), public :: spice_ephemeris !! Main class for accessing the SPICE ephemeris system. !! !! Note: SPICE is not object-oriented or threadsafe. So, !! while this class provides an object-oriented like interface !! to SPICE, it should really be treated as a singleton. character ( len = :), dimension (:), allocatable :: kernels !! the list of kernels contains procedure , public :: get_rv => get_rv_from_spice_ephemeris procedure , public :: get_r => get_r_from_spice_ephemeris procedure , public :: initialize => initialize_spice_ephemeris procedure , public :: close => close_spice_ephemeris end type spice_ephemeris #ifdef HAS_SPICELIB !these routines are in the SPICELIB: interface subroutine trcoff () implicit none end subroutine trcoff function failed () !! see: ftp://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/failed.html implicit none logical :: failed end function failed subroutine furnsh ( file ) !! see: ftp://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/furnsh.html implicit none character ( len =* ), intent ( in ) :: file end subroutine furnsh subroutine unload ( file ) !! see: ftp://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/unload.html implicit none character ( len =* ), intent ( in ) :: file end subroutine unload subroutine kclear () !! see: ftp://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/kclear.html implicit none end subroutine kclear subroutine spkgeo ( targ , et , ref , obs , state , lt ) !! see: ftp://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/spkgeo.html import :: wp implicit none integer :: targ real ( wp ) :: et character ( len =* ) :: ref integer :: obs real ( wp ), dimension ( 6 ) :: state real ( wp ) :: lt end subroutine spkgeo subroutine spkgps ( targ , et , ref , obs , pos , lt ) !! see: https://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/spkgps.html import :: wp implicit none integer :: targ real ( wp ) :: et character ( len =* ) :: ref integer :: obs real ( wp ), dimension ( 3 ) :: pos real ( wp ) :: lt end subroutine spkgps end interface #endif contains !***************************************************************************************** !***************************************************************************************** !> !  Close the SPICE ephemeris and unload all the kernels. subroutine close_spice_ephemeris ( me ) implicit none class ( spice_ephemeris ), intent ( inout ) :: me integer :: i !! counter #ifdef HAS_SPICELIB !unload all the kernels: if ( allocated ( me % kernels )) then do i = 1 , size ( me % kernels ) call unload ( trim ( me % kernels ( i ))) end do deallocate ( me % kernels ) end if !clear the system: call kclear () #else error stop 'this library was not built with SPICELIB support' #endif end subroutine close_spice_ephemeris !***************************************************************************************** !***************************************************************************************** !> !  Initialize a SPICE ephemeris by loading the specified kernels. subroutine initialize_spice_ephemeris ( me , kernels ) implicit none class ( spice_ephemeris ), intent ( inout ) :: me character ( len =* ), dimension (:), intent ( in ) :: kernels !! list of kernels to load integer :: i !! counter #ifdef HAS_SPICELIB ! disable the SPICE traceback system to speed it up. call trcoff () call me % close () ! just in case !save the kernel list for unloading later: allocate ( character ( len = len ( kernels )) :: me % kernels ( size ( kernels ))) !load all the kernels: do i = 1 , size ( kernels ) call furnsh ( trim ( kernels ( i ))) end do #else error stop 'this library was not built with SPICELIB support' #endif end subroutine initialize_spice_ephemeris !***************************************************************************************** !***************************************************************************************** !> !  Interface for the [[ephemeris_module]]. ! !  Return the Cartesian state of `targ` relative to `obs` in the `J2000` frame. subroutine get_rv_from_spice_ephemeris ( me , et , targ , obs , rv , status_ok ) use celestial_body_module , only : celestial_body use numbers_module , only : zero implicit none class ( spice_ephemeris ), intent ( inout ) :: me real ( wp ), intent ( in ) :: et !! ephemeris time [sec] type ( celestial_body ), intent ( in ) :: targ !! target body type ( celestial_body ), intent ( in ) :: obs !! observer body real ( wp ), dimension ( 6 ), intent ( out ) :: rv !! state of targ w.r.t. obs [km,km/s] in ICRF frame logical , intent ( out ) :: status_ok !! true if there were no problems real ( wp ) :: lt !! light time output from spkgeo #ifdef HAS_SPICELIB call spkgeo ( targ % id , et , 'J2000' , obs % id , rv , lt ) status_ok = . not . failed () #else error stop 'this library was not built with SPICELIB support' #endif end subroutine get_rv_from_spice_ephemeris !***************************************************************************************** !***************************************************************************************** !> !  Interface for the [[ephemeris_module]]. ! !  Return the Cartesian position vector of `targ` relative to `obs` in the `J2000` frame. subroutine get_r_from_spice_ephemeris ( me , et , targ , obs , r , status_ok ) use celestial_body_module , only : celestial_body use numbers_module , only : zero implicit none class ( spice_ephemeris ), intent ( inout ) :: me real ( wp ), intent ( in ) :: et !! ephemeris time [sec] type ( celestial_body ), intent ( in ) :: targ !! target body type ( celestial_body ), intent ( in ) :: obs !! observer body real ( wp ), dimension ( 3 ), intent ( out ) :: r !! position of targ w.r.t. obs [km] in ICRF frame logical , intent ( out ) :: status_ok !! true if there were no problems real ( wp ) :: lt !! light time output from spkgeo #ifdef HAS_SPICELIB call spkgps ( targ % id , et , 'J2000' , obs % id , r , lt ) status_ok = . not . failed () #else error stop 'this library was not built with SPICELIB support' #endif end subroutine get_r_from_spice_ephemeris !***************************************************************************************** !***************************************************************************************** end module spice_ephemeris_module !*****************************************************************************************","tags":"","url":"sourcefile/spice_ephemeris_module.f90.html"},{"title":"orbital_mechanics_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~orbital_mechanics_module.f90~~EfferentGraph sourcefile~orbital_mechanics_module.f90 orbital_mechanics_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~orbital_mechanics_module.f90->sourcefile~kind_module.f90 sourcefile~math_module.f90 math_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~math_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~numbers_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~vector_module.f90 sourcefile~math_module.f90->sourcefile~kind_module.f90 sourcefile~math_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~orbital_mechanics_module.f90~~AfferentGraph sourcefile~orbital_mechanics_module.f90 orbital_mechanics_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~orbital_mechanics_module.f90 sourcefile~rk_module_variable_step.f90 rk_module_variable_step.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~rk_module_variable_step.f90 sourcefile~rk_module_variable_step.f90->sourcefile~orbital_mechanics_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Basic orbital mechanics routines. module orbital_mechanics_module use kind_module use numbers_module use vector_module use math_module , only : wrap_angle implicit none private public :: rv_to_orbital_elements public :: orbital_elements_to_rv public :: orbit_period public :: orbit_energy public :: periapsis_apoapsis public :: sphere_of_influence public :: sphere_of_influence_earth_moon contains !***************************************************************************************** !***************************************************************************************** !> !  Convert position and velocity vectors to orbital elements. ! !### See also !  * The poliastro routine `rv2coe`. pure subroutine rv_to_orbital_elements ( mu , r , v , p , ecc , inc , raan , aop , tru ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;{3}/s&#94;{2}] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector [km/s] real ( wp ), intent ( out ) :: p !! semiparameter a(1-e&#94;{2}) [km] real ( wp ), intent ( out ) :: ecc !! eccentricity [--] real ( wp ), intent ( out ) :: inc !! inclination [rad] real ( wp ), intent ( out ) :: raan !! raan [rad] real ( wp ), intent ( out ) :: aop !! argument of peripsis [rad] real ( wp ), intent ( out ) :: tru !! true anomaly [rad] real ( wp ), dimension ( 3 ) :: h , n , e logical :: circular , equatorial reaL ( wp ) :: hmag , rmag , vmag rmag = norm2 ( r ) vmag = norm2 ( v ) h = cross ( r , v ) hmag = norm2 ( h ) n = cross ([ zero , zero , one ], h ) / hmag e = (( vmag ** 2 - mu / rmag ) * r - dot_product ( r , v ) * v ) / mu ecc = norm2 ( e ) p = hmag ** 2 / mu inc = atan2 ( norm2 ( h ( 1 : 2 )), h ( 3 )) call orbit_check ( ecc , inc , circular , equatorial ) if ( equatorial . and . . not . circular ) then raan = zero aop = wrap_angle ( atan2 ( e ( 2 ), e ( 1 ))) ! Longitude of periapsis tru = wrap_angle ( atan2 ( dot_product ( h , cross ( e , r )) / hmag , dot_product ( r , e ))) elseif ( . not . equatorial . and . circular ) then raan = wrap_angle ( atan2 ( n ( 2 ), n ( 1 ))) aop = zero tru = wrap_angle ( atan2 ( dot_product ( r , cross ( h , n )) / hmag , dot_product ( r , n ))) ! Argument of latitude elseif ( equatorial . and . circular ) then raan = zero aop = zero tru = wrap_angle ( atan2 ( r ( 2 ), r ( 1 ))) ! True longitude else raan = wrap_angle ( atan2 ( n ( 2 ), n ( 1 ))) aop = wrap_angle ( atan2 ( dot_product ( e , cross ( h , n )) / hmag , dot_product ( e , n ))) tru = wrap_angle ( atan2 ( dot_product ( r , cross ( h , e )) / hmag , dot_product ( r , e ))) endif end subroutine rv_to_orbital_elements !***************************************************************************************** !***************************************************************************************** !> !  Convert orbital elements to position and velocity vectors. pure subroutine orbital_elements_to_rv ( mu , p , ecc , inc , raan , aop , tru , r , v ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;{3}/s&#94;{2}] real ( wp ), intent ( in ) :: p !! semiparameter a(1-e&#94;{2}) [km] real ( wp ), intent ( in ) :: ecc !! eccentricity [--] real ( wp ), intent ( in ) :: inc !! inclination [rad] real ( wp ), intent ( in ) :: raan !! raan [rad] real ( wp ), intent ( in ) :: aop !! argument of peripsis [rad] real ( wp ), intent ( in ) :: tru !! true anomaly [rad] real ( wp ), dimension ( 3 ), intent ( out ) :: r !! position vector [km] real ( wp ), dimension ( 3 ), intent ( out ) :: v !! velocity vector [km/s] real ( wp ), dimension ( 3 , 2 ) :: rotmat real ( wp ), dimension ( 2 ) :: r_pqw , v_pqw logical :: circular , equatorial real ( wp ) :: ctru , stru , sr , cr , si , ci , sa , ca , raan_tmp , aop_tmp call orbit_check ( ecc , inc , circular , equatorial ) if ( circular ) then ! periapsis undefined aop_tmp = zero else aop_tmp = aop end if if ( equatorial ) then ! node undefined raan_tmp = zero else raan_tmp = raan end if ! perifocal position and velocity: ctru = cos ( tru ) stru = sin ( tru ) r_pqw = [ ctru , stru ] * p / ( one + ecc * ctru ) v_pqw = [ - stru , ( ecc + ctru )] * sqrt ( mu / p ) ! perifocal to cartesian: sr = sin ( raan_tmp ) cr = cos ( raan_tmp ) si = sin ( inc ) ci = cos ( inc ) sa = sin ( aop_tmp ) ca = cos ( aop_tmp ) rotmat ( 1 ,:) = [ cr * ca - sr * sa * ci , - cr * sa - sr * ca * ci ] rotmat ( 2 ,:) = [ sr * ca + cr * sa * ci , - sr * sa + cr * ca * ci ] rotmat ( 3 ,:) = [ sa * si , ca * si ] ! transform: r = matmul ( rotmat , r_pqw ) v = matmul ( rotmat , v_pqw ) end subroutine orbital_elements_to_rv !***************************************************************************************** !***************************************************************************************** !> !  Check the orbit for singularities. pure subroutine orbit_check ( ecc , inc , circular , equatorial ) implicit none real ( wp ), intent ( in ) :: ecc !! eccentricity real ( wp ), intent ( in ) :: inc !! inclination [rad] logical , intent ( out ) :: circular !! is the orbit circular? logical , intent ( out ) :: equatorial !! is the orbit equatorial? real ( wp ), parameter :: tol = 1.0e-10_wp !! tolerance for circular & equatorial checks circular = ecc < tol equatorial = ( one - abs ( cos ( inc ))) < tol ! 0 or 180 deg end subroutine orbit_check !***************************************************************************************** !***************************************************************************************** !> !  Compute the two-body orbital period. pure function orbit_period ( mu , a ) result ( period ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;{3}/s&#94;{2}] real ( wp ), intent ( in ) :: a !! semimajor axis [km] real ( wp ) :: period !! two-body orbital period [s] period = twopi / sqrt ( mu / a ** 3 ) end function orbit_period !***************************************************************************************** !***************************************************************************************** !> !  Compute the two-body orbital energy. pure function orbit_energy ( mu , rv ) result ( energy ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;{3}/s&#94;{2}] real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! position and velocity vector [km,km/s] real ( wp ) :: energy !! two-body orbital energy [km&#94;{2}/s&#94;{2}] real ( wp ) :: rmag !! position vector magnitude [km] real ( wp ) :: vmag !! velocity vector magnitude [km] rmag = norm2 ( rv ( 1 : 3 )) vmag = norm2 ( rv ( 4 : 6 )) energy = ( vmag ** 2 / two ) - ( mu / rmag ) end function orbit_energy !***************************************************************************************** !***************************************************************************************** !> !  Compute the periapsis and apoapsis position and velocity magnitudes. pure subroutine periapsis_apoapsis ( mu , a , e , rp , ra , vp , va ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;{3}/s&#94;{2}] real ( wp ), intent ( in ) :: a !! semimajor axis [km] real ( wp ), intent ( in ) :: e !! eccentricity [--] real ( wp ), intent ( out ) :: rp !! periapsis position magnitude [km] real ( wp ), intent ( out ) :: ra !! apoapsis position magnitude [km] real ( wp ), intent ( out ) :: vp !! periapsis velocity magnitude [km/s] real ( wp ), intent ( out ) :: va !! apoapsis velocity magnitude [km/s] real ( wp ) :: rarp !! r_a + r_p  real ( wp ) :: twomu !!  2 \\mu  twomu = two * mu rp = a * ( one - e ) ra = a * ( one + e ) rarp = ra + rp vp = sqrt ( twomu * ra / ( rp * rarp )) va = sqrt ( twomu * rp / ( ra * rarp )) end subroutine periapsis_apoapsis !***************************************************************************************** !***************************************************************************************** !> !  Computes the sphere-of-influence radius of the secondary body. ! !### See also !  * R.H. Battin, \"An Introduction to the Mathematics and !    Methods of Astrodynamics, Revised Edition\", AIAA, 1999. !  * This is the approximate formula (8.74 from Battin). pure function sphere_of_influence ( mu_primary , mu_secondary , r_ps ) result ( r_soi ) implicit none real ( wp ), intent ( in ) :: mu_primary !! primary body gravitational parameter [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: mu_secondary !! secondary body gravitational parameter [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: r_ps !! distance between the two bodies [km] real ( wp ) :: r_soi !! sphere of influence radius [km] real ( wp ), parameter :: two_fifths = two / five if ( mu_primary > zero . and . mu_secondary > zero . and . r_ps > zero ) then r_soi = r_ps * ( mu_secondary / mu_primary ) ** two_fifths else r_soi = zero end if end function sphere_of_influence !***************************************************************************************** !***************************************************************************************** !> !  Computes the sphere-of-influence radius of the secondary body. ! !### Notes !  * `r` and `r_sp` should be in the same inertial frame. !  * The mass of the spacecraft is neglected. ! !### See also !  * R.H. Battin, \"An Introduction to the Mathematics and !    Methods of Astrodynamics, Revised Edition\", AIAA, 1999. !  * This is the more complex formula, on p. 397 of Battin, !    which is better for the Earth/Moon system. pure function sphere_of_influence_earth_moon ( mu_primary , mu_secondary , r , r_sp ) result ( r_soi ) implicit none real ( wp ), intent ( in ) :: mu_primary !! primary body gravitational parameter [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: mu_secondary !! secondary body gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! vector from the secondary body to the spacecraft [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r_sp !! vector from the secondary to the primary body [km] real ( wp ) :: r_soi !! sphere of influence radius of the secondary body [km] real ( wp ) :: r_mag , r_sp_mag , alpha , ca , ca2 , denom r_mag = norm2 ( r ) r_sp_mag = norm2 ( r_sp ) if ( mu_primary > zero . and . mu_secondary > zero . and . r_mag > zero . and . r_sp_mag > zero ) then alpha = angle_between_vectors ( r , r_sp ) ca = cos ( alpha ) ca2 = ca * ca denom = ( mu_secondary ** 2 / mu_primary ** 2 ) ** ( one / five ) * ( one + three * ca2 ) ** ( one / ten ) + & ( two / five ) * ca * (( one + six * ca2 ) / ( one + three * ca2 )) r_soi = r_sp_mag / denom else r_soi = zero end if end function sphere_of_influence_earth_moon !***************************************************************************************** !***************************************************************************************** end module orbital_mechanics_module !*****************************************************************************************","tags":"","url":"sourcefile/orbital_mechanics_module.f90.html"},{"title":"geopotential_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~geopotential_module.f90~~EfferentGraph sourcefile~geopotential_module.f90 geopotential_module.f90 sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~geopotential_module.f90->sourcefile~conversion_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~geopotential_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~geopotential_module.f90->sourcefile~numbers_module.f90 sourcefile~random_module.f90 random_module.f90 sourcefile~geopotential_module.f90->sourcefile~random_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~geopotential_module.f90->sourcefile~vector_module.f90 sourcefile~conversion_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~random_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~geopotential_module.f90~~AfferentGraph sourcefile~geopotential_module.f90 geopotential_module.f90 sourcefile~c_interface_module.f90 c_interface_module.f90 sourcefile~c_interface_module.f90->sourcefile~geopotential_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geopotential_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~c_interface_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Gravity models for computing gravitational acceleration due to geopotential. ! !  Each routine returns the acceleration in the body-fixed frame. ! !# Example !```Fortran !    type(geopotential_model_mueller),target :: g !    call g%initialize(gravfile,n,m,status_ok) !    call g%get_acc(rvec,n,m,acc) !``` ! !@note Need to update to make sure they all work when N /= M module geopotential_module use kind_module , only : wp use numbers_module implicit none private type , abstract , public :: geopotential_model !! The base abstract class for the various geopotential models character ( len = :), allocatable :: name !! model name character ( len = :), allocatable :: filename !! model file name integer :: nmax = 0 !! degree of the model integer :: mmax = 0 !! order of the model real ( wp ) :: re = zero !! body radius [km] real ( wp ) :: mu = zero !! body grav. parameter [km3/s2] contains procedure , public :: initialize => read_geopotential_file procedure , public :: destroy => destroy_geopotential_model procedure ( acc_function ), deferred , public :: get_acc end type geopotential_model type , extends ( geopotential_model ), abstract , public :: geopotential_model_vector_coeff !! The models where the C,S coefficients are stored in vectors real ( wp ), dimension (:), allocatable :: c real ( wp ), dimension (:), allocatable :: s end type geopotential_model_vector_coeff type , extends ( geopotential_model ), abstract , public :: geopotential_model_matrix_coeff !! The models where the C,S coefficients are stored in matrices real ( wp ), dimension (:,:), allocatable :: cnm real ( wp ), dimension (:,:), allocatable :: snm end type geopotential_model_matrix_coeff type , extends ( geopotential_model_vector_coeff ), public :: geopotential_model_mueller !! Mueller method contains procedure , public :: get_acc => compute_gravity_acceleration_mueller end type geopotential_model_mueller type , extends ( geopotential_model_matrix_coeff ), public :: geopotential_model_lear !! Lear method contains procedure , public :: get_acc => compute_gravity_acceleration_lear end type geopotential_model_lear type , extends ( geopotential_model_matrix_coeff ), public :: geopotential_model_pines !! Pines method contains procedure , public :: get_acc => compute_gravity_acceleration_pines end type geopotential_model_pines type , extends ( geopotential_model_matrix_coeff ), public :: geopotential_model_normalized_pines !! Pines (normalized) method contains procedure , public :: get_acc => compute_gravity_acceleration_normalized_pines end type geopotential_model_normalized_pines type , extends ( geopotential_model_matrix_coeff ), public :: geopotential_model_kuga_carrara !! Kuga/Carrara method contains procedure , public :: get_acc => compute_gravity_acceleration_kuga_carrara end type geopotential_model_kuga_carrara abstract interface subroutine acc_function ( me , r , n , m , a ) !! Interface to the acceleration function for the different methods import implicit none class ( geopotential_model ), intent ( inout ) :: me real ( wp ), dimension ( 3 ), intent ( in ) :: r integer , intent ( in ) :: n integer , intent ( in ) :: m real ( wp ), dimension ( 3 ), intent ( out ) :: a end subroutine acc_function end interface public :: geopotential_module_test !for testing contains !***************************************************************************************** !***************************************************************************************** !> !  Destroy a gravity model. subroutine destroy_geopotential_model ( me ) implicit none class ( geopotential_model ), intent ( inout ) :: me !common to all: if ( allocated ( me % name )) deallocate ( me % name ) if ( allocated ( me % filename )) deallocate ( me % filename ) me % nmax = 0 me % mmax = 0 me % re = zero me % mu = zero select type ( me ) class is ( geopotential_model_vector_coeff ) if ( allocated ( me % c )) deallocate ( me % c ) if ( allocated ( me % s )) deallocate ( me % s ) class is ( geopotential_model_matrix_coeff ) if ( allocated ( me % cnm )) deallocate ( me % cnm ) if ( allocated ( me % snm )) deallocate ( me % snm ) end select end subroutine destroy_geopotential_model !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for Mueller method. subroutine compute_gravity_acceleration_mueller ( me , r , n , m , a ) implicit none class ( geopotential_model_mueller ), intent ( inout ) :: me real ( wp ), dimension ( 3 ), intent ( in ) :: r integer , intent ( in ) :: n integer , intent ( in ) :: m real ( wp ), dimension ( 3 ), intent ( out ) :: a call geopot ( r ( 1 ), r ( 2 ), r ( 3 ), n , m + 1 , me % re , me % mu , me % c , me % s , a ( 1 ), a ( 2 ), a ( 3 )) end subroutine compute_gravity_acceleration_mueller !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for Pines method. subroutine compute_gravity_acceleration_pines ( me , r , n , m , a ) implicit none class ( geopotential_model_pines ), intent ( inout ) :: me real ( wp ), dimension ( 3 ), intent ( in ) :: r integer , intent ( in ) :: n integer , intent ( in ) :: m real ( wp ), dimension ( 3 ), intent ( out ) :: a call gravpot ( r , n , me % re , me % mu , me % cnm , me % snm , a ) end subroutine compute_gravity_acceleration_pines !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for Lear method. subroutine compute_gravity_acceleration_lear ( me , r , n , m , a ) implicit none class ( geopotential_model_lear ), intent ( inout ) :: me real ( wp ), dimension ( 3 ), intent ( in ) :: r integer , intent ( in ) :: n integer , intent ( in ) :: m real ( wp ), dimension ( 3 ), intent ( out ) :: a call grav ( me % mu , r , me % re , n , m , me % cnm , me % snm , a ) end subroutine compute_gravity_acceleration_lear !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for Kuga/Carrara method. ! !@note Only computes n x n field (m input is ignored). subroutine compute_gravity_acceleration_kuga_carrara ( me , r , n , m , a ) implicit none class ( geopotential_model_kuga_carrara ), intent ( inout ) :: me real ( wp ), dimension ( 3 ), intent ( in ) :: r integer , intent ( in ) :: n integer , intent ( in ) :: m real ( wp ), dimension ( 3 ), intent ( out ) :: a call kuga_carrara_geopotential ( me % nmax , n , me % re , me % mu , me % cnm , me % snm , r , a ) end subroutine compute_gravity_acceleration_kuga_carrara !***************************************************************************************** !***************************************************************************************** !> !  Wrapper for normalized Pines method. subroutine compute_gravity_acceleration_normalized_pines ( me , r , n , m , a ) implicit none class ( geopotential_model_normalized_pines ), intent ( inout ) :: me real ( wp ), dimension ( 3 ), intent ( in ) :: r integer , intent ( in ) :: n integer , intent ( in ) :: m real ( wp ), dimension ( 3 ), intent ( out ) :: a a = pinesnorm ( me % mu , me % re , r , me % cnm , me % snm , n , m ) end subroutine compute_gravity_acceleration_normalized_pines !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 9/20/2014 ! !  Read the gravity coefficient file. !  Example file: ftp://ftp.csr.utexas.edu/pub/grav/EGM96.GEO.Z subroutine read_geopotential_file ( me , filename , nmax , mmax , status_ok ) implicit none class ( geopotential_model ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: filename integer , intent ( in ) :: nmax integer , intent ( in ) :: mmax logical , intent ( out ) :: status_ok character ( len = 100 ) :: c1 , c2 , fmt ! for reading the format statements integer :: iunit , istat , i1 , i2 , nc , i , ii , n , m real ( wp ) :: d1 , d2 , d3 , d4 , f1 , t1 , t2 call me % destroy () if ( nmax > 0 . and . mmax > 0 . and . mmax <= nmax ) then status_ok = . true . nc = number_of_coefficients ( nmax , mmax ) me % nmax = nmax me % mmax = mmax me % filename = trim ( filename ) open ( newunit = iunit , file = me % filename , status = 'OLD' , iostat = istat ) if ( istat == 0 ) then !size the coefficient arrays: select type ( me ) class is ( geopotential_model_vector_coeff ) allocate ( me % c ( nc )) !they are stored compressed into arrays allocate ( me % s ( nc )) ! me % c = zero me % s = zero class is ( geopotential_model_matrix_coeff ) !Note: will get all the nmax x nmax coefficients, even if mmax < nmax allocate ( me % cnm ( nmax , 0 : nmax )) !probably could replace with 2:nmax allocate ( me % snm ( nmax , 0 : nmax )) me % cnm = zero me % snm = zero class default write ( * , * ) 'ERROR: INVALID geopotential_model CLASS!' status_ok = . false . return end select !Read the file: ! (2A10,2E20.10)                                               J2-DOT = -26x10-12 !EGM 96                  398600.44150E+09          6378136.30 ! (A6,2I3,2D19.12,2D13.6,F4.0) !RECOEF  2  0-0.484165371736E-03 0.000000000000E+00 0.356106E-10 0.000000E+00 -1. !HONKCR  2  0-0.484169544736E-03 0.000000000000E+00 0.356106E-10 0.000000E+00 -1. !IERS    2  1-0.186987640000E-09 0.119528010000E-08 0.100000E-29 0.100000E-29 -1. !RECOEF  2  2 0.243914352398E-05-0.140016683654E-05 0.537392E-10 0.543533E-10 -1. !RECOEF  3  0 0.957254173792E-06 0.000000000000E+00 0.180942E-10 0.000000E+00 -1. !RECOEF  3  1 0.202998882184E-05 0.248513158716E-06 0.139652E-09 0.136459E-09 -1. read ( iunit , '(A)' , iostat = istat ) c1 !this is the FMT statement for the next line call get_format_statement ( c1 , fmt ) ! read ( iunit , trim ( fmt ), iostat = istat ) c1 , c2 , d1 , d2 me % name = trim ( c1 ) // trim ( c2 ) me % mu = d1 / 100 0.0_wp ** 3 !km3/s2 me % re = d2 / 100 0.0_wp !km read ( iunit , '(A)' , iostat = istat ) c1 !this is the FMT statement for the next lines call get_format_statement ( c1 , fmt ) ! do i = 1 , nc !...until end of file or all the coefficients have been read... read ( iunit , trim ( fmt ), iostat = istat ) c1 , i1 , i2 , d1 , d2 , d3 , d4 , f1 if ( istat > 0 ) then write ( * , * ) 'Error reading file:' // trim ( filename ) call me % destroy () status_ok = . false . exit else if ( istat < 0 ) then ! end of file: if ( i > nc ) then write ( * , * ) 'Error: not enough coefficients in file.' call me % destroy () status_ok = . false . exit end if end if select type ( me ) class is ( geopotential_model_vector_coeff ) me % c ( i ) = d1 me % s ( i ) = d2 class is ( geopotential_model_matrix_coeff ) me % cnm ( i1 , i2 ) = d1 me % snm ( i1 , i2 ) = d2 end select end do close ( iunit , iostat = istat ) else write ( * , * ) 'Error reading file: ' // trim ( filename ) call me % destroy () status_ok = . false . end if else write ( * , * ) 'Error: invalid n,m values: ' , nmax , mmax call me % destroy () status_ok = . false . end if !unnormalize the coefficients if necessary: if ( status_ok ) then select type ( me ) class is ( geopotential_model_vector_coeff ) !for this one, the coefficients are stored in arrays ii = 0 !counter do n = 2 , me % nmax ! based on Lear's CONVERT routine t1 = 2 * n + 1 ii = ii + 1 me % c ( ii ) = sqrt ( t1 ) * me % c ( ii ) me % s ( ii ) = zero do m = 1 , n ii = ii + 1 t2 = sqrt ( FL ( n - m ) * t1 * two / FL ( n + m )) me % c ( ii ) = t2 * me % c ( ii ) me % s ( ii ) = t2 * me % s ( ii ) end do end do class is ( geopotential_model_matrix_coeff ) !for this one, the coefficients are stored in matrices select type ( me ) class is ( geopotential_model_kuga_carrara ) !this model uses the normalized coefficients return class is ( geopotential_model_normalized_pines ) !this model uses the normalized coefficients return end select call convert ( me % nmax , me % cnm , me % snm ) end select end if end subroutine read_geopotential_file !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/24/2015 ! !  Returns the format statement from a line !  in a .GEO gravity coefficient file. subroutine get_format_statement ( str , fmt ) implicit none character ( len =* ), intent ( in ) :: str character ( len =* ), intent ( out ) :: fmt integer :: i1 , i2 !note: other text after the format statement is ignored i1 = index ( str , '(' ) i2 = index ( str , ')' ) if ( i1 /= 0 . and . i2 /= 0 . and . i2 > i1 ) then fmt = str ( i1 : i2 ) else write ( * , * ) 'ERROR: THE STRING DOES NOT CONTAIN A FORMAT STATEMENT: ' // trim ( str ) fmt = '' end if end subroutine get_format_statement !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 9/20/2014 ! !  Number of (c,s) coefficients for n x m geopotential model !  Starting with n=2,m=0. pure function number_of_coefficients ( n , m ) result ( np ) implicit none integer :: np !! number of coefficients integer , intent ( in ) :: n !! degree integer , intent ( in ) :: m !! order integer :: i !counter if ( n >= m . and . n > 1 ) then np = m - 1 + sum ( [ ( i , i = n , 2 , - 1 ) ] ) else np = - 999 !error end if end function number_of_coefficients !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 9/20/2014 ! !  The FL factorial function from [1]. ! !# References !  1. W. M. Lear, \"The Programs TRAJ1 and TRAJ2\", !     JSC Mission Planning and Analysis Division, !     JSC-22512, 87-FM-4, April 1987 ! !@note Coded from [1] with some modifications. ! !  SOURCE function FL ( n ) implicit none real ( wp ) :: FL integer , intent ( in ) :: n integer :: i FL = one if ( n == 0 . or . n == 1 ) return do i = 2 , n FL = FL * i end do end function FL !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 9/20/2014 ! !  Based on the CONVERT subroutine from [1]. !  Unnormalizes the C,S coefficients. ! !# References !  1. W. M. Lear, \"The Programs TRAJ1 and TRAJ2\", !     JSC Mission Planning and Analysis Division, !     JSC-22512, 87-FM-4, April 1987 ! !@note Coded from [1] with some modifications. subroutine convert ( nmodel , cnm , snm ) implicit none integer , intent ( in ) :: nmodel real ( wp ), dimension ( nmodel , 0 : nmodel ), intent ( inout ) :: cnm real ( wp ), dimension ( nmodel , 0 : nmodel ), intent ( inout ) :: snm integer :: n , m real ( wp ) :: t1 , t2 do n = 1 , nmodel !JW : this could be 2,nmodel ... t1 = 2 * n + 1 cnm ( n , 0 ) = sqrt ( t1 ) * cnm ( n , 0 ) do m = 1 , n t2 = sqrt ( FL ( n - m ) * t1 * two / FL ( n + m )) cnm ( n , m ) = t2 * cnm ( n , m ) snm ( n , m ) = t2 * snm ( n , m ) end do end do end subroutine convert !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/25/2014 ! !  Spencer's implementation of the Pines algorithms from [1] ! !# References !  1. J.L. Spencer, \"Pines' nonsingular gravitational potential !     derivation, description, and implementation\", !     NASA-CR-147478, MDC-W0013, Feb 9, 1976. !     http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19760011100.pdf ! !@note Updated and fixed bugs in the original code. subroutine gravpot ( r , nmax , re , mu , c , s , fg ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector integer , intent ( in ) :: nmax !! degree/order real ( wp ), intent ( in ) :: re !! body radius real ( wp ), intent ( in ) :: mu !! grav constant real ( wp ), dimension ( nmax , 0 : nmax ), intent ( in ) :: c !! C coefficients real ( wp ), dimension ( nmax , 0 : nmax ), intent ( in ) :: s !! S coefficients real ( wp ), dimension ( 3 ), intent ( out ) :: fg !! grav acceleration !local variables: real ( wp ), dimension ( nmax + 1 ) :: creal , cimag , rho real ( wp ), dimension ( nmax + 1 , nmax + 1 ) :: a , d , e , f integer :: nax0 , i , j , k , l , n , m real ( wp ) :: rinv , ess , t , u , r0 , rhozero , a1 , a2 , a3 , a4 , fac1 , fac2 , fac3 , fac4 real ( wp ) :: ci1 , si1 , temp !JW : not done in original paper, !     but seems to be necessary !     (probably assumed the compiler !      did it automatically) a = zero d = zero e = zero f = zero !get the direction cosines ess, t and u: nax0 = nmax + 1 rinv = one / norm2 ( r ) ess = r ( 1 ) * rinv t = r ( 2 ) * rinv u = r ( 3 ) * rinv !generate the functions creal, cimag, a, d, e, f and rho: r0 = re * rinv rhozero = mu * rinv !JW: typo in original paper (see p.18) rho ( 1 ) = r0 * rhozero creal ( 1 ) = ess cimag ( 1 ) = t d ( 1 , 1 ) = zero e ( 1 , 1 ) = zero f ( 1 , 1 ) = zero a ( 1 , 1 ) = one main_loop : do i = 2 , nax0 if ( i /= nax0 ) then !JW : to prevent access of c,s outside bounds ci1 = c ( i , 1 ) si1 = s ( i , 1 ) else ci1 = zero si1 = zero end if rho ( i ) = r0 * rho ( i - 1 ) creal ( i ) = ess * creal ( i - 1 ) - t * cimag ( i - 1 ) cimag ( i ) = ess * cimag ( i - 1 ) + t * creal ( i - 1 ) d ( i , 1 ) = ess * ci1 + t * si1 e ( i , 1 ) = ci1 f ( i , 1 ) = si1 a ( i , i ) = ( 2 * i - 1 ) * a ( i - 1 , i - 1 ) a ( i , i - 1 ) = u * a ( i , i ) do k = 2 , i if ( i /= nax0 ) then d ( i , k ) = c ( i , k ) * creal ( k ) + s ( i , k ) * cimag ( k ) e ( i , k ) = c ( i , k ) * creal ( k - 1 ) + s ( i , k ) * cimag ( k - 1 ) f ( i , k ) = s ( i , k ) * creal ( k - 1 ) - c ( i , k ) * cimag ( k - 1 ) end if !JW : typo in original paper !  (should be GOTO 1, rather than GOTO 10) if ( i /= 2 ) then L = i - 2 do j = 1 , L a ( i , i - j - 1 ) = ( u * a ( i , i - j ) - a ( i - 1 , i - j )) / ( j + 1 ) end do end if end do end do main_loop !compute auxiliary quantities a1, a2, a3, a4 a1 = zero a2 = zero a3 = zero a4 = rhozero * rinv do n = 2 , nmax fac1 = zero fac2 = zero fac3 = a ( n , 1 ) * c ( n , 0 ) fac4 = a ( n + 1 , 1 ) * c ( n , 0 ) do m = 1 , n temp = m * a ( n , m ) fac1 = fac1 + temp * e ( n , m ) fac2 = fac2 + temp * f ( n , m ) fac3 = fac3 + a ( n , m + 1 ) * d ( n , m ) fac4 = fac4 + a ( n + 1 , m + 1 ) * d ( n , m ) end do temp = rinv * rho ( n ) a1 = a1 + temp * fac1 a2 = a2 + temp * fac2 a3 = a3 + temp * fac3 a4 = a4 + temp * fac4 end do fg ( 1 ) = a1 - ess * a4 fg ( 2 ) = a2 - t * a4 fg ( 3 ) = a3 - u * a4 end subroutine gravpot !***************************************************************************************** !***************************************************************************************** !> !  Compute the gravitational acceleration vector using the Mueller method. ! !# References !  1. Alan C. Mueller, \"A Fast Recursive Algorithm for Calculating the !     Forces due to the Geopotential (Program GEOPOT)\", !     JSC Internal Note 75-FM-42, June 9, 1975. ! !@warning WARNING: this one crashes if nmax/=mmax subroutine geopot ( x , y , z , nmax , mmax , re , ksq , c , s , fx , fy , fz ) implicit none !subroutine arguments: real ( wp ), intent ( in ) :: x !! position vector x-component real ( wp ), intent ( in ) :: y !! position vector y-component real ( wp ), intent ( in ) :: z !! position vector z-component integer , intent ( in ) :: nmax !! degree of model integer , intent ( in ) :: mmax !! order+1 of model real ( wp ), intent ( in ) :: re !! body radius real ( wp ), intent ( in ) :: ksq !! body GM real ( wp ), dimension (:), intent ( in ) :: c !! C coefficients real ( wp ), dimension (:), intent ( in ) :: s !! S coefficients real ( wp ), intent ( out ) :: fx !! gravitational acceleration x-component real ( wp ), intent ( out ) :: fy !! gravitational acceleration y-component real ( wp ), intent ( out ) :: fz !! gravitational acceleration z-component !local variables: real ( wp ) :: r , ri , reor , reorn , ksqor2 , xor , yor , zor , rdedx , rdedy , rdedz ,& sum1 , sum2 , sum3 , sum4 , temp1 , temp2 , temp3 , temp4 , fact , dcstld , temp integer :: i , j , k , im1 , l , jm1 , jp1 , kk real ( wp ), dimension ( 0 : mmax ) :: p0 , p1 , p2 , ctil , stil !write(*,'(A,1x,*(e20.5,1x/))') 'c=',c !write(*,'(A,1x,*(e20.5,1x/))') 's=',s !abbreviations: r = sqrt ( x * x + y * y + z * z ) ri = one / r reor = re * ri reorn = reor ksqor2 = ksq * ri * ri zor = z * ri xor = x * ri yor = y * ri !the derivatives of the argument of the legendre polynomial - zor rdedz = zor * zor - one rdedx = zor * xor rdedy = zor * yor !initialization: k = 0 do i = 1 , mmax p0 ( i ) = zero p1 ( i ) = zero end do p0 ( 0 ) = one p1 ( 0 ) = zor p1 ( 1 ) = one ctil ( 0 ) = one stil ( 0 ) = zero ctil ( 1 ) = xor stil ( 1 ) = yor sum1 = zero !sum2   = zero       !original sum2 = one !JW : include central body term sum3 = zero sum4 = zero !computation of forces: do i = 2 , nmax reorn = reorn * reor fact = 2 * i - 1 im1 = i - 1 l = 1 !recursion formulas for legendre polynomial - p2(0) p2 ( 0 ) = ( fact * zor * p1 ( 0 ) - im1 * p0 ( 0 )) / i k = k + 1 p2 ( 1 ) = p0 ( 1 ) + fact * p1 ( 0 ) temp1 = p2 ( 1 ) * c ( k ) temp2 = p2 ( 0 ) * c ( k ) * ( i + 1 ) if ( i < mmax ) then !recursive formulas for: !    'ctilda' - ctil !    'stilda' - stil ctil ( i ) = ctil ( 1 ) * ctil ( im1 ) - stil ( 1 ) * stil ( im1 ) stil ( i ) = stil ( 1 ) * ctil ( im1 ) + ctil ( 1 ) * stil ( im1 ) temp3 = zero temp4 = zero do j = 1 , i jm1 = j - 1 jp1 = j + 1 !recursive formula for derivative of legendre polynomial - p2(j) p2 ( jp1 ) = p0 ( jp1 ) + fact * p1 ( j ) kk = k + j dcstld = j * p2 ( j ) temp = ( c ( kk ) * ctil ( j ) + s ( kk ) * stil ( j )) temp1 = temp1 + p2 ( jp1 ) * temp temp2 = temp2 + ( i + jp1 ) * p2 ( j ) * temp temp3 = temp3 + dcstld * ( c ( kk ) * ctil ( jm1 ) + s ( kk ) * stil ( jm1 )) temp4 = temp4 - dcstld * ( c ( kk ) * stil ( jm1 ) - s ( kk ) * ctil ( jm1 )) end do l = i sum3 = sum3 + reorn * temp3 sum4 = sum4 + reorn * temp4 end if sum1 = sum1 + reorn * temp1 sum2 = sum2 + reorn * temp2 k = k + i !shift indices: do j = 0 , l p0 ( j ) = p1 ( j ) p1 ( j ) = p2 ( j ) end do end do fx = - ksqor2 * ( sum1 * rdedx + sum2 * xor - sum3 ) fy = - ksqor2 * ( sum1 * rdedy + sum2 * yor - sum4 ) fz = - ksqor2 * ( sum1 * rdedz + sum2 * zor ) end subroutine geopot !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 9/20/2014 ! !  Based on the GRAV subroutine from [1]. ! !# References !  1. W. M. Lear, \"The Programs TRAJ1 and TRAJ2\", !     JSC Internal Note 87-FM-4, April 1987. !  2. W. M. Lear, \"The Gravitational Acceleration Equations\", !     JSC Internal Note 86-FM-15, April 1986. subroutine grav ( mu , rgr , rbar , nmodel , mmodel , cnm , snm , agr ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: rgr !! position vector [body-fixed coordinates] real ( wp ), intent ( in ) :: mu !! gravitational constant real ( wp ), intent ( in ) :: rbar !! gravitational scaling radius (generally the equatorial radius) integer , intent ( in ) :: nmodel !! the degree of the gravity model (>=2) integer , intent ( in ) :: mmodel !! the order of the gravity model (>=0, <=nmodel) real ( wp ), dimension ( nmodel , 0 : nmodel ), intent ( in ) :: cnm !! C gravity coefficients real ( wp ), dimension ( nmodel , 0 : nmodel ), intent ( in ) :: snm !! S gravity coefficients real ( wp ), dimension ( 3 ), intent ( out ) :: agr !! gravitational acceleration vector [body-fixed coordinates] !local variables: real ( wp ), dimension ( nmodel , nmodel ) :: pnm , ppnm real ( wp ), dimension ( nmodel ) :: cm , sm , pn , rb , ppn real ( wp ), dimension ( 3 ) :: asph real ( wp ) :: e1 , e2 , e3 , e4 , e5 , r1 , r2 , t1 , t3 , absr , sphi , cphi , tcm , tsm , tsnm , tcnm , tpnm integer :: n , nm1 , nm2 , m do n = 2 , nmodel pnm ( n - 1 , n ) = zero end do e1 = rgr ( 1 ) ** 2 + rgr ( 2 ) ** 2 r2 = e1 + rgr ( 3 ) ** 2 absr = sqrt ( r2 ) r1 = sqrt ( e1 ) sphi = rgr ( 3 ) / absr cphi = r1 / absr if ( r1 == zero ) then sm ( 1 ) = zero cm ( 1 ) = one else sm ( 1 ) = rgr ( 2 ) / r1 cm ( 1 ) = rgr ( 1 ) / r1 end if rb ( 1 ) = rbar / absr rb ( 2 ) = rb ( 1 ) ** 2 sm ( 2 ) = two * cm ( 1 ) * sm ( 1 ) cm ( 2 ) = two * cm ( 1 ) ** 2 - one pn ( 1 ) = sphi pn ( 2 ) = ( three * sphi ** 2 - one ) / two ppn ( 1 ) = one ppn ( 2 ) = three * sphi pnm ( 1 , 1 ) = one pnm ( 2 , 2 ) = three * cphi pnm ( 2 , 1 ) = ppn ( 2 ) ppnm ( 1 , 1 ) = - sphi ppnm ( 2 , 2 ) = - six * sphi * cphi ppnm ( 2 , 1 ) = three - six * sphi ** 2 if ( nmodel >= 3 ) then do n = 3 , nmodel nm1 = n - 1 nm2 = n - 2 rb ( n ) = rb ( nm1 ) * rb ( 1 ) sm ( n ) = two * cm ( 1 ) * sm ( nm1 ) - sm ( nm2 ) cm ( n ) = two * cm ( 1 ) * cm ( nm1 ) - cm ( nm2 ) e1 = 2 * n - 1 pn ( n ) = ( e1 * sphi * pn ( nm1 ) - nm1 * pn ( nm2 )) / n ppn ( n ) = sphi * ppn ( nm1 ) + n * pn ( nm1 ) pnm ( n , n ) = e1 * cphi * pnm ( nm1 , nm1 ) ppnm ( n , n ) = - n * sphi * pnm ( n , n ) end do do n = 3 , nmodel nm1 = n - 1 e1 = ( 2 * n - 1 ) * sphi e2 = - n * sphi do m = 1 , nm1 e3 = pnm ( nm1 , m ) e4 = n + m e5 = ( e1 * e3 - ( e4 - one ) * pnm ( n - 2 , m )) / ( n - m ) pnm ( n , m ) = e5 ppnm ( n , m ) = e2 * e5 + e4 * e3 end do end do end if asph ( 1 ) = - one ![NOTE: set to zero to only output the harmonic terms] asph ( 3 ) = zero do n = 2 , nmodel e1 = cnm ( n , 0 ) * rb ( n ) asph ( 1 ) = asph ( 1 ) - ( n + 1 ) * e1 * pn ( n ) asph ( 3 ) = asph ( 3 ) + e1 * ppn ( n ) end do asph ( 3 ) = cphi * asph ( 3 ) t1 = zero t3 = zero asph ( 2 ) = zero do n = 2 , nmodel e1 = zero e2 = zero e3 = zero !do m = 1, n                !original do m = 1 , min ( n , mmodel ) !JW - allow for specifying order !!!!!! tsnm = snm ( n , m ) tcnm = cnm ( n , m ) tsm = sm ( m ) tcm = cm ( m ) tpnm = pnm ( n , m ) e4 = tsnm * tsm + tcnm * tcm e1 = e1 + e4 * tpnm e2 = e2 + m * ( tsnm * tcm - tcnm * tsm ) * tpnm e3 = e3 + e4 * ppnm ( n , m ) end do t1 = t1 + ( n + 1 ) * rb ( n ) * e1 asph ( 2 ) = asph ( 2 ) + rb ( n ) * e2 t3 = t3 + rb ( n ) * e3 end do e4 = mu / r2 asph ( 1 ) = e4 * ( asph ( 1 ) - cphi * t1 ) asph ( 2 ) = e4 * asph ( 2 ) asph ( 3 ) = e4 * ( asph ( 3 ) + t3 ) e5 = asph ( 1 ) * cphi - asph ( 3 ) * sphi agr ( 1 ) = e5 * cm ( 1 ) - asph ( 2 ) * sm ( 1 ) agr ( 2 ) = e5 * sm ( 1 ) + asph ( 2 ) * cm ( 1 ) agr ( 3 ) = asph ( 1 ) * sphi + asph ( 3 ) * cphi end subroutine grav !***************************************************************************************** !***************************************************************************************** !> !  Compute geopotential acceleration using the Kuga/Carrara algorithm. !  Based on *Leg_ForCol_Ac* from [1]. ! !@note This one does not work at the poles ($\\phi = \\pm 90&#94;{\\circ}$) ! !# References !  1. Kuga, H.K. & Carrara, V. !    [Fortran- and C-codes for higher order and degree geopotential computation](www.dem.inpe.br/~hkk/software/high_geopot.html) subroutine kuga_carrara_geopotential ( nmax , nm , re , gm , c , s , x , ac ) implicit none integer , intent ( in ) :: nmax !! max. order and degree loaded integer , intent ( in ) :: nm !! desired order and degree (nm <= nmax) real ( wp ), intent ( in ) :: re !! body equatorial radius [km] real ( wp ), intent ( in ) :: gm !! gravitational constant [km3/s2] real ( wp ), dimension ( nmax , 0 : nm ), intent ( in ) :: c !! c coefficients (Normalized) real ( wp ), dimension ( nmax , 0 : nm ), intent ( in ) :: s !! s coefficients (Normalized) real ( wp ), dimension ( 3 ), intent ( in ) :: x !! body-fixed cartesian position vector [km] real ( wp ), dimension ( 3 ), intent ( out ) :: ac !! body-fixed cartesian acceleration vector [km/s2] integer :: n , m real ( wp ), dimension ( 0 : nm ) :: pn , qn real ( wp ) :: r , q , t , u2 , u , um , tf , al , sl , cl , gmr real ( wp ) :: pnm , dpnm , anm , bnm , fnm , cmm , smm real ( wp ) :: am , an , pnn , pnm1m , pnm2m , sm , cm , sml , cml real ( wp ) :: qc , qs , xc , xs , xcf , xsf , xcr , xsr , vl , vf , vr real ( wp ), parameter :: sqrt3 = sqrt ( 3.0_wp ) ! auxiliary variables r = norm2 ( x ) q = re / r t = x ( 3 ) / r ! sin (lat) u = sqrt ( 1.0_wp - t * t ) tf = t / u ! tan (lat) al = atan2 ( x ( 2 ), x ( 1 )) sl = sin ( al ) ! sin (long) cl = cos ( al ) ! cos (long) gmr = gm / r ! initialize vl = 0.0_wp vf = 0.0_wp vr = 0.0_wp ! store sectoral pn ( 0 ) = 1.0_wp pn ( 1 ) = sqrt3 * u ! sqrt(3) * cos (lat) qn ( 0 ) = 1.0_wp qn ( 1 ) = q do m = 2 , nm am = real ( m , wp ) pn ( m ) = u * sqrt ( 1.0_wp + 0.5_wp / am ) * pn ( m - 1 ) qn ( m ) = q * qn ( m - 1 ) end do ! initialize sin and cos recursions sm = 0.0_wp cm = 1.0_wp ! outer loop do m = 0 , nm ! init am = real ( m , wp ) ! for m = n (sectoral) pnm = pn ( m ) dpnm = - am * pnm * tf pnm1m = pnm pnm2m = 0.0_wp ! initialize Horner's scheme if ( m < 2 ) then cmm = 0.0_wp smm = 0.0_wp else cmm = c ( m , m ) smm = s ( m , m ) end if qc = qn ( m ) * cmm qs = qn ( m ) * smm xc = qc * pnm xs = qs * pnm xcf = qc * dpnm xsf = qs * dpnm xcr = ( am + 1.0_wp ) * qc * pnm xsr = ( am + 1.0_wp ) * qs * pnm ! inner loop do n = m + 1 , nm an = real ( n , wp ) anm = sqrt ((( an + an - 1.0_wp ) * ( an + an + 1.0_wp )) / (( an - am ) * ( an + am ))) bnm = sqrt ((( an + an + 1.0_wp ) * ( an + am - 1.0_wp ) * ( an - am - 1.0_wp )) / (( an - am ) * ( an + am ) * ( an + an - 3.0_wp ))) fnm = sqrt ((( an * an - am * am ) * ( an + an + 1.0_wp )) / ( an + an - 1.0_wp )) ! recursion p and dp pnm = anm * t * pnm1m - bnm * pnm2m dpnm = - an * pnm * tf + fnm * pnm1m / u ! signal opposite to paper ! store pnm2m = pnm1m pnm1m = pnm ! inner sum if ( n >= 2 ) then qc = qn ( n ) * c ( n , m ) qs = qn ( n ) * s ( n , m ) xc = xc + qc * pnm xs = xs + qs * pnm xcf = xcf + qc * dpnm xsf = xsf + qs * dpnm xcr = xcr + ( an + 1.0_wp ) * qc * pnm xsr = xsr + ( an + 1.0_wp ) * qs * pnm end if end do ! outer sum vl = vl + am * ( xc * sm - xs * cm ) vf = vf + ( xcf * cm + xsf * sm ) vr = vr + ( xcr * cm + xsr * sm ) ! sin and cos recursions for next m cml = cl * cm - sm * sl sml = cl * sm + cm * sl cm = cml ! save for next m sm = sml ! save for next m end do ! gradient vl = - gmr * vl vf = gmr * vf vr = - ( gmr / r ) * ( 1.0_wp + vr ) ! body x, y, z accelerations ac ( 1 ) = u * cl * vr - t * cl * vf / r - sl * vl / ( u * r ) ac ( 2 ) = u * sl * vr - t * sl * vf / r + cl * vl / ( u * r ) ac ( 3 ) = t * vr + u * vf / r end subroutine kuga_carrara_geopotential !***************************************************************************************** !***************************************************************************************** !> !  Normalized Pines geopotential code. ! !### Reference !  * `pinesnorm.m` Matlab code from \"Normalization and Implementation of !    Three Gravitational Acceleration Models\", NASA/TP-2016-218604. !    [link](https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/20160011252.pdf) ! !@note Change from the original reference: the central body term is !      added at the end, once the harmonic terms have been computed. pure function pinesnorm ( mu , req , r_f , cnm , snm , nmax , mmax ) result ( accel ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational constant [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: req !! body equatorial radius [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r_f !! body-fixed Cartesian position vector [km] real ( wp ), dimension (:, 0 :), intent ( in ) :: cnm !! c coefficients (Normalized) real ( wp ), dimension (:, 0 :), intent ( in ) :: snm !! s coefficients (Normalized) integer , intent ( in ) :: nmax !! desired degree integer , intent ( in ) :: mmax !! desired order real ( wp ), dimension ( 3 ) :: accel !! body-fixed Cartesian acceleration vector [km/s&#94;2] real ( wp ), dimension ( nmax + 3 , nmax + 3 ) :: anm real ( wp ), dimension ( mmax + 2 ) :: rm , im real ( wp ), dimension ( 3 ) :: harmonics_acc real ( wp ) :: alpha , alpha_den , alpha_num , beta , beta_den ,& beta_num , dnm , enm , fnm , g1 , g1temp , g2 ,& g2temp , g3 , g3temp , g4 , g4temp , rho , rhop , rmag ,& s , sm , t , u integer :: m , n , m_a , n_a , m_ri , nmodel rmag = norm2 ( r_f ) s = r_f ( 1 ) / rmag t = r_f ( 2 ) / rmag u = r_f ( 3 ) / rmag anm = 0.0_wp anm ( 1 , 1 ) = sqrt ( 2.0_wp ) do m = 0 , nmax + 2 m_a = m + 1 if ( m /= 0 ) then ! diagonal recursion anm ( m_a , m_a ) = sqrt ( 1 + ( 1.0_wp / ( 2 * m ))) * anm ( m_a - 1 , m_a - 1 ) end if if ( m /= nmax + 2 ) then ! first off-diagonal recursion anm ( m_a + 1 , m_a ) = sqrt ( real ( 2 * m + 3 , wp )) * u * anm ( m_a , m_a ) end if if ( m < nmax + 1 ) then ! column recursion do n = m + 2 , nmax + 2 n_a = n + 1 alpha_num = ( 2 * n + 1 ) * ( 2 * n - 1 ) alpha_den = ( n - m ) * ( n + m ) alpha = sqrt ( alpha_num / alpha_den ) beta_num = ( 2 * n + 1 ) * ( n - m - 1 ) * ( n + m - 1 ) beta_den = ( 2 * n - 3 ) * ( n + m ) * ( n - m ) beta = sqrt ( beta_num / beta_den ) anm ( n_a , m_a ) = alpha * u * anm ( n_a - 1 , m_a ) - beta * anm ( n_a - 2 , m_a ) end do end if end do do n = 0 , nmax + 2 n_a = n + 1 anm ( n_a , 1 ) = anm ( n_a , 1 ) * sqrt ( 0.5_wp ) end do rm = 0.0_wp im = 0.0_wp rm ( 1 ) = 0.0_wp im ( 1 ) = 0.0_wp rm ( 2 ) = 1.0_wp im ( 2 ) = 0.0_wp do m = 1 , mmax m_ri = m + 2 rm ( m_ri ) = s * rm ( m_ri - 1 ) - t * im ( m_ri - 1 ) im ( m_ri ) = s * im ( m_ri - 1 ) + t * rm ( m_ri - 1 ) end do rho = ( mu ) / ( req * rmag ) rhop = ( req ) / ( rmag ) g1 = 0.0_wp g2 = 0.0_wp g3 = 0.0_wp g4 = 0.0_wp do n = 0 , nmax n_a = n + 1 g1temp = 0.0_wp g2temp = 0.0_wp g3temp = 0.0_wp g4temp = 0.0_wp sm = 0.5_wp if ( n > mmax ) then nmodel = mmax else nmodel = n end if do m = 0 , nmodel if ( n >= 2 ) then m_a = m + 1 m_ri = m + 2 dnm = cnm ( n , m ) * rm ( m_ri ) + snm ( n , m ) * im ( m_ri ) enm = cnm ( n , m ) * rm ( m_ri - 1 ) + snm ( n , m ) * im ( m_ri - 1 ) fnm = snm ( n , m ) * rm ( m_ri - 1 ) - cnm ( n , m ) * im ( m_ri - 1 ) alpha = sqrt ( sm * ( n - m ) * ( n + m + 1 )) g1temp = g1temp + anm ( n_a , m_a ) * ( m ) * enm g2temp = g2temp + anm ( n_a , m_a ) * ( m ) * fnm g3temp = g3temp + alpha * anm ( n_a , m_a + 1 ) * dnm g4temp = g4temp + (( n + m + 1 ) * anm ( n_a , m_a ) + alpha * u * anm ( n_a , m_a + 1 )) * dnm if ( m == 0 ) sm = 1.0_wp end if end do rho = rhop * rho g1 = g1 + rho * g1temp g2 = g2 + rho * g2temp g3 = g3 + rho * g3temp g4 = g4 + rho * g4temp end do ! include central body term here: accel = ( - mu / rmag ** 3 * r_f ) + [ g1 - g4 * s , g2 - g4 * t , g3 - g4 * u ] end function pinesnorm !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 9/20/2014 ! !  Unit test routine for geopotential_module subroutine geopotential_module_test () use conversion_module use vector_module , only : spherical_to_cartesian use random_module , only : get_random_number implicit none character ( len =* ), parameter :: gravfile = './grav/GGM03C.GEO' !! the coefficient file class ( geopotential_model ), pointer :: g type ( geopotential_model_mueller ) , target :: g_mueller type ( geopotential_model_lear ) , target :: g_lear type ( geopotential_model_pines ) , target :: g_pines type ( geopotential_model_normalized_pines ) , target :: g_normalized_pines type ( geopotential_model_kuga_carrara ), target :: g_kuga_carrara real ( wp ), dimension ( 3 ) :: a1 , a2 , a3 , a4 , a5 , rvec logical :: status_ok integer :: lat , lon , i , j , nmax , mmax real ( wp ) :: h , err1 , err2 , err3 , err4 , rlon , rlat , tmp character ( len = 20 ) :: name real :: tstart , tstop real ( wp ), dimension ( 3 ), parameter :: r = [ 0.1275627320e+05_wp , & 0.1275627320e+05_wp , & 0.1275627320e+05_wp ] !! test case [km] integer , parameter :: n = 9 !! degree integer , parameter :: m = 9 !! order integer , parameter :: n_repeat = 1000000 !! number of time to repeat speed test write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' geopotential_module_test' write ( * , * ) '---------------' write ( * , * ) '' write ( * , * ) '' write ( * , * ) '*** number_of_coefficients routine ***' write ( * , * ) '' !tests: write ( * , * ) '' write ( * , * ) 6 , 6 , number_of_coefficients ( 6 , 6 ) ! 25 write ( * , * ) 3 , 2 , number_of_coefficients ( 3 , 2 ) ! 6 write ( * , * ) 4 , 0 , number_of_coefficients ( 4 , 0 ) ! 8 write ( * , * ) 4 , 1 , number_of_coefficients ( 4 , 1 ) ! 9 write ( * , * ) 0 , 0 , number_of_coefficients ( 0 , 0 ) ! -99 (error) write ( * , * ) '' write ( * , * ) '' write ( * , * ) '*** test case for the four methods ***' write ( * , * ) '' write ( * , * ) '' write ( * , * ) 'reading file: ' // gravfile write ( * , '(A,*(E30.16,1X))' ) 'r =' , r call g_mueller % initialize ( gravfile , n , m , status_ok ) if (. not . status_ok ) stop 'Error' call g_mueller % get_acc ( r , n , m , a1 ) call g_lear % initialize ( gravfile , n , m , status_ok ) if (. not . status_ok ) stop 'Error' call g_lear % get_acc ( r , n , m , a2 ) call g_pines % initialize ( gravfile , n , m , status_ok ) if (. not . status_ok ) stop 'Error' call g_pines % get_acc ( r , n , m , a3 ) call g_kuga_carrara % initialize ( gravfile , n , m , status_ok ) if (. not . status_ok ) stop 'Error' call g_kuga_carrara % get_acc ( r , n , m , a4 ) call g_normalized_pines % initialize ( gravfile , n , m , status_ok ) if (. not . status_ok ) stop 'Error' call g_normalized_pines % get_acc ( r , n , m , a5 ) write ( * , * ) '' write ( * , '(A,*(E30.16,1X))' ) 'mueller      =' , a1 write ( * , '(A,*(E30.16,1X))' ) 'lear         =' , a2 write ( * , '(A,*(E30.16,1X))' ) 'pines        =' , a3 write ( * , '(A,*(E30.16,1X))' ) 'kuga_carrara =' , a4 write ( * , '(A,*(E30.16,1X))' ) 'norm_pines   =' , a3 write ( * , * ) '' write ( * , '(A,*(E30.16,1X))' ) 'mueller-lear difference      =' , norm2 ( a1 - a2 ) write ( * , '(A,*(E30.16,1X))' ) 'mueller-pines difference     =' , norm2 ( a1 - a3 ) write ( * , '(A,*(E30.16,1X))' ) 'mueller-normpines difference =' , norm2 ( a1 - a5 ) write ( * , '(A,*(E30.16,1X))' ) 'lear-pines difference        =' , norm2 ( a2 - a3 ) write ( * , '(A,*(E30.16,1X))' ) 'lear-kuga_carrara difference =' , norm2 ( a2 - a4 ) write ( * , * ) '' write ( * , * ) '' write ( * , * ) '*** accuracy test ***' write ( * , * ) '' h = 677 8.0_wp !radius magnitude status_ok = . true . do lat = - 90 , 90 do lon = 0 , 360 rvec = spherical_to_cartesian ( h , lon * deg2rad , lat * deg2rad ) call g_mueller % get_acc ( rvec , n , m , a1 ) ! mueller call g_lear % get_acc ( rvec , n , m , a2 ) ! lear call g_pines % get_acc ( rvec , n , m , a3 ) ! pines call g_normalized_pines % get_acc ( rvec , n , m , a5 ) ! normalized pines call g_kuga_carrara % get_acc ( rvec , n , m , a4 ) ! kuga/carrara err1 = norm2 ( a2 - a1 ) err2 = norm2 ( a3 - a2 ) err3 = norm2 ( a4 - a1 ) err4 = norm2 ( a5 - a1 ) if ( err2 > 1.0e-15_wp . or . err1 > 1.0e-15_wp . or . err3 > 1.0e-15_wp . or . err4 > 1.0e-15_wp ) then write ( * , * ) lat , lon , norm2 ( a1 ), norm2 ( a2 ), norm2 ( a2 ), norm2 ( a3 ), err1 , err2 , err3 , err4 status_ok = . false . end if if ( abs ( lat ) == 90 ) exit !only do poles once end do end do call g_mueller % destroy () call g_lear % destroy () call g_pines % destroy () call g_normalized_pines % destroy () call g_kuga_carrara % destroy () if ( status_ok ) write ( * , * ) 'All tests passed.' write ( * , * ) '' write ( * , * ) '*** speed test ***' write ( * , * ) '' nmax = 10 mmax = 10 do i = 1 , 5 select case ( i ) case ( 1 ) g => g_mueller name = 'Mueller' case ( 2 ) g => g_lear name = 'Lear' case ( 3 ) g => g_pines name = 'Pines' case ( 4 ) g => g_kuga_carrara name = 'Kuga/Carrara' case ( 5 ) g => g_normalized_pines name = 'Normalized Pines' end select call g % initialize ( gravfile , nmax , mmax , status_ok ) if (. not . status_ok ) stop 'Error' call random_seed () tmp = zero call cpu_time ( tstart ) do j = 1 , n_repeat h = get_random_number ( 677 8.0_wp , 1000 0.0_wp ) rlon = get_random_number ( 0.0_wp , 36 0.0_wp ) rlat = get_random_number ( - 9 0.0_wp , 9 0.0_wp ) rvec = spherical_to_cartesian ( h , rlon * deg2rad , rlat * deg2rad ) call g % get_acc ( rvec , nmax , mmax , a1 ) tmp = tmp + norm2 ( a1 ) end do call cpu_time ( tstop ) call g % destroy () write ( * , '(A10,1X,E30.16,1X,F13.6,1X,A)' ) trim ( name ), tmp , tstop - tstart , 'sec' end do end subroutine geopotential_module_test !***************************************************************************************** !***************************************************************************************** end module geopotential_module !*****************************************************************************************","tags":"","url":"sourcefile/geopotential_module.f90.html"},{"title":"eispack_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~eispack_module.f90~~EfferentGraph sourcefile~eispack_module.f90 eispack_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~eispack_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~eispack_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~eispack_module.f90~~AfferentGraph sourcefile~eispack_module.f90 eispack_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~eispack_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Refactored SLATEC/EISPACK routines for computing eigenvalues and eigenvectors. module eispack_module use kind_module , only : wp implicit none private public :: compute_eigenvalues_and_eigenvectors public :: compute_real_eigenvalues_and_normalized_eigenvectors public :: eispack_test contains !***************************************************************************************** !***************************************************************************************** !> !  Balance a real general matrix and isolate eigenvalues !  whenever possible. ! !  This subroutine is a translation of the ALGOL procedure BALANCE, !  NUM. MATH. 13, 293-304(1969) by Parlett and Reinsch. !  HANDBOOK FOR AUTO. COMP., Vol.II-LINEAR ALGEBRA, 315-326(1971). ! !  This subroutine balances a REAL matrix and isolates !  eigenvalues whenever possible. ! !### On INPUT ! !        NM must be set to the row dimension of the two-dimensional !          array parameter, A, as declared in the calling program !          dimension statement.  NM is an INTEGER variable. ! !        N is the order of the matrix A.  N is an INTEGER variable. !          N must be less than or equal to NM. ! !        A contains the input matrix to be balanced.  A is a !          two-dimensional REAL array, dimensioned A(NM,N). ! !### On OUTPUT ! !        A contains the balanced matrix. ! !        LOW and IGH are two INTEGER variables such that A(I,J) !          is equal to zero if !           (1) I is greater than J and !           (2) J=1,...,LOW-1 or I=IGH+1,...,N. ! !        SCALE contains information determining the permutations and !          scaling factors used.  SCALE is a one-dimensional REAL array, !          dimensioned SCALE(N). ! !     Suppose that the principal submatrix in rows LOW through IGH !     has been balanced, that P(J) denotes the index interchanged !     with J during the permutation step, and that the elements !     of the diagonal matrix used are denoted by D(I,J).  Then !        SCALE(J) = P(J),    for J = 1,...,LOW-1 !                 = D(J,J),      J = LOW,...,IGH !                 = P(J)         J = IGH+1,...,N. !     The order in which the interchanges are made is N to IGH+1, !     then 1 TO LOW-1. ! !     Note that 1 is returned for IGH if IGH is zero formally. ! !  The ALGOL procedure EXC contained in BALANCE appears in !  BALANC in line.  (Note that the ALGOL roles of identifiers !  K,L have been reversed.) ! !  Questions and comments should be directed to B. S. Garbow, !  Applied Mathematics Division, ARGONNE NATIONAL LABORATORY ! !### References !  * B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow, !    Y. Ikebe, V. C. Klema and C. B. Moler, Matrix Eigen- !    system Routines - EISPACK Guide, Springer-Verlag, !    1976. ! !### Revision history !  * Author: Smith, B. T., et al. !  * 760101  DATE WRITTEN !  * 890831  Modified array declarations.  (WRB) !  * 890831  REVISION DATE from Version 3.2 !  * 891214  Prologue converted to Version 4.0 format.  (BAB) !  * 920501  Reformatted the REFERENCES section.  (WRB) subroutine balanc ( Nm , n , a , Low , Igh , Scale ) implicit none integer :: i , j , k , l , m , n , jj , Nm , Igh , Low , iexc , igo , igo1 , igo2 real ( wp ) :: a ( Nm , * ), Scale ( * ) real ( wp ) :: c , f , g , r , s , b2 logical :: noconv real ( wp ), parameter :: radix = 1 6.0_wp b2 = radix * radix k = 1 l = n igo = 1 igo1 = 0 igo2 = 1 ! IN-LINE PROCEDURE FOR ROW AND ! COLUMN EXCHANGE do while ( igo2 == 1 ) igo2 = 0 if ( igo1 == 1 ) then Scale ( m ) = j if ( j /= m ) then do i = 1 , l f = a ( i , j ) a ( i , j ) = a ( i , m ) a ( i , m ) = f enddo do i = k , n f = a ( j , i ) a ( j , i ) = a ( m , i ) a ( m , i ) = f enddo endif if ( iexc == 2 ) then ! SEARCH FOR COLUMNS ISOLATING AN EIGENVALUE ! AND PUSH THEM LEFT k = k + 1 igo = 0 else ! SEARCH FOR ROWS ISOLATING AN EIGENVALUE ! AND PUSH THEM DOWN if ( l == 1 ) then Low = k Igh = l return end if l = l - 1 endif end if ! FOR J=L STEP -1 UNTIL 1 DO -- igo1 = 1 if ( igo == 1 ) then do jj = 1 , l igo = 1 j = l + 1 - jj do i = 1 , l if ( i /= j ) then if ( a ( j , i ) /= 0.0_wp ) then igo = 0 exit end if endif enddo if ( igo == 0 ) cycle m = l iexc = 1 igo2 = 1 exit enddo if ( igo2 == 1 ) cycle end if do j = k , l igo = 1 do i = k , l if ( i /= j ) then if ( a ( i , j ) /= 0.0_wp ) then igo = 0 exit end if endif enddo if ( igo == 0 ) cycle m = k iexc = 2 igo2 = 1 exit enddo if ( igo2 == 1 ) cycle end do ! NOW BALANCE THE SUBMATRIX IN ROWS K TO L do i = k , l Scale ( i ) = 1.0_wp enddo ! ITERATIVE LOOP FOR NORM REDUCTION noconv = . true . do while ( noconv ) noconv = . false . do i = k , l c = 0.0_wp r = 0.0_wp do j = k , l if ( j /= i ) then c = c + abs ( a ( j , i )) r = r + abs ( a ( i , j )) endif enddo ! GUARD AGAINST ZERO C OR R DUE TO UNDERFLOW if ( c /= 0.0_wp . and . r /= 0.0_wp ) then g = r / radix f = 1.0_wp s = c + r do while ( c < g ) f = f * radix c = c * b2 end do g = r * radix do while ( c >= g ) f = f / radix c = c / b2 end do ! NOW BALANCE if (( c + r ) / f < 0.95_wp * s ) then g = 1.0_wp / f Scale ( i ) = Scale ( i ) * f noconv = . true . do j = k , n a ( i , j ) = a ( i , j ) * g enddo do j = 1 , l a ( j , i ) = a ( j , i ) * f enddo endif endif enddo end do Low = k Igh = l end subroutine balanc !***************************************************************************************** !***************************************************************************************** !> !  Form the eigenvectors of a real general matrix from the !  eigenvectors of matrix output from BALANC. ! !  This subroutine is a translation of the ALGOL procedure BALBAK, !  NUM. MATH. 13, 293-304(1969) by Parlett and Reinsch. !  HANDBOOK FOR AUTO. COMP., Vol.II-LINEAR ALGEBRA, 315-326(1971). ! !  This subroutine forms the eigenvectors of a REAL GENERAL !  matrix by back transforming those of the corresponding !  balanced matrix determined by  BALANC. ! !### On Input ! !        NM must be set to the row dimension of the two-dimensional !          array parameter, Z, as declared in the calling program !          dimension statement.  NM is an INTEGER variable. ! !        N is the number of components of the vectors in matrix Z. !          N is an INTEGER variable.  N must be less than or equal !          to NM. ! !        LOW and IGH are INTEGER variables determined by  BALANC. ! !        SCALE contains information determining the permutations and !          scaling factors used by  BALANC.  SCALE is a one-dimensional !          REAL array, dimensioned SCALE(N). ! !        M is the number of columns of Z to be back transformed. !          M is an INTEGER variable. ! !        Z contains the real and imaginary parts of the eigen- !          vectors to be back transformed in its first M columns. !          Z is a two-dimensional REAL array, dimensioned Z(NM,M). ! !### On Output ! !        Z contains the real and imaginary parts of the !          transformed eigenvectors in its first M columns. ! !     Questions and comments should be directed to B. S. Garbow, !     Applied Mathematics Division, ARGONNE NATIONAL LABORATORY ! !### References !  * B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow, !    Y. Ikebe, V. C. Klema and C. B. Moler, Matrix Eigen- !    system Routines - EISPACK Guide, Springer-Verlag, !    1976. ! !### Revision History !  * Author: Smith, B. T., et al. !  * 760101  DATE WRITTEN !  * 890831  Modified array declarations.  (WRB) !  * 890831  REVISION DATE from Version 3.2 !  * 891214  Prologue converted to Version 4.0 format.  (BAB) !  * 920501  Reformatted the REFERENCES section.  (WRB) subroutine balbak ( Nm , n , Low , Igh , Scale , m , z ) implicit none integer :: i , j , k , m , n , ii , Nm , Igh , Low real ( wp ) :: Scale ( * ), z ( Nm , * ) real ( wp ) :: s if ( m /= 0 ) then if ( Igh /= Low ) then do i = Low , Igh s = Scale ( i ) ! LEFT HAND EIGENVECTORS ARE BACK TRANSFORMED ! IF THE FOREGOING STATEMENT IS REPLACED BY ! S=1.0_wp/SCALE(I). do j = 1 , m z ( i , j ) = z ( i , j ) * s enddo enddo endif ! FOR I=LOW-1 STEP -1 UNTIL 1, ! IGH+1 STEP 1 UNTIL N DO -- do ii = 1 , n i = ii if ( i < Low . or . i > Igh ) then if ( i < Low ) i = Low - ii k = Scale ( i ) if ( k /= i ) then do j = 1 , m s = z ( i , j ) z ( i , j ) = z ( k , j ) z ( k , j ) = s enddo endif endif enddo endif end subroutine balbak !***************************************************************************************** !***************************************************************************************** !> !  Compute the complex quotient of two complex numbers. ! !  Complex division, (CR,CI) = (AR,AI)/(BR,BI) ! !### Revision History !  * 811101  DATE WRITTEN !  * 891214  Prologue converted to Version 4.0 format.  (BAB) !  * 900402  Added TYPE section.  (WRB) subroutine cdiv ( Ar , Ai , Br , Bi , Cr , Ci ) implicit none real ( wp ) :: Ar , Ai , Br , Bi , Cr , Ci real ( wp ) :: s , ars , ais , brs , bis s = abs ( Br ) + abs ( Bi ) ars = Ar / s ais = Ai / s brs = Br / s bis = Bi / s s = brs ** 2 + bis ** 2 Cr = ( ars * brs + ais * bis ) / s Ci = ( ais * brs - ars * bis ) / s end subroutine cdiv !***************************************************************************************** !***************************************************************************************** !> !  Reduce a real general matrix to upper Hessenberg form !  using stabilized elementary similarity transformations. ! !  This subroutine is a translation of the ALGOL procedure ELMHES, !  NUM. MATH. 12, 349-368(1968) by Martin and Wilkinson. !  HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 339-358(1971). ! !  Given a REAL GENERAL matrix, this subroutine !  reduces a submatrix situated in rows and columns !  LOW through IGH to upper Hessenberg form by !  stabilized elementary similarity transformations. ! !### On Input ! !        NM must be set to the row dimension of the two-dimensional !          array parameter, A, as declared in the calling program !          dimension statement.  NM is an INTEGER variable. ! !        N is the order of the matrix, A.  N is an INTEGER variable. !          N must be less than or equal to NM. ! !        LOW and IGH are two INTEGER variables determined by the !          balancing subroutine  BALANC.  If  BALANC  has not been !          used, set LOW=1 and IGH equal to the order of the matrix, N. ! !        A contains the input matrix.  A is a two-dimensional REAL !          array, dimensioned A(NM,N). ! !### On Output ! !        A contains the upper Hessenberg matrix.  The multipliers which !          were used in the reduction are stored in the remaining !          triangle under the Hessenberg matrix. ! !        INTV contains information on the rows and columns interchanged !          in the reduction.  Only elements LOW through IGH are used. !          INTV is a one-dimensional INTEGER array, dimensioned INTV(IGH). ! !     Questions and comments should be directed to B. S. Garbow, !     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY ! !### References !  * B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow, !    Y. Ikebe, V. C. Klema and C. B. Moler, Matrix Eigen- !    system Routines - EISPACK Guide, Springer-Verlag, !    1976. ! !### Revision History !  * Author: Smith, B. T., et al. !  * 760101  DATE WRITTEN !  * 890831  Modified array declarations.  (WRB) !  * 890831  REVISION DATE from Version 3.2 !  * 891214  Prologue converted to Version 4.0 format.  (BAB) !  * 920501  Reformatted the REFERENCES section.  (WRB) subroutine elmhes ( Nm , n , Low , Igh , a , Intv ) implicit none integer :: i , j , m , n , la , Nm , Igh , kp1 , Low , mm1 , mp1 real ( wp ) :: a ( Nm , * ) real ( wp ) :: x , y integer :: Intv ( * ) la = Igh - 1 kp1 = Low + 1 if ( la >= kp1 ) then do m = kp1 , la mm1 = m - 1 x = 0.0_wp i = m do j = m , Igh if ( abs ( a ( j , mm1 )) > abs ( x )) then x = a ( j , mm1 ) i = j endif enddo Intv ( m ) = i if ( i /= m ) then ! INTERCHANGE ROWS AND COLUMNS OF A do j = mm1 , n y = a ( i , j ) a ( i , j ) = a ( m , j ) a ( m , j ) = y enddo do j = 1 , Igh y = a ( j , i ) a ( j , i ) = a ( j , m ) a ( j , m ) = y enddo endif ! END INTERCHANGE if ( x /= 0.0_wp ) then mp1 = m + 1 do i = mp1 , Igh y = a ( i , mm1 ) if ( y /= 0.0_wp ) then y = y / x a ( i , mm1 ) = y do j = m , n a ( i , j ) = a ( i , j ) - y * a ( m , j ) enddo do j = 1 , Igh a ( j , m ) = a ( j , m ) + y * a ( j , i ) enddo endif enddo endif enddo endif end subroutine elmhes !***************************************************************************************** !***************************************************************************************** !> !  Accumulates the stabilized elementary similarity !  transformations used in the reduction of a real general !  matrix to upper Hessenberg form by ELMHES. ! !  This subroutine is a translation of the ALGOL procedure ELMTRANS, !  NUM. MATH. 16, 181-204(1970) by Peters and Wilkinson. !  HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 372-395(1971). ! !  This subroutine accumulates the stabilized elementary !  similarity transformations used in the reduction of a !  REAL GENERAL matrix to upper Hessenberg form by  ELMHES. ! !### On Input ! !        NM must be set to the row dimension of the two-dimensional !          array parameters, A and Z, as declared in the calling !          program dimension statement.  NM is an INTEGER variable. ! !        N is the order of the matrix A.  N is an INTEGER variable. !          N must be less than or equal to NM. ! !        LOW and IGH are two INTEGER variables determined by the !          balancing subroutine  BALANC.  If  BALANC  has not been !          used, set LOW=1 and IGH equal to the order of the matrix, N. ! !        A contains the multipliers which were used in the reduction !          by  ELMHES  in its lower triangle below the subdiagonal. !          A is a two-dimensional REAL array, dimensioned A(NM,IGH). ! !        INT contains information on the rows and columns interchanged !          in the reduction by  ELMHES.  Only elements LOW through IGH !          are used.  INT is a one-dimensional INTEGER array, !          dimensioned INT(IGH). ! !### On Output ! !        Z contains the transformation matrix produced in the reduction !          by  ELMHES.  Z is a two-dimensional REAL array, dimensioned !          Z(NM,N). ! !     Questions and comments should be directed to B. S. Garbow, !     APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY ! !### References !  * B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow, !    Y. Ikebe, V. C. Klema and C. B. Moler, Matrix Eigen- !    system Routines - EISPACK Guide, Springer-Verlag, !    1976. ! !### Revision History !  * Author: Smith, B. T., et al. !  * 760101  DATE WRITTEN !  * 890831  Modified array declarations.  (WRB) !  * 890831  REVISION DATE from Version 3.2 !  * 891214  Prologue converted to Version 4.0 format.  (BAB) !  * 920501  Reformatted the REFERENCES section.  (WRB) subroutine eltran ( Nm , n , Low , Igh , a , Int , z ) implicit none integer i , j , n , kl , mm , mp , Nm , Igh , Low , mp1 real ( wp ) a ( Nm , * ), z ( Nm , * ) integer Int ( * ) do i = 1 , n do j = 1 , n z ( i , j ) = 0.0_wp enddo z ( i , i ) = 1.0_wp enddo kl = Igh - Low - 1 if ( kl >= 1 ) then ! for mp=igh-1 step -1 until low+1 do -- do mm = 1 , kl mp = Igh - mm mp1 = mp + 1 do i = mp1 , Igh z ( i , mp ) = a ( i , mp - 1 ) enddo i = Int ( mp ) if ( i /= mp ) then do j = mp , Igh z ( mp , j ) = z ( i , j ) z ( i , j ) = 0.0_wp enddo z ( i , mp ) = 1.0_wp endif enddo endif end subroutine eltran !***************************************************************************************** !***************************************************************************************** !> !  Compute the eigenvalues of a real upper Hessenberg matrix !  using the QR method. ! !  This subroutine is a translation of the ALGOL procedure HQR, !  NUM. MATH. 14, 219-231(1970) by Martin, Peters, and Wilkinson. !  HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 359-371(1971). ! !  This subroutine finds the eigenvalues of a REAL !  UPPER Hessenberg matrix by the QR method. ! !### On Input ! !        NM must be set to the row dimension of the two-dimensional !          array parameter, H, as declared in the calling program !          dimension statement.  NM is an INTEGER variable. ! !        N is the order of the matrix H.  N is an INTEGER variable. !          N must be less than or equal to NM. ! !        LOW and IGH are two INTEGER variables determined by the !          balancing subroutine  BALANC.  If  BALANC  has not been !          used, set LOW=1 and IGH equal to the order of the matrix, N. ! !        H contains the upper Hessenberg matrix.  Information about !          the transformations used in the reduction to Hessenberg !          form by  ELMHES  or  ORTHES, if performed, is stored !          in the remaining triangle under the Hessenberg matrix. !          H is a two-dimensional REAL array, dimensioned H(NM,N). ! !### On Output ! !        H has been destroyed.  Therefore, it must be saved before !          calling  HQR  if subsequent calculation and back !          transformation of eigenvectors is to be performed. ! !        WR and WI contain the real and imaginary parts, respectively, !          of the eigenvalues.  The eigenvalues are unordered except !          that complex conjugate pairs of values appear consecutively !          with the eigenvalue having the positive imaginary part first. !          If an error exit is made, the eigenvalues should be correct !          for indices IERR+1, IERR+2, ..., N.  WR and WI are one- !          dimensional REAL arrays, dimensioned WR(N) and WI(N). ! !        IERR is an INTEGER flag set to !          Zero       for normal return, !          J          if the J-th eigenvalue has not been !                     determined after a total of 30*N iterations. !                     The eigenvalues should be correct for indices !                     IERR+1, IERR+2, ..., N. ! !  Questions and comments should be directed to B. S. Garbow, !  APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY ! !### References !  * B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow, !    Y. Ikebe, V. C. Klema and C. B. Moler, Matrix Eigen- !    system Routines - EISPACK Guide, Springer-Verlag, !    1976. ! !### Revision History !  * Author: Smith, B. T., et al. !  * 760101  DATE WRITTEN !  * 890531  Changed all specific intrinsics to generic.  (WRB) !  * 890831  Modified array declarations.  (WRB) !  * 890831  REVISION DATE from Version 3.2 !  * 891214  Prologue converted to Version 4.0 format.  (BAB) !  * 920501  Reformatted the REFERENCES section.  (WRB) subroutine hqr ( Nm , n , Low , Igh , h , Wr , Wi , Ierr ) implicit none integer :: i , j , k , l , m , n , en , ll , mm , na , Nm , Igh , & itn , its , Low , mp2 , enm2 , Ierr , gt real ( wp ) :: h ( Nm , * ), Wr ( * ), Wi ( * ) real ( wp ) :: p , q , r , s , t , w , x , y , zz , norm , s1 , s2 logical :: notlas gt = 0 Ierr = 0 norm = 0.0_wp k = 1 ! STORE ROOTS ISOLATED BY BALANC ! AND COMPUTE MATRIX NORM do i = 1 , n do j = k , n norm = norm + abs ( h ( i , j )) enddo k = i if ( i < Low . or . i > Igh ) then Wr ( i ) = h ( i , i ) Wi ( i ) = 0.0_wp endif enddo en = Igh t = 0.0_wp itn = 30 * n ! SEARCH FOR NEXT EIGENVALUES do while ( en >= Low ) gt = 0 its = 0 na = en - 1 enm2 = na - 1 ! LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT ! FOR L=EN STEP -1 UNTIL LOW DO -- do while (. true .) do ll = Low , en l = en + Low - ll if ( l == Low ) exit s = abs ( h ( l - 1 , l - 1 )) + abs ( h ( l , l )) if ( s == 0.0_wp ) s = norm s2 = s + abs ( h ( l , l - 1 )) if ( s2 == s ) exit enddo ! FORM SHIFT x = h ( en , en ) if ( l == en ) then ! ONE ROOT FOUND Wr ( en ) = x + t Wi ( en ) = 0.0_wp en = na gt = 1 exit else y = h ( na , na ) w = h ( en , na ) * h ( na , en ) if ( l == na ) exit if ( itn == 0 ) then ! SET ERROR -- NO CONVERGENCE TO AN ! EIGENVALUE AFTER 30*N ITERATIONS Ierr = en return else if ( its == 10 . or . its == 20 ) then ! FORM EXCEPTIONAL SHIFT t = t + x do i = Low , en h ( i , i ) = h ( i , i ) - x enddo s = abs ( h ( en , na )) + abs ( h ( na , enm2 )) x = 0.75_wp * s y = x w = - 0.4375_wp * s * s endif its = its + 1 itn = itn - 1 ! LOOK FOR TWO CONSECUTIVE SMALL ! SUB-DIAGONAL ELEMENTS. ! FOR M=EN-2 STEP -1 UNTIL L DO -- do mm = l , enm2 m = enm2 + l - mm zz = h ( m , m ) r = x - zz s = y - zz p = ( r * s - w ) / h ( m + 1 , m ) + h ( m , m + 1 ) q = h ( m + 1 , m + 1 ) - zz - r - s r = h ( m + 2 , m + 1 ) s = abs ( p ) + abs ( q ) + abs ( r ) p = p / s q = q / s r = r / s if ( m == l ) exit s1 = abs ( p ) * ( abs ( h ( m - 1 , m - 1 )) + abs ( zz ) + abs ( h ( m + 1 , m + 1 ))) s2 = s1 + abs ( h ( m , m - 1 )) * ( abs ( q ) + abs ( r )) if ( s2 == s1 ) exit enddo mp2 = m + 2 do i = mp2 , en h ( i , i - 2 ) = 0.0_wp if ( i /= mp2 ) h ( i , i - 3 ) = 0.0_wp enddo ! DOUBLE QR STEP INVOLVING ROWS L TO EN AND ! COLUMNS M TO EN do k = m , na notlas = k /= na if ( k /= m ) then p = h ( k , k - 1 ) q = h ( k + 1 , k - 1 ) r = 0.0_wp if ( notlas ) r = h ( k + 2 , k - 1 ) x = abs ( p ) + abs ( q ) + abs ( r ) if ( x == 0.0_wp ) cycle p = p / x q = q / x r = r / x endif s = sign ( sqrt ( p * p + q * q + r * r ), p ) if ( k == m ) then if ( l /= m ) h ( k , k - 1 ) = - h ( k , k - 1 ) else h ( k , k - 1 ) = - s * x endif p = p + s x = p / s y = q / s zz = r / s q = q / p r = r / p ! ROW MODIFICATION do j = k , en p = h ( k , j ) + q * h ( k + 1 , j ) if ( notlas ) then p = p + r * h ( k + 2 , j ) h ( k + 2 , j ) = h ( k + 2 , j ) - p * zz endif h ( k + 1 , j ) = h ( k + 1 , j ) - p * y h ( k , j ) = h ( k , j ) - p * x enddo j = min ( en , k + 3 ) ! COLUMN MODIFICATION do i = l , j p = x * h ( i , k ) + y * h ( i , k + 1 ) if ( notlas ) then p = p + zz * h ( i , k + 2 ) h ( i , k + 2 ) = h ( i , k + 2 ) - p * r endif h ( i , k + 1 ) = h ( i , k + 1 ) - p * q h ( i , k ) = h ( i , k ) - p enddo enddo endif endif enddo ! TWO ROOTS FOUND if ( gt == 0 ) then p = ( y - x ) / 2.0_wp q = p * p + w zz = sqrt ( abs ( q )) x = x + t if ( q < 0.0_wp ) then ! COMPLEX PAIR Wr ( na ) = x + p Wr ( en ) = x + p Wi ( na ) = zz Wi ( en ) = - zz else ! REAL PAIR zz = p + sign ( zz , p ) Wr ( na ) = x + zz Wr ( en ) = Wr ( na ) if ( zz /= 0.0_wp ) Wr ( en ) = x - w / zz Wi ( na ) = 0.0_wp Wi ( en ) = 0.0_wp endif en = enm2 end if enddo end subroutine hqr !***************************************************************************************** !***************************************************************************************** !> !  Compute the eigenvalues and eigenvectors of a real upper !  Hessenberg matrix using QR method. ! !  This subroutine is a translation of the ALGOL procedure HQR2, !  NUM. MATH. 16, 181-204(1970) by Peters and Wilkinson. !  HANDBOOK FOR AUTO. COMP., VOL.II-LINEAR ALGEBRA, 372-395(1971). ! !  This subroutine finds the eigenvalues and eigenvectors !  of a REAL UPPER Hessenberg matrix by the QR method.  The !  eigenvectors of a REAL GENERAL matrix can also be found !  if  ELMHES  and  ELTRAN  or  ORTHES  and  ORTRAN  have !  been used to reduce this general matrix to Hessenberg form !  and to accumulate the similarity transformations. ! !### On Input ! !        NM must be set to the row dimension of the two-dimensional !          array parameters, H and Z, as declared in the calling !          program dimension statement.  NM is an INTEGER variable. ! !        N is the order of the matrix H.  N is an INTEGER variable. !          N must be less than or equal to NM. ! !        LOW and IGH are two INTEGER variables determined by the !          balancing subroutine  BALANC.  If  BALANC  has not been !          used, set LOW=1 and IGH equal to the order of the matrix, N. ! !        H contains the upper Hessenberg matrix.  H is a two-dimensional !          REAL array, dimensioned H(NM,N). ! !        Z contains the transformation matrix produced by  ELTRAN !          after the reduction by  ELMHES, or by  ORTRAN  after the !          reduction by  ORTHES, if performed.  If the eigenvectors !          of the Hessenberg matrix are desired, Z must contain the !          identity matrix.  Z is a two-dimensional REAL array, !          dimensioned Z(NM,M). ! !### On Output ! !        H has been destroyed. ! !        WR and WI contain the real and imaginary parts, respectively, !          of the eigenvalues.  The eigenvalues are unordered except !          that complex conjugate pairs of values appear consecutively !          with the eigenvalue having the positive imaginary part first. !          If an error exit is made, the eigenvalues should be correct !          for indices IERR+1, IERR+2, ..., N.  WR and WI are one- !          dimensional REAL arrays, dimensioned WR(N) and WI(N). ! !        Z contains the real and imaginary parts of the eigenvectors. !          If the J-th eigenvalue is real, the J-th column of Z !          contains its eigenvector.  If the J-th eigenvalue is complex !          with positive imaginary part, the J-th and (J+1)-th !          columns of Z contain the real and imaginary parts of its !          eigenvector.  The eigenvectors are unnormalized.  If an !          error exit is made, none of the eigenvectors has been found. ! !        IERR is an INTEGER flag set to !          Zero       for normal return, !          J          if the J-th eigenvalue has not been !                     determined after a total of 30*N iterations. !                     The eigenvalues should be correct for indices !                     IERR+1, IERR+2, ..., N, but no eigenvectors are !                     computed. ! !     Calls CDIV for complex division. ! !  Questions and comments should be directed to B. S. Garbow, !  APPLIED MATHEMATICS DIVISION, ARGONNE NATIONAL LABORATORY ! !### References !  * B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow, !    Y. Ikebe, V. C. Klema and C. B. Moler, Matrix Eigen- !    system Routines - EISPACK Guide, Springer-Verlag, !    1976. ! !### Revision History !  * Smith, B. T., et al. !  * 760101  DATE WRITTEN !  * 890531  Changed all specific intrinsics to generic.  (WRB) !  * 890831  Modified array declarations.  (WRB) !  * 890831  REVISION DATE from Version 3.2 !  * 891214  Prologue converted to Version 4.0 format.  (BAB) !  * 920501  Reformatted the REFERENCES section.  (WRB) subroutine hqr2 ( Nm , n , Low , Igh , h , Wr , Wi , z , Ierr ) implicit none integer :: i , j , k , l , m , n , en , ii , jj , ll , mm , na , Nm , & nn , gt integer :: Igh , itn , its , Low , mp2 , enm2 , Ierr real ( wp ) :: h ( Nm , * ), Wr ( * ), Wi ( * ), z ( Nm , * ) real ( wp ) :: p , q , r , s , t , w , x , y , ra , sa , vi , vr , zz , & norm , s1 , s2 logical :: notlas gt = 0 Ierr = 0 norm = 0.0_wp k = 1 ! STORE ROOTS ISOLATED BY BALANC ! AND COMPUTE MATRIX NORM do i = 1 , n do j = k , n norm = norm + abs ( h ( i , j )) enddo k = i if ( i < Low . or . i > Igh ) then Wr ( i ) = h ( i , i ) Wi ( i ) = 0.0_wp endif enddo en = Igh t = 0.0_wp itn = 30 * n ! SEARCH FOR NEXT EIGENVALUES do while ( en >= Low ) gt = 0 its = 0 na = en - 1 enm2 = na - 1 ! LOOK FOR SINGLE SMALL SUB-DIAGONAL ELEMENT ! FOR L=EN STEP -1 UNTIL LOW DO -- do while (. true .) do ll = Low , en l = en + Low - ll if ( l == Low ) exit s = abs ( h ( l - 1 , l - 1 )) + abs ( h ( l , l )) if ( s == 0.0_wp ) s = norm s2 = s + abs ( h ( l , l - 1 )) if ( s2 == s ) exit enddo ! FORM SHIFT x = h ( en , en ) if ( l == en ) then ! ONE ROOT FOUND h ( en , en ) = x + t Wr ( en ) = h ( en , en ) Wi ( en ) = 0.0_wp en = na gt = 1 exit else y = h ( na , na ) w = h ( en , na ) * h ( na , en ) if ( l == na ) exit if ( itn == 0 ) then ! SET ERROR -- NO CONVERGENCE TO AN ! EIGENVALUE AFTER 30*N ITERATIONS Ierr = en return else if ( its == 10 . or . its == 20 ) then ! FORM EXCEPTIONAL SHIFT t = t + x do i = Low , en h ( i , i ) = h ( i , i ) - x enddo s = abs ( h ( en , na )) + abs ( h ( na , enm2 )) x = 0.75_wp * s y = x w = - 0.4375_wp * s * s endif its = its + 1 itn = itn - 1 ! LOOK FOR TWO CONSECUTIVE SMALL ! SUB-DIAGONAL ELEMENTS. ! FOR M=EN-2 STEP -1 UNTIL L DO -- do mm = l , enm2 m = enm2 + l - mm zz = h ( m , m ) r = x - zz s = y - zz p = ( r * s - w ) / h ( m + 1 , m ) + h ( m , m + 1 ) q = h ( m + 1 , m + 1 ) - zz - r - s r = h ( m + 2 , m + 1 ) s = abs ( p ) + abs ( q ) + abs ( r ) p = p / s q = q / s r = r / s if ( m == l ) exit s1 = abs ( p ) * ( abs ( h ( m - 1 , m - 1 )) + abs ( zz ) + abs ( h ( m + 1 , m + 1 ))) s2 = s1 + abs ( h ( m , m - 1 )) * ( abs ( q ) + abs ( r )) if ( s2 == s1 ) exit enddo mp2 = m + 2 do i = mp2 , en h ( i , i - 2 ) = 0.0_wp if ( i /= mp2 ) h ( i , i - 3 ) = 0.0_wp enddo ! DOUBLE QR STEP INVOLVING ROWS L TO EN AND ! COLUMNS M TO EN do k = m , na notlas = k /= na if ( k /= m ) then p = h ( k , k - 1 ) q = h ( k + 1 , k - 1 ) r = 0.0_wp if ( notlas ) r = h ( k + 2 , k - 1 ) x = abs ( p ) + abs ( q ) + abs ( r ) if ( x == 0.0_wp ) cycle p = p / x q = q / x r = r / x endif s = sign ( sqrt ( p * p + q * q + r * r ), p ) if ( k == m ) then if ( l /= m ) h ( k , k - 1 ) = - h ( k , k - 1 ) else h ( k , k - 1 ) = - s * x endif p = p + s x = p / s y = q / s zz = r / s q = q / p r = r / p ! ROW MODIFICATION do j = k , n p = h ( k , j ) + q * h ( k + 1 , j ) if ( notlas ) then p = p + r * h ( k + 2 , j ) h ( k + 2 , j ) = h ( k + 2 , j ) - p * zz endif h ( k + 1 , j ) = h ( k + 1 , j ) - p * y h ( k , j ) = h ( k , j ) - p * x enddo j = min ( en , k + 3 ) ! COLUMN MODIFICATION do i = 1 , j p = x * h ( i , k ) + y * h ( i , k + 1 ) if ( notlas ) then p = p + zz * h ( i , k + 2 ) h ( i , k + 2 ) = h ( i , k + 2 ) - p * r endif h ( i , k + 1 ) = h ( i , k + 1 ) - p * q h ( i , k ) = h ( i , k ) - p enddo ! ACCUMULATE TRANSFORMATIONS do i = Low , Igh ! p = x * z ( i , k ) + y * z ( i , k + 1 ) if ( notlas ) then p = p + zz * z ( i , k + 2 ) z ( i , k + 2 ) = z ( i , k + 2 ) - p * r endif z ( i , k + 1 ) = z ( i , k + 1 ) - p * q z ( i , k ) = z ( i , k ) - p ! enddo enddo endif endif enddo if ( gt == 1 ) cycle ! TWO ROOTS FOUND p = ( y - x ) / 2.0_wp q = p * p + w zz = sqrt ( abs ( q )) h ( en , en ) = x + t x = h ( en , en ) h ( na , na ) = y + t if ( q < 0.0_wp ) then ! COMPLEX PAIR Wr ( na ) = x + p Wr ( en ) = x + p Wi ( na ) = zz Wi ( en ) = - zz else ! REAL PAIR zz = p + sign ( zz , p ) Wr ( na ) = x + zz Wr ( en ) = Wr ( na ) if ( zz /= 0.0_wp ) Wr ( en ) = x - w / zz Wi ( na ) = 0.0_wp Wi ( en ) = 0.0_wp x = h ( en , na ) s = abs ( x ) + abs ( zz ) p = x / s q = zz / s r = sqrt ( p * p + q * q ) p = p / r q = q / r ! ROW MODIFICATION do j = na , n zz = h ( na , j ) h ( na , j ) = q * zz + p * h ( en , j ) h ( en , j ) = q * h ( en , j ) - p * zz enddo ! COLUMN MODIFICATION do i = 1 , en zz = h ( i , na ) h ( i , na ) = q * zz + p * h ( i , en ) h ( i , en ) = q * h ( i , en ) - p * zz enddo ! ACCUMULATE TRANSFORMATIONS do i = Low , Igh zz = z ( i , na ) z ( i , na ) = q * zz + p * z ( i , en ) z ( i , en ) = q * z ( i , en ) - p * zz enddo endif en = enm2 enddo ! ALL ROOTS FOUND.  BACKSUBSTITUTE TO FIND ! VECTORS OF UPPER TRIANGULAR FORM if ( norm /= 0.0_wp ) then ! FOR EN=N STEP -1 UNTIL 1 DO -- do nn = 1 , n en = n + 1 - nn p = Wr ( en ) q = Wi ( en ) na = en - 1 if ( q < 0 ) then ! END COMPLEX VECTOR ! COMPLEX VECTOR m = na ! LAST VECTOR COMPONENT CHOSEN IMAGINARY SO THAT ! EIGENVECTOR MATRIX IS TRIANGULAR if ( abs ( h ( en , na )) <= abs ( h ( na , en ))) then call cdiv ( 0.0_wp , - h ( na , en ), h ( na , na ) - p , q , h ( na , na ), h ( na , en )) else h ( na , na ) = q / h ( en , na ) h ( na , en ) = - ( h ( en , en ) - p ) / h ( en , na ) endif h ( en , na ) = 0.0_wp h ( en , en ) = 1.0_wp enm2 = na - 1 if ( enm2 /= 0 ) then ! FOR I=EN-2 STEP -1 UNTIL 1 DO -- do ii = 1 , enm2 i = na - ii w = h ( i , i ) - p ra = 0.0_wp sa = h ( i , en ) ! do j = m , na ra = ra + h ( i , j ) * h ( j , na ) sa = sa + h ( i , j ) * h ( j , en ) enddo ! if ( Wi ( i ) >= 0.0_wp ) then m = i if ( Wi ( i ) == 0.0_wp ) then call cdiv ( - ra , - sa , w , q , h ( i , na ), h ( i , en )) else ! SOLVE COMPLEX EQUATIONS x = h ( i , i + 1 ) y = h ( i + 1 , i ) vr = ( Wr ( i ) - p ) * ( Wr ( i ) - p ) + Wi ( i ) * Wi ( i ) - q * q vi = ( Wr ( i ) - p ) * 2.0_wp * q if ( vr == 0.0_wp . and . vi == 0.0_wp ) then s1 = norm * ( abs ( w ) + abs ( q ) + abs ( x ) + abs ( y ) + abs ( zz )) vr = s1 do while (. true .) vr = 0.5_wp * vr if ( s1 + vr <= s1 ) exit enddo vr = 2.0_wp * vr endif call cdiv ( x * r - zz * ra + q * sa , x * s - zz * sa - q * ra , vr , vi , h ( i , na ), & h ( i , en )) if ( abs ( x ) <= abs ( zz ) + abs ( q )) then call cdiv ( - r - y * h ( i , na ), - s - y * h ( i , en ), zz , q , h ( i + 1 , na ), & h ( i + 1 , en )) else h ( i + 1 , na ) = ( - ra - w * h ( i , na ) + q * h ( i , en )) / x h ( i + 1 , en ) = ( - sa - w * h ( i , en ) - q * h ( i , na )) / x endif endif else zz = w r = ra s = sa endif enddo endif elseif ( q == 0 ) then ! REAL VECTOR m = en h ( en , en ) = 1.0_wp if ( na /= 0 ) then ! FOR I=EN-1 STEP -1 UNTIL 1 DO -- do ii = 1 , na i = en - ii w = h ( i , i ) - p r = h ( i , en ) if ( m <= na ) then do j = m , na r = r + h ( i , j ) * h ( j , en ) enddo endif if ( Wi ( i ) >= 0.0_wp ) then ! END REAL VECTOR m = i if ( Wi ( i ) == 0.0_wp ) then t = w if ( t == 0.0_wp ) then t = norm do while (. true .) t = 0.5_wp * t if ( norm + t <= norm ) exit enddo t = 2.0_wp * t endif h ( i , en ) = - r / t else ! SOLVE REAL EQUATIONS x = h ( i , i + 1 ) y = h ( i + 1 , i ) q = ( Wr ( i ) - p ) * ( Wr ( i ) - p ) + Wi ( i ) * Wi ( i ) t = ( x * s - zz * r ) / q h ( i , en ) = t if ( abs ( x ) <= abs ( zz )) then h ( i + 1 , en ) = ( - s - y * t ) / zz else h ( i + 1 , en ) = ( - r - w * t ) / x endif endif else zz = w s = r endif enddo endif endif enddo ! END BACK SUBSTITUTION. ! VECTORS OF ISOLATED ROOTS do i = 1 , n if ( i < Low . or . i > Igh ) then do j = i , n z ( i , j ) = h ( i , j ) enddo endif enddo ! MULTIPLY BY TRANSFORMATION MATRIX TO GIVE ! VECTORS OF ORIGINAL FULL MATRIX. ! FOR J=N STEP -1 UNTIL LOW DO -- do jj = Low , n j = n + Low - jj m = min ( j , Igh ) do i = Low , Igh zz = 0.0_wp do k = Low , m zz = zz + z ( i , k ) * h ( k , j ) enddo z ( i , j ) = zz enddo enddo endif end subroutine hqr2 !***************************************************************************************** !***************************************************************************************** !> !  Compute the eigenvalues and, optionally, the eigenvectors !  of a real general matrix. ! !  This subroutine calls the recommended sequence of !  subroutines from the eigensystem subroutine package (EISPACK) !  To find the eigenvalues and eigenvectors (if desired) !  of a REAL GENERAL matrix. ! !### References !  * B. T. Smith, J. M. Boyle, J. J. Dongarra, B. S. Garbow, !    Y. Ikebe, V. C. Klema and C. B. Moler, Matrix Eigen- !    system Routines - EISPACK Guide, Springer-Verlag, !    1976. ! !### Author !  * Smith, B. T., et al. ! !### History  (YYMMDD) !  * 760101  DATE WRITTEN !  * 890831  Modified array declarations.  (WRB) !  * 890831  REVISION DATE from Version 3.2 !  * 891214  Prologue converted to Version 4.0 format.  (BAB) !  * 920501  Reformatted the REFERENCES section.  (WRB) !  * 921103  Corrected description of IV1.  (DWL, FNF and WRB) !  * Jacob Williams, refactored into modern Fortran (3/25/2018) subroutine rg ( Nm , n , a , Wr , Wi , Matz , z , Iv1 , Fv1 , Ierr ) implicit none integer , intent ( in ) :: n !! the order of the matrix A. !! N must be less than or equal to NM. integer , intent ( in ) :: Nm !! must be set to the row dimension of the two-dimensional !! array parameters, A and Z, as declared in the calling !! program dimension statement. integer , intent ( in ) :: Matz !! an INTEGER variable set equal to zero if only !! eigenvalues are desired.  Otherwise, it is set to any !! non-zero integer for both eigenvalues and eigenvectors. real ( wp ), intent ( inout ) :: a ( Nm , * ) !! contains the real general matrix. !! dimensioned A(NM,N). !! Note: A is destroyed on output. integer , intent ( out ) :: Ierr !! an INTEGER flag set to: !! !! * 0 -- for normal return, !! * 10*N -- if N is greater than NM, !! * J    -- if the J-th eigenvalue has not been !!           determined after a total of 30 iterations. !!           The eigenvalues should be correct for indices !!           IERR+1, IERR+2, ..., N, but no eigenvectors are !!           computed. real ( wp ), intent ( out ) :: Wr ( * ) !! real part of the eigenvalues.  The eigenvalues are unordered except !! that complex conjugate pairs of eigenvalues appear consecutively !! with the eigenvalue having the positive imaginary part !! first.  If an error exit is made, the eigenvalues should be !! correct for indices IERR+1, IERR+2, ..., N.  WR and WI are !! one-dimensional REAL arrays, dimensioned WR(N) and WI(N). real ( wp ), intent ( out ) :: Wi ( * ) !! imaginary part of the eigenvalues. real ( wp ), intent ( out ) :: z ( Nm , * ) !! contains the real and imaginary parts of the eigenvectors !! if MATZ is not zero.  If the J-th eigenvalue is real, the !! J-th column of Z contains its eigenvector.  If the J-th !! eigenvalue is complex with positive imaginary part, the !! J-th and (J+1)-th columns of Z contain the real and !! imaginary parts of its eigenvector.  The conjugate of this !! vector is the eigenvector for the conjugate eigenvalue. !! Z is a two-dimensional REAL array, dimensioned Z(NM,N). real ( wp ), intent ( inout ) :: Fv1 ( * ) !! one-dimensional temporary storage arrays of dimension N. integer , intent ( inout ) :: Iv1 ( * ) !! one-dimensional temporary storage arrays of dimension N. integer :: is1 integer :: is2 if ( n <= Nm ) then call balanc ( Nm , n , a , is1 , is2 , Fv1 ) call elmhes ( Nm , n , is1 , is2 , a , Iv1 ) if ( Matz /= 0 ) then ! find both eigenvalues and eigenvectors call eltran ( Nm , n , is1 , is2 , a , Iv1 , z ) call hqr2 ( Nm , n , is1 , is2 , a , Wr , Wi , z , Ierr ) if ( Ierr == 0 ) call balbak ( Nm , n , is1 , is2 , Fv1 , n , z ) else ! find eigenvalues only call hqr ( Nm , n , is1 , is2 , a , Wr , Wi , Ierr ) endif else Ierr = 10 * n endif end subroutine rg !***************************************************************************************** !***************************************************************************************** !> !  Compute the eigenvalues and, optionally, the eigenvectors !  of a real general matrix. ! !### See also !  * See [[rg]] for more details. This routine is just a wrapper to that one. ! !### Author !  * Jacob Williams, 3/25/2018 subroutine compute_eigenvalues_and_eigenvectors ( n , a , w , z , ierr ) use numbers_module implicit none integer , intent ( in ) :: n !! the order of the matrix `a` real ( wp ), dimension ( n , n ), intent ( in ) :: a !! contains the real general matrix real ( wp ), dimension ( n , 2 ), intent ( out ) :: w !! real and imaginary parts of the eigenvalues real ( wp ), dimension ( n , n ), intent ( out ) :: z !! real and imaginary parts of the eigenvectors integer , intent ( out ) :: ierr !! output flag from [[rg]] integer , parameter :: matz = 1 !! tells [[rg]] to compute eigenvalues and eigenvectors integer :: i !! counter real ( wp ), dimension ( n , n ) :: a_tmp !! copy of [[a]] matrix real ( wp ), dimension ( n ) :: fv1 !! work array for [[rg]] integer , dimension ( n ) :: iv1 !! work array for [[rg]] real ( wp ), dimension ( n ) :: wr !! real part of the eigenvalues real ( wp ), dimension ( n ) :: wi !! imaginary part of the eigenvalues ! temp arrays: a_tmp = a wr = zero wi = zero ! call the general routine: call rg ( n , n , a_tmp , wr , wi , matz , z , iv1 , fv1 , ierr ) ! pack outputs: do i = 1 , n w ( i , 1 ) = wr ( i ) w ( i , 2 ) = wi ( i ) end do end subroutine compute_eigenvalues_and_eigenvectors !***************************************************************************************** !***************************************************************************************** !> !  Returns only the real eigenvalues and the associated eigenvectors. !  Wrapper for [[compute_eigenvalues_and_eigenvectors]]. subroutine compute_real_eigenvalues_and_normalized_eigenvectors ( n , a , e , v , n_results , ierr ) use numbers_module implicit none integer , intent ( in ) :: n !! the order of the matrix `a` real ( wp ), dimension ( n , n ), intent ( in ) :: a !! contains the real general matrix real ( wp ), dimension (:), allocatable , intent ( out ) :: e !! eigenvalues (size `n_results`) real ( wp ), dimension (:,:), allocatable , intent ( out ) :: v !! eigenvectors (size `n,n_results`) integer , intent ( out ) :: n_results !! number of real eigenvalues integer , intent ( out ) :: ierr !! output flag from [[rg]] real ( wp ), dimension ( n , 2 ) :: w !! real and imaginary parts of the eigenvalues real ( wp ), dimension ( n , n ) :: z !! real and imaginary parts of the eigenvectors integer :: i !! counter integer :: j !! counter call compute_eigenvalues_and_eigenvectors ( n , a , w , z , ierr ) if ( ierr == 0 ) then n_results = count ( w (:, 2 ) == 0.0_wp ) if ( n_results > 0 ) then allocate ( e ( n_results )) allocate ( v ( n , n_results )) j = 0 do i = 1 , n if ( w ( i , 2 ) == 0.0_wp ) then ! real eigenvalue j = j + 1 e ( j ) = w ( i , 1 ) v (:, j ) = z (:, i ) / norm2 ( z (:, i )) ! normalized eigenvector end if end do end if else n_results = 0 end if end subroutine compute_real_eigenvalues_and_normalized_eigenvectors !***************************************************************************************** !***************************************************************************************** !> !  Unit test subroutine eispack_test () implicit none real ( wp ), dimension ( 3 , 3 ), parameter :: a = reshape ([ 1.0_wp , 4.0_wp , - 3.0_wp ,& 2.0_wp , 3.0_wp , - 8.0_wp ,& 3.0_wp , 2.0_wp , 1.001_wp ], [ 3 , 3 ]) real ( wp ), dimension ( 3 , 2 ) :: w !! real and imaginary parts of the eigenvalues real ( wp ), dimension ( 3 , 3 ) :: z !! real and imaginary parts of the eigenvectors integer :: ierr !! output flag integer :: i !! counter integer :: j !! counter complex ( wp ), dimension ( 3 ) :: v call compute_eigenvalues_and_eigenvectors ( 3 , a , w , z , ierr ) write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' eispack_test' write ( * , * ) '---------------' write ( * , * ) '' write ( * , * ) '' write ( * , * ) 'ierr = ' , ierr write ( * , * ) '' write ( * , * ) 'eigenvalues:' do i = 1 , 3 write ( * , * ) w ( i ,:) end do write ( * , * ) '' write ( * , * ) 'eigenvectors (normalized):' do i = 1 , 3 if ( w ( i , 2 ) == 0.0_wp ) then ! If the J-th eigenvalue is real, the ! J-th column of Z contains its eigenvector do j = 1 , 3 v ( j ) = cmplx ( z ( j , i ), 0.0_wp , wp ) end do elseif ( w ( i , 2 ) > 0.0_wp ) then ! If the J-th eigenvalue is complex with positive imaginary part, the ! J-th and (J+1)-th columns of Z contain the real and ! imaginary parts of its eigenvector. do j = 1 , 3 v ( j ) = cmplx ( z ( j , i ), z ( j , i + 1 ), wp ) end do else do j = 1 , 3 v ( j ) = cmplx ( z ( j , i - 1 ), - z ( j , i ), wp ) end do end if v = v / sqrt ( dot_product ( v , v )) do j = 1 , 3 write ( * , '(F16.6,F16.6)' ) v ( j )% re , v ( j )% im end do write ( * , * ) '' end do ! ... results: ! eigenvalues: ! -1.89041207397761       0.000000000000000E+000 ! 3.44570603698881        5.01584673789593 ! 3.44570603698881       -5.01584673789593 ! ! eigenvectors: ! 0.650411095383963      -0.379058329718174      -0.373946474570154 ! 0.605673686824173       0.640277015571315      -7.629236177444867E-002 ! 8.565310483790509E-002 -0.395692850335186        1.34627813418190 ! ... from numpy: ! eigenvalues: ! array([-1.89041207+0.j        ,  3.44570604+5.01584674j, 3.44570604-5.01584674j]) ! ! eigenvectors: ! array([[ 0.77377504  ,  0.03085326-0.3669729j  ,  0.03085326+0.3669729j ], !        [-0.4509546   , -0.25965047-0.37137631j , -0.25965047+0.37137631j], !        [-0.44487317  ,  0.81181293             ,  0.81181293            ] ]) end subroutine eispack_test !***************************************************************************************** !***************************************************************************************** end module eispack_module !*****************************************************************************************","tags":"","url":"sourcefile/eispack_module.f90.html"},{"title":"c_interface_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~c_interface_module.f90~~EfferentGraph sourcefile~c_interface_module.f90 c_interface_module.f90 sourcefile~geopotential_module.f90 geopotential_module.f90 sourcefile~c_interface_module.f90->sourcefile~geopotential_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~c_interface_module.f90->sourcefile~kind_module.f90 sourcefile~geopotential_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~geopotential_module.f90->sourcefile~conversion_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~geopotential_module.f90->sourcefile~numbers_module.f90 sourcefile~random_module.f90 random_module.f90 sourcefile~geopotential_module.f90->sourcefile~random_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~geopotential_module.f90->sourcefile~vector_module.f90 sourcefile~conversion_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~random_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~c_interface_module.f90~~AfferentGraph sourcefile~c_interface_module.f90 c_interface_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~c_interface_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  C interfaces to some of the routines. !  This is an experiment to be able to call them from Python. !  (see the `python_test.py` file in `tests`) module c_interface_module use iso_c_binding use geopotential_module use kind_module , only : wp implicit none private type :: container !! a container for data that is !! to be passed to C. We include !! it here so that we can use `c_loc()` private class ( * ), pointer :: data end type container interface function strlen ( str ) result ( isize ) bind ( C , name = 'strlen' ) !! C string length import type ( c_ptr ), value :: str integer ( c_int ) :: isize end function strlen end interface contains !***************************************************************************************** !***************************************************************************************** !> ! !@note This is just a wapper for `initialize` in [[geopotential_model]]. function initialize_geopotential_model ( itype , gravfile , n , m ) & result ( cp ) bind ( c , name = 'initialize_geopotential_model' ) implicit none integer ( c_int ), intent ( in ), value :: itype !! mode : !! !! * 1 (Mueller) is only mode !! currently supported type ( c_ptr ), intent ( in ), value :: gravfile !! gravity coefficient file name integer ( c_int ), intent ( in ), value :: n !! degree integer ( c_int ), intent ( in ), value :: m !! order type ( c_ptr ) :: cp !! pointer to a [[container]] !! containing a [[geopotential_model]] type ( container ), pointer :: grav_container !! Fortran version of `cp` class ( geopotential_model ), pointer :: grav !! the data in the container logical :: status_ok !! initialization status flag character ( len = :), allocatable :: gravfile_f !! Fortran version of `gravfile` allocate ( grav_container ) select case ( itype ) case ( 1 ) !! mueller method allocate ( geopotential_model_mueller :: grav_container % data ) select type ( g => grav_container % data ) class is ( geopotential_model_mueller ) ! get the gravity file name: call c_ptr_to_f_string ( gravfile , gravfile_f ) call g % initialize ( gravfile_f , n , m , status_ok ) if (. not . status_ok ) then write ( * , * ) 'error in initialize!' call g % destroy () cp = c_null_ptr else cp = c_loc ( grav_container ) end if end select case default error stop 'error: invalid itype input' end select ! if there was an error: if ( c_associated ( cp , c_null_ptr )) then deallocate ( grav_container ) end if end function initialize_geopotential_model !***************************************************************************************** !***************************************************************************************** !> ! !@note This is just a wapper for `destroy` in [[geopotential_model]]. subroutine destroy_geopotential_model ( cp ) bind ( c , name = 'destroy_geopotential_model' ) implicit none type ( c_ptr ), intent ( in ), value :: cp !! pointer to a [[container]] !! containing a [[geopotential_model]] type ( container ), pointer :: grav_container !! Fortran version of `cp` ! convert cp to fortran: call c_f_pointer ( cp , grav_container ) if ( associated ( grav_container )) then select type ( g => grav_container % data ) class is ( geopotential_model ) call g % destroy () !cp = c_null_ptr  ! should we do this too (make inout ?) end select deallocate ( grav_container ) else error stop 'error: pointer is not associated' end if end subroutine destroy_geopotential_model !***************************************************************************************** !***************************************************************************************** !> ! !@note This is just a wapper for `get_acc` in [[geopotential_model]]. subroutine get_acceleration ( cp , n , m , rvec , acc ) bind ( c , name = 'get_acceleration' ) implicit none type ( c_ptr ), intent ( in ), value :: cp !! pointer to a [[container]] !! containing a [[geopotential_model]] integer ( c_int ), intent ( in ), value :: n !! degree integer ( c_int ), intent ( in ), value :: m !! order real ( c_double ), dimension ( 3 ), intent ( in ) :: rvec !! position vector real ( c_double ), dimension ( 3 ), intent ( out ) :: acc !! acceleration vector type ( container ), pointer :: grav_container !! Fortran version of `cp` ! just in case wp /= c_double, we have to make a copy here real ( wp ), dimension ( 3 ) :: rvec_f !! position vector real ( wp ), dimension ( 3 ) :: acc_f !! acceleration vector ! convert cp to fortran: call c_f_pointer ( cp , grav_container ) if ( associated ( grav_container )) then select type ( g => grav_container % data ) class is ( geopotential_model ) rvec_f = rvec call g % get_acc ( rvec_f , n , m , acc_f ) acc = acc_f end select else error stop 'error: pointer is not associated' end if end subroutine get_acceleration !***************************************************************************************** !***************************************************************************************** !> !  Convert a `c_ptr` to a string into a Fortran string. subroutine c_ptr_to_f_string ( cp , fstr ) implicit none type ( c_ptr ), intent ( in ) :: cp character ( len = :), allocatable , intent ( out ) :: fstr integer :: ilen !! string length ilen = strlen ( cp ) block !convert the C string to a Fortran string character ( kind = c_char , len = ilen + 1 ), pointer :: s call c_f_pointer ( cp , s ) fstr = s ( 1 : ilen ) nullify ( s ) end block end subroutine c_ptr_to_f_string !***************************************************************************************** !***************************************************************************************** !> !  Convert a Fortran string to a `c_ptr` to a string. !  (the C string must already have been allocated to a fixed size) subroutine f_string_to_c_ptr ( fstr , buffer ) implicit none character ( len =* ), intent ( in ) :: fstr type ( c_ptr ), intent ( inout ) :: buffer !! a preallocated string buffer integer :: ilen !! string length of buffer ilen = strlen ( buffer ) block character ( kind = c_char , len = ilen + 1 ), pointer :: s call c_f_pointer ( buffer , s ) s ( 1 : min ( len ( fstr ), ilen )) = fstr ( 1 : min ( len ( fstr ), ilen )) buffer = c_loc ( s ) end block end subroutine f_string_to_c_ptr !***************************************************************************************** !***************************************************************************************** !> !  Just a test of [[f_string_to_c_ptr]]. subroutine return_a_string ( ival , buffer ) bind ( c , name = 'return_a_string' ) implicit none integer ( c_int ), intent ( in ), value :: ival type ( c_ptr ), intent ( inout ) :: buffer !! a preallocated string buffer call f_string_to_c_ptr ( repeat ( '*' , ival ), buffer ) end subroutine return_a_string !***************************************************************************************** !***************************************************************************************** end module c_interface_module !*****************************************************************************************","tags":"","url":"sourcefile/c_interface_module.f90.html"},{"title":"rk_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~rk_module.f90~~EfferentGraph sourcefile~rk_module.f90 rk_module.f90 sourcefile~brent_module.f90 brent_module.f90 sourcefile~rk_module.f90->sourcefile~brent_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~rk_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~rk_module.f90->sourcefile~numbers_module.f90 sourcefile~brent_module.f90->sourcefile~kind_module.f90 sourcefile~brent_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~rk_module.f90~~AfferentGraph sourcefile~rk_module.f90 rk_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~rk_module.f90 sourcefile~halo_orbit_module.f90 halo_orbit_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~halo_orbit_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~rk_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Runge-Kutta integration. module rk_module use kind_module , only : wp use numbers_module , only : zero implicit none private type , abstract , public :: rk_class !! main integration class: integer :: n = 0 !! user specified number of variables procedure ( deriv_func ), pointer :: f => null () !! user-specified derivative function procedure ( report_func ), pointer :: report => null () !! user-specified report function procedure ( event_func ), pointer :: g => null () !! event function (stop when this is zero) contains procedure :: initialize !! initialize the class (set n,f, and report) procedure , non_overridable , public :: integrate !! main integration routine procedure , non_overridable , public :: integrate_to_event !! integration with event finding procedure ( step_func ), deferred :: step !! the step routine for the rk method procedure , public :: destroy !! destructor end type rk_class !extend the abstract class to create an RK4 method: ! [all we need to do is set the step function] type , extends ( rk_class ), public :: rk4_class !! 4th order Runge-Kutta method. contains procedure :: step => rk4 end type rk4_class type , extends ( rk_class ), public :: rk8_10_class !! 8th order Runge-Kutta method. contains procedure :: step => rk8_10 end type rk8_10_class interface subroutine deriv_func ( me , t , x , xdot ) !! derivative function import :: rk_class , wp implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! state vector real ( wp ), dimension ( me % n ), intent ( out ) :: xdot !! derivative of state vector end subroutine deriv_func subroutine event_func ( me , t , x , g ) !! event function import :: rk_class , wp implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! state vector real ( wp ), intent ( out ) :: g !! g(t,x). The goal is to stop the integration when g=0. end subroutine event_func subroutine report_func ( me , t , x ) !! report function import :: rk_class , wp implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! state vector end subroutine report_func subroutine step_func ( me , t , x , h , xf ) !! rk step function import :: rk_class , wp implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state vector real ( wp ), intent ( in ) :: h !! time step  |\\Delta t|  real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! final state vector end subroutine step_func end interface public :: rk_test !for testing contains !***************************************************************************************** !***************************************************************************************** !> !  Initialize the [[rk_class]]. subroutine initialize ( me , n , f , report , g ) implicit none class ( rk_class ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of variables procedure ( deriv_func ) :: f !! derivative function procedure ( report_func ), optional :: report !! for reporting the steps procedure ( event_func ), optional :: g !! for stopping at an event call me % destroy () me % n = n me % f => f if ( present ( report )) me % report => report if ( present ( g )) me % g => g end subroutine initialize !***************************************************************************************** !***************************************************************************************** !> !  Destructor for [[rk_class]]. subroutine destroy ( me ) implicit none class ( rk_class ), intent ( out ) :: me end subroutine destroy !***************************************************************************************** !***************************************************************************************** !> !  Main integration routine for the [[rk_class]]. subroutine integrate ( me , t0 , x0 , h , tf , xf ) implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t0 !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x0 !! initial state real ( wp ), intent ( in ) :: h !! abs(time step) real ( wp ), intent ( in ) :: tf !! final time real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! final state real ( wp ) :: t , dt , t2 real ( wp ), dimension ( me % n ) :: x logical :: last , export if (. not . associated ( me % f )) error stop 'Error in integrate: f is not associated.' export = associated ( me % report ) if ( export ) call me % report ( t0 , x0 ) !first point if ( h == zero ) then xf = x0 else t = t0 x = x0 dt = sign ( h , tf - t0 ) !time step (correct sign) do t2 = t + dt last = (( dt >= zero . and . t2 >= tf ) . or . & !adjust last time step ( dt < zero . and . t2 <= tf )) ! if ( last ) dt = tf - t ! call me % step ( t , x , dt , xf ) if ( last ) exit if ( export ) call me % report ( t2 , xf ) !intermediate point x = xf t = t2 end do end if if ( export ) call me % report ( tf , xf ) !last point end subroutine integrate !***************************************************************************************** !***************************************************************************************** !> !  Event-finding integration routine for the [[rk_class]]. !  Integrates until g(t,x)=0, or until t=tf (whichever happens first). ! !@note There are some efficiency improvements that could be made here. !      This is a work in progress. subroutine integrate_to_event ( me , t0 , x0 , h , tmax , tol , tf , xf , gf ) use brent_module implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t0 !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x0 !! initial state real ( wp ), intent ( in ) :: h !! abs(time step) real ( wp ), intent ( in ) :: tmax !! max final time if event not located real ( wp ), intent ( in ) :: tol !! function tolerance for root finding real ( wp ), intent ( out ) :: tf !! actual final time reached real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! final state (at tf) real ( wp ), intent ( out ) :: gf !! g value at tf !local variables: real ( wp ) :: t , dt , t2 , ga , gb , dt_root , dum real ( wp ), dimension ( me % n ) :: x , g_xf logical :: first , last , export procedure ( report_func ), pointer :: report type ( brent_class ) :: solver integer :: iflag if (. not . associated ( me % f )) error stop 'Error in integrate_to_event: f is not associated.' if (. not . associated ( me % g )) error stop 'Error in integrate_to_event: g is not associated.' if ( h == zero ) error stop 'Error in integrate_to_event: h must not be zero.' !If the points are being exported: export = associated ( me % report ) !first point: if ( export ) call me % report ( t0 , x0 ) if ( t0 == tmax ) then xf = x0 tf = t0 call me % g ( t0 , x0 , gf ) else first = . true . t = t0 x = x0 call me % g ( t0 , x0 , ga ) !evaluate event function dt = sign ( h , tmax - t0 ) !time step (correct sign) do t2 = t + dt last = (( dt >= zero . and . t2 >= tmax ) . or . & !adjust last time step ( dt < zero . and . t2 <= tmax )) ! if ( last ) then dt = tmax - t t2 = tmax end if call me % step ( t , x , dt , xf ) call me % g ( t2 , xf , gb ) !evaluate event function if ( first . and . abs ( ga ) <= tol ) then !we ignore a root at t0 after the first step if ( abs ( gb ) <= tol ) then !check this one since it could have landed on a root gf = gb tf = t2 exit else if ( last ) then !exiting without having found a root tf = t2 gf = gb exit end if if ( export ) call me % report ( t2 , xf ) !intermediate point x = xf t = t2 ga = gb end if elseif ( ga * gb <= zero ) then !there is a root somewhere on [t,t+dt] !find the root: call solver % set_function ( solver_func ) call solver % find_zero ( zero , dt , tol , dt_root , dum , iflag , ga , gb ) t2 = t + dt_root gf = solver_func ( solver , dt_root ) tf = t2 xf = g_xf !computed in the solver function exit else !no root yet, continue if ( last ) then !exiting without having found a root tf = t2 gf = gb exit end if if ( export ) call me % report ( t2 , xf ) !intermediate point x = xf t = t2 ga = gb end if if ( first ) first = . false . end do end if if ( export ) call me % report ( t2 , xf ) !last point contains function solver_func ( this , delt ) result ( g ) !! root solver function. The input is the dt offset from time t. implicit none class ( brent_class ), intent ( inout ) :: this real ( wp ), intent ( in ) :: delt !! from [0 to dt] real ( wp ) :: g !take a step from t to t+delt and evaluate g function: call me % step ( t , x , delt , g_xf ) call me % g ( t + delt , g_xf , g ) end function solver_func end subroutine integrate_to_event !***************************************************************************************** !***************************************************************************************** !> !  Take one Runge Kutta 4 integration step: `t -> t+h (x -> xf)` subroutine rk4 ( me , t , x , h , xf ) implicit none class ( rk4_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state real ( wp ), intent ( in ) :: h !! time step real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! state at time `t+h` !local variables: real ( wp ), dimension ( me % n ) :: f1 , f2 , f3 , f4 real ( wp ) :: h2 !parameters: real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: six = 6.0_wp h2 = half * h call me % f ( t , x , f1 ) call me % f ( t + h2 , x + h2 * f1 , f2 ) call me % f ( t + h2 , x + h2 * f2 , f3 ) call me % f ( t + h , x + h * f3 , f4 ) xf = x + h * ( f1 + f2 + f2 + f3 + f3 + f4 ) / six end subroutine rk4 !***************************************************************************************** !***************************************************************************************** !> !  Take one Runge Kutta 8 integration step: `t -> t+h (x -> xf)` !  This is Formula (8-10) from Reference [1]. ! !# Reference !  1. E. B. Shanks, \"[Higher Order Approximations of Runge-Kutta Type](http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19650022581.pdf)\", !     NASA Technical Note, NASA TN D-2920, Sept. 1965. subroutine rk8_10 ( me , t , x , h , xf ) implicit none class ( rk8_10_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state real ( wp ), intent ( in ) :: h !! time step real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! state at time `t+h` !local variables: real ( wp ), dimension ( me % n ) :: f0 , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 !parameters: real ( wp ), parameter :: a1 = 4.0_wp / 2 7.0_wp real ( wp ), parameter :: a2 = 2.0_wp / 9.0_wp real ( wp ), parameter :: a3 = 1.0_wp / 3.0_wp real ( wp ), parameter :: a4 = 1.0_wp / 2.0_wp real ( wp ), parameter :: a5 = 2.0_wp / 3.0_wp real ( wp ), parameter :: a6 = 1.0_wp / 6.0_wp real ( wp ), parameter :: a8 = 5.0_wp / 6.0_wp real ( wp ), parameter :: c = 1.0_wp / 84 0.0_wp real ( wp ), parameter :: c0 = 4 1.0_wp real ( wp ), parameter :: c3 = 2 7.0_wp real ( wp ), parameter :: c4 = 27 2.0_wp real ( wp ), parameter :: c5 = 2 7.0_wp real ( wp ), parameter :: c6 = 21 6.0_wp real ( wp ), parameter :: c8 = 21 6.0_wp real ( wp ), parameter :: c9 = 4 1.0_wp real ( wp ), parameter :: aa1 = 4.0_wp / 2 7.0_wp real ( wp ), parameter :: aa2 = 1.0_wp / 1 8.0_wp real ( wp ), parameter :: aa3 = 1.0_wp / 1 2.0_wp real ( wp ), parameter :: aa4 = 1.0_wp / 8.0_wp real ( wp ), parameter :: aa5 = 1.0_wp / 5 4.0_wp real ( wp ), parameter :: aa6 = 1.0_wp / 432 0.0_wp real ( wp ), parameter :: aa7 = 1.0_wp / 2 0.0_wp real ( wp ), parameter :: aa8 = 1.0_wp / 28 8.0_wp real ( wp ), parameter :: aa9 = 1.0_wp / 82 0.0_wp real ( wp ), parameter :: b21 = 3.0_wp real ( wp ), parameter :: b32 = 3.0_wp real ( wp ), parameter :: b43 = 3.0_wp real ( wp ), parameter :: b50 = 1 3.0_wp real ( wp ), parameter :: b52 = - 2 7.0_wp real ( wp ), parameter :: b53 = 4 2.0_wp real ( wp ), parameter :: b54 = 8.0_wp real ( wp ), parameter :: b60 = 38 9.0_wp real ( wp ), parameter :: b62 = - 5 4.0_wp real ( wp ), parameter :: b63 = 96 6.0_wp real ( wp ), parameter :: b64 = - 82 4.0_wp real ( wp ), parameter :: b65 = 24 3.0_wp real ( wp ), parameter :: b70 = - 23 1.0_wp real ( wp ), parameter :: b72 = 8 1.0_wp real ( wp ), parameter :: b73 = - 116 4.0_wp real ( wp ), parameter :: b74 = 65 6.0_wp real ( wp ), parameter :: b75 = - 12 2.0_wp real ( wp ), parameter :: b76 = 80 0.0_wp real ( wp ), parameter :: b80 = - 12 7.0_wp real ( wp ), parameter :: b82 = 1 8.0_wp real ( wp ), parameter :: b83 = - 67 8.0_wp real ( wp ), parameter :: b84 = 45 6.0_wp real ( wp ), parameter :: b85 = - 9.0_wp real ( wp ), parameter :: b86 = 57 6.0_wp real ( wp ), parameter :: b87 = 4.0_wp real ( wp ), parameter :: b90 = 148 1.0_wp real ( wp ), parameter :: b92 = - 8 1.0_wp real ( wp ), parameter :: b93 = 710 4.0_wp real ( wp ), parameter :: b94 = - 337 6.0_wp real ( wp ), parameter :: b95 = 7 2.0_wp real ( wp ), parameter :: b96 = - 504 0.0_wp real ( wp ), parameter :: b97 = - 6 0.0_wp real ( wp ), parameter :: b98 = 72 0.0_wp call me % f ( t , x , f0 ) call me % f ( t + a1 * h , x + aa1 * h * f0 , f1 ) call me % f ( t + a2 * h , x + aa2 * h * ( f0 + b21 * f1 ), f2 ) call me % f ( t + a3 * h , x + aa3 * h * ( f0 + b32 * f2 ), f3 ) call me % f ( t + a4 * h , x + aa4 * h * ( f0 + b43 * f3 ), f4 ) call me % f ( t + a5 * h , x + aa5 * h * ( b50 * f0 + b52 * f2 + b53 * f3 + b54 * f4 ), f5 ) call me % f ( t + a6 * h , x + aa6 * h * ( b60 * f0 + b62 * f2 + b63 * f3 + b64 * f4 + b65 * f5 ), f6 ) call me % f ( t + h , x + aa7 * h * ( b70 * f0 + b72 * f2 + b73 * f3 + b74 * f4 + b75 * f5 + b76 * f6 ), f7 ) call me % f ( t + a8 * h , x + aa8 * h * ( b80 * f0 + b82 * f2 + b83 * f3 + b84 * f4 + b85 * f5 + b86 * f6 + b87 * f7 ), f8 ) call me % f ( t + h , x + aa9 * h * ( b90 * f0 + b92 * f2 + b93 * f3 + b94 * f4 + b95 * f5 + b96 * f6 + b97 * f7 + b98 * f8 ), f9 ) xf = x + h * c * ( c0 * f0 + c3 * f3 + c4 * f4 + c5 * f5 + c6 * f6 + c8 * f8 + c9 * f9 ) end subroutine rk8_10 !***************************************************************************************** !***************************************************************************************** !> !  Unit test of the [[rk_module]]. !  Integrate a two-body orbit around the Earth. subroutine rk_test () type , extends ( rk4_class ) :: spacecraft !! spacecraft propagation type. !! extends the [[rk4_class]] to include data used in the deriv routine real ( wp ) :: mu = zero !! central body gravitational parameter (km3/s2) integer :: fevals = 0 !! number of function evaluations logical :: first = . true . !! first point is being exported end type spacecraft integer , parameter :: n = 6 !! number of state variables real ( wp ), parameter :: tol = 1.0e-12_wp !! event location tolerance type ( spacecraft ) :: s , s2 real ( wp ) :: t0 , tf , x0 ( n ), dt , xf ( n ), x02 ( n ), gf , tf_actual write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' rk_test' write ( * , * ) '---------------' write ( * , * ) '' !*************************************************************************** !constructor (main body is Earth): s = spacecraft ( n = n , f = twobody , mu = 39860 0.436233_wp , report = twobody_report ) !initial conditions: x0 = [ 1000 0.0_wp , 1000 0.0_wp , 1000 0.0_wp ,& !initial state [r,v] (km,km/s) 1.0_wp , 2.0_wp , 3.0_wp ] t0 = zero !initial time (sec) dt = 1 0.0_wp !time step (sec) tf = 100 0.0_wp !final time (sec) s % fevals = 0 s % first = . true . call s % integrate ( t0 , x0 , dt , tf , xf ) !forward write ( * , * ) '' write ( * , '(A/,*(F15.6/))' ) 'Final state:' , xf s % fevals = 0 s % report => null () !disable reporting call s % integrate ( tf , xf , - dt , t0 , x02 ) !backwards write ( * , '(A/,*(E20.12/))' ) 'Error:' , x02 - x0 write ( * , '(A,I5)' ) 'Function evaluations:' , s % fevals write ( * , * ) '' !*************************************************************************** !event finding test: write ( * , * ) ' Event test - integrate until z = 12,000' s2 = spacecraft ( n = n , f = twobody , g = twobody_event , mu = 39860 0.436233_wp , report = twobody_report ) x0 = [ 1000 0.0_wp , 1000 0.0_wp , 1000 0.0_wp ,& !initial state [r,v] (km,km/s) 1.0_wp , 2.0_wp , 3.0_wp ] t0 = zero !initial time (sec) dt = 1 0.0_wp !time step (sec) tf = 100 0.0_wp !final time (sec) call s2 % integrate_to_event ( t0 , x0 , dt , tf , tol , tf_actual , xf , gf ) write ( * , * ) '' write ( * , '(A/,*(F15.6/))' ) 'Final time: ' , tf_actual write ( * , '(A/,*(F15.6/))' ) 'Final state:' , xf write ( * , '(A/,*(F15.6/))' ) 'Event func :' , gf contains !***************************************************************************************** !********************************************************* subroutine twobody ( me , t , x , xdot ) !! derivative routine for two-body orbit propagation implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension ( me % n ), intent ( in ) :: x real ( wp ), dimension ( me % n ), intent ( out ) :: xdot real ( wp ), dimension ( 3 ) :: r , v , a_grav real ( wp ) :: rmag select type ( me ) class is ( spacecraft ) r = x ( 1 : 3 ) v = x ( 4 : 6 ) rmag = norm2 ( r ) a_grav = - me % mu / rmag ** 3 * r !acceleration due to gravity xdot ( 1 : 3 ) = v xdot ( 4 : 6 ) = a_grav me % fevals = me % fevals + 1 end select end subroutine twobody !********************************************************* !********************************************************* subroutine twobody_report ( me , t , x ) !! report function - write time,state to console implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension ( me % n ), intent ( in ) :: x select type ( me ) class is ( spacecraft ) if ( me % first ) then !print header write ( * , * ) '' write ( * , '(*(A15,1X))' ) 'time (sec)' , 'x (km)' , 'y (km)' , 'z (km)' ,& 'vx (km/s)' , 'vy (km/s)' , 'vz (km/s)' me % first = . false . end if end select write ( * , '(*(F15.6,1X))' ) t , x end subroutine twobody_report !********************************************************* !********************************************************* subroutine twobody_event ( me , t , x , g ) !! event function (z = 12,000) implicit none class ( rk_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension ( me % n ), intent ( in ) :: x real ( wp ), intent ( out ) :: g g = x ( 3 ) - 1200 0.0_wp end subroutine twobody_event !********************************************************* end subroutine rk_test !***************************************************************************************** !***************************************************************************************** end module rk_module !*****************************************************************************************","tags":"","url":"sourcefile/rk_module.f90.html"},{"title":"transformation_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~transformation_module.f90~~EfferentGraph sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~celestial_body_module.f90 celestial_body_module.f90 sourcefile~transformation_module.f90->sourcefile~celestial_body_module.f90 sourcefile~ephemeris_module.f90 ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~ephemeris_module.f90 sourcefile~iau_orientation_module.f90 iau_orientation_module.f90 sourcefile~transformation_module.f90->sourcefile~iau_orientation_module.f90 sourcefile~jpl_ephemeris_module.f90 jpl_ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~transformation_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~transformation_module.f90->sourcefile~numbers_module.f90 sourcefile~obliquity_module.f90 obliquity_module.f90 sourcefile~transformation_module.f90->sourcefile~obliquity_module.f90 sourcefile~time_module.f90 time_module.f90 sourcefile~transformation_module.f90->sourcefile~time_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~transformation_module.f90->sourcefile~vector_module.f90 sourcefile~celestial_body_module.f90->sourcefile~kind_module.f90 sourcefile~celestial_body_module.f90->sourcefile~numbers_module.f90 sourcefile~base_class_module.f90 base_class_module.f90 sourcefile~celestial_body_module.f90->sourcefile~base_class_module.f90 sourcefile~ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~kind_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~numbers_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~vector_module.f90 sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~conversion_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~numbers_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~time_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~conversion_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~obliquity_module.f90->sourcefile~kind_module.f90 sourcefile~obliquity_module.f90->sourcefile~conversion_module.f90 sourcefile~time_module.f90->sourcefile~kind_module.f90 sourcefile~time_module.f90->sourcefile~conversion_module.f90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 sourcefile~conversion_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~transformation_module.f90~~AfferentGraph sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~transformation_module.f90 sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 sourcefile~lighting_module.f90->sourcefile~transformation_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Coordinate transformations. module transformation_module use numbers_module use kind_module use vector_module use ephemeris_module use iau_orientation_module use time_module use celestial_body_module use iso_fortran_env , only : error_unit implicit none private !frame center options for two_body_rotating_frame: integer , parameter , public :: center_at_primary_body = 1 integer , parameter , public :: center_at_secondary_body = 2 integer , parameter , public :: center_at_barycenter = 3 !abstract frame classes: type , abstract , public :: reference_frame !! a reference frame defines an orientation at !! a specified frame center at a specified epoch. !! Usually, the center is the `primary_body` of the !! frame, but can be otherwise for a !! [[two_body_rotating_frame]]. private type ( celestial_body ) :: primary_body = body_earth !! the primary body of the frame real ( wp ) :: et = zero !! epoch at which the frame is defined [sec] contains private procedure , pass ( from ), public :: transform !! coordinate transformation routine procedure ( c_cdot_func ), deferred :: get_c_cdot !! to get the rotating matrix for the frame orientation end type reference_frame type , abstract , extends ( reference_frame ), public :: inertial_frame_class !! a non-rotating frame (a frame where the orientation axes are time invariant) end type inertial_frame_class type , abstract , extends ( reference_frame ), public :: rotating_frame_class !! a rotating frame (a frame where the orientation axes vary with time) end type rotating_frame_class type , abstract , extends ( rotating_frame_class ), public :: iau_rotating_frame_class !! frame defined by the orientation of a celestial body using the IAU models. end type iau_rotating_frame_class !concrete rotating frames: type , extends ( rotating_frame_class ), public :: two_body_rotating_frame !! The two-body rotating frame is constructed from the states !! of two celestial bodies. type ( celestial_body ) :: secondary_body = body_moon !! the secondary body used to construct the frame integer :: center = center_at_barycenter !! the frame center (can be primary_body,secondary_body, or barycenter) real ( wp ), dimension ( 6 ) :: rv12 = zero !! [r,v] of secondary body w.r.t. primary body logical :: inertial = . false . !! to make it a quasi-inertial frame (cdot is zero) contains procedure :: from_primary_to_center procedure :: get_c_cdot => get_c_cdot_two_body_rotating end type two_body_rotating_frame interface two_body_rotating_frame module procedure :: two_body_rotating_frame_constructor end interface two_body_rotating_frame type , extends ( two_body_rotating_frame ), public :: two_body_rotating_pulsating_frame !! This frame is an extension of the two-body rotating frame, where !! a scale factor is used to scale the position and velocity of the state !! based on the distance between the primary and secondary bodies. real ( wp ) :: scale = zero !! scale factor contains procedure :: get_c_cdot => get_c_cdot_two_body_rotating_pulsating end type two_body_rotating_pulsating_frame interface two_body_rotating_pulsating_frame module procedure :: two_body_rotating_pulsating_frame_constructor end interface two_body_rotating_pulsating_frame !... note: could also have a two_body_rotating_pulsating_crtbp_frame !          which scales r,v,t based on the crtbp assumptions... !IAU rotating frames [not finished...]: type , extends ( iau_rotating_frame_class ), public :: iau_earth_rotating_frame !! IAU Earth frame contains procedure :: get_c_cdot => get_c_cdot_iau_earth end type iau_earth_rotating_frame interface iau_earth_rotating_frame module procedure :: iau_earth_rotating_frame_constructor end interface iau_earth_rotating_frame type , extends ( iau_rotating_frame_class ), public :: iau_moon_rotating_frame !! IAU Moon frame contains procedure :: get_c_cdot => get_c_cdot_iau_moon end type iau_moon_rotating_frame interface iau_moon_rotating_frame module procedure :: iau_moon_rotating_frame_constructor end interface iau_moon_rotating_frame !inertial frame definitions: type , extends ( inertial_frame_class ), public :: icrf_frame !! the fundamental inertial frame !! for the ephemeris (i.e., J2000). contains procedure :: get_c_cdot => get_c_cdot_icrf end type icrf_frame interface icrf_frame module procedure :: icrf_frame_constructor end interface icrf_frame type , extends ( inertial_frame_class ), public :: ecliptic_frame !! Mean ecliptic frame. contains procedure :: get_c_cdot => get_c_cdot_ecliptic end type ecliptic_frame interface ecliptic_frame module procedure :: ecliptic_frame_constructor end interface ecliptic_frame abstract interface subroutine c_cdot_func ( me , eph , to_icrf , c , cdot , status_ok ) import :: wp , reference_frame , ephemeris_class implicit none class ( reference_frame ), intent ( inout ) :: me class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations !! (assumed to have already !! been initialized) logical , intent ( in ) :: to_icrf real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot logical , intent ( out ) :: status_ok end subroutine c_cdot_func end interface !test routine: public :: transformation_module_test contains !******************************************************************************** !******************************************************************************** !> !  Constructor for a [[two_body_rotating_frame]] pure function two_body_rotating_frame_constructor (& primary_body , secondary_body , center , et , inertial ) result ( f ) implicit none type ( two_body_rotating_frame ) :: f type ( celestial_body ), intent ( in ) :: primary_body !! the primary body of !! the frame type ( celestial_body ), intent ( in ) :: secondary_body !! the secondary body used !! to construct the frame integer , intent ( in ) :: center !! the frame center (can !! be `primary_body`, !! `secondary_body`, or !! `barycenter`) real ( wp ), intent ( in ) :: et !! epoch at which the !! frame is defined [sec] logical , intent ( in ), optional :: inertial !! if true, it's a quasi-inertial frame !! [default is false] f % primary_body = primary_body f % secondary_body = secondary_body f % center = center f % et = et if ( present ( inertial )) f % inertial = inertial end function two_body_rotating_frame_constructor !******************************************************************************** !******************************************************************************** !> !  Constructor for a [[two_body_rotating_pulsating_frame]] pure function two_body_rotating_pulsating_frame_constructor (& primary_body , secondary_body , center , scale , et ) result ( f ) implicit none type ( two_body_rotating_pulsating_frame ) :: f type ( celestial_body ), intent ( in ) :: primary_body !! the primary body of !! the frame type ( celestial_body ), intent ( in ) :: secondary_body !! the secondary body used !! to construct the frame integer , intent ( in ) :: center !! the frame center (can !! be `primary_body`, !! `secondary_body`, or !! `barycenter`) real ( wp ), intent ( in ) :: scale !! scale factor real ( wp ), intent ( in ) :: et !! epoch at which the !! frame is defined [sec] f % primary_body = primary_body f % secondary_body = secondary_body f % center = center f % scale = scale f % et = et end function two_body_rotating_pulsating_frame_constructor !******************************************************************************** !******************************************************************************** !> !  Constructor for a [[iau_earth_rotating_frame]] pure function iau_earth_rotating_frame_constructor ( b , et ) result ( f ) implicit none type ( iau_earth_rotating_frame ) :: f type ( celestial_body ), intent ( in ) :: b !! the central body real ( wp ), intent ( in ) :: et !! epoch at which the !! frame is defined [sec] f % primary_body = b f % et = et end function iau_earth_rotating_frame_constructor !******************************************************************************** !******************************************************************************** !> !  Constructor for a [[iau_moon_rotating_frame]] pure function iau_moon_rotating_frame_constructor ( b , et ) result ( f ) implicit none type ( iau_earth_rotating_frame ) :: f type ( celestial_body ), intent ( in ) :: b !! the central body real ( wp ), intent ( in ) :: et !! epoch at which the !! frame is defined [sec] f % primary_body = b f % et = et end function iau_moon_rotating_frame_constructor !******************************************************************************** !******************************************************************************** !> !  Constructor for a [[icrf_frame]] ! !@note the `et` doesn't matter for inertial frames pure function icrf_frame_constructor ( b ) result ( f ) implicit none type ( icrf_frame ) :: f type ( celestial_body ), intent ( in ) :: b !! the central body f % primary_body = b end function icrf_frame_constructor !******************************************************************************** !******************************************************************************** !> !  Constructor for a [[ecliptic_frame]] ! !@note the `et` doesn't matter for inertial frames pure function ecliptic_frame_constructor ( b ) result ( f ) implicit none type ( ecliptic_frame ) :: f type ( celestial_body ), intent ( in ) :: b !! the central body f % primary_body = b end function ecliptic_frame_constructor !******************************************************************************** !******************************************************************************** !> !  Transform a Cartesian state from one reference frame to another at !  a specified epoch. The `from` and `to` [[reference_frame]]s may each !  be defined at a different epoch. The `et` ephemeris time is the time !  the transformation is to be done, and accounts for the motion of the two !  frame centers from `from%et` and `to%et` to `et`. subroutine transform ( from , rv , to , et , eph , rv_out , status_ok ) implicit none class ( reference_frame ), intent ( inout ) :: from real ( wp ), dimension ( 6 ), intent ( in ) :: rv class ( reference_frame ), intent ( inout ) :: to real ( wp ), intent ( in ) :: et !! the time of the transformation [sec] class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) real ( wp ), dimension ( 6 ), intent ( out ) :: rv_out logical , intent ( out ) :: status_ok ! local variables real ( wp ), dimension ( 3 , 3 ) :: c , cdot real ( wp ), dimension ( 3 , 3 ) :: rot1 , rotd1 real ( wp ), dimension ( 3 , 3 ) :: rot2 , rotd2 real ( wp ), dimension ( 3 ) :: rc21_out , vc21_out real ( wp ), dimension ( 3 ) :: rc21_icrf , vc21_icrf ! rotation matrix: input -> inertial call from % get_c_cdot ( eph = eph , to_icrf = . true ., c = rot1 , cdot = rotd1 , status_ok = status_ok ) if (. not . status_ok ) then write ( error_unit , '(A)' ) 'Error in transform: ' // & 'Could not compute rotation matrix from FROM frame to inertial.' rv_out = zero return end if ! rotation matrix: inertial -> output call to % get_c_cdot ( eph = eph , to_icrf = . false ., c = rot2 , cdot = rotd2 , status_ok = status_ok ) if (. not . status_ok ) then write ( error_unit , '(A)' ) 'Error in transform: ' // & 'Could not compute rotation matrix from inertial to TO frame.' rv_out = zero return end if ! rotation matrix: input -> output c = matmul ( rot2 , rot1 ) cdot = matmul ( rotd2 , rot1 ) + matmul ( rot2 , rotd1 ) ! get the state of the `from` frame center w.r.t. the `to` frame center, ! at the transformation time: call rvcto_rvcfrom_icrf ( from , to , eph , et , & rc21_icrf , vc21_icrf , status_ok ) if ( status_ok ) then ! to->from frame center state: inertial -> output frame rc21_out = matmul ( rot2 , rc21_icrf ) vc21_out = matmul ( rotd2 , rc21_icrf ) + matmul ( rot2 , vc21_icrf ) ! rotation + translation: rv_out ( 1 : 3 ) = matmul ( c , rv ( 1 : 3 )) + rc21_out rv_out ( 4 : 6 ) = matmul ( c , rv ( 4 : 6 )) + matmul ( cdot , rv ( 1 : 3 )) + vc21_out else !error rv_out = zero end if end subroutine transform !******************************************************************************** !******************************************************************************** subroutine rvcto_rvcfrom_icrf ( from , to , eph , et , rc21 , vc21 , status_ok ) !! Returns the state of the `from` frame center w.r.t. the `to` frame center, !! at the specified ephemeris time `et`. implicit none class ( reference_frame ), intent ( in ) :: from class ( reference_frame ), intent ( in ) :: to class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) real ( wp ), intent ( in ) :: et !! ephemeris time [sec] real ( wp ), dimension ( 3 ), intent ( out ) :: rc21 !! position of `from` frame center w.r.t. `to` frame center real ( wp ), dimension ( 3 ), intent ( out ) :: vc21 !! velocity of `from` frame center w.r.t. `to` frame center logical , intent ( out ) :: status_ok !! true if there were no errors ! local variables real ( wp ), dimension ( 6 ) :: rvc1 !! inertial state of `from` frame center w.r.t. `from` primary body real ( wp ), dimension ( 6 ) :: rvc2 !! inertial state of `to`   frame center w.r.t. `to`   primary body real ( wp ), dimension ( 6 ) :: rvb21 !! inertial state of `from` primary body w.r.t. `to`   primary body real ( wp ), dimension ( 6 ) :: rvc21 !! inertial state of `from` frame center w.r.t. `to`   frame center ! get TO primary body -> FROM primary body state [inertial] call eph % get_rv ( et , from % primary_body , to % primary_body , rvb21 , status_ok ) if ( status_ok ) then ! currently, only the two-body rotating frames may be ! centered somewhere other than the primary body. select type ( from ) class is ( two_body_rotating_frame ) call from % from_primary_to_center ( eph , et , rvc1 , status_ok ) class default rvc1 = zero end select if ( status_ok ) then select type ( to ) class is ( two_body_rotating_frame ) call to % from_primary_to_center ( eph , et , rvc2 , status_ok ) class default rvc2 = zero end select if ( status_ok ) then rvc21 = rvb21 + rvc1 - rvc2 rc21 = rvc21 ( 1 : 3 ) vc21 = rvc21 ( 4 : 6 ) return else write ( error_unit , '(A)' ) 'Error in rvcto_rvcfrom_icrf: ' // & 'Could not compute center of TO frame.' end if else write ( error_unit , '(A)' ) 'Error in rvcto_rvcfrom_icrf: ' // & 'Could not compute center of FROM frame.' end if else !error write ( error_unit , '(A)' ) 'Error in rvcto_rvcfrom_icrf: ' // & 'Could not compute translation.' end if ! we end up here if there was an error: rc21 = zero vc21 = zero end subroutine rvcto_rvcfrom_icrf !******************************************************************************** !******************************************************************************** subroutine from_primary_to_center ( me , eph , et , rc , status_ok ) !! returns the state of the frame center w.r.t. the frame primary body. implicit none class ( two_body_rotating_frame ), intent ( in ) :: me class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) real ( wp ), intent ( in ) :: et !! ephemeris time [sec] real ( wp ), dimension ( 6 ), intent ( out ) :: rc !! state of frame center w.r.t. primary body [inertial] logical , intent ( out ) :: status_ok !! true if no errors. real ( wp ) :: mu1 !! gravitational parameter of primary body real ( wp ) :: mu2 !! gravitational parameter of secondary body if ( me % center == center_at_primary_body ) then rc = zero else ! primary body -> secondary body state [inertial]: call eph % get_rv ( et , me % secondary_body , me % primary_body , rc , status_ok ) if ( status_ok ) then if ( me % center == center_at_barycenter ) then mu1 = me % primary_body % mu mu2 = me % secondary_body % mu rc = rc * ( mu2 / ( mu1 + mu2 ) ) elseif ( me % center == center_at_secondary_body ) then !frame center is secondary body (rc already computed) else error stop 'invalid rotating frame center selection.' end if else write ( error_unit , '(A)' ) 'Error in from_primary_to_center: ' // & 'Could not compute primary to secondary body state.' end if end if end subroutine from_primary_to_center !******************************************************************************** !******************************************************************************** subroutine get_c_cdot_two_body_rotating ( me , eph , to_icrf , c , cdot , status_ok ) !! rotation matrix for ROTATING <-> ICRF implicit none class ( two_body_rotating_frame ), intent ( inout ) :: me class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) logical , intent ( in ) :: to_icrf real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot logical , intent ( out ) :: status_ok real ( wp ), dimension ( 3 ) :: r !! position of secondary body w.r.t. primary body [inertial frame] real ( wp ), dimension ( 3 ) :: v !! velocity of secondary body w.r.t. primary body [inertial frame] real ( wp ), dimension ( 3 ) :: h !! angular momentum vector real ( wp ), dimension ( 3 ) :: w !! angular velocity of frame logical :: need_cdot !! if we need to compute `cdot` real ( wp ), dimension ( 3 ) :: rhat !! `r` unit vector real ( wp ), dimension ( 3 ) :: hhat !! `h` unit vector need_cdot = present ( cdot ) ! get position & velocity of secondary body w.r.t. primary body, in the inertial frame call eph % get_rv ( me % et , me % secondary_body , me % primary_body , me % rv12 , status_ok ) if ( status_ok ) then r = me % rv12 ( 1 : 3 ) v = me % rv12 ( 4 : 6 ) h = cross ( r , v ) rhat = unit ( r ) hhat = unit ( h ) c ( 1 ,:) = rhat c ( 3 ,:) = hhat c ( 2 ,:) = cross ( hhat , rhat ) if ( need_cdot ) then if ( me % inertial ) then ! quasi inertial frame cdot = zero else w = h / dot_product ( r , r ) ! see: https://en.wikipedia.org/wiki/Angular_velocity cdot = - matmul ( c , cross_matrix ( w )) ! see: http://arxiv.org/pdf/1311.6010.pdf end if end if if ( to_icrf ) then c = transpose ( c ) if ( need_cdot ) cdot = transpose ( cdot ) end if else write ( error_unit , '(A)' ) 'Error in get_c_cdot_two_body_rotating: ' // & 'Could not compute rotation matrix.' c = zero if ( need_cdot ) cdot = zero end if end subroutine get_c_cdot_two_body_rotating !******************************************************************************** !******************************************************************************** subroutine get_c_cdot_two_body_rotating_pulsating ( me , eph , to_icrf , c , cdot , status_ok ) !! rotation matrix for ROTATING_PULSATING <-> ICRF implicit none class ( two_body_rotating_pulsating_frame ), intent ( inout ) :: me class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) logical , intent ( in ) :: to_icrf real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot logical , intent ( out ) :: status_ok ! local variables real ( wp ), dimension ( 3 , 3 ) :: cr , crdot real ( wp ), dimension ( 3 ) :: r12 , v12 real ( wp ) :: r12mag , factor logical :: need_cdot need_cdot = present ( cdot ) ! rotating frame transformation matrices: if ( need_cdot ) then call me % two_body_rotating_frame % get_c_cdot ( eph , to_icrf , cr , crdot , status_ok = status_ok ) else call me % two_body_rotating_frame % get_c_cdot ( eph , to_icrf , cr , status_ok = status_ok ) end if if ( status_ok ) then r12 = me % rv12 ( 1 : 3 ) ! was computed in get_c_cdot_two_body_rotating v12 = me % rv12 ( 4 : 6 ) r12mag = norm2 ( r12 ) if ( to_icrf ) then factor = r12mag / me % scale c = factor * cr if ( need_cdot ) cdot = factor * ( dot_product ( v12 , r12 ) * cr / ( r12mag ** 2 ) + crdot ) else factor = me % scale / r12mag c = factor * cr if ( need_cdot ) cdot = factor * ( - dot_product ( v12 , r12 ) * cr / ( r12mag ** 2 ) + crdot ) end if else !error write ( error_unit , '(A)' ) 'Error in get_c_cdot_two_body_rotating_pulsating: ' // & 'Could not compute rotation matrix.' c = zero if ( need_cdot ) cdot = zero end if end subroutine get_c_cdot_two_body_rotating_pulsating !******************************************************************************** !******************************************************************************** subroutine get_c_cdot_icrf ( me , eph , to_icrf , c , cdot , status_ok ) !! rotation matrix for ICRF <-> ICRF implicit none class ( icrf_frame ), intent ( inout ) :: me class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) logical , intent ( in ) :: to_icrf real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot logical , intent ( out ) :: status_ok c = identity_3x3 if ( present ( cdot )) cdot = zero status_ok = . true . end subroutine get_c_cdot_icrf !******************************************************************************** !******************************************************************************** subroutine get_c_cdot_ecliptic ( me , eph , to_icrf , c , cdot , status_ok ) !! rotation matrix for ICRF <-> Mean Ecliptic use obliquity_module implicit none class ( ecliptic_frame ), intent ( inout ) :: me class ( ephemeris_class ), intent ( inout ) :: eph logical , intent ( in ) :: to_icrf real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot logical , intent ( out ) :: status_ok if ( to_icrf ) then c = mean_ecliptic_to_equatorial_rotmat () else c = equatorial_to_mean_ecliptic_rotmat () end if if ( present ( cdot )) cdot = zero status_ok = . true . end subroutine get_c_cdot_ecliptic !******************************************************************************** !******************************************************************************** subroutine get_c_cdot_iau_earth ( me , eph , to_icrf , c , cdot , status_ok ) !! rotation matrix for IAU_EARTH <-> ICRF implicit none class ( iau_earth_rotating_frame ), intent ( inout ) :: me class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) logical , intent ( in ) :: to_icrf real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot logical , intent ( out ) :: status_ok c = icrf_to_iau_earth ( me % et ) !... don't have the cdot code yet... need to refactor iau code ... ! see also: ftp://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/tisbod.html !if (present(cdot)) cdot = error stop 'not yet supported' status_ok = . true . end subroutine get_c_cdot_iau_earth !******************************************************************************** !******************************************************************************** subroutine get_c_cdot_iau_moon ( me , eph , to_icrf , c , cdot , status_ok ) !! rotation matrix for IAU_MOON <-> ICRF implicit none class ( iau_moon_rotating_frame ), intent ( inout ) :: me class ( ephemeris_class ), intent ( inout ) :: eph !! for ephemeris computations (assumed to have already been initialized) logical , intent ( in ) :: to_icrf real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot logical , intent ( out ) :: status_ok c = icrf_to_iau_moon ( me % et ) !... don't have the cdot code yet... need to refactor iau code ... ! see also: ftp://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/spicelib/tisbod.html !if (present(cdot)) cdot = error stop 'not yet supported' status_ok = . true . end subroutine get_c_cdot_iau_moon !******************************************************************************** !******************************************************************************** !> !  Transformation units test subroutine transformation_module_test () use jpl_ephemeris_module , only : jpl_ephemeris implicit none real ( wp ), dimension ( 6 ), parameter :: initial_state = [ 1000 0.0_wp ,& 0.0_wp ,& 0.0_wp ,& 1.0_wp ,& 2.0_wp ,& 3.0_wp ] !! km, km/s real ( wp ), parameter :: et = zero !! ephemeris time [sec] real ( wp ), parameter :: scale = 38440 0.0_wp !! scale factor [km] character ( len =* ), parameter :: ephemeris_file_421 = './eph/JPLEPH.421' !! JPL DE421 ephemeris file type ( icrf_frame ) :: from type ( two_body_rotating_pulsating_frame ) :: to type ( jpl_ephemeris ) :: eph421 logical :: status_ok real ( wp ), dimension ( 6 ) :: rv_out type ( ecliptic_frame ) :: ecliptic_f real ( wp ), dimension ( 3 , 3 ) :: c integer :: i !! counter write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' transformation_module_test' write ( * , * ) '---------------' write ( * , * ) '' !open the ephemeris: call eph421 % initialize ( filename = ephemeris_file_421 , status_ok = status_ok ) if (. not . status_ok ) error stop 'Error initializing DE421 ephemeris.' !initialize frames: !  [NOTE: need to make constructors for the frames] ! note: default is Earth-Moon-barycenter: from = icrf_frame ( et = et ) to = two_body_rotating_pulsating_frame ( et = et , scale = scale ) call from % transform ( initial_state , to , et , eph421 , rv_out , status_ok ) if (. not . status_ok ) error stop 'Error in state transformation.' !results: write ( * , * ) '' write ( * , '(A/,*(E30.16/))' ) 'initial state (J2000-Earth):' , initial_state write ( * , '(A/,*(E30.16/))' ) 'final state (Earth-Moon rotating, centered at barycenter, scale=384400):' , rv_out write ( * , * ) '' ! ecliptic frame: ecliptic_f = ecliptic_frame ( b = body_earth ) call ecliptic_f % get_c_cdot ( eph421 , to_icrf = . true ., c = c , status_ok = status_ok ) write ( * , * ) '' write ( * , * ) 'ecliptic to j2000:' do i = 1 , 3 write ( * , * ) c ( i ,:) end do ! from SPICE: ! rot = [1.0000000000000000E+00, 0.0000000000000000E+00, 0.0000000000000000E+00, !        0.0000000000000000E+00, 9.1748206206918181E-01, -3.9777715593191371E-01, !        0.0000000000000000E+00, 3.9777715593191371E-01, 9.1748206206918181E-01] ! ! from FAT: !        1.0000000000000000        0.0000000000000000        0.0000000000000000 !        0.0000000000000000       0.91748206206918181      -0.39777715593191371 !        0.0000000000000000       0.39777715593191371       0.91748206206918181 !close the ephemeris: call eph421 % close () end subroutine transformation_module_test !******************************************************************************** !******************************************************************************** end module transformation_module !********************************************************************************","tags":"","url":"sourcefile/transformation_module.f90.html"},{"title":"kepler_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~kepler_module.f90~~EfferentGraph sourcefile~kepler_module.f90 kepler_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~kepler_module.f90->sourcefile~kind_module.f90 sourcefile~newton_module.f90 newton_module.f90 sourcefile~kepler_module.f90->sourcefile~newton_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~kepler_module.f90->sourcefile~numbers_module.f90 sourcefile~newton_module.f90->sourcefile~kind_module.f90 sourcefile~newton_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~kepler_module.f90~~AfferentGraph sourcefile~kepler_module.f90 kepler_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~kepler_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !******************************************************************************* !> !  Kepler propagation routines. module kepler_module use numbers_module use kind_module , only : wp use iso_fortran_env , only : error_unit implicit none private public :: kepler_shepperd public :: kepler_goodyear_stienon_klumpp public :: kepler_classical contains !******************************************************************************* !******************************************************************************* !> !  Classical Kepler propagator for elliptical and hyperbolic orbits. !  Uses Lagrange formulations from Battin & Newton's method. ! !### See also !  * Dario Izzo: pykep/src/core_functions/propagate_lagrangian.h subroutine kepler_classical ( x0 , dt , mu , xf ) use newton_module , only : newton implicit none real ( wp ), dimension ( 6 ), intent ( in ) :: x0 !! initial position,velocity vector real ( wp ), intent ( in ) :: dt !! propagation time real ( wp ), intent ( in ) :: mu !! central body gravitational parameter real ( wp ), dimension ( 6 ), intent ( out ) :: xf !! final position,velocity vector real ( wp ), dimension ( 3 ) :: r0 !! initial position vector real ( wp ), dimension ( 3 ) :: v0 !! initial velocity vector real ( wp ) :: de !! eccentric anomaly difference real ( wp ) :: dh !! hyperbolic anomaly difference integer :: iflag !! newton status flag real ( wp ) :: r , rmag , vmag , energy , a , sqrta , f ,& g , ft , gt , sigma0 , dm , dn , xs , fx , b , p , x , z , term real ( wp ), parameter :: parabolic_tol = 1.0e-12_wp !! zero tol for parabolic orbits (energy) real ( wp ), parameter :: ftol = 1.0e-12_wp !! function tol for root finding real ( wp ), parameter :: xtol = 1.0e-12_wp !! indep variable tol for root finding integer , parameter :: max_iter = 1000 !! maximum number of iterations in newton ! check trivial case: if ( dt == zero ) then xf = x0 return end if r0 = x0 ( 1 : 3 ) v0 = x0 ( 4 : 6 ) rmag = norm2 ( r0 ) vmag = norm2 ( v0 ) energy = ( vmag * vmag / two - mu / rmag ) sigma0 = dot_product ( r0 , v0 ) / sqrt ( mu ) ! if not parabolic, then compute semimajor axis if ( abs ( energy ) > parabolic_tol ) then a = - mu / two / energy end if if ( energy < - parabolic_tol ) then ! elliptical case sqrta = sqrt ( a ) dm = sqrt ( mu / a ** 3 ) * dt de = dm call newton ( de , kepde_ , d_kepde_ , ftol , xtol , max_iter , xs , fx , iflag ) if ( iflag < 0 ) then write ( error_unit , '(A)' ) 'Error in kepler_classical [elliptical]: newton did not converge' write ( * , * ) xs , fx , iflag end if de = xs r = a + ( rmag - a ) * cos ( de ) + sigma0 * sqrta * sin ( de ) ! eqn 4.42 ! lagrange coefficients (Battin eqn 4.41) f = one - a / rmag * ( one - cos ( de )) g = a * sigma0 / sqrt ( mu ) * ( one - cos ( de )) + rmag * sqrt ( a / mu ) * sin ( de ) ft = - sqrt ( mu * a ) / ( r * rmag ) * sin ( de ) gt = one - a / r * ( one - cos ( de )) else if ( energy > parabolic_tol ) then ! hyperbolic case sqrta = sqrt ( - a ) dn = sqrt ( - mu / a ** 3 ) * dt dh = sign ( one , dt ) ! todo: need a better initial guess call newton ( dh , kepdh_ , d_kepdh_ , ftol , xtol , max_iter , xs , fx , iflag ) if ( iflag < 0 ) then write ( error_unit , '(A)' ) 'Error in kepler_classical [hyperbola]: newton did not converge' write ( * , * ) xs , fx , iflag end if dh = xs r = a + ( rmag - a ) * cosh ( dh ) + sigma0 * sqrta * sinh ( dh ) ! lagrange coefficients (Battin eqn 4.62) f = one - a / rmag * ( one - cosh ( dh )) g = a * sigma0 / sqrt ( mu ) * ( one - cosh ( dh )) + rmag * sqrt ( - a / mu ) * sinh ( dh ) ft = - sqrt ( - mu * a ) / ( r * rmag ) * sinh ( dh ) gt = one - a / r * ( one - cosh ( dh )) else ! parbolic case ! See Battin Section 4.2 p = two * rmag - sigma0 ** 2 B = one / p ** 1.5_wp * ( sigma0 * ( rmag + p ) + three * sqrt ( mu ) * dt ) term = B + sqrt ( one + B * B ) z = ( term ) ** ( one / three ) - ( term ) ** ( - one / three ) ! Battin eqn 4.12 where z = tan(f/2) x = sqrt ( p ) * z - sigma0 r = rmag + sigma0 * x + one / two * x ** 2 f = one - x ** 2 / two / rmag g = x / two / sqrt ( mu ) * ( two * rmag + sigma0 * x ) ft = - sqrt ( mu ) * x / rmag / r gt = one - x ** 2 / two / r end if ! results: xf ( 1 : 3 ) = f * r0 + g * v0 xf ( 4 : 6 ) = ft * r0 + gt * v0 contains ! function wrappers for newtons method: subroutine kepde_ ( x , f ) implicit none real ( wp ), intent ( in ) :: x !! de real ( wp ), intent ( out ) :: f f = kepde ( x , dm , sigma0 , sqrta , a , rmag ) end subroutine kepde_ subroutine d_kepde_ ( x , f ) implicit none real ( wp ), intent ( in ) :: x !! de real ( wp ), intent ( out ) :: f f = d_kepde ( x , sigma0 , sqrta , a , rmag ) end subroutine d_kepde_ subroutine kepdh_ ( x , f ) implicit none real ( wp ), intent ( in ) :: x !! dh real ( wp ), intent ( out ) :: f f = kepdh ( x , dn , sigma0 , sqrta , a , rmag ) end subroutine kepdh_ subroutine d_kepdh_ ( x , f ) implicit none real ( wp ), intent ( in ) :: x !! dh real ( wp ), intent ( out ) :: f f = d_kepdh ( x , sigma0 , sqrta , a , rmag ) end subroutine d_kepdh_ end subroutine kepler_classical !******************************************************************************* !******************************************************************************* !> !  Elliptic Kepler's equation pure function kepe ( e , m , ecc ) implicit none real ( wp ), intent ( in ) :: e !! eccentric anomaly real ( wp ), intent ( in ) :: m !! mean anomaly real ( wp ), intent ( in ) :: ecc !! eccentricity real ( wp ) :: kepe kepe = e - ecc * sin ( e ) - m end function kepe !******************************************************************************* !******************************************************************************* !> !  Derivative of [[kepe]] w.r.t. `e` pure function d_kepe ( e , ecc ) implicit none real ( wp ), intent ( in ) :: e !! eccentric anomaly real ( wp ), intent ( in ) :: ecc !! eccentricity real ( wp ) :: d_kepe d_kepe = one - ecc * cos ( e ) end function d_kepe !******************************************************************************* !******************************************************************************* !> !  Elliptic Kepler's equation written in terms of the !  eccentric anomaly difference.  See Battin, eqn 4.43. pure function kepde ( de , dm , sigma0 , sqrta , a , r ) implicit none real ( wp ), intent ( in ) :: de !! eccentric anomaly difference real ( wp ), intent ( in ) :: dm !! mean anomaly difference real ( wp ), intent ( in ) :: sigma0 real ( wp ), intent ( in ) :: sqrta real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ) :: r real ( wp ) :: kepde kepde = - dm + de + sigma0 / sqrta * ( one - cos ( de )) - & ( one - r / a ) * sin ( de ) end function kepde !******************************************************************************* !******************************************************************************* !> !  Derivative of [[kepde]] w.r.t `de`. pure function d_kepde ( de , sigma0 , sqrta , a , r ) implicit none real ( wp ), intent ( in ) :: de !! eccentric anomaly difference real ( wp ), intent ( in ) :: sigma0 real ( wp ), intent ( in ) :: sqrta real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ) :: r real ( wp ) :: d_kepde d_kepde = one + sigma0 / sqrta * sin ( de ) - ( one - r / a ) * cos ( de ) end function d_kepde !******************************************************************************* !******************************************************************************* !> !  Battin, eqn. 4.64. pure function kepdh ( dh , dn , sigma0 , sqrta , a , r ) implicit none real ( wp ), intent ( in ) :: dh !! hyperbolic anomaly difference real ( wp ), intent ( in ) :: dn real ( wp ), intent ( in ) :: sigma0 real ( wp ), intent ( in ) :: sqrta real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ) :: r real ( wp ) :: kepdh kepdh = - dn - dh + sigma0 / sqrta * ( cosh ( dh ) - one ) + & ( one - r / a ) * sinh ( dh ) end function kepdh !******************************************************************************* !******************************************************************************* !> !  Derivative of [[kepdh]] w.r.t `dh`. pure function d_kepdh ( dh , sigma0 , sqrta , a , r ) implicit none real ( wp ), intent ( in ) :: dh !! hyperbolic anomaly difference real ( wp ), intent ( in ) :: sigma0 real ( wp ), intent ( in ) :: sqrta real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ) :: r real ( wp ) :: d_kepdh d_kepdh = - one + sigma0 / sqrta * sinh ( dh ) + ( one - r / a ) * cosh ( dh ) end function d_kepdh !******************************************************************************* !******************************************************************************* !> !  Barker time of flight equation pure function barker ( r1 , r2 , mu ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: r1 real ( wp ), dimension ( 3 ), intent ( in ) :: r2 real ( wp ), intent ( in ) :: mu real ( wp ) :: barker real ( wp ) :: x , r1mag , r2mag , r21mag , sigma , r1pr2mag real ( wp ), dimension ( 3 ) :: r21 r1mag = norm2 ( r1 ) r2mag = norm2 ( r2 ) r21 = r2 - r1 r21mag = norm2 ( r21 ) x = r1 ( 1 ) * r2 ( 2 ) - r1 ( 2 ) * r2 ( 1 ) sigma = sign ( one , x ) r1pr2mag = r1mag + r2mag barker = ( r1pr2mag + r21mag ) ** 1.5_wp - & sigma * ( r1pr2mag - r21mag ) ** 1.5_wp / ( six * sqrt ( mu )) end function barker !******************************************************************************* !******************************************************************************* !> ! pure function kepds ( ds , dt , r0 , vr0 , alpha , mu ) implicit none real ( wp ), intent ( in ) :: ds !! universal anomaly difference real ( wp ), intent ( in ) :: dt real ( wp ), intent ( in ) :: r0 real ( wp ), intent ( in ) :: vr0 real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: mu real ( wp ) :: kepds real ( wp ) :: c , s , ads2 , ds2 ds2 = ds * ds ads2 = alpha * ds2 s = stumpff_s ( ads2 ) c = stumpff_c ( ads2 ) kepds = - sqrt ( mu ) * dt + r0 * vr0 * ds2 * c / sqrt ( mu ) + & ( one - alpha * r0 ) * ds2 * ds * s + r0 * ds end function kepds !******************************************************************************* !******************************************************************************* !> ! pure function d_kepds ( ds , r0 , vr0 , alpha , mu ) implicit none real ( wp ), intent ( in ) :: ds real ( wp ), intent ( in ) :: r0 real ( wp ), intent ( in ) :: vr0 real ( wp ), intent ( in ) :: alpha real ( wp ), intent ( in ) :: mu real ( wp ) :: d_kepds real ( wp ) :: c , s , ads2 , ds2 ds2 = ds * ds ads2 = alpha * ds2 s = stumpff_s ( ads2 ) c = stumpff_c ( ads2 ) d_kepds = r0 * vr0 / sqrt ( mu ) * ds * ( one - ads2 * s ) + & ( one - alpha * r0 ) * ds2 * c + r0 end function d_kepds !******************************************************************************* !******************************************************************************* !> !  Stumpff function S(z) pure function stumpff_s ( z ) result ( s ) implicit none real ( wp ), intent ( in ) :: z real ( wp ) :: s if ( z > zero ) then s = ( sqrt ( z ) - sin ( sqrt ( z ))) / sqrt ( z ) ** 3 else if ( z < zero ) then s = ( sinh ( sqrt ( - z )) - sqrt ( - z )) / ( - z ) ** ( three / two ) else s = one / six end if end function stumpff_s !******************************************************************************* !******************************************************************************* !> !  Stumpff function C(z) pure function stumpff_c ( z ) result ( c ) implicit none real ( wp ), intent ( in ) :: z real ( wp ) :: c if ( z > zero ) then c = ( one - cos ( sqrt ( z ))) / z else if ( z < zero ) then c = ( cosh ( sqrt ( - z )) - one ) / ( - z ) else c = 0.5_wp end if end function stumpff_c !******************************************************************************* !******************************************************************************* !> !  Kepler propagation using Shepperd's method. ! !### Reference !  * S.W. Shepperd, \"Universal Keplerian State Transition Matrix\". !    Celestial Mechanics 35(1985) p. 129-144. !  * Rody P.S. Oldenhuis, `progress_orbitM` Matlab function (BSD license). !    http://www.mathworks.com/matlabcentral/fileexchange/26349-kepler-state-transition-matrix-mex !  * C.D. Eagle, Orbital Mechanics with MATLAB, `twobody2.m` Matlab function (BSD license). !    http://www.mathworks.com/matlabcentral/fileexchange/48723-matlab-functions-for-two-body-orbit-propagation subroutine kepler_shepperd ( mu , rv1 , dt , rv2 , istat ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter real ( wp ), dimension ( 6 ), intent ( in ) :: rv1 !! initial position,velocity vector real ( wp ), intent ( in ) :: dt !! time step real ( wp ), dimension ( 6 ), intent ( out ) :: rv2 !! final position,velocity vector integer , intent ( out ), optional :: istat !! status flag (if not present, warnings are printed): !! Linear combination of : !! !! `0` : all is well !! `-10` : failed to converge in time loop !! `-100` : failed to converge in `g` loop ! note: some of these could also be (optional) input: real ( wp ), parameter :: min_dt = epsilon ( one ) !! time step considered as zero (sec) integer , parameter :: max_iter = 1000 !! max iterations for time integer , parameter :: max_iter_g = 1000 !! max iterations for g real ( wp ), parameter :: ttol = 1.0e-8_wp !! tolerance for time (sec) real ( wp ), parameter :: gtol = 1.0e-12_wp !! tolerance for g real ( wp ), parameter :: zero_tol = epsilon ( one ) !! tolerance for beta=0 (parabola) logical , parameter :: use_halley = . true . !! use the Halley update !! rather than the original Newton real ( wp ), dimension ( 3 ) :: r1 !! initial position vector real ( wp ), dimension ( 3 ) :: v1 !! initial velocity vector real ( wp ) :: r1mag , nu0 , beta , p , deltau , u , t , deltat , bu , q ,& a , b , gprev , u0w2 , u1w2 , uu , u0 , u1 , u2 , u3 , r ,& ff , f , gg , g , umin , umax , du , abs_beta integer :: n , iter , k , d , l , iterg if ( present ( istat )) istat = 0 if ( abs ( dt ) <= min_dt ) then rv2 = rv1 else r1 = rv1 ( 1 : 3 ) v1 = rv1 ( 4 : 6 ) r1mag = norm2 ( r1 ) nu0 = dot_product ( r1 , v1 ) beta = two * mu / r1mag - dot_product ( v1 , v1 ) abs_beta = abs ( beta ) if ( abs_beta > zero_tol ) then umax = one / sqrt ( abs_beta ) else umax = huge ( one ) end if umin = - umax if ( beta > zero ) then p = twopi * mu * beta ** ( - three / two ) n = floor (( dt + p / two - two * nu0 / beta ) / p ) deltau = twopi * n * beta ** ( - five / two ) else deltau = zero end if u = zero t = zero iter = 0 deltat = dt - t do while ( abs ( deltat ) > ttol ) iter = iter + 1 bu = beta * u * u q = min ( 0.5_wp , bu / ( one + bu )) ! avoid q > 0.5 due to numerical issues a = one b = one g = one n = 0 k = - 9 d = 15 l = 3 gprev = huge ( one ) iterg = 0 do while ( abs ( g - gprev ) > gtol ) iterg = iterg + 1 k = - k l = l + 2 d = d + 4 * l n = n + ( 1 + k ) * l a = d / ( d - n * a * q ) b = ( a - one ) * b gprev = g g = g + b if ( iterg == max_iter_g ) then if ( present ( istat )) then istat = istat - 100 else write ( * , * ) 'Warning: kepler_shepperd failed to converge in g iteration' end if exit end if end do u0w2 = one - two * q u1w2 = two * ( one - q ) * u uu = 1 6.0_wp / 1 5.0_wp * u1w2 ** 5 * g + deltau u0 = two * u0w2 ** 2 - one u1 = two * u0w2 * u1w2 u2 = two * u1w2 ** 2 u3 = beta * uu + u1 * u2 / three r = r1mag * u0 + nu0 * u1 + mu * u2 t = r1mag * u1 + nu0 * u2 + mu * u3 deltat = dt - t if ( use_halley ) then ! Halley version from Oldenhuis routine du = deltat / (( one - q ) * ( four * r + deltat * beta * u )) else ! original Newton du = deltat / four / ( one - q ) / r end if ! this logic is from the Eagle routine if ( du < zero ) then umax = u u = u + du if ( u < umin ) u = ( umin + umax ) / two else umin = u u = u + du if ( u > umax ) u = ( umin + umax ) / two end if if ( iter == max_iter ) then if ( abs ( deltat ) > ttol ) then ! it still hasn't converged if ( present ( istat )) then istat = istat - 10 else write ( * , * ) 'Warning: kepler_shepperd failed to converge in time iteration' end if exit end if end if end do ff = one - mu / r1mag * u2 f = - mu * u1 / r / r1mag gg = r1mag * u1 + nu0 * u2 g = one - mu / r * u2 rv2 = [ r1 * ff + v1 * gg , r1 * f + v1 * g ] end if end subroutine kepler_shepperd !******************************************************************************* !******************************************************************************* !> !  Kepler propagator based on the Goodyear code with !  modifications by Stienon and Klumpp. ! !### See also !  * W. H. Goodyear, \"Completely General Closed-Form Solution for Coordinates !    and Partial Derivatives of the Two-Body Problem\", Astronomical Journal, !    Vol. 70, No. 3, April 1965. !    [pdf](http://adsabs.harvard.edu/full/1965AJ.....70..189G) !  * W. H. Goodyear, \"A General Method for the Computation of Cartesian !    Coordinates and Partial Derivatives of the Two-Body Problem\", !    NASA CR-522, Sep 1, 1966. !    [pdf](https://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19660027556.pdf) !  * A. Klumpp, \"Performance Comparision of Lambert and Kepler Algorithms\", !    JPL Interoffice Memorandum, 314.1-0426-ARK, Jan 2, 1991. !   (See the `KEPGSK` Fortran 77 routine) subroutine kepler_goodyear_stienon_klumpp ( rv0 , tau , mu , accy , rvf ) implicit none real ( wp ), dimension ( 6 ), intent ( in ) :: rv0 !! state vector at reference !! time T0 [km,km/s] real ( wp ), intent ( in ) :: tau !! Time interval T-T0 [sec] real ( wp ), intent ( in ) :: mu !! Central body gravitational !! constant [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: accy !! Fractional accuracy required !! [0->0.1] real ( wp ), dimension ( 6 ), intent ( out ) :: rvf !! state vector at solution time !! T [km,km/s] real ( wp ), parameter :: onethird = 1.0_wp / 3.0_wp !! 0.333333 in original code integer :: iloop !! loop counter defining number of iterations real ( wp ) :: r !! radius at solution time `T` real ( wp ) :: r0 !! radius at solution time `T0` integer :: i !! index integer :: j !! index integer :: m !! counter for normalizing lambda real ( wp ) :: psi !! independent variable in Kepler's equation real ( wp ) :: psin !! lower limit to `psi` real ( wp ) :: psip !! upper limit to `psi` real ( wp ) :: dlim !! tau/periapsis distance = abs(limit to `psi`) real ( wp ) :: dtau !! Kepler's equation residual real ( wp ) :: dtaun !! lower limit to `dtau` real ( wp ) :: dtaup !! upper limit to `dtau` real ( wp ) :: accrcy !! accuracy = midval(zero, `accy`, 0.1) real ( wp ) :: sig0 !! dot product: `r` with `v` real ( wp ) :: alpha !! twice the energy per unit mass real ( wp ) :: h2 !! square of angular momentum per unit mass real ( wp ) :: a !! reduced argument of `s_0`, `s_1`, etc. real ( wp ) :: ap !! actual argument of `s_0`, `s_1`, etc. real ( wp ) :: c0 !! c(n) is the nth Goodyear polynomial `s_n` !! divided by its leading term, so that !! !! * `c0 = s_0 = cosh(z)` !! * `c1 = s_1/psi = sinh(z)/z` !! * `c(n+2) = (n+1)(n+2)[c(n)-1]/z&#94;2` !! !! where `z = psi*sqrt(alpha)`. `ap=norm2(z)` real ( wp ) :: c1 real ( wp ) :: c2 real ( wp ) :: c3 real ( wp ) :: c4 real ( wp ) :: c5x3 real ( wp ) :: s1 !! `s_n` is the nth Goodyear !! polynomial, given by !! `s_n = psi&#94;n sim{z&#94;(2k)/(2k)!} k >=0 ` real ( wp ) :: s2 real ( wp ) :: s3 real ( wp ) :: g !! the G-function real ( wp ) :: gdm1 !! time derivative of the G-function minus one real ( wp ) :: fm1 !! the F-function minus one real ( wp ) :: fd !! time derivative of the F-function real ( wp ), dimension ( 4 ) :: c !! terms in F(psi) accrcy = min ( max ( zero , accy ), 0.1_wp ) r0 = dot_product ( rv0 ( 1 : 3 ), rv0 ( 1 : 3 )) ! r dot r sig0 = dot_product ( rv0 ( 1 : 3 ), rv0 ( 4 : 6 )) ! r dot v alpha = dot_product ( rv0 ( 4 : 6 ), rv0 ( 4 : 6 )) ! v dot v h2 = max ( r0 * alpha - sig0 * sig0 , zero ) r0 = sqrt ( r0 ) alpha = alpha - two * mu / r0 !compute initial limits for phi and dtau: c0 = sqrt ( max ( mu * mu + h2 * alpha , zero )) ! gm * eccentricity dlim = div ( 1.1_wp * tau * ( c0 + mu ), h2 ) ! tau/periapsis distance = max(a). ! Arbitrary factor 1.1 ensures ! psin <= psi <= psip ! when converged, despite ! numerical imprecision. if ( tau < zero ) then psin = dlim psip = zero dtaun = psin dtaup = - tau else psin = zero psip = dlim dtaun = - tau dtaup = psip end if !compute initial value of psi: psi = tau / r0 if ( alpha >= zero ) then c2 = one if ( tau < zero ) c2 = - one c3 = abs ( tau ) if ( alpha > zero ) then c0 = h2 * sqrt ( h2 ) / ( mu + c0 ) ** 2 if ( c3 > c0 ) then c1 = sqrt ( alpha ) psi = log ( two * alpha * c1 * c3 / ( r0 * alpha + c2 * c1 * sig0 + mu )) psi = max ( psi , one ) * c2 / c1 end if else !parabola c0 = r0 * sqrt ( six * r0 / mu ) if ( c3 > c0 ) psi = c2 * ( six * c3 / mu ) ** onethird end if end if ! begin loop for solving Kepler's equation: m = 0 iloop = 0 do iloop = iloop + 1 ! begin series summation: !compute argument a in reduced series obtained by factoring out psi's: a = alpha * psi * psi if ( abs ( a ) > one ) then !save a in ap and mod a if a exceeds unity in magnitude ap = a do m = m + 1 a = a * 0.25_wp if ( abs ( a ) <= one ) exit end do end if !sum series c5x3=3*s5/psi**5 and c4=s4/psi**4 c4 = one c5x3 = one do i = 9 , 3 , - 1 j = 2 * i c5x3 = one + a * c5x3 / ( j * ( j + 1 )) c4 = one + a * c4 / ( j * ( j - 1 )) end do c5x3 = c5x3 / 4 0.0_wp c4 = c4 / 2 4.0_wp !compute series c3=s3/psi**3,c2=s2/psi**2,c1=s1/psi,c0=rv0 c3 = ( 0.5_wp + a * c5x3 ) / three c2 = 0.5_wp + a * c4 c1 = one + a * c3 c0 = one + a * c2 if ( m > 0 ) then !demod series c0 and c1 if necessary with double angle formulas: do c1 = c1 * c0 c0 = two * c0 * c0 - one m = m - 1 if ( m <= 0 ) exit end do !compute c2,c3,c4,c5x3 from c0,c1,ap if demod required: c2 = ( c0 - one ) / ap c3 = ( c1 - one ) / ap c4 = ( c2 - 0.5_wp ) / ap c5x3 = ( three * c3 - 0.5_wp ) / ap end if !compute series s1,s2,s3 from c1,c2,c3: s1 = c1 * psi s2 = c2 * psi * psi s3 = c3 * psi * psi * psi ! compute slope r and residuals for kepler's equation: c ( 1 ) = r0 * s1 c ( 2 ) = sig0 * s2 c ( 3 ) = mu * s3 c ( 4 ) = tau g = c ( 4 ) - c ( 3 ) dtau = c ( 1 ) + c ( 2 ) - g r = abs ( r0 * c0 + ( sig0 * s1 + mu * s2 )) ! compute next psi: do !method = 0 if ( dtau < zero ) then psin = psi dtaun = dtau psi = psi - dtau / r if ( psi < psip ) exit ! < (not <=) to avoid false convergence else psip = psi dtaup = dtau psi = psi - dtau / r if ( psi > psin ) exit ! > (not >=) to avoid false convergence end if !reset psi within bounds psin and psip: !try incrementing bound with dtau nearest zero by the ratio 4*dtau/tau !--method = 1 if ( abs ( dtaun ) < abs ( dtaup )) psi = psin * ( one - div ( four * dtaun , tau )) if ( abs ( dtaup ) < abs ( dtaun )) psi = psip * ( one - div ( four * dtaup , tau )) if ( psi_in ( psi )) exit !try doubling bound closest to zero: !--method = 2 if ( tau > zero ) psi = psin + psin if ( tau < zero ) psi = psip + psip if ( psi_in ( psi )) exit !try interpolating between bounds: !--method = 3 psi = psin + ( psip - psin ) * div ( - dtaun , dtaup - dtaun ) if ( psi_in ( psi )) exit !try halving between bounds: !--method = 4 psi = psin + ( psip - psin ) * 0.5_wp exit end do ! test for convergence i = 1 do j = 2 , 4 if ( abs ( c ( j )) > abs ( c ( i ))) i = j end do if ( abs ( dtau ) > abs ( c ( i )) * accrcy . and . & psip - psin > abs ( psi ) * accrcy . and . & psi /= psin . and . psi /= psip ) then cycle else exit end if end do !compute remaining three of four functions: g, gdm1, fm1, fd gdm1 = - mu * s2 / r fm1 = - mu * s2 / r0 fd = - mu * s1 / r0 / r ! compute state at time T = T0 + TAU rvf ( 1 : 3 ) = rv0 ( 1 : 3 ) + fm1 * rv0 ( 1 : 3 ) + g * rv0 ( 4 : 6 ) ! terminal positions rvf ( 4 : 6 ) = rv0 ( 4 : 6 ) + fd * rv0 ( 1 : 3 ) + gdm1 * rv0 ( 4 : 6 ) ! terminal velocities contains !******************************************************************************* !*************************************************************************** !> !  Returns a nonoverflowing quotient pure function div ( num , den ) implicit none real ( wp ) :: div real ( wp ), intent ( in ) :: num real ( wp ), intent ( in ) :: den real ( wp ), parameter :: fsmall = 1.0e-38_wp !! small number above underflow limit real ( wp ), parameter :: flarge = 1.0e+38_wp !! large number below underflow limit div = num / ( sign ( one , den ) * max ( abs ( den ), abs ( num ) / flarge , fsmall ) ) end function div !*************************************************************************** !*************************************************************************** !> !  Returns true if `phi` is within and not on bounds pure function psi_in ( psi ) implicit none logical :: psi_in real ( wp ), intent ( in ) :: psi ! > & < (not >= & <=) to avoid false convergence psi_in = ( psi > psin . and . psi < psip ) end function psi_in !*************************************************************************** end subroutine kepler_goodyear_stienon_klumpp !******************************************************************************* !******************************************************************************* end module kepler_module !*******************************************************************************","tags":"","url":"sourcefile/kepler_module.f90.html"},{"title":"crtbp_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~crtbp_module.f90~~EfferentGraph sourcefile~crtbp_module.f90 crtbp_module.f90 sourcefile~celestial_body_module.f90 celestial_body_module.f90 sourcefile~crtbp_module.f90->sourcefile~celestial_body_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~crtbp_module.f90->sourcefile~kind_module.f90 sourcefile~math_module.f90 math_module.f90 sourcefile~crtbp_module.f90->sourcefile~math_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~crtbp_module.f90->sourcefile~numbers_module.f90 sourcefile~celestial_body_module.f90->sourcefile~kind_module.f90 sourcefile~celestial_body_module.f90->sourcefile~numbers_module.f90 sourcefile~base_class_module.f90 base_class_module.f90 sourcefile~celestial_body_module.f90->sourcefile~base_class_module.f90 sourcefile~math_module.f90->sourcefile~kind_module.f90 sourcefile~math_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~crtbp_module.f90~~AfferentGraph sourcefile~crtbp_module.f90 crtbp_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~crtbp_module.f90 sourcefile~halo_orbit_module.f90 halo_orbit_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~halo_orbit_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~crtbp_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  This module contains various routines related to the !  Circular Restricted Three-Body Problem (CRTBP). module crtbp_module use kind_module , only : wp use numbers_module implicit none private public :: compute_crtpb_parameter public :: compute_jacobi_constant public :: crtbp_derivs public :: crtbp_derivs_with_stm public :: normalize_variables , unnormalize_variables public :: compute_libration_points , compute_libration_points_v2 public :: crtbp_test contains !******************************************************************************* !******************************************************************************* !> !  Compute  \\mu , the normalized CRTBP parameter. !  It is equal to  M_2 / (M_1 + M_2) . ! !@note The inputs can either be mu's or masses, !      as long are they are both the same units. pure function compute_crtpb_parameter ( mu1 , mu2 ) result ( mu ) implicit none real ( wp ), intent ( in ) :: mu1 !! grav param for body 1 [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: mu2 !! grav param for body 2 [km&#94;3/s&#94;2] real ( wp ) :: mu !! CRTBP parameter \\mu mu = mu2 / ( mu1 + mu2 ) end function compute_crtpb_parameter !******************************************************************************* !******************************************************************************* !> !  Convert state in km, km/s units to normalized CRTBP state. subroutine normalize_variables ( mu1 , mu2 , d12 , x , m , t , x_crtbp , m_crtbp , t_crtbp ) implicit none real ( wp ), intent ( in ) :: mu1 !! grav. param. of body 1  [\\mathrm{km}&#94;3/\\mathrm{s}&#94;2]  real ( wp ), intent ( in ) :: mu2 !! grav. param. of body 2  [\\mathrm{km}&#94;3/\\mathrm{s}&#94;2]  real ( wp ), intent ( in ) :: d12 !! distance between body 1 and body 2 [km] real ( wp ), dimension ( 6 ), intent ( in ), optional :: x !! unnormalized state w.r.t. barycenter [km,km/s] real ( wp ), intent ( in ), optional :: m !! unnormalized mass [kg] real ( wp ), intent ( in ), optional :: t !! unnormalized time [sec] real ( wp ), dimension ( 6 ), intent ( out ), optional :: x_crtbp !! CRTBP normalized state real ( wp ), intent ( out ), optional :: m_crtbp !! CRTBP normalized mass real ( wp ), intent ( out ), optional :: t_crtbp !! CRTBP normalized time real ( wp ) :: tp , n , tu , du , mu n = sqrt (( mu1 + mu2 ) / d12 ** 3 ) !mean motion (rad/sec) tu = one / n !time unit du = d12 !distance unit if ( present ( x ) . and . present ( x_crtbp )) then x_crtbp ( 1 : 3 ) = x ( 1 : 3 ) / du !scale distance x_crtbp ( 4 : 6 ) = x ( 4 : 6 ) / ( du / tu ) !scale velocity end if if ( present ( m ) . and . present ( m_crtbp )) then mu = ( mu1 + mu2 ) / universal_grav_constant !mass unit m_crtbp = m / mu !scale mass end if if ( present ( t ) . and . present ( t_crtbp )) t_crtbp = t / tu !scale time end subroutine normalize_variables !******************************************************************************* !******************************************************************************* !> !  Convert normalized CRTBP state to km, km/s units. ! !# Notes: ! ! See also: http://www.spaceatdia.org/uploads/mariano/ss1/2012SSLecture3.pdf ! !   m1 = one - mu   ! mass of body 1 !   m2 = mu         ! mass of body 2 ! !   x1 = -mu        ! location of body 1 !   x2 = one - mu   ! location of body 2 ! !   normalized mass     : 1 MU -> (m1 + m2) kg !   normalized position : 1 DU -> d12 km !   normalized time     : 1 TU -> 1/n sec !                         (2pi TU -> 1 rev -> 2pi/n) subroutine unnormalize_variables ( mu1 , mu2 , d12 , x_crtbp , m_crtbp , t_crtbp , x , m , t ) implicit none real ( wp ), intent ( in ) :: mu1 !! grav. param. of body 1  [\\mathrm{km}&#94;3/\\mathrm{s}&#94;2]  real ( wp ), intent ( in ) :: mu2 !! grav. param. of body 2  [\\mathrm{km}&#94;3/\\mathrm{s}&#94;2]  real ( wp ), intent ( in ) :: d12 !! distance between body 1 and body 2 [km] real ( wp ), dimension ( 6 ), intent ( in ), optional :: x_crtbp !! CRTBP normalized state real ( wp ), intent ( in ), optional :: m_crtbp !! CRTBP normalized mass real ( wp ), intent ( in ), optional :: t_crtbp !! CRTBP normalized time real ( wp ), dimension ( 6 ), intent ( out ), optional :: x !! unnormalized state w.r.t. barycenter [km,km/s] real ( wp ), intent ( out ), optional :: m !! unnormalized mass [kg] real ( wp ), intent ( out ), optional :: t !! unnormalized time [sec] real ( wp ) :: tp , n , tu , du , mu n = sqrt (( mu1 + mu2 ) / d12 ** 3 ) !mean motion (rad/sec) tu = one / n !time unit du = d12 !distance unit if ( present ( x ) . and . present ( x_crtbp )) then x ( 1 : 3 ) = x_crtbp ( 1 : 3 ) * du !unscale distance x ( 4 : 6 ) = x_crtbp ( 4 : 6 ) * ( du / tu ) !unscale velocity end if if ( present ( m ) . and . present ( m_crtbp )) then mu = ( mu1 + mu2 ) / universal_grav_constant !mass unit m = m_crtbp * mu !unscale mass end if if ( present ( t ) . and . present ( t_crtbp )) t = t_crtbp * tu !unscale time end subroutine unnormalize_variables !******************************************************************************* !******************************************************************************* !> !  Compute the CRTBP Jacobi constant, given the state. pure function compute_jacobi_constant ( mu , x ) result ( c ) implicit none real ( wp ), intent ( in ) :: mu !! CRTBP parameter (See [[compute_crtpb_parameter]]) real ( wp ), dimension ( 6 ), intent ( in ) :: x !! normalized state vector real ( wp ) :: c !! Jacobi constant !local variables: real , dimension ( 3 ) :: r , v , rb1 , rb2 real ( wp ) :: omm , r1 , r2 !extract variables from x vector: r = x ( 1 : 3 ) ! position v = x ( 4 : 6 ) ! velocity !other parameters: omm = one - mu rb1 = [ - mu , zero , zero ] ! location of body 1 rb2 = [ omm , zero , zero ] ! location of body 2 r1 = norm2 ( r - rb1 ) ! body1 -> sc distance r2 = norm2 ( r - rb2 ) ! body2 -> sc distance !compute Jacobi integral: ! [ See: http://cosweb1.fau.edu/~jmirelesjames/hw4Notes.pdf ] if ( r1 == zero . or . r2 == zero ) then c = huge ( one ) ! a large value else c = r ( 1 ) ** 2 + r ( 2 ) ** 2 + & two * omm / r1 + two * mu / r2 - & ( v ( 1 ) ** 2 + v ( 2 ) ** 2 + v ( 3 ) ** 2 ) end if end function compute_jacobi_constant !******************************************************************************* !******************************************************************************* !> !  Compute the coordinates of the libration points (L1,L2,L3,L4,L5). !  L1-L3 are computed using Newton's method. L4-L5 are known analytically. ! !@note The coordinate are w.r.t. the barycenter of the system. subroutine compute_libration_points ( mu , r1 , r2 , r3 , r4 , r5 ) use math_module , only : cube_root implicit none real ( wp ), intent ( in ) :: mu !! CRTBP parameter real ( wp ), intent ( out ), optional :: r1 !! L1 x coordinate real ( wp ), intent ( out ), optional :: r2 !! L2 x coordinate real ( wp ), intent ( out ), optional :: r3 !! L3 x coordinate real ( wp ), dimension ( 2 ), intent ( out ), optional :: r4 !! L4 [x,y] coordinates real ( wp ), dimension ( 2 ), intent ( out ), optional :: r5 !! L5 [x,y] coordinates integer :: i !! counter real ( wp ) :: f !! quintic function value (to be driven to zero) real ( wp ) :: fp !! derivative of quintic function real ( wp ) :: x !! indep. variable in the quintic functions integer , parameter :: maxiter = 100 !! maximum number of !! iterations for newton's method real ( wp ), parameter :: tol = 1.0e-12_wp !! convergence tolerance for !! newton's method !L1, L2, and L3 are solved using iterative Newton method: if ( present ( r1 )) then x = cube_root ( mu / ( 3.0_wp - 3.0_wp * mu )) !initial guess do i = 1 , maxiter f = x ** 5 - & ( 3.0_wp - mu ) * x ** 4 + & ( 3.0_wp - 2.0_wp * mu ) * x ** 3 - & mu * x ** 2 + & 2.0_wp * mu * x - & mu if ( abs ( f ) <= tol ) exit fp = 5.0_wp * x ** 4 - & 4.0_wp * x ** 3 * ( 3.0_wp - mu ) + & 3.0_wp * x ** 2 * ( 3.0_wp - 2.0_wp * mu ) - & 2.0_wp * x * mu + & 2.0_wp * mu x = x - f / fp end do r1 = 1.0_wp - x ! wrt primary body r1 = r1 - mu ! wrt barycenter end if if ( present ( r2 )) then x = cube_root ( mu / ( 3.0_wp - 3.0_wp * mu )) !initial guess do i = 1 , maxiter f = x ** 5 + & ( 3.0_wp - mu ) * x ** 4 + & ( 3.0_wp - 2.0_wp * mu ) * x ** 3 - & mu * x ** 2 - & 2.0_wp * mu * x - & mu if ( abs ( f ) <= tol ) exit fp = 5.0_wp * x ** 4 + & 4.0_wp * x ** 3 * ( 3.0_wp - mu ) + & 3.0_wp * x ** 2 * ( 3.0_wp - 2.0_wp * mu ) - & 2.0_wp * x * mu - & 2.0_wp * mu x = x - f / fp end do r2 = 1.0_wp + x ! wrt primary body r2 = r2 - mu ! wrt barycenter end if if ( present ( r3 )) then x = - ( 7.0_wp / 1 2.0_wp ) * mu !initial guess do i = 1 , maxiter f = x ** 5 + & ( 7.0_wp + mu ) * x ** 4 + & ( 1 9.0_wp + 6.0_wp * mu ) * x ** 3 + & ( 2 4.0_wp + 1 3.0_wp * mu ) * x ** 2 + & 2.0_wp * ( 6.0_wp + 7.0_wp * mu ) * x + & 7.0_wp * mu if ( abs ( f ) <= tol ) exit fp = 5.0_wp * x ** 4 + & 4.0_wp * x ** 3 * ( 7.0_wp + mu ) + & 3.0_wp * x ** 2 * ( 1 9.0_wp + 6.0_wp * mu ) + & 2.0_wp * x * ( 2 4.0_wp + 1 3.0_wp * mu ) + & 2.0_wp * ( 6.0_wp + 7.0_wp * mu ) x = x - f / fp end do r3 = - ( x + 1.0_wp ) ! wrt primary body r3 = r3 - mu ! wrt barycenter end if ! L4 and L5 are analytic: if ( present ( r4 )) r4 = [ 0.5_wp - mu , sqrt ( 3.0_wp ) / 2.0_wp ] if ( present ( r5 )) r5 = [ 0.5_wp - mu , - sqrt ( 3.0_wp ) / 2.0_wp ] end subroutine compute_libration_points !******************************************************************************* !******************************************************************************* !> !  Compute the coordinates of the libration points (L1,L2,L3,L4,L5). ! !  This is just an alternate version of [[compute_libration_points]]. ! !### Reference !  * J.S. Parker, R.L. Anderson, \"Low-Energy Lunar Trajectory Design\", 2014. !   (Appendix A.5) ! !@note The coordinate are w.r.t. the barycenter of the system. subroutine compute_libration_points_v2 ( mu , r1 , r2 , r3 , r4 , r5 ) use math_module , only : cube_root implicit none real ( wp ), intent ( in ) :: mu !! CRTBP parameter real ( wp ), intent ( out ), optional :: r1 !! L1 x coordinate real ( wp ), intent ( out ), optional :: r2 !! L2 x coordinate real ( wp ), intent ( out ), optional :: r3 !! L3 x coordinate real ( wp ), dimension ( 2 ), intent ( out ), optional :: r4 !! L4 [x,y] coordinates real ( wp ), dimension ( 2 ), intent ( out ), optional :: r5 !! L5 [x,y] coordinates integer , parameter :: maxiter = 100 !! maximum number of iterations real ( wp ), parameter :: tol = 1.0e-12_wp !! convergence tolerance real ( wp ) :: gamma , gamma0 integer :: i !! counter if ( present ( r1 )) then gamma0 = cube_root ( mu * ( one - mu ) / three ) gamma = gamma0 + one do i = 1 , maxiter if ( abs ( gamma - gamma0 ) <= tol ) exit gamma0 = gamma gamma = cube_root (( mu * ( gamma0 - one ) ** 2 ) / ( three - two * mu - gamma0 * ( three - mu - gamma0 ))) end do r1 = one - mu - gamma end if if ( present ( r2 )) then gamma0 = cube_root ( mu * ( one - mu ) / three ) gamma = gamma0 + one do i = 1 , maxiter if ( abs ( gamma - gamma0 ) <= tol ) exit gamma0 = gamma gamma = cube_root (( mu * ( gamma0 + one ) ** 2 ) / ( three - two * mu + gamma0 * ( three - mu + gamma0 ))) end do r2 = one - mu + gamma end if if ( present ( r3 )) then gamma0 = cube_root ( mu * ( one - mu ) / three ) gamma = gamma0 + one do i = 1 , maxiter if ( abs ( gamma - gamma0 ) <= tol ) exit gamma0 = gamma gamma = cube_root (( one - mu ) * ( gamma0 + one ) ** 2 / ( one + two * mu + gamma0 * ( two + mu + gamma0 ))) end do r3 = - mu - gamma end if call compute_libration_points ( mu , r4 = r4 , r5 = r5 ) end subroutine compute_libration_points_v2 !******************************************************************************* !******************************************************************************* !> !  CRTBP derivatives: state only. subroutine crtbp_derivs ( mu , x , dx ) implicit none real ( wp ), intent ( in ) :: mu !! CRTBP parameter (See [[compute_crtpb_parameter]]) real ( wp ), dimension ( 6 ), intent ( in ) :: x !! normalized state [\\mathbf{r},\\mathbf{v}] real ( wp ), dimension ( 6 ), intent ( out ) :: dx !! normalized state derivative [\\dot{\\mathbf{r}},\\dot{\\mathbf{v}}] !local variables: real ( wp ), dimension ( 3 ) :: r1 , r2 , rb1 , rb2 , r , v , g real ( wp ) :: r13 , r23 , omm , c1 , c2 !extract variables from x vector: r = x ( 1 : 3 ) ! position v = x ( 4 : 6 ) ! velocity !other parameters: omm = one - mu rb1 = [ - mu , zero , zero ] ! location of body 1 rb2 = [ omm , zero , zero ] ! location of body 2 r1 = r - rb1 ! body1 -> sc vector r2 = r - rb2 ! body2 -> sc vector r13 = norm2 ( r1 ) ** 3 r23 = norm2 ( r2 ) ** 3 c1 = omm / r13 c2 = mu / r23 !normalized gravity from both bodies: g ( 1 ) = - c1 * ( r ( 1 ) + mu ) - c2 * ( r ( 1 ) - one + mu ) g ( 2 ) = - c1 * r ( 2 ) - c2 * r ( 2 ) g ( 3 ) = - c1 * r ( 3 ) - c2 * r ( 3 ) ! derivative of x: dx ( 1 : 3 ) = v ! rdot dx ( 4 ) = two * v ( 2 ) + r ( 1 ) + g ( 1 ) ! vdot dx ( 5 ) = - two * v ( 1 ) + r ( 2 ) + g ( 2 ) ! dx ( 6 ) = g ( 3 ) ! end subroutine crtbp_derivs !******************************************************************************* !******************************************************************************* !> !  CRTBP derivatives: state + state transition matrix. subroutine crtbp_derivs_with_stm ( mu , x , dx ) implicit none real ( wp ), intent ( in ) :: mu !! CRTBP parameter (See [[compute_crtpb_parameter]]) real ( wp ), dimension ( 42 ), intent ( in ) :: x !! normalized state and STM [\\mathbf{r},\\mathbf{v},\\mathbf{\\Phi}] real ( wp ), dimension ( 42 ), intent ( out ) :: dx !! normalized state and STM derivative [\\dot{\\mathbf{r}},\\dot{\\mathbf{v}},\\dot{\\mathbf{\\Phi}}] !local variables: real , dimension ( 3 ) :: rb1 , rb2 , r , v , g real ( wp ), dimension ( 6 , 6 ) :: A , phi , phi_dot real ( wp ) :: r1 , r2 , r13 , r23 , r15 , r25 , omm , tmu , tomm , c1 , c2 real ( wp ) :: Uxx , Uxy , Uxz , Uyx , Uyy , Uyz , Uzx , Uzy , Uzz !extract variables from x vector: r = x ( 1 : 3 ) ! position v = x ( 4 : 6 ) ! velocity !other parameters: omm = one - mu rb1 = [ - mu , zero , zero ] ! location of body 1 rb2 = [ omm , zero , zero ] ! location of body 2 r1 = norm2 ( r - rb1 ) ! body1 -> sc distance r2 = norm2 ( r - rb2 ) ! body2 -> sc distance r13 = r1 ** 3 r23 = r2 ** 3 r15 = r1 ** 5 r25 = r2 ** 5 c1 = omm / r13 c2 = mu / r23 tmu = three * mu tomm = three * omm !normalized gravity from both bodies: g ( 1 ) = - c1 * ( r ( 1 ) + mu ) - c2 * ( r ( 1 ) - one + mu ) g ( 2 ) = - c1 * r ( 2 ) - c2 * r ( 2 ) g ( 3 ) = - c1 * r ( 3 ) - c2 * r ( 3 ) !STM terms: Uxx = one - c1 - c2 + tomm * ( r ( 1 ) + mu ) ** 2 / r15 + tmu * ( r ( 1 ) - one + mu ) ** 2 / r25 Uyy = one - c1 - c2 + tomm * r ( 2 ) ** 2 / r15 + tmu * r ( 2 ) ** 2 / r25 Uzz = c1 - c2 + tomm * r ( 3 ) ** 2 / r15 + tmu * r ( 3 ) ** 2 / r25 Uxy = tomm * ( r ( 1 ) + mu ) * r ( 2 ) / r15 + tmu * ( r ( 1 ) - one + mu ) * r ( 2 ) / r25 Uxz = tomm * ( r ( 1 ) + mu ) * r ( 3 ) / r15 + tmu * ( r ( 1 ) - one + mu ) * r ( 3 ) / r25 Uyz = tomm * r ( 2 ) * r ( 3 ) / r15 + tmu * r ( 2 ) * r ( 3 ) / r25 Uyx = Uxy Uzx = Uxz Uzy = Uyz !columns of A matrix: A (:, 1 ) = [ zero , zero , zero , Uxx , Uyx , Uzx ] A (:, 2 ) = [ zero , zero , zero , Uxy , Uyy , Uzy ] A (:, 3 ) = [ zero , zero , zero , Uxz , Uyz , Uzz ] A (:, 4 ) = [ one , zero , zero , zero , - two , zero ] A (:, 5 ) = [ zero , one , zero , two , zero , zero ] A (:, 6 ) = [ zero , zero , one , zero , zero , zero ] !unpack phi into matrix: phi = reshape ( x ( 7 : 42 ), shape = [ 6 , 6 ]) !derivative of phi matrix: phi_dot = matmul ( A , phi ) !derivative of x vector: dx ( 1 : 3 ) = v ! r_dot dx ( 4 ) = two * v ( 2 ) + r ( 1 ) + g ( 1 ) ! v_dot dx ( 5 ) = - two * v ( 1 ) + r ( 2 ) + g ( 2 ) ! dx ( 6 ) = g ( 3 ) ! dx ( 7 : 42 ) = pack ( phi_dot , mask = . true .) ! phi_dot end subroutine crtbp_derivs_with_stm !******************************************************************************* !******************************************************************************* !> !  Unit tests for CRTBP routines. subroutine crtbp_test () use celestial_body_module implicit none real ( wp ), parameter :: mu_earth = body_earth % mu !!  \\mu_{Earth} ~ (\\mathrm{km}&#94;3/\\mathrm{s}&#94;2)  real ( wp ), parameter :: mu_moon = body_moon % mu !!  \\mu_{Moon}  ~ (\\mathrm{km}&#94;3/\\mathrm{s}&#94;2)  real ( wp ), parameter :: mu_sun = body_sun % mu !!  \\mu_{Sun}   ~ (\\mathrm{km}&#94;3/\\mathrm{s}&#94;2)  !< sample state (normalized) !< see: [Celestial Mechanics Notes Set 4: The Circular Restricted !< Three Body Problem](http://cosweb1.fau.edu/~jmirelesjames/hw4Notes.pdf), p.40. real ( wp ), dimension ( 6 ), parameter :: x = [ 0.30910452642073_wp , & 0.07738174525518_wp , & 0.0_wp , & - 0.72560796964234_wp , & 1.55464233412773_wp , & 0.0_wp ] integer :: i !! counter real ( wp ) :: mu !! CRTPB parameter real ( wp ) :: mu1 !! primary body mu real ( wp ) :: mu2 !! secondary body mu real ( wp ) :: c !! Jacobi constant real ( wp ), dimension ( 6 ) :: xd !! derivative vector: state real ( wp ), dimension ( 42 ) :: x_phi !! initial state + phi (identity) real ( wp ), dimension ( 42 ) :: x_phi_d !! derivative vector: state + phi real ( wp ), dimension ( 6 , 6 ) :: eye !! 6x6 identity matrix real ( wp ) :: r1 !! L1 x coordinate (normalized) real ( wp ) :: r2 !! L2 x coordinate (normalized) real ( wp ) :: r3 !! L3 x coordinate (normalized) real ( wp ), dimension ( 2 ) :: r4 !! L4 x coordinate (normalized) real ( wp ), dimension ( 2 ) :: r5 !! L5 x coordinate (normalized) !create an identity matrix for stm initial condition: eye = zero do i = 1 , 6 eye ( i , i ) = one end do x_phi = [ x , pack ( eye , mask = . true .)] write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' crtbp_test' write ( * , * ) '---------------' write ( * , * ) '' do i = 1 , 3 select case ( i ) case ( 1 ) mu1 = mu_earth mu2 = mu_moon case ( 2 ) mu1 = mu_earth mu2 = mu_earth case ( 3 ) mu1 = mu_earth + mu_moon / four mu2 = mu_earth end select write ( * , * ) '' mu = compute_crtpb_parameter ( mu1 , mu2 ) c = compute_jacobi_constant ( mu , x ) call crtbp_derivs ( mu , x , xd ) call crtbp_derivs_with_stm ( mu , x_phi , x_phi_d ) call compute_libration_points ( mu , r1 , r2 , r3 , r4 , r5 ) write ( * , '(A,1X,*(F30.16,1X))' ) 'mu:         ' , mu write ( * , '(A,1X,*(F30.16,1X))' ) 'L1 x:       ' , r1 write ( * , '(A,1X,*(F30.16,1X))' ) 'L2 x:       ' , r2 write ( * , '(A,1X,*(F30.16,1X))' ) 'L3 x:       ' , r3 write ( * , '(A,1X,*(F30.16,1X))' ) 'L4 x:       ' , r4 write ( * , '(A,1X,*(F30.16,1X))' ) 'L5 x:       ' , r5 write ( * , '(A,1X,*(F30.16,1X))' ) 'x:          ' , x write ( * , '(A,1X,*(F30.16,1X))' ) 'c:          ' , c write ( * , '(A,1X,*(F30.16,1X))' ) 'xd:         ' , xd write ( * , '(A,1X,*(F30.16,1X))' ) 'x+phi:      ' , x_phi write ( * , '(A,1X,*(F30.16,1X))' ) 'xd+phi_dot: ' , x_phi_d write ( * , * ) '' call compute_libration_points_v2 ( mu , r1 , r2 , r3 , r4 , r5 ) write ( * , * ) '' write ( * , * ) 'alternate formulation:' write ( * , '(A,1X,*(F30.16,1X))' ) 'L1 x:       ' , r1 write ( * , '(A,1X,*(F30.16,1X))' ) 'L2 x:       ' , r2 write ( * , '(A,1X,*(F30.16,1X))' ) 'L3 x:       ' , r3 write ( * , '(A,1X,*(F30.16,1X))' ) 'L4 x:       ' , r4 write ( * , '(A,1X,*(F30.16,1X))' ) 'L5 x:       ' , r5 write ( * , * ) '' end do end subroutine crtbp_test !******************************************************************************* !******************************************************************************* end module crtbp_module !*******************************************************************************","tags":"","url":"sourcefile/crtbp_module.f90.html"},{"title":"gooding_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~gooding_module.f90~~EfferentGraph sourcefile~gooding_module.f90 gooding_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~gooding_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~gooding_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~gooding_module.f90~~AfferentGraph sourcefile~gooding_module.f90 gooding_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~gooding_module.f90 sourcefile~lambert_module.f90 lambert_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lambert_module.f90 sourcefile~lambert_module.f90->sourcefile~gooding_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Gooding's Kepler and universal elements conversion routines. ! !# Notes !  The Gooding universal elements are: ! !   * `alpha` - mu/a [km&#94;2/s&#94;2] !   * `rp`    - periapsis radius [km] !   * `inc`   - inclination [rad] !   * `raan`  - right ascension of the ascending node [rad] !   * `w`     - argument of periapsis [rad] !   * `tau`   - time since last periapsis passage [sec] ! !# References !  1. A. W. Odell, R. H. Gooding, \"Procedures for solving Kepler's equation\" !     Celestial Mechanics 38 (1986), 307-334. !  2. R. H. Gooding, \"On universal elements, and conversion procedures !     to and from position and velocity\" !     Celestial Mechanics 44 (1988), 283-298. !  3. R. H. Gooding, A. W. Odell. \"The hyperbolic Kepler equation !     (and the elliptic equation revisited)\" !     Celestial Mechanics 44 (1988), 267-282. module gooding_module use kind_module , only : wp use numbers_module implicit none private !constants: real ( wp ), parameter :: ntwo = - two real ( wp ), parameter :: pineg = - pi real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: athird = one / three real ( wp ), parameter :: asixth = one / six public :: els3pv , pv3els public :: ekepl , ekepl1 , ekepl2 , emkepl , emkep , shkepl , shmkep public :: propagate contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Basic two-body propagator using the Gooding universal element routines. pure subroutine propagate ( mu , rv0 , dt , rvf ) implicit none real ( wp ), intent ( in ) :: mu !! grav. parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 6 ), intent ( in ) :: rv0 !! initial state [km, km/s] real ( wp ), intent ( in ) :: dt !! time step [sec] real ( wp ), dimension ( 6 ), intent ( out ) :: rvf !! final state [km, km/s] real ( wp ), dimension ( 6 ) :: e !convert to elements, increment time, ! then convert back to cartesian: call pv3els ( mu , rv0 , e ) e ( 6 ) = e ( 6 ) + dt call els3pv ( mu , e , rvf ) end subroutine propagate !***************************************************************************************** !***************************************************************************************** !> !  Kepler's equation, `em = ekepl - (1 - e1)*sin(ekepl)`, !  with `e1` in range 1 to 0 inclusive, solved accurately !  (based on ekepl3, but entering `e1`, not `e`) pure function ekepl ( em , e1 ) implicit none real ( wp ) :: ekepl real ( wp ), intent ( in ) :: em real ( wp ), intent ( in ) :: e1 real ( wp ) :: emr , ee , e , w , fdd , fddd , f , fd , dee integer :: iter real ( wp ), parameter :: sw = 0.25_wp !range-reduce em to lie in range -pi to pi emr = mod ( em , twopi ) if ( emr < pineg ) emr = emr + twopi if ( emr > pi ) emr = emr - twopi ee = emr if ( ee /= zero ) then if ( ee < zero ) ee = - ee !(emr is range-reduced em & ee is absolute value of emr) !starter by first solving cubic equation e = one - e1 w = dcbsol ( e , two * e1 , three * ee ) !effectively interpolate in emr (absolute value) ee = ( ee * ee + ( pi - ee ) * w ) / pi if ( emr < zero ) ee = - ee !do two iterations of halley, each followed by newton do iter = 1 , 2 fdd = e * sin ( ee ) fddd = e * cos ( ee ) if ( ee * ee / six + e1 >= sw ) then f = ( ee - fdd ) - emr fd = one - fddd else f = emkep ( e1 , ee ) - emr fd = two * e * sin ( half * ee ) ** 2 + e1 end if dee = f * fd / ( half * f * fdd - fd * fd ) f = f + dee * ( fd + half * dee * ( fdd + athird * dee * fddd )) !to reduce the danger of underflow replace the last line by !    w = fd + half*dee*(fdd + athird*dee*fddd) fd = fd + dee * ( fdd + half * dee * fddd ) ee = ee + dee - f / fd !if replacing as above, then also replace the last line by !ee = ee - (f - dee*(fd - w))/fd end do end if !range-expand ekepl = ee + ( em - emr ) end function ekepl !***************************************************************************************** !***************************************************************************************** !> !  Solve kepler's equation, `em = ekepl - e*sin(ekepl)`, !  with legendre-based starter and halley iterator !  (function has also been used under the name eafkep) pure function ekepl1 ( em , e ) implicit none real ( wp ) :: ekepl1 real ( wp ), intent ( in ) :: em real ( wp ), intent ( in ) :: e real ( wp ) :: c , s , psi , xi , eta , fd , fdd , f real ( wp ), parameter :: testsq = 1.0e-8_wp c = e * cos ( em ) s = e * sin ( em ) psi = s / sqrt ( one - c - c + e * e ) do xi = cos ( psi ) eta = sin ( psi ) fd = ( one - c * xi ) + s * eta fdd = c * eta + s * xi f = psi - fdd psi = psi - f * fd / ( fd * fd - half * f * fdd ) if ( f * f < testsq ) exit end do ekepl1 = em + psi end function ekepl1 !***************************************************************************************** !***************************************************************************************** !> !  Kepler's equation, `em = ekepl - e*sin(ekepl)` with !  e in range 0 to 1 inclusive, solved accurately pure function ekepl2 ( em , e ) implicit none real ( wp ) :: ekepl2 real ( wp ), intent ( in ) :: em real ( wp ), intent ( in ) :: e real ( wp ) :: emr , ee , w , e1 , fdd , fddd , f , fd , dee logical :: l integer :: iter real ( wp ), parameter :: sw = 0.1_wp real ( wp ), parameter :: a = ( pi - one ) ** 2 / ( pi + two / three ) real ( wp ), parameter :: b = two * ( pi - asixth ) ** 2 / ( pi + two / three ) !range-reduce em to line in range -pi to pi emr = mod ( em , twopi ) if ( emr < pineg ) emr = emr + twopi if ( emr > pi ) emr = emr - twopi ee = emr if ( ee /= zero ) then if ( ee < zero ) ee = - ee !(emr is range-reduced em & ee is absolute value of emr) !started for e = 1 by cube root of bilinear function if ( ee < asixth ) then ee = ( six * ee ) ** athird else w = pi - ee ee = pi - a * w / ( b - w ) end if if ( emr < zero ) ee = - ee !interpolate for e ee = emr + ( ee - emr ) * e !do two iterations of halley, each followed by newton e1 = one - e l = ( e1 + ee * ee / six ) >= sw do iter = 1 , 2 fdd = e * sin ( ee ) fddd = e * cos ( ee ) if ( l ) then f = ( ee - fdd ) - emr fd = one - fddd else f = emkepl ( e , ee ) - emr fd = e1 + two * e * sin ( half * ee ) ** 2 end if dee = f * fd / ( half * f * fdd - fd * fd ) f = f + dee * ( fd + half * dee * ( fdd + athird * dee * fddd )) !to reduce the danger of underflow replace the last line by !w = fd + half*dee*(fdd + athird*dee*fddd) fd = fd + dee * ( fdd + half * dee * fddd ) ee = ee + dee - f / fd !if replacing as above, then also replace the last line by !ee = ee - (f - dee*(fd - w))/fd end do end if !range-expand ekepl2 = ee + ( em - emr ) end function ekepl2 !***************************************************************************************** !***************************************************************************************** !> !  Accurate computation of `ee - e*sin(ee)` !  when (e, ee) is close to (1, 0) ! !@note must not be used for large ee (absolute) !      as then rounding worse not better pure function emkepl ( e , ee ) implicit none real ( wp ) :: emkepl real ( wp ), intent ( in ) :: e real ( wp ), intent ( in ) :: ee real ( wp ) :: x , ee2 , term , d , x0 x = ( one - e ) * sin ( ee ) ee2 = - ee * ee term = ee d = zero do d = d + two term = term * ee2 / ( d * ( d + one )) x0 = x x = x - term if ( x == x0 ) exit end do emkepl = x end function emkepl !***************************************************************************************** !***************************************************************************************** !> !  Similar to emkepl, except input is `1-e`. pure function emkep ( e1 , ee ) implicit none real ( wp ) :: emkep real ( wp ), intent ( in ) :: e1 real ( wp ), intent ( in ) :: ee real ( wp ) :: x , ee2 , term , d , x0 x = e1 * sin ( ee ) ee2 = - ee * ee term = ee d = zero do d = d + two term = term * ee2 / ( d * ( d + one )) x0 = x x = x - term if ( x == x0 ) exit end do emkep = x end function emkep !***************************************************************************************** !***************************************************************************************** !> !  Equation `el = shkepl + (g1 - 1)*asinh(shkepl)`, !  with g1 in range 0 to 1 inclusive, solved accurately. pure function shkepl ( el , g1 ) implicit none real ( wp ) :: shkepl real ( wp ), intent ( in ) :: el real ( wp ), intent ( in ) :: g1 real ( wp ) :: s , g , cl , al , w , s0 , s1 , s2 , s3 , fdd , fddd , f , fd , ds , stemp integer :: iter real ( wp ), parameter :: sw = half s = el if ( el /= zero ) then !started based on lagrange's theorem g = one - g1 cl = sqrt ( one + el ** 2 ) al = asinh ( el ) w = g ** 2 * al / cl ** 3 s = one - g / cl s = el + g * al / dcubrt ( s ** 3 + w * el * ( 1.5_wp - g / 0.75_wp )) !two iterations (at most) of halley-then-newton process do iter = 1 , 2 s0 = s * s s1 = s0 + one s2 = sqrt ( s1 ) s3 = s1 * s2 fdd = g * s / s3 fddd = g * ( one - two * s0 ) / ( s1 * s3 ) if ( asixth * s0 + g1 >= sw ) then f = ( s - g * asinh ( s )) - el fd = one - g / s2 else f = shmkep ( g1 , s ) - el fd = ( s0 / ( s2 + one ) + g1 ) / s2 end if ds = f * fd / ( half * f * fdd - fd * fd ) stemp = s + ds if ( stemp == s ) exit f = f + ds * ( fd + half * ds * ( fdd + athird * ds * fddd )) fd = fd + ds * ( fdd + half * ds * fddd ) s = stemp - f / fd end do end if shkepl = s end function shkepl !***************************************************************************************** !***************************************************************************************** !> !  Accurate computation of `s - (1 - g1)*asinh(s)` !  when (g1, s) is close to (0, 0) pure function shmkep ( g1 , s ) implicit none real ( wp ) :: shmkep real ( wp ), intent ( in ) :: g1 real ( wp ), intent ( in ) :: s real ( wp ) :: g , t , tsq , x , term , twoi1 , x0 g = one - g1 t = s / ( one + sqrt ( one + s * s )) tsq = t * t x = s * ( g1 + g * tsq ) term = two * g * t twoi1 = one do twoi1 = twoi1 + two term = term * tsq x0 = x x = x - term / twoi1 if ( x == x0 ) exit end do shmkep = x end function shmkep !***************************************************************************************** !***************************************************************************************** !> !  Algorithm for two-dimensional conversion !  from orbital elements to position and velocity. pure subroutine els2pv ( gm , al , q , om , tau , r , u , vr , vt ) implicit none real ( wp ), intent ( in ) :: gm !! grav. parameter [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: al !! alpha [km&#94;2/s&#94;2] real ( wp ), intent ( in ) :: q !! periapsis distance [km] real ( wp ), intent ( in ) :: om !! argument of periapsis relative to assumed reference direction [rad] real ( wp ), intent ( in ) :: tau !! time from periapsis [sec] real ( wp ), intent ( out ) :: r !! radial distance [km] real ( wp ), intent ( out ) :: u !! angle from reference direction [rad] real ( wp ), intent ( out ) :: vr !! radial velocity [km/2] real ( wp ), intent ( out ) :: vt !! transverse velocity >=0 [km/s] real ( wp ) :: d , h , v , e1 , e , ep1 , alp , rtal , em , ee2 , s2 , c2 , emv , s , c if ( al == zero ) then !(parabola - gm cannot be zero) d = dcbsol ( half / gm , q , 1.5_wp * gm * tau ) r = q + half * d * d / gm h = sqrt ( two * gm * q ) v = two * atan2 ( d , h ) else !(ellipse or hyperbola) e1 = al * q e = gm - e1 ep1 = gm + e h = sqrt ( q * ep1 ) alp = abs ( al ) rtal = sqrt ( alp ) !(last 6 items could be saved if repeating gm, al & q) em = tau * alp * rtal if ( al > zero ) then !(ellipse - gm cannot be zero) ! make sure e1 argument to ekepl is between [0,1] ee2 = half * ekepl ( em / gm , max ( zero , min ( one , e1 / gm ))) s2 = sin ( ee2 ) c2 = cos ( ee2 ) r = q + two * e * s2 * s2 / al d = two * e * s2 * c2 / rtal v = two * atan2 ( ep1 * s2 , h * rtal * c2 ) emv = em / gm - v v = v + fourpi * sign ( real ( int ( abs ( emv / fourpi ) + half ), wp ), emv ) else !(hyperbola) s = shkepl ( em / e , - e1 / e ) s2 = s * s c = sqrt ( one + s2 ) s2 = s2 / ( c + one ) r = q - e * s2 / al d = e * s / rtal v = atan2 ( s * h * rtal , - gm * s2 - e1 ) end if end if !(all orbits) u = om + v vr = d / r vt = h / r end subroutine els2pv !***************************************************************************************** !***************************************************************************************** !> !  Algorithm for three-dimensional conversion !  from orbital elements to position and velocity pure subroutine els3pv ( gm , e , pv ) implicit none real ( wp ), intent ( in ) :: gm !! grav. parameter [km&#94;3/sec&#94;2] real ( wp ), dimension ( 6 ), intent ( in ) :: e !! [al, q, ei, bom, om, tau] real ( wp ), dimension ( 6 ), intent ( out ) :: pv !! [x, y, z, xdot, ydot, zdot] real ( wp ) :: x , y , z , xdot , ydot , zdot , al , q , ei , bom , om , tau real ( wp ) :: r , u , vr , vt , c , s , x1 , x2 , y1 , y2 if ( all ( e == zero )) then pv = zero else al = e ( 1 ) q = e ( 2 ) ei = e ( 3 ) bom = e ( 4 ) om = e ( 5 ) tau = e ( 6 ) call els2pv ( gm , al , q , om , tau , r , u , vr , vt ) c = cos ( u ) s = sin ( u ) x1 = r * c y1 = r * s x2 = vr * c - vt * s y2 = vr * s + vt * c c = cos ( ei ) s = sin ( ei ) z = y1 * s y1 = y1 * c zdot = y2 * s y2 = y2 * c c = cos ( bom ) s = sin ( bom ) x = x1 * c - y1 * s y = x1 * s + y1 * c xdot = x2 * c - y2 * s ydot = x2 * s + y2 * c pv ( 1 ) = x pv ( 2 ) = y pv ( 3 ) = z pv ( 4 ) = xdot pv ( 5 ) = ydot pv ( 6 ) = zdot end if end subroutine els3pv !***************************************************************************************** !***************************************************************************************** !> !  Algorithm for two-dimensional conversion !  from position and velocity to orbital elements. pure subroutine pv2els ( gm , r , u , vr , vt , al , q , om , tau ) implicit none real ( wp ), intent ( in ) :: gm !! grav. parameter [km&#94;3/s&#94;2] real ( wp ), intent ( in ) :: r !! radial distance [km] real ( wp ), intent ( in ) :: u !! angle from assumed reference direction [rad] real ( wp ), intent ( in ) :: vr !! radial velocity [km/2] real ( wp ), intent ( in ) :: vt !! transverse velocity >=0 [km/s] real ( wp ), intent ( out ) :: al !! alpha: gm/a [km&#94;2/s&#94;2] real ( wp ), intent ( out ) :: q !! periapsis distance [km] real ( wp ), intent ( out ) :: om !! argument of periapsis relative to reference direction [rad] real ( wp ), intent ( out ) :: tau !! time from periapsis [sec] real ( wp ) :: esq1 , es , eses , ec , ecec , esq , e , v , e1 real ( wp ) :: eh , em , ecesq , en , adj , vsq , rtal , d , h , p , alp real ( wp ), parameter :: sw = 0.25_wp logical , parameter :: l = . false . !(all orbits) vsq = vr * vr + vt * vt al = two * gm / r - vsq alp = abs ( al ) rtal = sqrt ( alp ) d = r * vr h = r * vt p = h * h esq1 = p * al es = d * rtal eses = es * es ec = r * vsq - gm ecec = ec * ec if ( al > zero ) then !(one esq formula superior for the ellipse) esq = ecec + eses else !(different formula superior for the hyperbola) esq = gm * gm - esq1 end if e = sqrt ( esq ) q = p / ( gm + e ) if ( al == zero ) then !(parabola) tau = d * ( two * q + r ) / ( three * gm ) v = two * atan2 ( vr , vt ) else if ( e == zero ) then !(circle) tau = zero v = zero else !(ellipse or hyperbola) e1 = al * q if ( al > zero ) then !(ellipse) eh = atan2 ( es , ec ) if ( gm * eh * eh / six + e1 >= gm * sw ) then !(general case) em = gm * eh - es ecesq = gm * ec - esq else !(for e1 & eh both near zero) em = gm * emkep ( e1 / gm , eh ) ecesq = ( esq1 * ecec - esq * eses ) / ( esq + gm * ec ) end if else !(hyperbola) eh = asinh ( es / e ) if ( gm * eh * eh / six - e1 >= gm * sw ) then !(general case) em = es - gm * eh ecesq = esq - gm * ec else !(for e1 & eh both near zero) em = e * shmkep ( - e1 / e , es / e ) ecesq = - ( esq1 * ecec + esq * eses ) / ( esq + gm * ec ) end if end if !(ellipse or hyperbola still) en = alp * rtal tau = em / en v = atan2 ( es * h * rtal , ecesq ) end if !(all orbits) om = u - v ! !  note: the following is never executed... set l=true and test... ! if ( l . and . al > zero ) then !(for ellipse, adjust revolutions if required (using l)) adj = twopi * sign ( real ( int ( abs ( om / twopi ) + half ), wp ), om ) om = om - adj tau = tau + adj / en end if end subroutine pv2els !***************************************************************************************** !***************************************************************************************** !> !  Algorithm for three-dimensional conversion !  from position and velocity to orbital elements. pure subroutine pv3els ( gm , pv , e ) implicit none real ( wp ), intent ( in ) :: gm !! grav. parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 6 ), intent ( in ) :: pv !! [x, y, z, xdot, ydot, zdot] real ( wp ), dimension ( 6 ), intent ( out ) :: e !! [al, q, ei, bom, om, tau] real ( wp ) :: x , y , z , xdot , ydot , zdot , al , q , ei , bom , om , tau , xsqysq ,& rsq , r , vr , hx , hy , hz , hsq , u , vt , bx , by , bz , w , h if ( all ( pv == zero )) then e = zero else x = pv ( 1 ) y = pv ( 2 ) z = pv ( 3 ) xdot = pv ( 4 ) ydot = pv ( 5 ) zdot = pv ( 6 ) xsqysq = x * x + y * y rsq = xsqysq + z * z r = sqrt ( rsq ) vr = ( x * xdot + y * ydot + z * zdot ) / r hx = y * zdot - z * ydot hy = z * xdot - x * zdot hz = x * ydot - y * xdot hsq = hx * hx + hy * hy + hz * hz if ( hsq == zero ) then !(rectilinear orbit) ei = halfpi if ( xsqysq == zero ) then !(axial orbit) bom = zero else !(general rectilinear orbit) bom = atan2 ( y , x ) end if u = atan2 ( z , sqrt ( xsqysq )) vt = zero else !(non-degenerate orbit) bx = hy * z - hz * y by = hz * x - hx * z bz = hx * y - hy * x hx = y * bz - z * by hy = z * bx - x * bz hz = x * by - y * bx w = hx * hx + hy * hy h = sqrt ( w + hz * hz ) ei = atan2 ( sqrt ( w ), hz ) if ( w == zero ) then !(orbit in reference plane) bom = zero u = atan2 ( y * sign ( one , hz ), x ) else !(general orbit) bom = atan2 ( hx , - hy ) u = atan2 ( h * z , rsq * bz ) end if vt = h / ( r * rsq ) end if call pv2els ( gm , r , u , vr , vt , al , q , om , tau ) e ( 1 ) = al e ( 2 ) = q e ( 3 ) = ei e ( 4 ) = bom e ( 5 ) = om e ( 6 ) = tau end if end subroutine pv3els !***************************************************************************************** !***************************************************************************************** !> !  Solution to `a*x**3 + 3*b*x - 2c = 0`, where !  `a` and `b**3 + a*c**2` are both non-negative !  (zero generated, in lieu of infinity, if `a = b = 0`) pure function dcbsol ( a , b , c ) result ( x ) implicit none real ( wp ) :: x real ( wp ), intent ( in ) :: a real ( wp ), intent ( in ) :: b real ( wp ), intent ( in ) :: c real ( wp ) :: bsq , d if ( a == zero . and . b == zero . or . c == zero ) then x = zero else bsq = b * b d = sqrt ( a ) * abs ( c ) d = dcubrt ( d + sqrt ( b * bsq + d * d )) ** 2 x = two * c / ( d + b + bsq / d ) end if end function dcbsol !***************************************************************************************** !***************************************************************************************** !> !  Cube root computed accurately, by incorporating !  one Newton-Raphson iteration. pure function dcubrt ( x ) result ( c ) implicit none real ( wp ) :: c real ( wp ), intent ( in ) :: x real ( wp ) :: y if ( x == zero ) then c = zero else y = abs ( x ) c = y ** athird c = c - athird * ( c - y / c ** 2 ) c = sign ( c , x ) end if end function dcubrt !***************************************************************************************** !***************************************************************************************** end module gooding_module !*****************************************************************************************","tags":"","url":"sourcefile/gooding_module.f90.html"},{"title":"lighting_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~lighting_module.f90~~EfferentGraph sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~celestial_body_module.f90 celestial_body_module.f90 sourcefile~lighting_module.f90->sourcefile~celestial_body_module.f90 sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~lighting_module.f90->sourcefile~conversion_module.f90 sourcefile~ephemeris_module.f90 ephemeris_module.f90 sourcefile~lighting_module.f90->sourcefile~ephemeris_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~lighting_module.f90->sourcefile~kind_module.f90 sourcefile~math_module.f90 math_module.f90 sourcefile~lighting_module.f90->sourcefile~math_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~lighting_module.f90->sourcefile~numbers_module.f90 sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~lighting_module.f90->sourcefile~transformation_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~lighting_module.f90->sourcefile~vector_module.f90 sourcefile~celestial_body_module.f90->sourcefile~kind_module.f90 sourcefile~celestial_body_module.f90->sourcefile~numbers_module.f90 sourcefile~base_class_module.f90 base_class_module.f90 sourcefile~celestial_body_module.f90->sourcefile~base_class_module.f90 sourcefile~conversion_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 sourcefile~ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~math_module.f90->sourcefile~kind_module.f90 sourcefile~math_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~transformation_module.f90->sourcefile~celestial_body_module.f90 sourcefile~transformation_module.f90->sourcefile~ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~kind_module.f90 sourcefile~transformation_module.f90->sourcefile~numbers_module.f90 sourcefile~transformation_module.f90->sourcefile~vector_module.f90 sourcefile~iau_orientation_module.f90 iau_orientation_module.f90 sourcefile~transformation_module.f90->sourcefile~iau_orientation_module.f90 sourcefile~jpl_ephemeris_module.f90 jpl_ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~obliquity_module.f90 obliquity_module.f90 sourcefile~transformation_module.f90->sourcefile~obliquity_module.f90 sourcefile~time_module.f90 time_module.f90 sourcefile~transformation_module.f90->sourcefile~time_module.f90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~conversion_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~kind_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~numbers_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~vector_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~conversion_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~numbers_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~time_module.f90 sourcefile~obliquity_module.f90->sourcefile~conversion_module.f90 sourcefile~obliquity_module.f90->sourcefile~kind_module.f90 sourcefile~time_module.f90->sourcefile~conversion_module.f90 sourcefile~time_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~lighting_module.f90~~AfferentGraph sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Routines for computing solar fraction, lighting, eclipses, etc. module lighting_module use kind_module , only : wp use numbers_module , only : pi , zero , one , two , c_light , fourpi , solar_luminosity use vector_module , only : unit , cross , axis_angle_rotation use ephemeris_module , only : ephemeris_class use transformation_module , only : icrf_frame use celestial_body_module , only : celestial_body , body_sun , body_ssb use conversion_module , only : deg2rad , rad2deg , km2m use math_module , only : wrap_angle implicit none private public :: from_j2000body_to_j2000ssb public :: apparent_position public :: get_sun_fraction ! high-level routine public :: solar_fraction ! low-level routine public :: solar_fraction_alt ! low-level routine public :: solar_fraction_alt2 ! low-level routine public :: cubic_shadow_model ! low-level routine public :: solar_radiation_pressure public :: lighting_module_test contains !***************************************************************************************** !******************************************************************************** !> !  Compute the solar radiation pressure force vector on a spacecraft. function solar_radiation_pressure ( area , cr , r_sc_sun , sunfrac ) result ( srp ) real ( wp ), intent ( in ) :: area !! cross-sectional area of spacecraft [m&#94;2] real ( wp ), intent ( in ) :: cr !! coefficient of reflectivity real ( wp ), dimension ( 3 ), intent ( in ) :: r_sc_sun !! vector from spacecraft to sun [km] real ( wp ), intent ( in ) :: sunfrac !! sun fraction [0=total eclipse, 1=no eclipse] real ( wp ), dimension ( 3 ) :: srp !! solar radiation pressure force vector [N] real ( wp ) :: mag !! srp magnitude real ( wp ) :: r_mag !! magnitude of `r_sc_sun` if ( sunfrac == zero ) then srp = zero else r_mag = norm2 ( r_sc_sun ) * km2m ! (m) mag = sunfrac * cr * solar_luminosity * area / ( c_light * km2m * fourpi * r_mag ** 2 ) srp = - mag * r_sc_sun * km2m / r_mag ! (N) end if end function solar_radiation_pressure !******************************************************************************** !******************************************************************************** !> !  Compute the \"sun fraction\" using the selected shadow model. function get_sun_fraction ( b , rad_body , rad_sun , eph , et , rv , model , rbubble , use_geometric , info ) result ( phi ) type ( celestial_body ), intent ( in ) :: b !! eclipsing body real ( wp ), intent ( in ) :: rad_body !! radius of the eclipsing body [km] real ( wp ), intent ( in ) :: rad_sun !! radius of the Sun [km] class ( ephemeris_class ), intent ( inout ) :: eph !! the ephemeris to use for sun and ssb (if necessary) real ( wp ), intent ( in ) :: et !! observer ephemeris time (sec) real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! state of the spacecraft (j2000-body frame) integer , intent ( in ) :: model !! algorithm to use: !! !!  * 1: circular cubic shadow model !!  * 2-4: solar fraction model real ( wp ), intent ( in ) :: rbubble !! eclipse bubble [km]. see the reference. !! if rbubble=0, then no bubble is used. !! only used if model=1 logical , intent ( in ), optional :: use_geometric !! if true, use geometric positions !! (no light time or stellar aberration correction) !! default = false character ( len = :), allocatable , intent ( out ), optional :: info !! info string real ( wp ) :: phi !! solar fraction returned: !! !!  * if `model=1`, circular cubic sun frac value: !!     * `>0` no eclipse !!     * `<0` eclipse !!     * `=0` on the eclipse line !!  * if `model=2`, true solar fraction value [0=total eclipse, 1=no eclipse], !!    with model of umbra/penumbra/antumbra (Wertz, 1978) !!  * if `model=3`, alternate version of solar fraction (Montenbruck and Gill) !!  * if `model=4`, alternate version of solar fraction (nyxspace) logical :: status_ok !! true if no problems real ( wp ), dimension ( 3 ) :: r_sun !! apparent state of the sun (j2000-ssb frame) real ( wp ), dimension ( 3 ) :: r_body !! apparent state of the eclipsing body (j2000-ssb frame) real ( wp ), dimension ( 6 ) :: rv_ssb !! state of the spacecraft !! (j2000-ssb frame) logical :: use_apparent if ( present ( use_geometric )) then use_apparent = . not . use_geometric else use_apparent = . true . end if if ( use_apparent ) then ! apparent position of sun and body wrt to the spacecraft call from_j2000body_to_j2000ssb ( b , eph , et , rv , rv_ssb ) ! state of spacecraft in j2000-ssb call apparent_position ( eph , body_sun , et , rv_ssb , r_sun , status_ok ) ! apparent position of sun in j2000 if (. not . status_ok ) error stop 'error getting apparent sun position' call apparent_position ( eph , b , et , rv_ssb , r_body , status_ok ) ! apparent position of body in j2000 if (. not . status_ok ) error stop 'error getting apparent body position' else ! use geometric positions r_body = - rv ( 1 : 3 ) ! geometric position of body wrt spacecraft in j2000 call eph % get_r ( et , body_sun , b , r_sun , status_ok ) ! geometric position of sun wrt body in j2000 if (. not . status_ok ) error stop 'error getting geometric sun position' r_sun = r_body + r_sun ! geometric position of sun wrt spacecraft in j2000 end if ! compute sun fraction value select case ( model ) case ( 1 ); call cubic_shadow_model ( r_sun , rad_sun , r_body , rad_body , phi , rbubble ) case ( 2 ); call solar_fraction ( r_sun , rad_sun , r_body , rad_body , phi , info ) case ( 3 ); call solar_fraction_alt ( r_sun , rad_sun , r_body , rad_body , phi , info ) case ( 4 ); call solar_fraction_alt2 ( r_sun , rad_sun , r_body , rad_body , phi ) case default error stop 'invalid sun fraction model' end select end function get_sun_fraction !******************************************************************************** !***************************************************************************************** !> !  Compute the solar fraction visible due to an eclipse by another body. ! !### Reference !  * J. Wertz, \"Spacecraft Attitude Determination and Control\", 1978. !    See Chapter 3 and Appendix A. Note that the implementation here corrects !    a typo in this reference, and also protects for a division by zero. subroutine solar_fraction ( d_s , rs , d_p , rp , fraction , info ) real ( wp ), dimension ( 3 ), intent ( in ) :: d_s !! vector from the spacecraft to the Sun real ( wp ), intent ( in ) :: rs !! radius of the Sun real ( wp ), dimension ( 3 ), intent ( in ) :: d_p !! vector from the spacecraft to the planet real ( wp ), intent ( in ) :: rp !! radius of the planet real ( wp ), intent ( out ) :: fraction !! fraction of the Sun visible [0=total eclipse, 1=no eclipse] character ( len = :), allocatable , intent ( out ), optional :: info !! info string real ( wp ) :: s !! distance from the planet to the Sun real ( wp ) :: c !! distance from the center of the planet to the apex of the shadow cone real ( wp ) :: rho_c !! angular radius of the shadow cone real ( wp ) :: rho_s !! angular radius of the Sun real ( wp ) :: rho_p !! angular radius of the planet real ( wp ) :: theta !! angular separation of the sun and planet as viewed by the spacecraft real ( wp ) :: ds !! distance from the spacecraft to the Sun real ( wp ) :: dp !! distance from the spacecraft to the planet real ( wp ) :: drho !! difference in angular radii of the planet and Sun real ( wp ) :: crp , crs , srp , srs , cth , sth , t1 , t2 , t3 , delr !! temp variables if ( rp <= zero ) then ! no eclipse possible if the planet has no radius if ( present ( info )) info = 'no eclipse: planet radius <= 0' fraction = one return end if ds = norm2 ( d_s ) dp = norm2 ( d_p ) if ( ds <= rs ) then ! inside the Sun if ( present ( info )) info = 'inside Sun' fraction = one return else if ( dp <= rp ) then ! inside the planet if ( present ( info )) info = 'inside Planet' fraction = zero return end if s = norm2 ( d_s - d_p ) delr = rs - rp if ( delr == zero ) then ! special case when the bodies are the same size, ! to avoid division by zero c = huge ( 1.0_wp ) else c = ( rp * s ) / delr end if rho_c = asin ( delr / s ) ! appx = asin(rs/s) rho_s = asin ( rs / ds ) rho_p = asin ( rp / dp ) theta = acos ( dot_product ( unit ( d_s ), unit ( d_p ))) drho = rho_p - rho_s crp = cos ( rho_p ) crs = cos ( rho_s ) srp = sin ( rho_p ) srs = sin ( rho_s ) cth = cos ( theta ) sth = sin ( theta ) if ( ( ds > s ) . and . ( rho_p + rho_s > theta ) . and . ( theta > abs ( drho )) ) then ! partial eclipse if ( present ( info )) info = 'penumbra' t1 = pi - crs * acos ( ( crp - crs * cth ) / ( srs * sth ) ) t2 = - crp * acos ( ( crs - crp * cth ) / ( srp * sth ) ) t3 = - acos ( ( cth - crs * crp ) / ( srs * srp ) ) fraction = one - ( t1 + t2 + t3 ) / ( pi * ( one - crs )) else if ( ( s < ds ) . and . ( ds - s < c ) . and . ( drho > theta ) ) then ! total eclipse if ( present ( info )) info = 'umbra' fraction = zero else if ( ( c < ds - s ) . and . ( drho < theta ) ) then ! JW : typo in original reference ! annular eclipse if ( present ( info )) info = 'antumbra' fraction = one - ( one - crp ) / ( one - crs ) else ! no eclipse if ( present ( info )) info = 'full sun' fraction = one end if end subroutine solar_fraction !***************************************************************************************** !******************************************************************************** !> !  convert from a j2000-body frame to a j2000-ssb frame. subroutine from_j2000body_to_j2000ssb ( b , eph , et , rv , rv_ssb ) type ( celestial_body ), intent ( in ) :: b !! eclipsing body class ( ephemeris_class ), intent ( inout ) :: eph !! the ephemeris to use for body and ssb real ( wp ), intent ( in ) :: et !! ephemeris time (sec) real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! j2000-body state (km, km/s) real ( wp ), dimension ( 6 ), intent ( out ) :: rv_ssb !! j2000-ssb state (km, km/s) type ( icrf_frame ) :: f1 , f2 logical :: status_ok f1 = icrf_frame ( b = b ) f2 = icrf_frame ( b = body_ssb ) call f1 % transform ( rv , f2 , et , eph , rv_ssb , status_ok ) ! from f1 to f2 if (. not . status_ok ) error stop 'transformation error in from_j2000body_to_j2000ssb' end subroutine from_j2000body_to_j2000ssb !******************************************************************************** !******************************************************************************** !> !  Return the position of a target body relative to an observer, !  corrected for light time and stellar aberration. ! !  see the SPICELIB routine `spkapo` (with 'lt+s') subroutine apparent_position ( eph , b_target , et , rv_obs_ssb , r_target , status_ok ) class ( ephemeris_class ), intent ( inout ) :: eph !! the ephemeris type ( celestial_body ), intent ( in ) :: b_target !! target body real ( wp ), dimension ( 6 ), intent ( in ) :: rv_obs_ssb !! state of the observer !! (j2000 frame w.r.t. solar system barycenter) real ( wp ), intent ( in ) :: et !! observer ephemeris time (sec) real ( wp ), dimension ( 3 ), intent ( out ) :: r_target !! apparant state of the target (j2000 frame) !! Corrected for one-way light time and stellar aberration logical , intent ( out ) :: status_ok !! true if no problems real ( wp ), dimension ( 3 ) :: r_targ_ssb !! target body r wrt. ssb real ( wp ) :: lt !! one-way light time [sec] ! Find the geometric position of the target body with respect to the ! solar system barycenter. Subtract the position of the observer ! to get the relative position. Use this to compute the one-way ! light time. call eph % get_r ( et , b_target , body_ssb , r_targ_ssb , status_ok ) if (. not . status_ok ) return r_targ_ssb = r_targ_ssb - rv_obs_ssb ( 1 : 3 ) ! relative pos of target lt = norm2 ( r_targ_ssb ) / c_light ! light time ! To correct for light time, find the position of the target body ! at the current epoch minus the one-way light time. Note that ! the observer remains where he is. call eph % get_r ( et - lt , b_target , body_ssb , r_targ_ssb , status_ok ) if (. not . status_ok ) return r_targ_ssb = r_targ_ssb - rv_obs_ssb ( 1 : 3 ) ! At this point, r_targ_ssb contains the geometric or light-time ! corrected position of the target relative to the observer ! stellar aberration correction r_target = stellar_aberration ( r_targ_ssb , rv_obs_ssb ( 4 : 6 )) contains function stellar_aberration ( pobj , vobs ) result ( appobj ) !!  Correct the apparent position of an object for stellar aberration. !!  see SPICELIB routine `STELAB` real ( wp ), dimension ( 3 ), intent ( in ) :: pobj real ( wp ), dimension ( 3 ), intent ( in ) :: vobs real ( wp ), dimension ( 3 ) :: appobj real ( wp ), dimension ( 3 ) :: u , vbyc , h real ( wp ) :: lensqr , sinphi , phi real ( wp ), parameter :: zero_tol = epsilon ( 1.0_wp ) !! tolerance for zero u = unit ( pobj ) vbyc = vobs / c_light lensqr = dot_product ( vbyc , vbyc ) if ( lensqr >= 1.0_wp ) error stop 'velocity > speed of light' h = cross ( u , vbyc ) sinphi = norm2 ( h ) if ( abs ( sinphi ) > zero_tol ) then ! if (sinphi /= 0) ! rotate the position of the object by phi ! radians about h to obtain the apparent position. phi = asin ( sinphi ) call axis_angle_rotation ( pobj , h , phi , appobj ) else ! observer is moving along the line of sight to the object, ! and no correction is required appobj = pobj end if end function stellar_aberration end subroutine apparent_position !******************************************************************************** !******************************************************************************** !> !  The \"circular cubic\" shadow model. ! !### Reference !  * J. Williams, et. al, \"A new eclipse algorithm for use in !    spacecraft trajectory optimization\", 2023, AAS 23-243 subroutine cubic_shadow_model ( rsun , radsun , rplanet , radplanet , sunfrac , rbubble ) real ( wp ), dimension ( 3 ), intent ( in ) :: rsun !! apparent position vector of sun wrt spacecraft [km] real ( wp ), intent ( in ) :: radsun !! radius of sun [km] real ( wp ), dimension ( 3 ), intent ( in ) :: rplanet !! apparent position vector of eclipsing body wrt spacecraft [km] real ( wp ), intent ( in ) :: radplanet !! radius of the eclipsing body [km] real ( wp ), intent ( out ) :: sunfrac !! value of the function (>0 no eclipse, !! <0 eclipse, =0 on the shadow line) real ( wp ), intent ( in ), optional :: rbubble !! eclipse bubble radius. if present, then `sunfrac` is !! the value along an arc length of `rbubble` !! in the direction of the max eclipse line. real ( wp ), dimension ( 3 ) :: r !! radius vector from eclipsing body to spacecraft real ( wp ), dimension ( 3 ) :: rsb !! radius vector from the sun to the eclipsing body real ( wp ) :: tmp !! temp value real ( wp ) :: alpha !! [deg] real ( wp ) :: alpha0 !! [deg] real ( wp ) :: sin_alpha0 !! `sin(alpha0)` real ( wp ) :: rsbmag !! magnitude of radius vector from the sun to the eclipsing body real ( wp ) :: rmag !! magnitude of `r` logical :: compute_bubble !! use the `rbubble` inputs to adjust `alpha` compute_bubble = present ( rbubble ) if ( compute_bubble ) compute_bubble = rbubble > zero r = - rplanet rmag = norm2 ( r ) if ( rmag < radplanet ) then ! if inside the body, just return value from the surface r = radplanet * unit ( r ) rmag = radplanet end if rsb = rplanet - rsun alpha = safe_acosd ( dot_product ( unit ( r ), unit ( rsb ))) if ( compute_bubble ) alpha = rad2deg * abs ( wrap_angle ( alpha * deg2rad - abs ( rbubble ) / rmag )) rsbmag = norm2 ( rsb ) tmp = ( radsun + radplanet ) / rsbmag sin_alpha0 = ( one / rmag ) * ( radplanet * sqrt (( one / tmp ) ** 2 - one ) + sqrt ( rmag ** 2 - radplanet ** 2 )) * tmp alpha0 = safe_asind ( sin_alpha0 ) sunfrac = ( alpha ** 2 / ( alpha0 ** 2 - alpha0 ** 3 / 27 0.0_wp )) * ( one - alpha / 27 0.0_wp ) - one contains pure real ( wp ) function safe_asind ( x ) !! `asind` with range checking real ( wp ), intent ( in ) :: x safe_asind = asind ( min ( one , max ( - one , x ))) end function safe_asind pure real ( wp ) function safe_acosd ( x ) !! `acosd` with range checking real ( wp ), intent ( in ) :: x safe_acosd = acosd ( min ( one , max ( - one , x ))) end function safe_acosd end subroutine cubic_shadow_model !***************************************************************************************** !***************************************************************************************** !> !  Another eclipse model, using circular area assumptions. ! !### References !  * Montenbruck and Gill, \"Satellite Orbits\". !  * The GMAT routine `ShadowState::FindShadowState`. subroutine solar_fraction_alt ( d_s , rs , d_p , rp , percentsun , info ) real ( wp ), dimension ( 3 ), intent ( in ) :: d_s !! vector from the spacecraft to the Sun real ( wp ), intent ( in ) :: rs !! radius of the Sun real ( wp ), dimension ( 3 ), intent ( in ) :: d_p !! vector from the spacecraft to the planet real ( wp ), intent ( in ) :: rp !! radius of the planet real ( wp ), intent ( out ) :: percentsun !! fraction of the Sun visible [0=total eclipse, 1=no eclipse] character ( len = :), allocatable , intent ( out ), optional :: info !! info string real ( wp ), dimension ( 3 ) :: unitsun , d_s_hat , d_p_hat real ( wp ) :: rho_s , rho_p , theta , rdotsun , d_s_mag , d_p_mag , c , a2 , b2 , x , y , area !              [sc] !            /     \\ !        d_s       d_p !      /              \\ !  [sun] ---------- [body] unitsun = unit ( d_s - d_p ) ! body to sun unit vector rdotsun = dot_product ( - d_p , unitsun ) if ( rdotsun > zero ) then ! sunny side of central body is always fully lit ! [the assumption here is the sun is always bigger than the body?] if ( present ( info )) info = 'full sun' percentsun = one else d_s_mag = norm2 ( d_s ) d_p_mag = norm2 ( d_p ) if ( rs >= d_s_mag ) then ! inside the Sun if ( present ( info )) info = 'inside Sun' percentsun = one else if ( rp >= d_p_mag ) then ! inside the planet if ( present ( info )) info = 'inside Planet' percentsun = zero else rho_s = asin ( rs / d_s_mag ) rho_p = asin ( rp / d_p_mag ) d_p_hat = unit ( d_p ) d_s_hat = unit ( d_s ) theta = acos ( dot_product ( d_p_hat , d_s_hat )) ! apparant distance from sun to body if ( rho_s + rho_p <= theta ) then ! full sunlight if ( present ( info )) info = 'full sunlight' percentsun = one else if ( theta <= rho_p - rho_s ) then ! umbra if ( present ( info )) info = 'umbra' percentsun = zero else if ( ( abs ( rho_s - rho_p ) < theta ) . and . ( theta < rho_s + rho_p ) ) then ! penumbra if ( present ( info )) info = 'penumbra' ! see montenbruck and gill, eq. 3.87-3.94 c = acos ( dot_product ( d_p_hat , d_s_hat )) a2 = rho_s * rho_s b2 = rho_p * rho_p x = ( c * c + a2 - b2 ) / ( two * c ) y = sqrt ( a2 - x * x ) area = a2 * acos ( x / rho_s ) + b2 * acos (( c - x ) / rho_p ) - c * y percentsun = one - area / ( pi * a2 ) else ! antumbra if ( present ( info )) info = 'antumbra' percentsun = one - rho_p * rho_p / ( rho_s * rho_s ) end if end if end if end subroutine solar_fraction_alt !***************************************************************************************** !***************************************************************************************** !> !  Another eclipse model, using circular area assumptions, !  coded up based on the nixspace documentation. !  The results are very similar to `solar_fraction_alt`. ! !### References !  * https://nyxspace.com/nyxspace/MathSpec/celestial/eclipse/#nomenclature subroutine solar_fraction_alt2 ( r_l , Rl , r_e , Re , percentsun , info ) real ( wp ), dimension ( 3 ), intent ( in ) :: r_l !! vector from the spacecraft to the Sun real ( wp ), intent ( in ) :: Rl !! radius of the Sun real ( wp ), dimension ( 3 ), intent ( in ) :: r_e !! vector from the spacecraft to the planet real ( wp ), intent ( in ) :: Re !! radius of the planet real ( wp ), intent ( out ) :: percentsun !! fraction of the Sun visible [0=total eclipse, 1=no eclipse] character ( len = :), allocatable , intent ( out ), optional :: info !! info string real ( wp ) :: rlp , rep , dp , r_l_mag , r_e_mag , & d1 , d2 , dp2 , rlp2 , rep2 , At , Astar ! this check isn't mentioned in the reference, but needed ! for sc -- sun -- body case if ( dot_product ( - r_e , unit ( r_l - r_e )) > zero ) then ! sunny side of body is always fully lit ! [the assumption here is the sun is always bigger than the body?] if ( present ( info )) info = 'full sun' percentsun = one return end if r_l_mag = norm2 ( r_l ) r_e_mag = norm2 ( r_e ) ! these checks also aren't in the writeup: if ( Rl >= r_l_mag ) then ! inside the Sun if ( present ( info )) info = 'inside Sun' percentsun = one ; return else if ( Re >= r_e_mag ) then ! inside the planet if ( present ( info )) info = 'inside Planet' percentsun = zero ; return end if rlp = asin ( Rl / r_l_mag ) rep = asin ( Re / r_e_mag ) dp = acos ( dot_product ( r_l , r_e ) / ( r_l_mag * r_e_mag )) ! modified this check: !if (dp-rlp<rep) then  ! original if ( rlp + rep <= dp ) then ! corrected if ( present ( info )) info = 'full sun' percentsun = one ! full sun else if ( rep >= dp + rlp ) then if ( present ( info )) info = 'umbra' percentsun = zero ! umbra else if ( rlp - rep >= dp . or . dp >= rlp + rep ) then ! antumbra if ( present ( info )) info = 'antumbra' percentsun = one - rep * rep / ( rlp * rlp ) else ! penumbra if ( present ( info )) info = 'penumbra' dp2 = dp * dp rlp2 = rlp * rlp rep2 = rep * rep d1 = ( dp2 - rlp2 + rep2 ) / ( two * dp ) d2 = ( dp2 + rlp2 - rep2 ) / ( two * dp ) At = A ( rep , rep2 , d1 ) + A ( rlp , rlp2 , d2 ) Astar = pi * rlp2 percentsun = ( Astar - At ) / Astar end if contains pure real ( wp ) function A ( r , r2 , d ) real ( wp ), intent ( in ) :: r , r2 , d A = r2 * acos ( d / r ) - d * sqrt ( r2 - d * d ) end function A end subroutine solar_fraction_alt2 !***************************************************************************************** !***************************************************************************************** !> !  Unit tests for the listing module. subroutine lighting_module_test () real ( wp ) :: rs , rp real ( wp ), dimension ( 3 ) :: d_s , d_p rs = 1.0_wp ! sun radius rp = 1.0_wp ! planet radius ! sun -- body -- sc  -> 0.0 d_s = [ - 10 0.0_wp , 0.0_wp , 0.0_wp ] d_p = [ - 1 0.0_wp , 0.0_wp , 0.0_wp ] call go () ! sc -- sun -- body  -> 1.0 d_s = [ 1 0.0_wp , 0.0_wp , 0.0_wp ] d_p = [ 10 0.0_wp , 0.0_wp , 0.0_wp ] call go () ! sc -- body -- sun  -> 0.0 d_s = [ 10 0.0_wp , 0.0_wp , 0.0_wp ] d_p = [ 1 0.0_wp , 0.0_wp , 0.0_wp ] call go () ! sc -- body -- sun  -> penumbra d_s = [ 10 0.0_wp , 0.0_wp , 0.0_wp ] d_p = [ 1 0.0_wp , 1.0_wp , 0.0_wp ] call go () ! body -- sc -- sun d_s = [ - 10 0.0_wp , 0.0_wp , 0.0_wp ] d_p = [ 10 0.0_wp , 0.0_wp , 0.0_wp ] call go () !.................................... ! sc -- body -- sun  -> antumbra rs = 10 0.0_wp d_s = [ 2000 0.0_wp , 0.0_wp , 0.0_wp ] d_p = [ 40 0.0_wp , 0.0_wp , 0.0_wp ] call go () rs = 10 0.0_wp ! umbra d_s = [ 2000 0.0_wp , 0.0_wp , 0.0_wp ] d_p = [ 10 0.0_wp , 0.0_wp , 0.0_wp ] call go () ! realistic sun/earth case: !  sun -- earth -- sc rs = 69600 0.0_wp rp = 637 8.0_wp d_s = [ - 14959787 0.7_wp , 0.0_wp , 0.0_wp ] d_p = [ - 677 8.0_wp , 640 0.0_wp , 0.0_wp ] call go () ! ! an edge case, a very small sun very close to the body on x-axis, ! ! sc on y-axis very close to body    .. i don't think any properly handle this .. .double check... ! rs = 0.0001_wp ! sun radius ! rp = 10.0_wp ! planet radius ! d_p = [0.0001_wp, -rp-0.01_wp, 0.0_wp] ! d_s = d_p + [-rp-0.01_wp, 0.0_wp, 0.0_wp] ! call go() contains subroutine go () real ( wp ) :: phi1 , phi2 , phi3 character ( len = :), allocatable :: info1 , info2 , info3 print * , '----------------------------------' write ( * , * ) '' call solar_fraction ( d_s , rs , d_p , rp , phi1 , info1 ) call solar_fraction_alt ( d_s , rs , d_p , rp , phi2 , info2 ) call solar_fraction_alt2 ( d_s , rs , d_p , rp , phi3 , info3 ) write ( * , * ) 'phi1 = ' , phi1 , info1 write ( * , * ) 'phi2 = ' , phi2 , info2 write ( * , * ) 'phi3 = ' , phi3 , info3 write ( * , * ) 'diff 1= ' , abs ( phi1 - phi2 ) ! spherical vs circular write ( * , * ) 'diff 2= ' , abs ( phi2 - phi3 ) ! two circular models if ( abs ( phi1 - phi2 ) > 1.0e-4_wp ) error stop 'WARNING: large difference between models' print * , '' end subroutine go end subroutine lighting_module_test !***************************************************************************************** !***************************************************************************************** end module lighting_module !*****************************************************************************************","tags":"","url":"sourcefile/lighting_module.f90.html"},{"title":"jpl_ephemeris_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~jpl_ephemeris_module.f90~~EfferentGraph sourcefile~jpl_ephemeris_module.f90 jpl_ephemeris_module.f90 sourcefile~celestial_body_module.f90 celestial_body_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~conversion_module.f90 sourcefile~ephemeris_module.f90 ephemeris_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~jpl_ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~numbers_module.f90 sourcefile~time_module.f90 time_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~time_module.f90 sourcefile~celestial_body_module.f90->sourcefile~kind_module.f90 sourcefile~celestial_body_module.f90->sourcefile~numbers_module.f90 sourcefile~base_class_module.f90 base_class_module.f90 sourcefile~celestial_body_module.f90->sourcefile~base_class_module.f90 sourcefile~conversion_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 sourcefile~ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~time_module.f90->sourcefile~conversion_module.f90 sourcefile~time_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~jpl_ephemeris_module.f90~~AfferentGraph sourcefile~jpl_ephemeris_module.f90 jpl_ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~transformation_module.f90 sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 sourcefile~transformation_module.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~lighting_module.f90->sourcefile~transformation_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  For reading the JPL planetary and lunar ephemerides. !  This is an extensively modified version of the original FORTRAN 77 code from JPL. ! !### Ephemeris files !  Note that this module uses the JPL binary ephemeris files, which !  can be obtained using the instructions !  [here](ftp://ssd.jpl.nasa.gov/pub/eph/planets/fortran/userguide.txt). !  See also the comments in [[ephemeris_test]] for more details. ! !### License ! !  ***Original JPL License*** ! !  THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE !  CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S. !  GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE !  ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE !  PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED \"AS-IS\" !  TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY !  WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A !  PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC !  SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE !  SOFTWARE AND RELATED MATERIALS, HOWEVER USED. ! !  IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA !  BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT !  LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND, !  INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS, !  REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE !  REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY. ! !  RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF !  THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY !  CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE !  ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE. ! !  ***Modifications*** ! !  Modifications for the Fortran Astrodynamics Toolkit are covered !  under the [following license](https://github.com/jacobwilliams/Fortran-Astrodynamics-Toolkit/blob/master/LICENSE). ! !### History !  * [Original code from JPL](ftp://ssd.jpl.nasa.gov/pub/eph/planets/fortran/) Version : March 25, 2013 !  * Extensive modifications by Jacob Williams for the Fortran Astrodynamics Toolkit. ! !@note Warning: all calculations here are done with 64 bit reals. if using 128-bit reals !      the state is just copied into a 128-bit variable. Perhaps we should do the interpolations !      in 128-bit? (the data from the file must be read as 64-bit) module jpl_ephemeris_module use kind_module , only : fat_wp => wp use , intrinsic :: iso_fortran_env , only : real64 , error_unit use ephemeris_module implicit none private integer , parameter :: wp = real64 !! using double precision reals since that is how the ephemeris is stored. integer , parameter , public :: nmax = 1000 !! Current maximum number of ephemeris constants !! used in the integration and listed !! in the `header.xxx` file for the ephemeris. integer , parameter :: oldmax = 400 !! For earlier versions of the code, the maximum !! number of ephemeris constants used in the !! integration and listed in the `header.xxx` !! file for the ephemeris. integer , parameter :: nrecl = 4 !! `nrecl=1` if `recl` in the open statement is the record length in s.p. words !! `nrecl=4` if `recl` in the open statement is the record length in bytes type , extends ( ephemeris_class ), public :: jpl_ephemeris !! Main class for accessing a JPL ephemeris file. character ( len = :), allocatable :: namfil !! name of the binary ephemeris file integer :: ksize = 2036 !! ksize must be set by the user according to the ephemeris to be read: !!   for ***de200***, set `ksize=1652`, !!   for ***de405***, set `ksize=2036`, !!   for ***de406***, set `ksize=1456`, !!   for ***de414***, set `ksize=2036`, !!   for ***de418***, set `ksize=2036`, !!   for ***de421***, set `ksize=2036`, !!   for ***de422***, set `ksize=2036`, !!   for ***de423***, set `ksize=2036`, !!   for ***de424***, set `ksize=2036`, !!   for ***de430***, set `ksize=2036`. !ephhdr integer , dimension ( 3 , 13 ) :: ipt = 0 !! ipt(39) real ( wp ), dimension ( nmax ) :: cval = 0.0_wp real ( wp ), dimension ( 3 ) :: ss = 0.0_wp real ( wp ) :: au = 0.0_wp real ( wp ) :: emrat = 0.0_wp integer :: ncon = 0 integer :: numde = 0 !stcomx real ( wp ), dimension ( 6 ) :: pvsun = 0.0_wp !! dp 6-word array containing the barycentric position and !! velocity of the sun. logical :: km = . true . !! logical flag defining physical units of the output states. !!   km = .true.  : km and km/sec !!   km = .false. : au and au/day !! for nutations and librations.  angle unit is always radians. logical :: bary = . false . !! logical flag defining output center. !! only the 9 planets are affected. !!   bary = .true.  : center is solar-system barycenter !!   bary = .false. : center is sun !chrhdr character ( len = 6 ), dimension ( 14 , 3 ) :: ttl = '' character ( len = 6 ), dimension ( nmax ) :: cnam = '' logical :: initialized = . false . !! is the ephemeris initialized? integer :: nrfile = 0 !! file unit for the ephemeris file integer :: nrl = - 1 !! this was formerly in state integer :: ncoeffs = 0 ! formerly in state: real ( wp ), dimension ( 1500 ) :: buf = 0.0_wp ! formerly in interp: real ( wp ), dimension ( 18 ) :: pc = 0.0_wp real ( wp ), dimension ( 18 ) :: vc = 0.0_wp integer :: np = 2 integer :: nv = 3 real ( wp ) :: twot = 0.0_wp contains procedure , public :: get_rv => get_rv_from_jpl_ephemeris procedure , public :: get_r => get_r_from_jpl_ephemeris procedure , public :: initialize => initialize_ephemeris procedure , public :: get_state procedure , public :: get_constants procedure , public :: close => close_ephemeris procedure :: interp procedure :: state end type jpl_ephemeris !> !  These correspond to the numbering convention for 'ntarg' and 'ncent' in [[get_state]]: character ( len =* ), dimension ( 15 ), parameter :: list_of_bodies = [ & 'mercury                ' ,& 'venus                  ' ,& 'earth                  ' ,& 'mars                   ' ,& 'jupiter                ' ,& 'saturn                 ' ,& 'uranus                 ' ,& 'neptune                ' ,& 'pluto                  ' ,& 'moon                   ' ,& 'sun                    ' ,& 'solar-system barycenter' ,& 'earth-moon barycenter  ' ,& 'nutations              ' ,& 'librations             ' ] !public routines: public :: ephemeris_test contains !***************************************************************************************** !***************************************************************************************** !> !  Interface for the [[ephemeris_module]]. subroutine get_rv_from_jpl_ephemeris ( me , et , targ , obs , rv , status_ok ) use time_module , only : et_to_jd use conversion_module , only : day2sec use celestial_body_module , only : celestial_body use numbers_module , only : zero implicit none class ( jpl_ephemeris ), intent ( inout ) :: me real ( fat_wp ), intent ( in ) :: et !! ephemeris time [sec] type ( celestial_body ), intent ( in ) :: targ !! target body type ( celestial_body ), intent ( in ) :: obs !! observer body real ( fat_wp ), dimension ( 6 ), intent ( out ) :: rv !! state of targ w.r.t. obs [km,km/s] in ICRF frame logical , intent ( out ) :: status_ok !! true if there were no problems real ( wp ) :: jd !! julian date for input to [[get_state]]. integer :: ntarg !! id code for target body integer :: ncent !! id code for observer body real ( wp ), dimension ( 6 ) :: rv_ !! in case `wp /= fat_wp` we need a copy if ( targ == obs ) then !don't bother if target and observer are the same body rv = zero status_ok = . true . else !convert to expected inputs: jd = et_to_jd ( et ) ntarg = spice_id_to_old_id ( targ % id ) ncent = spice_id_to_old_id ( obs % id ) if ( ntarg > 0 . and . ncent > 0 ) then call me % get_state ( jd , ntarg , ncent , rv_ , status_ok ) rv = rv_ if ( status_ok ) then if (. not . me % km ) then !we must return in units of km/s !so, convert from AU, AU/day to km, km/s rv = rv * me % au rv ( 4 : 6 ) = rv ( 4 : 6 ) / day2sec end if else write ( error_unit , '(A)' ) 'Error in get_rv_from_jpl_ephemeris: ' // & 'Error calling ephemeris.' end if else write ( error_unit , '(A)' ) 'Error in get_rv_from_jpl_ephemeris: ' // & 'No ephemeris for this body.' status_ok = . false . end if end if end subroutine get_rv_from_jpl_ephemeris !***************************************************************************************** !***************************************************************************************** !> !  Interface for the [[ephemeris_module]]. subroutine get_r_from_jpl_ephemeris ( me , et , targ , obs , r , status_ok ) use time_module , only : et_to_jd use conversion_module , only : day2sec use celestial_body_module , only : celestial_body use numbers_module , only : zero implicit none class ( jpl_ephemeris ), intent ( inout ) :: me real ( fat_wp ), intent ( in ) :: et !! ephemeris time [sec] type ( celestial_body ), intent ( in ) :: targ !! target body type ( celestial_body ), intent ( in ) :: obs !! observer body real ( fat_wp ), dimension ( 3 ), intent ( out ) :: r !! position of targ w.r.t. obs [km] in ICRF frame logical , intent ( out ) :: status_ok !! true if there were no problems real ( wp ) :: jd !! julian date for input to [[get_state]]. integer :: ntarg !! id code for target body integer :: ncent !! id code for observer body real ( wp ), dimension ( 6 ) :: rv_ !! in case `wp /= fat_wp` we need a copy if ( targ == obs ) then !don't bother if target and observer are the same body r = zero status_ok = . true . else !convert to expected inputs: jd = et_to_jd ( et ) ntarg = spice_id_to_old_id ( targ % id ) ncent = spice_id_to_old_id ( obs % id ) if ( ntarg > 0 . and . ncent > 0 ) then call me % get_state ( jd , ntarg , ncent , rv_ , status_ok , pos_only = . true .) ! only return position r = rv_ ( 1 : 3 ) if ( status_ok ) then if (. not . me % km ) then !we must return in units of km !so, convert from AU to km r = r * me % au end if else write ( error_unit , '(A)' ) 'Error in get_r_from_jpl_ephemeris: ' // & 'Error calling ephemeris.' end if else write ( error_unit , '(A)' ) 'Error in get_r_from_jpl_ephemeris: ' // & 'No ephemeris for this body.' status_ok = . false . end if end if end subroutine get_r_from_jpl_ephemeris !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 3/20/2016 ! !  Convert the NAIF SPICE ID code to the old one used by the JPL ephemeris. !  Returns `0` if the body was not found. pure function spice_id_to_old_id ( spice_id ) result ( old_id ) implicit none integer , intent ( in ) :: spice_id !! the ID code used by SPICE integer :: old_id !! the ID code used by this module (old JPL ephemeris code) integer :: i !! counter !> !  The index of this array is the old ID code. The value is the new code. !  See: [NAIF Integer ID codes](http://naif.jpl.nasa.gov/pub/naif/toolkit_docs/FORTRAN/req/naif_ids.html) integer , parameter , dimension ( 13 ) :: new_ids = & [ 199 ,& ! mercury 299 ,& ! venus 399 ,& ! earth 499 ,& ! mars 599 ,& ! jupiter 699 ,& ! saturn 799 ,& ! uranus 899 ,& ! neptune 999 ,& ! pluto 301 ,& ! moon 10 , & ! sun 0 , & ! solar-system barycenter 3 ] ! earth-moon barycenter !just a simple search of the list: ! [small enough that bisection search probably not worth it] do i = 1 , size ( new_ids ) if ( new_ids ( i ) == spice_id ) then old_id = i return end if end do !not found: old_id = 0 end function spice_id_to_old_id !***************************************************************************************** !***************************************************************************************** !> !  This subroutine reads the JPL planetary ephemeris !  and gives the position and velocity of the point `ntarg` !  with respect to `ncent`. ! !### Notes ! !  The numbering convention for `ntarg` and `ncent` is: ! !    1 = mercury      8 = neptune !    2 = venus        9 = pluto !    3 = earth       10 = moon !    4 = mars        11 = sun !    5 = jupiter     12 = solar-system barycenter !    6 = saturn      13 = earth-moon barycenter !    7 = uranus      14 = nutations (longitude and obliq) !                    15 = librations, if on eph file ! !  (if nutations are wanted, set ntarg = 14. !  for librations, set ntarg = 15. set ncent=0.) subroutine get_state ( me , jd , ntarg , ncent , rrd , status_ok , pos_only ) implicit none class ( jpl_ephemeris ), intent ( inout ) :: me real ( wp ), intent ( in ) :: jd !! d.p. Julian ephemeris date at which interpolation is wanted. integer , intent ( in ) :: ntarg !! integer number of 'target' point. integer , intent ( in ) :: ncent !! integer number of 'center' point. real ( wp ), dimension ( 6 ), intent ( out ) :: rrd !! output 6-word d.p. array containing position and velocity !! of point `ntarg` relative to `ncent`. !! the units are AU and AU/day (or km and km/sec if `me%km=.true.`). !! For librations the units are radians and radians !! per day. In the case of nutations the first four words of !! `rrd` will be set to nutations and rates, having units of !! radians and radians/day. logical , intent ( out ) :: status_ok !! true if there were no problems logical , intent ( in ), optional :: pos_only !! if .true. only the position components are returned, not the velocity. [doesn't work yet] real ( wp ), dimension ( 2 ) :: et2 real ( wp ), dimension ( 6 , 13 ) :: pv real ( wp ), dimension ( 6 , 11 ) :: pvst real ( wp ), dimension ( 4 ) :: pnut integer , dimension ( 12 ) :: list integer :: i , j , k logical :: bsave logical :: full_state !! if .true. then we return the full state, otherwise only the position integer :: ilist !! for the `list` array status_ok = . false . if ( present ( pos_only )) then full_state = . not . pos_only else full_state = . true . end if ! if (.not. full_state) then !     ilist = 1   ! only return the position ! else !     ilist = 2   ! return position and velocity ! end if ilist = 2 ! note: setting to 1 doesn't seem to work. need to figure out why. ! for now, will always interpolate the full state. if ( me % initialized ) then ! initialize et2 for 'state' and set up component count et2 ( 1 ) = jd et2 ( 2 ) = 0.0_wp list = 0 rrd = 0.0_wp if ( ntarg /= ncent ) then select case ( ntarg ) case ( 14 ) !nutation if ( me % ipt ( 2 , 12 ) > 0 ) then !me%ipt(35) list ( 11 ) = 2 call me % state ( et2 , list , pvst , pnut , status_ok ) if (. not . status_ok ) then write ( error_unit , '(A)' ) 'error interpolating nutations in get_state.' return end if rrd ( 1 : 4 ) = pnut ( 1 : 4 ) rrd ( 5 ) = 0.0_wp rrd ( 6 ) = 0.0_wp return else rrd ( 1 : 4 ) = 0.0_wp write ( error_unit , '(A)' ) 'error in get_state: the ephemeris file does not contain nutations.' return endif case ( 15 ) !librations if ( me % ipt ( 2 , 13 ) > 0 ) then !me%ipt(38) list ( 12 ) = 2 call me % state ( et2 , list , pvst , pnut , status_ok ) if (. not . status_ok ) then write ( error_unit , '(A)' ) 'error interpolating librations in get_state.' return end if rrd = pvst (:, 11 ) return else write ( error_unit , '(A)' ) 'error in get_state: the ephemeris file does not contain librations.' return endif case default ! force barycentric output by 'state' bsave = me % bary me % bary = . true . ! set up proper entries in 'list' array for state call do i = 1 , 2 if ( i == 1 ) then k = ntarg else k = ncent end if if ( k <= 10 ) list ( k ) = ilist ! can we set all these to 1 for position only? doesn't seem to work? if ( k == 10 ) list ( 3 ) = ilist if ( k == 3 ) list ( 10 ) = ilist if ( k == 13 ) list ( 3 ) = ilist enddo ! make call to state call me % state ( et2 , list , pvst , pnut , status_ok ) if (. not . status_ok ) then write ( error_unit , '(A)' ) 'error interpolating state in get_state.' return end if do i = 1 , 10 do j = 1 , 6 pv ( j , i ) = pvst ( j , i ) end do enddo if ( ntarg == 11 . or . ncent == 11 ) pv (:, 11 ) = me % pvsun if ( ntarg == 12 . or . ncent == 12 ) pv (:, 12 ) = 0.0_wp if ( ntarg == 13 . or . ncent == 13 ) pv (:, 13 ) = pvst (:, 3 ) if ( ntarg * ncent == 30 . and . ntarg + ncent == 13 ) then pv (:, 3 ) = 0.0_wp else if ( list ( 3 ) == 2 ) pv (:, 3 ) = pvst (:, 3 ) - pvst (:, 10 ) / ( 1.0_wp + me % emrat ) if ( list ( 10 ) == 2 ) pv (:, 10 ) = pv (:, 3 ) + pvst (:, 10 ) end if rrd = pv (:, ntarg ) - pv (:, ncent ) me % bary = bsave end select end if status_ok = . true . else write ( error_unit , '(A)' ) 'error in get_state: the ephemeris is not initialized.' end if end subroutine get_state !***************************************************************************************** !***************************************************************************************** !> !  this subroutine differentiates and interpolates a !  set of chebyshev coefficients to give position and velocity. subroutine interp ( me , buf , t , ncf , ncm , na , ifl , pv ) implicit none class ( jpl_ephemeris ), intent ( inout ) :: me integer , intent ( in ) :: ncf !! # of coefficients per component integer , intent ( in ) :: ncm !! # of components per set of coefficients real ( wp ), dimension ( ncf , ncm , * ) :: buf !! 1st location of array of d.p. chebyshev coefficients of position real ( wp ), dimension ( 2 ), intent ( in ) :: t integer , intent ( in ) :: na !! # of sets of coefficients in full array !! (i.e., # of sub-intervals in full interval) integer , intent ( in ) :: ifl !! integer flag !! = 1 for positions only !! = 2 for pos and vel real ( wp ), dimension ( ncm , * ) :: pv !! interpolated quantities requested.  dimension !! expected is pv(ncm,ifl), dp. real ( wp ) :: dna , dt1 , temp , vfac , tc integer :: l , i , j ! entry point. get correct sub-interval number for this set ! of coefficients and then get normalized chebyshev time ! within that subinterval. dna = dble ( na ) dt1 = int ( t ( 1 )) temp = dna * t ( 1 ) l = int ( temp - dt1 ) + 1 ! tc is the normalized chebyshev time (-1 <= tc <= 1) tc = 2.0_wp * ( mod ( temp , 1.0_wp ) + dt1 ) - 1.0_wp ! check to see whether chebyshev time has changed, ! and compute new polynomial values if it has. ! (the element pc(2) is the value of t1(tc) and hence ! contains the value of tc on the previous call.) if ( tc /= me % pc ( 2 )) then me % np = 2 me % nv = 3 me % pc ( 2 ) = tc me % twot = tc + tc endif ! be sure that at least 'ncf' polynomials have been evaluated ! and are stored in the array 'pc'. if ( me % np < ncf ) then do i = me % np + 1 , ncf me % pc ( i ) = me % twot * me % pc ( i - 1 ) - me % pc ( i - 2 ) end do me % np = ncf endif ! interpolate to get position for each component do i = 1 , ncm pv ( i , 1 ) = 0.0_wp do j = ncf , 1 , - 1 pv ( i , 1 ) = pv ( i , 1 ) + me % pc ( j ) * buf ( j , i , l ) end do end do if ( ifl <= 1 ) return ! if velocity interpolation is wanted, be sure enough ! derivative polynomials have been generated and stored. vfac = ( dna + dna ) / t ( 2 ) me % vc ( 3 ) = me % twot + me % twot if ( me % nv < ncf ) then do i = me % nv + 1 , ncf me % vc ( i ) = me % twot * me % vc ( i - 1 ) + me % pc ( i - 1 ) + me % pc ( i - 1 ) - me % vc ( i - 2 ) end do me % nv = ncf endif ! interpolate to get velocity for each component do i = 1 , ncm pv ( i , 2 ) = 0.0_wp do j = ncf , 2 , - 1 pv ( i , 2 ) = pv ( i , 2 ) + me % vc ( j ) * buf ( j , i , l ) end do pv ( i , 2 ) = pv ( i , 2 ) * vfac end do end subroutine interp !***************************************************************************************** !***************************************************************************************** !> !  this subroutine breaks a d.p. number into a d.p. integer !  and a d.p. fractional part. subroutine split ( tt , fr ) implicit none real ( wp ), intent ( in ) :: tt !! d.p. input number real ( wp ), dimension ( 2 ), intent ( out ) :: fr !! d.p. 2-word output array. !! fr(1) contains integer part !! fr(2) contains fractional part !! for negative input numbers, fr(1) contains the next !! more negative integer; fr(2) contains a positive fraction. ! get integer and fractional parts fr ( 1 ) = int ( tt ) fr ( 2 ) = tt - fr ( 1 ) if ( tt >= 0.0_wp . or . fr ( 2 ) == 0.0_wp ) return ! make adjustments for negative input number fr ( 1 ) = fr ( 1 ) - 1.0_wp fr ( 2 ) = fr ( 2 ) + 1.0_wp end subroutine split !***************************************************************************************** !***************************************************************************************** !> !  Initialize the ephemeris. !  This routine may be called to load a different ephemeris file. !  Otherwise, it is called on the first call to get_state, and loads !  the file specified in the module header. ! !# Note !  * Based on code formerly in [[state]]. subroutine initialize_ephemeris ( me , filename , ksize , km , bary , status_ok ) implicit none class ( jpl_ephemeris ), intent ( inout ) :: me character ( len =* ), intent ( in ) :: filename !! ephemeris file name integer , intent ( in ), optional :: ksize !! corresponding `ksize` logical , intent ( in ), optional :: km !! defining physical units of the output states. !! `km = .true.`  : km and km/sec [default], !! `km = .false.` : au and au/day. logical , intent ( in ), optional :: bary !! logical flag defining output center. !! only the 9 planets are affected. !! `bary = .true.`  : center is solar-system barycenter, !! `bary = .false.` : center is sun [default]. logical , intent ( out ) :: status_ok !! true if there were not problems. !local variables: integer :: irecsz , istat , i , j , k , l !just in case it was already open: call me % close () ! clears everything in the class !ephemeris file name: me % namfil = trim ( filename ) !optional inputs: if ( present ( ksize )) me % ksize = ksize if ( present ( km )) me % km = km if ( present ( bary )) me % bary = bary irecsz = nrecl * me % ksize me % ncoeffs = me % ksize / 2 open ( newunit = me % nrfile , & file = me % namfil , & access = 'DIRECT' , & form = 'UNFORMATTED' , & action = 'READ' , & !JW added recl = irecsz , & iostat = istat , & status = 'OLD' ) !write(*,*) \"istat=\",istat status_ok = ( istat == 0 ) !if there were no problems opening the file if ( status_ok ) then read ( me % nrfile , rec = 1 , iostat = istat ) & me % ttl ,( me % cnam ( k ), k = 1 , oldmax ), me % ss , me % ncon , me % au , me % emrat ,& (( me % ipt ( i , j ), i = 1 , 3 ), j = 1 , 12 ), me % numde ,( me % ipt ( i , 13 ), i = 1 , 3 ), & ( me % cnam ( l ), l = oldmax + 1 , me % ncon ) if ( istat == 0 ) then if ( me % ncon <= oldmax ) then read ( me % nrfile , rec = 2 , iostat = istat ) ( me % cval ( i ), i = 1 , oldmax ) else read ( me % nrfile , rec = 2 , iostat = istat ) ( me % cval ( i ), i = 1 , me % ncon ) endif if ( istat == 0 ) then me % nrl = 0 me % initialized = . true . end if end if ! check if the reads went OK: status_ok = me % initialized if ( status_ok ) then !initialize some of the class variables: ! [note: this was formerly done in the interp routine] me % pc ( 1 ) = 1.0_wp me % vc ( 2 ) = 1.0_wp else write ( error_unit , '(A)' ) 'Error reading ephemeris file: ' // trim ( me % namfil ) end if else write ( error_unit , '(A)' ) 'Error opening ephemeris file: ' // trim ( me % namfil ) end if end subroutine initialize_ephemeris !***************************************************************************************** !***************************************************************************************** !> !  Close the ephemeris. subroutine close_ephemeris ( me ) implicit none class ( jpl_ephemeris ), intent ( inout ) :: me logical :: is_open integer :: istat if ( me % initialized ) then !close the file: inquire ( unit = me % nrfile , opened = is_open , iostat = istat ) if ( is_open ) close ( unit = me % nrfile , iostat = istat ) !initialize all class variables to defaults: call clear ( me ) end if contains subroutine clear ( eph ) !! clear all the variables in the [[jpl_ephemeris]] class. implicit none class ( jpl_ephemeris ), intent ( out ) :: eph end subroutine clear end subroutine close_ephemeris !***************************************************************************************** !***************************************************************************************** !> !  This subroutine reads and interpolates the JPL planetary ephemeris file. ! !@note The ephemeris is assumed to have been initialized. subroutine state ( me , et2 , list , pv , pnut , status_ok ) implicit none class ( jpl_ephemeris ), intent ( inout ) :: me real ( wp ), dimension ( 2 ), intent ( in ) :: et2 !! 2-word Julian ephemeris epoch at which interpolation !! is wanted.  any combination of `et2(1)+et2(2)` which falls !! within the time span on the file is a permissible epoch. !! !! ***a.*** for ease in programming, the user may put the !!    entire epoch in `et2(1)` and set `et2(2)=0`. !! ***b.*** for maximum interpolation accuracy, set `et2(1)` = !!    the most recent midnight at or before interpolation !!    epoch and set `et2(2)` = fractional part of a day !!    elapsed between `et2(1)` and epoch. !! ***c.*** as an alternative, it may prove convenient to set !!    `et2(1)` = some fixed epoch, such as start of integration, !!    and `et2(2)` = elapsed interval between then and epoch. integer , dimension ( 12 ), intent ( in ) :: list !! 12-word integer array specifying what interpolation !! is wanted for each of the bodies on the file. !!    ***list(i) = 0*** : no interpolation for body i, !!    ***list(i) = 1*** : position only, !!    ***list(i) = 2*** : position and velocity. !! !! The designation of the astronomical bodies by i is: !!    ***i = 1*** : mercury, !!    ***i = 2*** : venus, !!    ***i = 3*** : earth-moon barycenter, !!    ***i = 4*** : mars, !!    ***i = 5*** : jupiter, !!    ***i = 6*** : saturn, !!    ***i = 7*** : uranus, !!    ***i = 8*** : neptune, !!    ***i = 9*** : pluto, !!    ***i =10*** : geocentric moon, !!    ***i =11*** : nutations in longitude and obliquity, !!    ***i =12*** : lunar librations (if on file). real ( wp ), dimension ( 6 , 11 ), intent ( out ) :: pv !! dp 6 x 11 array that will contain requested interpolated !! quantities (other than nutation, stored in `pnut`). !! the body specified by `list(i)` will have its !! state in the array starting at `pv(1,i)`. !! (on any given call, only those words in `pv` which are !! affected by the first 10 `list` entries, and by `list(12)` !! if librations are on the file, are set. !! the rest of the `pv` array is untouched.) !! the order of components starting in `pv(1,i)` is: !! `x`,`y`,`z`,`dx`,`dy`,`dz`. !! !! All output vectors are referenced to the earth mean !! equator and equinox of J2000 if the DE number is 200 or !! greater; of B1950 if the DE number is less than 200. !! !! The moon state is always geocentric; the other nine states !! are either heliocentric or solar-system barycentric, !! depending on the setting of the `bary` variable in the class. !! !! Lunar librations, if on file, are put into `pv(k,11)` if !! `list(12)` is `1` or `2`. real ( wp ), dimension ( 4 ), intent ( out ) :: pnut !! dp 4-word array that will contain nutations and rates, !! depending on the setting of `list(11)`.  the order of !! quantities in `pnut` is: !! !! * `d psi`  (nutation in longitude), !! * `d epsilon` (nutation in obliquity), !! * `d psi dot`, !! * `d epsilon dot`. logical , intent ( out ) :: status_ok !! true if there were no problems real ( wp ), dimension ( 2 ) :: t real ( wp ), dimension ( 4 ) :: pjd real ( wp ) :: aufac , s , tmp1 , tmp2 integer :: istat , i , j , k , nr status_ok = . true . s = et2 ( 1 ) - 0.5_wp call split ( s , pjd ( 1 : 2 )) call split ( et2 ( 2 ), pjd ( 3 : 4 )) pjd ( 1 ) = pjd ( 1 ) + pjd ( 3 ) + 0.5_wp pjd ( 2 ) = pjd ( 2 ) + pjd ( 4 ) call split ( pjd ( 2 ), pjd ( 3 : 4 )) pjd ( 1 ) = pjd ( 1 ) + pjd ( 3 ) ! error return for epoch out of range if ( pjd ( 1 ) + pjd ( 4 ) < me % ss ( 1 ) . or . pjd ( 1 ) + pjd ( 4 ) > me % ss ( 2 )) then write ( error_unit , '(A,F12.2,A,2F22.2)' ) & 'Error: requested jed,' ,& et2 ( 1 ) + et2 ( 2 ),& ' not within ephemeris limits,' ,& me % ss ( 1 ), me % ss ( 2 ) status_ok = . false . return end if ! calculate record # and relative time in interval nr = int (( pjd ( 1 ) - me % ss ( 1 )) / me % ss ( 3 )) + 3 if ( pjd ( 1 ) == me % ss ( 2 )) nr = nr - 1 tmp1 = dble ( nr - 3 ) * me % ss ( 3 ) + me % ss ( 1 ) tmp2 = pjd ( 1 ) - tmp1 t ( 1 ) = ( tmp2 + pjd ( 4 )) / me % ss ( 3 ) ! read correct record if not in core if ( nr /= me % nrl ) then me % nrl = nr read ( me % nrfile , rec = nr , iostat = istat ) ( me % buf ( k ), k = 1 , me % ncoeffs ) if ( istat /= 0 ) then write ( error_unit , '(2F12.2,A80)' ) et2 , 'Error return in state' status_ok = . false . return end if endif if ( me % km ) then t ( 2 ) = me % ss ( 3 ) * 8640 0.0_wp aufac = 1.0_wp else t ( 2 ) = me % ss ( 3 ) aufac = 1.0_wp / me % au endif ! interpolate ssbary sun call me % interp ( me % buf ( me % ipt ( 1 , 11 )), t , me % ipt ( 2 , 11 ), 3 , me % ipt ( 3 , 11 ), 2 , me % pvsun ) me % pvsun = me % pvsun * aufac ! check and interpolate whichever bodies are requested do i = 1 , 10 if ( list ( i ) == 0 ) cycle call me % interp ( me % buf ( me % ipt ( 1 , i )), t , me % ipt ( 2 , i ), 3 , me % ipt ( 3 , i ), list ( i ), pv ( 1 , i )) do j = 1 , 6 if ( i <= 9 . and . . not . me % bary ) then pv ( j , i ) = pv ( j , i ) * aufac - me % pvsun ( j ) else pv ( j , i ) = pv ( j , i ) * aufac endif enddo end do ! do nutations if requested (and if on file) if ( list ( 11 ) > 0 . and . me % ipt ( 2 , 12 ) > 0 ) & call me % interp ( me % buf ( me % ipt ( 1 , 12 )), t , me % ipt ( 2 , 12 ), 2 , me % ipt ( 3 , 12 ), list ( 11 ), pnut ) ! get librations if requested (and if on file) if ( list ( 12 ) > 0 . and . me % ipt ( 2 , 13 ) > 0 ) & call me % interp ( me % buf ( me % ipt ( 1 , 13 )), t , me % ipt ( 2 , 13 ), 3 , me % ipt ( 3 , 13 ), list ( 12 ), pv ( 1 , 11 )) end subroutine state !***************************************************************************************** !***************************************************************************************** !> !  Obtain the constants from the ephemeris file. subroutine get_constants ( me , nam , val , sss , n ) implicit none class ( jpl_ephemeris ), intent ( inout ) :: me character ( len = 6 ), dimension (:), intent ( out ) :: nam !! array of constant names real ( wp ), dimension (:), intent ( out ) :: val !! array of values of constants real ( wp ), dimension ( 3 ), intent ( out ) :: sss !! jd start, jd stop, step of ephemeris integer , intent ( out ) :: n !! number of entries in `nam` and `val` arrays integer :: i if ( me % initialized ) then n = me % ncon sss = me % ss do i = 1 , n nam ( i ) = me % cnam ( i ) val ( i ) = me % cval ( i ) enddo else write ( error_unit , '(A)' ) 'error in get_constants: the ephemeris is not initialized.' end if end subroutine get_constants !***************************************************************************************** !***************************************************************************************** !> !  Ephemeris test routine. ! !### Ephemeris files !  This routine requires the DE405 and DE421 JPL binary ephemeris files !  to be present in the `./eph` directory. !  These can be built by using the instructions !  [here](https://ssd.jpl.nasa.gov/ftp/eph/planets/fortran/userguide.txt). ! !  See also `get_third_party.sh` script in the repo. subroutine ephemeris_test () use time_module , only : jd_to_et use celestial_body_module , fat_wp => wp implicit none ! note: the low-level functions use real64 variables. character ( len = 6 ), dimension ( nmax ) :: nams real ( wp ), dimension ( 6 ) :: diffrv real ( wp ), dimension ( 3 ) :: ss real ( wp ), dimension ( nmax ) :: vals integer :: nvs , ntarg , nctr , i , j type ( jpl_ephemeris ) :: eph405 , eph421 logical :: status_ok_405 , status_ok_421 real ( wp ) :: jd_64 , rv_64 ( 6 ), rv1_64 ( 6 ), rv2_64 ( 6 ) real ( fat_wp ) :: et real ( fat_wp ), dimension ( 3 ) :: r real ( fat_wp ), dimension ( 6 ) :: rv , rv1 , rv2 real ( fat_wp ) :: jd character ( len =* ), parameter :: ephemeris_file_405 = './eph/JPLEPH.405' !! JPL DE405 ephemeris file character ( len =* ), parameter :: ephemeris_file_421 = './eph/JPLEPH.421' !! JPL DE421 ephemeris file write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' ephemeris_test' write ( * , * ) '---------------' write ( * , * ) '' !initialize: call eph405 % initialize ( filename = ephemeris_file_405 , status_ok = status_ok_405 ) call eph421 % initialize ( filename = ephemeris_file_421 , status_ok = status_ok_421 ) if ( status_ok_405 ) then !get some constants from the file: call eph405 % get_constants ( nams , vals , ss , nvs ) write ( * , '(A)' ) '' write ( * , '(A)' ) 'Ephemeris initialized' write ( * , '(A,1X,F15.3,1X,A,1X,F15.3)' ) 'JD range: ' , ss ( 1 ), 'to ' , ss ( 2 ) write ( * , '(A)' ) '' do i = 1 , nvs write ( * , '(A,1X,D25.16)' ) nams ( i ), vals ( i ) end do jd = 245153 6.5_wp ! julian date et = jd_to_et ( jd ) ! ephemeris time if ( jd < ss ( 1 ) . or . jd > ss ( 2 )) then write ( * , '(A)' ) '' write ( * , * ) 'error: jed out of bounds.' write ( * , * ) 'jed   = ' , jd write ( * , * ) 'ss(1) = ' , ss ( 1 ) write ( * , * ) 'ss(2) = ' , ss ( 2 ) else !test DE405: do j = 1 , 2 if ( j == 1 ) then ntarg = 3 !earth nctr = 11 !sun else ntarg = 10 !moon nctr = 3 !earth end if write ( * , * ) '' write ( * , * ) 'DE405' write ( * , * ) 'state of \"' // trim ( list_of_bodies ( ntarg )) // & '\" wrt \"' // trim ( list_of_bodies ( nctr )) // '\"' do i = 1 , 10 jd_64 = jd call eph405 % get_state ( jd_64 , ntarg , nctr , rv_64 , status_ok_405 ) rv = rv_64 write ( * , '(F15.2,1X,*(E25.16,1X))' ) jd , norm2 ( rv ( 1 : 3 )), rv jd = jd + 1 0.0_wp end do end do end if else write ( * , * ) 'Error opening DE405 ephemeris file' end if if ( status_ok_405 . and . status_ok_421 ) then !compare DE405 with DE421 do j = 1 , 2 if ( j == 1 ) then ntarg = 3 !earth nctr = 11 !sun else ntarg = 10 !moon nctr = 3 !earth end if write ( * , * ) '' write ( * , * ) 'DE421 - DE405 Difference' write ( * , * ) 'state of \"' // trim ( list_of_bodies ( ntarg )) // & '\" wrt \"' // trim ( list_of_bodies ( nctr )) // '\"' do i = 1 , 10 jd_64 = jd call eph405 % get_state ( jd_64 , ntarg , nctr , rv1_64 , status_ok_405 ) rv1 = rv1_64 jd_64 = jd call eph421 % get_state ( jd_64 , ntarg , nctr , rv2_64 , status_ok_421 ) rv2 = rv2_64 diffrv = rv2 - rv1 write ( * , '(F15.2,1X,*(E25.16,1X))' ) jd , norm2 ( diffrv ( 1 : 3 )), norm2 ( diffrv ( 4 : 6 )) jd = jd + 1 0.0_wp end do end do ! compare get_rv with get_r call eph405 % get_rv ( et , body_earth , body_moon , rv , status_ok_405 ) call eph405 % get_r ( et , body_earth , body_moon , r , status_ok_405 ) write ( * , * ) '' write ( * , * ) 'r - rv(1:3) = ' , r - rv ( 1 : 3 ) if (. not . all ( r - rv ( 1 : 3 ) == zero )) error stop 'error in ephemeris' write ( * , * ) '' else write ( * , * ) 'Error opening DE421 ephemeris file' end if !cleanup: call eph405 % close () call eph421 % close () end subroutine ephemeris_test !***************************************************************************************** !***************************************************************************************** end module jpl_ephemeris_module !*****************************************************************************************","tags":"","url":"sourcefile/jpl_ephemeris_module.f90.html"},{"title":"time_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~time_module.f90~~EfferentGraph sourcefile~time_module.f90 time_module.f90 sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~time_module.f90->sourcefile~conversion_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~time_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~time_module.f90~~AfferentGraph sourcefile~time_module.f90 time_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~time_module.f90 sourcefile~jpl_ephemeris_module.f90 jpl_ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~standish_module.f90 standish_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~standish_module.f90 sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~transformation_module.f90 sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~time_module.f90 sourcefile~standish_module.f90->sourcefile~time_module.f90 sourcefile~transformation_module.f90->sourcefile~time_module.f90 sourcefile~transformation_module.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~lighting_module.f90->sourcefile~transformation_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Time conversion routines. module time_module use kind_module implicit none private !parameters: real ( wp ), parameter :: jd_j2000 = 245154 5.0_wp !! julian date of J2000 epoch interface julian_date !! calendar date to julian date module procedure :: julian_date_realsec , & julian_date_intsec end interface interface julian_date_to_calendar_date module procedure :: calendar_date_realsec end interface !public routines: public :: julian_day public :: julian_date public :: et_to_jd public :: jd_to_et public :: jd_to_mjd public :: mjd_to_jd public :: julian_date_to_calendar_date public :: calendar_date_to_et public :: is_leap_year !test routine: public :: time_module_test contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 2/3/2015 ! !  Convert ephemeris time (seconds from J2000 epoch) to Julian date. pure function et_to_jd ( et ) result ( jd ) use conversion_module , only : sec2day implicit none real ( wp ), intent ( in ) :: et !! ephemeris time [sec from J2000 epoch] real ( wp ) :: jd !! Julian date [days] jd = jd_j2000 + et * sec2day end function et_to_jd !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 3/19/2016 ! !  Convert Julian date to ephemeris time (seconds from J2000 epoch). pure function jd_to_et ( jd ) result ( et ) use conversion_module , only : day2sec implicit none real ( wp ), intent ( in ) :: jd !! Julian date [days] real ( wp ) :: et !! ephemeris time [sec from J2000 epoch] et = ( jd - jd_j2000 ) * day2sec end function jd_to_et !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 3/15/2015 ! !  Converts Julian date to Modified Julian date. ! !### Reference !   * [USNO](http://tycho.usno.navy.mil/mjd.html) pure function jd_to_mjd ( jd ) result ( mjd ) implicit none real ( wp ) :: mjd !! modified julian date real ( wp ), intent ( in ) :: jd !! julian date mjd = jd - 240000 0.5_wp end function jd_to_mjd !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 3/15/2015 ! !  Converts Modified Julian date to Julian date. ! !### Reference !   * [USNO](http://tycho.usno.navy.mil/mjd.html) pure function mjd_to_jd ( mjd ) result ( jd ) implicit none real ( wp ) :: jd !! julian date real ( wp ), intent ( in ) :: mjd !! modified julian date jd = mjd + 240000 0.5_wp end function mjd_to_jd !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Returns the Julian day number (i.e., the Julian date at Greenwich noon) !  on the specified YEAR, MONTH, and DAY. ! !  Valid for any Gregorian calendar date producing a !  Julian date greater than zero. ! !### Reference !   * [USNO](http://aa.usno.navy.mil/faq/docs/JD_Formula.php) pure integer function julian_day ( y , m , d ) implicit none integer , intent ( in ) :: y !! year (YYYY) integer , intent ( in ) :: m !! month (MM) integer , intent ( in ) :: d !! day (DD) julian_day = d - 32075 + 1461 * ( y + 4800 + ( m - 14 ) / 12 ) / 4 + 367 * & ( m - 2 - ( m - 14 ) / 12 * 12 ) / 12 - 3 * (( y + 4900 + ( m - 14 ) / 12 ) / 100 ) / 4 end function julian_day !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/21/2015 ! !  Returns the Julian date for the specified YEAR, MONTH, DAY, HR, MIN, SEC. ! !  Valid for any Gregorian calendar date producing a !  Julian date greater than zero. ! !### History !  * JW : 10/4/2017 : moved main code to [[julian_date_realsec]] routine. pure function julian_date_intsec ( y , m , d , hour , minute , second ) result ( julian_date ) implicit none real ( wp ) :: julian_date integer , intent ( in ) :: y integer , intent ( in ) :: m integer , intent ( in ) :: d integer , intent ( in ) :: hour integer , intent ( in ) :: minute integer , intent ( in ) :: second ! call the other routine: julian_date = julian_date_realsec ( y , m , d , hour , minute , real ( second , wp )) end function julian_date_intsec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/21/2015 ! !  Returns the Julian date for the specified YEAR, MONTH, DAY, HR, MIN, SEC. ! !  Valid for any Gregorian calendar date producing a !  Julian date greater than zero. ! !### History !  * JW : 10/4/2017 : made `second` a real value & renamed routine. pure function julian_date_realsec ( y , m , d , hour , minute , second ) result ( julian_date ) implicit none real ( wp ) :: julian_date integer , intent ( in ) :: y integer , intent ( in ) :: m integer , intent ( in ) :: d integer , intent ( in ) :: hour integer , intent ( in ) :: minute real ( wp ), intent ( in ) :: second integer :: julian_day_number julian_day_number = julian_day ( y , m , d ) julian_date = real ( julian_day_number , wp ) + & ( hour - 1 2.0_wp ) / 2 4.0_wp + & minute / 144 0.0_wp + & second / 8640 0.0_wp end function julian_date_realsec !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Returns the year, month, day, hr, min, sec for the specified Julian date. ! !### See also !  * https://aa.usno.navy.mil/faq/JD_formula.html !  * http://www.davidgsimpson.com/software/jd2greg_f90.txt pure subroutine calendar_date_realsec ( julian_date , year , month , day , hrs , min , sec ) implicit none real ( wp ), intent ( in ) :: julian_date !! julian date integer , intent ( out ) :: year integer , intent ( out ) :: month integer , intent ( out ) :: day integer , intent ( out ) :: hrs integer , intent ( out ) :: min real ( wp ), intent ( out ) :: sec integer :: i , j , k , l , n , jd real ( wp ) :: frac_day jd = int ( julian_date ) l = jd + 68569 n = 4 * l / 146097 l = l - ( 146097 * n + 3 ) / 4 i = 4000 * ( l + 1 ) / 1461001 l = l - 1461 * i / 4 + 31 j = 80 * l / 2447 k = l - 2447 * j / 80 l = j / 11 j = j + 2 - 12 * l i = 100 * ( n - 49 ) + i + l year = i month = j day = k frac_day = julian_date - real ( jd , wp ) + 0.5_wp hrs = int ( frac_day * 2 4.0_wp ) min = int (( frac_day - hrs / 2 4.0_wp ) * 144 0.0_wp ) sec = ( frac_day - hrs / 2 4.0_wp - min / 144 0.0_wp ) * 8640 0.0_wp if ( sec == 6 0.0_wp ) then sec = 0.0_wp min = min + 1 end if if ( min == 60 ) then min = 0 hrs = hrs + 1 end if end subroutine calendar_date_realsec !***************************************************************************************** !***************************************************************************************** !> !  Return true if the specified year is a leap year. pure logical function is_leap_year ( y ) integer , intent ( in ) :: y !! year is_leap_year = ( mod ( y , 4 ) == 0 . and . ( mod ( y , 100 ) /= 0 . or . mod ( y , 400 ) == 0 )) end function is_leap_year !***************************************************************************************** !***************************************************************************************** !> !  Directly converts a calendar date to seconds since the J2000 epoch. function calendar_date_to_et ( year , month , day , hour , minute , second ) result ( et ) use conversion_module , only : hr2sec , min2sec , day2sec integer , intent ( in ) :: year , month , day , hour , minute real ( wp ), intent ( in ) :: second real ( wp ) :: et ! Constants for the J2000 epoch: January 1, 2000, 12:00:00 integer , parameter :: j2000_year = 2000 integer , parameter :: j2000_month = 1 integer , parameter :: j2000_day = 1 integer , parameter :: j2000_hour = 12 integer , parameter :: j2000_minute = 0 real ( wp ), parameter :: j2000_second = 0.0_wp ! Days in each month (non-leap year) integer , dimension ( 12 ), parameter :: days_in_month = [ 31 , 28 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] integer :: y , m integer :: total_days ! first do time of day: et = real ( hour - j2000_hour , wp ) * hr2sec + & real ( minute - j2000_minute , wp ) * min2sec + & ( second - j2000_second ) ! now, calculate the total number of days from J2000 to the given date total_days = 0 do y = j2000_year , year - 1 total_days = total_days + 365 + merge ( 1 , 0 , is_leap_year ( y )) end do do m = 1 , month - 1 if ( m == 2 ) then total_days = total_days + days_in_month ( m ) + merge ( 1 , 0 , is_leap_year ( year )) else total_days = total_days + days_in_month ( m ) end if end do ! add days: et = et + real ( total_days + ( day - j2000_day ), wp ) * day2sec end function calendar_date_to_et !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 1/21/2015 ! !  Test routine for the Julian date routines. subroutine time_module_test () implicit none real ( wp ) :: jd , sec integer :: year , month , day , hrs , min real ( wp ) :: et1 , et2 write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' time_module_test' write ( * , * ) '---------------' write ( * , * ) '' ! JD = 2451545.0 jd = julian_date ( 2000 , 1 , 1 , 12 , 0 , 0 ) call calendar_date_realsec ( jd , year , month , day , hrs , min , sec ) write ( * , * ) 'jd    ' , jd write ( * , * ) 'year  ' , year write ( * , * ) 'month ' , month write ( * , * ) 'day   ' , day write ( * , * ) 'hrs   ' , hrs write ( * , * ) 'min   ' , min write ( * , * ) 'sec   ' , sec if ( year /= 2000 ) error stop 'error: incorrect year' if ( month /= 1 ) error stop 'error: incorrect month' if ( day /= 1 ) error stop 'error: incorrect day' if ( hrs /= 12 ) error stop 'error: incorrect hrs' if ( min /= 0 ) error stop 'error: incorrect min' if ( sec /= 0.0_wp ) error stop 'error: incorrect sec' ! compare two ways to convert calendar date to ephemeris time: ! et1 should be more accurate since it doesn't go through jd write ( * , * ) '' et1 = calendar_date_to_et ( 2026 , 3 , 4 , 8 , 9 , 1 0.12345678_wp ) et2 = jd_to_et ( julian_date ( 2026 , 3 , 4 , 8 , 9 , 1 0.12345678_wp )) write ( * , * ) 'et1   ' , et1 write ( * , * ) 'et2   ' , et2 write ( * , * ) 'et diff: ' , abs ( et1 - et2 ) write ( * , * ) '' write ( * , * ) 'PASSED' end subroutine time_module_test !***************************************************************************************** !***************************************************************************************** end module time_module !*****************************************************************************************","tags":"","url":"sourcefile/time_module.f90.html"},{"title":"relative_motion_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~relative_motion_module.f90~~EfferentGraph sourcefile~relative_motion_module.f90 relative_motion_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~relative_motion_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~relative_motion_module.f90->sourcefile~numbers_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~relative_motion_module.f90->sourcefile~vector_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~relative_motion_module.f90~~AfferentGraph sourcefile~relative_motion_module.f90 relative_motion_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~relative_motion_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  This module contains various routines related to relative motion. ! !## Axis systems ! !  Three different axis systems are used here.  They are: ! !  * The **IJK** frame ! !  * The **LVLH** frame, defined by: ! !     * x-axis : completes the right handed system !       (for a perfectly-circular orbit, the x-axis is  \\hat{\\mathbf{v}} ) !     * y-axis :  -\\hat{\\mathbf{h}}  !     * z-axis :  -\\hat{\\mathbf{r}}  ! !  * The **RSW** frame, defined by: ! !     * x-axis :  \\hat{\\mathbf{r}}  !     * y-axis : completes the right handed system !       (for a perfectly-circular orbit, the y-axis is  \\hat{\\mathbf{v}} ) !     * z-axis :  \\hat{\\mathbf{h}}  ! !  * The **VUW** frame, defined by: ! !     * x-axis :  \\hat{\\mathbf{v}}  !     * y-axis : completes the right handed system !     * z-axis :  \\hat{\\mathbf{h}}  module relative_motion_module use kind_module , only : wp use numbers_module implicit none private abstract interface subroutine report_func ( t , rv ) !! for reporting the points in the [[cw_propagator]]. import :: wp implicit none real ( wp ), intent ( in ) :: t !! time [sec] real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! state [km,km/s] end subroutine report_func subroutine frame_transform_func ( mu , r , v , a , c , cdot ) import implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] [not used by all algorithms] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector of target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector of target [km/s] real ( wp ), dimension ( 3 ), intent ( in ), optional :: a !! acceleration vector of target [km/s&#94;2] !! (if not present, then a torque-free force model is assumed) real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c !! C transformation matrix real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot !! CDOT transformation matrix end subroutine frame_transform_func end interface interface from_ijk_to_lvlh !! Conversion from IJK to LVLH procedure :: from_ijk_to_lvlh_mat !! just returns matrices procedure :: from_ijk_to_lvlh_rv !! transforms the r,v vectors end interface from_ijk_to_lvlh public :: from_ijk_to_lvlh interface from_lvlh_to_ijk !! Conversion from LVLH to IJK procedure :: from_lvlh_to_ijk_mat !! just returns matrices procedure :: from_lvlh_to_ijk_rv !! transforms the r,v vectors end interface from_lvlh_to_ijk public :: from_lvlh_to_ijk interface from_ijk_to_rsw !! Conversion from IJK to RSW procedure :: from_ijk_to_rsw_mat !! just returns matrices procedure :: from_ijk_to_rsw_rv !! transforms the r,v vectors end interface from_ijk_to_rsw public :: from_ijk_to_rsw interface from_rsw_to_ijk !! Conversion from RSW to IJK procedure :: from_rsw_to_ijk_mat !! just returns matrices procedure :: from_rsw_to_ijk_rv !! transforms the r,v vectors end interface from_rsw_to_ijk public :: from_rsw_to_ijk interface from_lvlh_to_rsw !! Conversion from LVLH to RSW procedure :: from_lvlh_to_rsw_rv !! transforms the r,v vectors end interface from_lvlh_to_rsw public :: from_lvlh_to_rsw interface from_rsw_to_lvlh !! Conversion from RSW to LVLH procedure :: from_rsw_to_lvlh_rv !! transforms the r,v vectors end interface from_rsw_to_lvlh public :: from_rsw_to_lvlh interface from_ijk_to_vuw !! Conversion from IJK to vuw procedure :: from_ijk_to_vuw_mat !! just returns matrices procedure :: from_ijk_to_vuw_rv !! transforms the r,v vectors end interface from_ijk_to_vuw public :: from_ijk_to_vuw interface from_vuw_to_ijk !! Conversion from vuw to IJK procedure :: from_vuw_to_ijk_mat !! just returns matrices procedure :: from_vuw_to_ijk_rv !! transforms the r,v vectors end interface from_vuw_to_ijk public :: from_vuw_to_ijk public :: cw_equations public :: cw_propagator public :: relative_motion_test !test routine contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 6/14/2015 ! !  Clohessy-Wiltshire equations for relative motion. ! !  These apply to an RSW frame centered at the target spacecraft. ! !# References !   * [The Clohessy Wiltshire Model](http://courses.ae.utexas.edu/ase366k/cw_equations.pdf) function cw_equations ( x0 , dt , n ) result ( x ) implicit none real ( wp ), dimension ( 6 ), intent ( in ) :: x0 !! initial state [r,v] of chaser (at t0) [km, km/s] real ( wp ), intent ( in ) :: dt !! elapsed time from t0 [sec] real ( wp ), intent ( in ) :: n !! mean motion of target orbit (`sqrt(mu/a**3)`) [1/sec] real ( wp ), dimension ( 6 ) :: x !! final state [r,v] of chaser [km, km/s] real ( wp ) :: nt , cnt , snt if ( dt == zero ) then x = x0 else if ( n == zero ) then error stop 'Error: Target orbit mean motion must be non-zero.' else nt = n * dt cnt = cos ( nt ) snt = sin ( nt ) x ( 1 ) = ( four - three * cnt ) * x0 ( 1 ) + ( snt / n ) * x0 ( 4 ) + ( two / n ) * ( one - cnt ) * x0 ( 5 ) x ( 2 ) = six * ( snt - nt ) * x0 ( 1 ) + x0 ( 2 ) - ( two / n ) * ( one - cnt ) * x0 ( 4 ) + one / n * ( four * snt - three * nt ) * x0 ( 5 ) x ( 3 ) = cnt * x0 ( 3 ) + ( snt / n ) * x0 ( 6 ) x ( 4 ) = three * n * snt * x0 ( 1 ) + cnt * x0 ( 4 ) + two * snt * x0 ( 5 ) x ( 5 ) = - ( six * n * ( one - cnt )) * x0 ( 1 ) - two * snt * x0 ( 4 ) + ( four * cnt - three ) * x0 ( 5 ) x ( 6 ) = - n * snt * x0 ( 3 ) + cnt * x0 ( 6 ) end if end if end function cw_equations !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 8/23/2015 ! !  Clohessy-Wiltshire propagation routine. ! !# See also !   * [[rk_module]] subroutine cw_propagator ( t0 , x0 , h , n , tf , xf , report ) implicit none real ( wp ), intent ( in ) :: t0 !! initialize time [sec] real ( wp ), dimension ( 6 ), intent ( in ) :: x0 !! initial state in RST coordinates [km,km/s] real ( wp ), intent ( in ) :: h !! abs(time step) [sec] real ( wp ), intent ( in ) :: n !! mean motion of target orbit (`sqrt(mu/a**3)`) [1/sec] real ( wp ), intent ( in ) :: tf !! final time [sec] real ( wp ), dimension ( 6 ), intent ( out ) :: xf !! final state in RST coordinates [km,km/s] procedure ( report_func ), optional :: report !! to report each point real ( wp ) :: t , dt , t2 real ( wp ), dimension ( 6 ) :: x logical :: last , export export = present ( report ) if ( export ) call report ( t0 , x0 ) !first point if ( h == zero ) then xf = x0 else t = t0 x = x0 dt = sign ( h , tf - t0 ) !time step  (correct sign) do t2 = t + dt last = (( dt >= zero . and . t2 >= tf ) . or . & !adjust last time step ( dt < zero . and . t2 <= tf )) ! if ( last ) dt = tf - t ! xf = cw_equations ( x , dt , n ) ! propagate if ( last ) exit if ( export ) call report ( t2 , xf ) !intermediate point x = xf t = t2 end do end if if ( export ) call report ( tf , xf ) !last point end subroutine cw_propagator !***************************************************************************************** !***************************************************************************************** !> !  Transform a position (and optionally velocity) vector from IJK to a specified relative frame. subroutine from_ijk_to_frame_rv ( mu , from_ijk_to_frame , rt_ijk , vt_ijk , r_ijk , v_ijk , dr_frame , dv_frame ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] procedure ( frame_transform_func ) :: from_ijk_to_frame !! function to compute the transformation matrices real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ) :: dr_frame !! Chaser frame position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: dv_frame !! Chaser frame position vector relative to target [km] real ( wp ), dimension ( 3 , 3 ) :: c real ( wp ), dimension ( 3 , 3 ) :: cdot real ( wp ), dimension ( 3 ) :: dr_ijk , dv_ijk !IJK state of chaser relative to target: dr_ijk = r_ijk - rt_ijk ! [target + delta = chaser] if ( present ( dv_frame )) then dv_ijk = v_ijk - vt_ijk ! [target + delta = chaser] call from_ijk_to_frame ( mu , rt_ijk , vt_ijk , c = c , cdot = cdot ) dr_frame = matmul ( c , dr_ijk ) dv_frame = matmul ( cdot , dr_ijk ) + matmul ( c , dv_ijk ) else call from_ijk_to_frame ( mu , r_ijk , v_ijk , c = c ) dr_frame = matmul ( c , dr_ijk ) end if end subroutine from_ijk_to_frame_rv !***************************************************************************************** !***************************************************************************************** !> !  Transform a position (and optionally velocity) vector from a specified relative frame to IJK. subroutine from_frame_to_ijk_rv ( mu , from_frame_to_ijk , rt_ijk , vt_ijk , dr_frame , dv_frame , r_ijk , v_ijk ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] procedure ( frame_transform_func ) :: from_frame_to_ijk !! function to compute the transformation matrices real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dr_frame !! Chaser frame position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dv_frame !! Chaser frame position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: v_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 , 3 ) :: c real ( wp ), dimension ( 3 , 3 ) :: cdot if ( present ( v_ijk )) then call from_frame_to_ijk ( mu , rt_ijk , vt_ijk , c = c , cdot = cdot ) !chaser = target + delta: r_ijk = rt_ijk + matmul ( c , dr_frame ) v_ijk = vt_ijk + matmul ( cdot , dr_frame ) + matmul ( c , dv_frame ) else call from_frame_to_ijk ( mu , rt_ijk , vt_ijk , c = c ) r_ijk = rt_ijk + matmul ( c , dr_frame ) end if end subroutine from_frame_to_ijk_rv !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/19/2014 ! !  Compute the transformation matrices to convert IJK to LVLH. ! !# See also !   * [LVLH Transformations](http://degenerateconic.com/wp-content/uploads/2015/03/lvlh.pdf) subroutine from_ijk_to_lvlh_mat ( mu , r , v , a , c , cdot ) use vector_module , only : unit , cross , uhat_dot implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector of target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector of target [km/s] real ( wp ), dimension ( 3 ), intent ( in ), optional :: a !! acceleration vector of target [km/s&#94;2] !! (if not present, then a torque-free force model is assumed) real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c !! C transformation matrix real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot !! CDOT transformation matrix real ( wp ), dimension ( 3 ) :: ex_hat , ex_hat_dot real ( wp ), dimension ( 3 ) :: ey_hat , ey_hat_dot real ( wp ), dimension ( 3 ) :: ez_hat , ez_hat_dot real ( wp ), dimension ( 3 ) :: h , h_hat , h_dot h = cross ( r , v ) h_hat = unit ( h ) ez_hat = - unit ( r ) ey_hat = - h_hat ex_hat = cross ( ey_hat , ez_hat ) c ( 1 ,:) = ex_hat c ( 2 ,:) = ey_hat c ( 3 ,:) = ez_hat if ( present ( cdot )) then ez_hat_dot = - uhat_dot ( r , v ) if ( present ( a )) then h_dot = cross ( r , a ) ey_hat_dot = - uhat_dot ( h , h_dot ) ex_hat_dot = cross ( ey_hat_dot , ez_hat ) + cross ( ey_hat , ez_hat_dot ) else !assume no external torque ey_hat_dot = zero ex_hat_dot = cross ( ey_hat , ez_hat_dot ) end if cdot ( 1 ,:) = ex_hat_dot cdot ( 2 ,:) = ey_hat_dot cdot ( 3 ,:) = ez_hat_dot end if end subroutine from_ijk_to_lvlh_mat !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 8/23/2014 ! !  Transform a position (and optionally velocity) vector from IJK to LVLH. subroutine from_ijk_to_lvlh_rv ( mu , rt_ijk , vt_ijk , r_ijk , v_ijk , dr_lvlh , dv_lvlh ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ) :: dr_lvlh !! Chaser LVLH position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: dv_lvlh !! Chaser LVLH position vector relative to target [km] call from_ijk_to_frame_rv ( mu , from_ijk_to_lvlh_mat , rt_ijk , vt_ijk , r_ijk , v_ijk , dr_lvlh , dv_lvlh ) end subroutine from_ijk_to_lvlh_rv !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/19/2014 ! !  Compute the transformation matrices to convert LVLH to IJK. ! !# See also !   * [LVLH Transformations](http://degenerateconic.com/wp-content/uploads/2015/03/lvlh.pdf) subroutine from_lvlh_to_ijk_mat ( mu , r , v , a , c , cdot ) use vector_module , only : unit , cross implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector of target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector of target [km/s] real ( wp ), dimension ( 3 ), intent ( in ), optional :: a !! acceleration vector of target [km/s&#94;2] !! (if not present, then a torque-free force model is assumed) real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c !! C transformation matrix real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot !! CDOT transformation matrix call from_ijk_to_lvlh ( mu , r , v , a , c , cdot ) c = transpose ( c ) if ( present ( cdot )) cdot = transpose ( cdot ) end subroutine from_lvlh_to_ijk_mat !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 8/23/2014 ! !  Transform a position (and optionally velocity) vector from LVLH to IJK. subroutine from_lvlh_to_ijk_rv ( mu , rt_ijk , vt_ijk , dr_lvlh , dv_lvlh , r_ijk , v_ijk ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dr_lvlh !! Chaser LVLH position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dv_lvlh !! Chaser LVLH position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: v_ijk !! Chaser IJK absolute position vector [km] call from_frame_to_ijk_rv ( mu , from_lvlh_to_ijk_mat , rt_ijk , vt_ijk , dr_lvlh , dv_lvlh , r_ijk , v_ijk ) end subroutine from_lvlh_to_ijk_rv !***************************************************************************************** !***************************************************************************************** !> !  Compute the transformation matrices to convert IJK to vuw. subroutine from_ijk_to_vuw_mat ( mu , r , v , a , c , cdot ) use vector_module , only : unit , cross , uhat_dot implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] !! this is used here to assume instantaneous conic motion if `a` is not present. real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector of target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector of target [km/s] real ( wp ), dimension ( 3 ), intent ( in ), optional :: a !! acceleration vector of target [km/s&#94;2] !! (if not present, then a torque-free force model is assumed) real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c !! C transformation matrix real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot !! CDOT transformation matrix real ( wp ), dimension ( 3 ) :: ex_hat , ex_hat_dot real ( wp ), dimension ( 3 ) :: ey_hat , ey_hat_dot real ( wp ), dimension ( 3 ) :: ez_hat , ez_hat_dot real ( wp ), dimension ( 3 ) :: h , h_hat , h_dot , v_hat , a_conic real ( wp ) :: rmag !! position vector magniude h = cross ( r , v ) h_hat = unit ( h ) v_hat = unit ( v ) ex_hat = v_hat ez_hat = h_hat ey_hat = cross ( ez_hat , ex_hat ) c ( 1 ,:) = ex_hat c ( 2 ,:) = ey_hat c ( 3 ,:) = ez_hat if ( present ( cdot )) then if ( present ( a )) then ex_hat_dot = uhat_dot ( v , a ) h_dot = cross ( r , a ) else rmag = norm2 ( r ) ! is this as simple as we can make this? ! here we assume instantaneous conic motion a_conic = - mu / rmag ** 3 * r ! accceleration for conic motion ex_hat_dot = uhat_dot ( v , a_conic ) h_dot = zero end if ez_hat_dot = uhat_dot ( h , h_dot ) ey_hat_dot = cross ( ez_hat_dot , ex_hat ) + cross ( ez_hat , ex_hat_dot ) cdot ( 1 ,:) = ex_hat_dot cdot ( 2 ,:) = ey_hat_dot cdot ( 3 ,:) = ez_hat_dot end if end subroutine from_ijk_to_vuw_mat !***************************************************************************************** !***************************************************************************************** !> !  Transform a position (and optionally velocity) vector from IJK to VUW. subroutine from_ijk_to_vuw_rv ( mu , rt_ijk , vt_ijk , r_ijk , v_ijk , dr_vuw , dv_vuw ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ) :: dr_vuw !! Chaser vuw position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: dv_vuw !! Chaser vuw position vector relative to target [km] call from_ijk_to_frame_rv ( mu , from_ijk_to_vuw_mat , rt_ijk , vt_ijk , r_ijk , v_ijk , dr_vuw , dv_vuw ) end subroutine from_ijk_to_vuw_rv !***************************************************************************************** !***************************************************************************************** !> !  Compute the transformation matrices to convert VUW to IJK. subroutine from_vuw_to_ijk_mat ( mu , r , v , a , c , cdot ) use vector_module , only : unit , cross implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector of target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector of target [km/s] real ( wp ), dimension ( 3 ), intent ( in ), optional :: a !! acceleration vector of target [km/s&#94;2] !! (if not present, then a torque-free force model is assumed) real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c !! C transformation matrix real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot !! CDOT transformation matrix call from_ijk_to_vuw ( mu , r , v , a , c , cdot ) c = transpose ( c ) if ( present ( cdot )) cdot = transpose ( cdot ) end subroutine from_vuw_to_ijk_mat !***************************************************************************************** !***************************************************************************************** !> !  Transform a position (and optionally velocity) vector from VUW to IJK. subroutine from_vuw_to_ijk_rv ( mu , rt_ijk , vt_ijk , dr_vuw , dv_vuw , r_ijk , v_ijk ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dr_vuw !! Chaser vuw position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dv_vuw !! Chaser vuw position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: v_ijk !! Chaser IJK absolute position vector [km] call from_frame_to_ijk_rv ( mu , from_vuw_to_ijk_mat , rt_ijk , vt_ijk , dr_vuw , dv_vuw , r_ijk , v_ijk ) end subroutine from_vuw_to_ijk_rv !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/19/2014 ! !  Compute the transformation matrices to convert IJK to RSW. subroutine from_ijk_to_rsw_mat ( mu , r , v , a , c , cdot ) use vector_module , only : unit , cross , uhat_dot implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector of target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector of target [km/s] real ( wp ), dimension ( 3 ), intent ( in ), optional :: a !! acceleration vector of target [km/s&#94;2] !! (if not present, then a torque-free force model is assumed) real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c !! C transformation matrix real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot !! CDOT transformation matrix real ( wp ), dimension ( 3 ) :: ex_hat , ex_hat_dot real ( wp ), dimension ( 3 ) :: ey_hat , ey_hat_dot real ( wp ), dimension ( 3 ) :: ez_hat , ez_hat_dot real ( wp ), dimension ( 3 ) :: h , h_hat , h_dot h = cross ( r , v ) h_hat = unit ( h ) ex_hat = unit ( r ) ez_hat = h_hat ey_hat = cross ( ez_hat , ex_hat ) c ( 1 ,:) = ex_hat c ( 2 ,:) = ey_hat c ( 3 ,:) = ez_hat if ( present ( cdot )) then ex_hat_dot = uhat_dot ( r , v ) if ( present ( a )) then h_dot = cross ( r , a ) ez_hat_dot = uhat_dot ( h , h_dot ) ey_hat_dot = cross ( ez_hat_dot , ex_hat ) + cross ( ez_hat , ex_hat_dot ) else !assume no external torque ez_hat_dot = zero ey_hat_dot = cross ( ez_hat , ex_hat_dot ) end if cdot ( 1 ,:) = ex_hat_dot cdot ( 2 ,:) = ey_hat_dot cdot ( 3 ,:) = ez_hat_dot end if end subroutine from_ijk_to_rsw_mat !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 8/23/2014 ! !  Transform a position (and optionally velocity) vector from IJK to RSW. subroutine from_ijk_to_rsw_rv ( mu , rt_ijk , vt_ijk , r_ijk , v_ijk , dr_rsw , dv_rsw ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ) :: dr_rsw !! Chaser RSW position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: dv_rsw !! Chaser RSW position vector relative to target [km] call from_ijk_to_frame_rv ( mu , from_ijk_to_rsw_mat , rt_ijk , vt_ijk , r_ijk , v_ijk , dr_rsw , dv_rsw ) end subroutine from_ijk_to_rsw_rv !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 4/19/2014 ! !  Compute the transformation matrices to convert RSW to IJK. subroutine from_rsw_to_ijk_mat ( mu , r , v , a , c , cdot ) use vector_module , only : unit , cross implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: r !! position vector of target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: v !! velocity vector of target [km/s] real ( wp ), dimension ( 3 ), intent ( in ), optional :: a !! acceleration vector of target [km/s&#94;2] !! (if not present, then a torque-free force model is assumed) real ( wp ), dimension ( 3 , 3 ), intent ( out ) :: c !! C transformation matrix real ( wp ), dimension ( 3 , 3 ), intent ( out ), optional :: cdot !! CDOT transformation matrix call from_ijk_to_rsw ( mu , r , v , a , c , cdot ) c = transpose ( c ) if ( present ( cdot )) cdot = transpose ( cdot ) end subroutine from_rsw_to_ijk_mat !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 8/23/2014 ! !  Transform a position (and optionally velocity) vector from RSW to IJK. subroutine from_rsw_to_ijk_rv ( mu , rt_ijk , vt_ijk , dr_rsw , dv_rsw , r_ijk , v_ijk ) implicit none real ( wp ), intent ( in ) :: mu !! gravitational parameter [km&#94;3/s&#94;2] real ( wp ), dimension ( 3 ), intent ( in ) :: rt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: vt_ijk !! Target IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dr_rsw !! Chaser RSW position vector [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dv_rsw !! Chaser RSW velocity vector [km/s] real ( wp ), dimension ( 3 ), intent ( out ) :: r_ijk !! Chaser IJK absolute position vector [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: v_ijk !! Chaser IJK absolute velocity vector [km/s] call from_frame_to_ijk_rv ( mu , from_rsw_to_ijk_mat , rt_ijk , vt_ijk , dr_rsw , dv_rsw , r_ijk , v_ijk ) end subroutine from_rsw_to_ijk_rv !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 8/23/2014 ! !  Transform a position (and optionally velocity) vector from RSW to LVLH. subroutine from_rsw_to_lvlh_rv ( dr_rsw , dv_rsw , dr_lvlh , dv_lvlh ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: dr_rsw !! Chaser RSW position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dv_rsw !! Chaser RSW velocity vector relative to target [km/s] real ( wp ), dimension ( 3 ), intent ( out ) :: dr_lvlh !! Chaser LVLH position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: dv_lvlh !! Chaser LVLH position vector relative to target [km] dr_lvlh ( 1 ) = dr_rsw ( 2 ) dr_lvlh ( 2 ) = - dr_rsw ( 3 ) dr_lvlh ( 3 ) = - dr_rsw ( 1 ) if ( present ( dv_lvlh )) then dv_lvlh ( 1 ) = dv_rsw ( 2 ) dv_lvlh ( 2 ) = - dv_rsw ( 3 ) dv_lvlh ( 3 ) = - dv_rsw ( 1 ) end if end subroutine from_rsw_to_lvlh_rv !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 8/23/2014 ! !  Transform a position (and optionally velocity) vector from LVLH to RSW. subroutine from_lvlh_to_rsw_rv ( dr_lvlh , dv_lvlh , dr_rsw , dv_rsw ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: dr_lvlh !! Chaser LVLH position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( in ) :: dv_lvlh !! Chaser LVLH position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ) :: dr_rsw !! Chaser RSW position vector relative to target [km] real ( wp ), dimension ( 3 ), intent ( out ), optional :: dv_rsw !! Chaser RSW velocity vector relative to target [km/s] dr_rsw ( 2 ) = dr_lvlh ( 1 ) dr_rsw ( 3 ) = - dr_lvlh ( 2 ) dr_rsw ( 1 ) = - dr_lvlh ( 3 ) if ( present ( dv_rsw )) then dv_rsw ( 2 ) = dv_lvlh ( 1 ) dv_rsw ( 3 ) = - dv_lvlh ( 2 ) dv_rsw ( 1 ) = - dv_lvlh ( 3 ) end if end subroutine from_lvlh_to_rsw_rv !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 8/22/2015 ! !  Unit tests for the [[relative_motion_module]]. subroutine relative_motion_test () implicit none real ( wp ), dimension ( 6 ), parameter :: target_eci_state = [ - 230167 2.24489839_wp , & - 537107 6.10250925_wp , & - 342114 6.71530212_wp , & 613 3.8624555516_wp , & 30 6.265184163608_wp , & - 459 7.13439017524_wp ] real ( wp ), dimension ( 6 ), parameter :: chaser_eci_state = [ - 225521 3.51862763_wp , & - 536655 3.94133467_wp , & - 345387 1.15040494_wp , & 615 6.89588163809_wp , & 35 6.79933181917_wp , & - 456 5.88915429063_wp ] real ( wp ), dimension ( 3 ) :: r_12_I , r1_I , r2_I real ( wp ), dimension ( 3 ) :: v_12_I , v1_I , v2_I real ( wp ), dimension ( 3 ) :: r_12_R , v_12_R real ( wp ), dimension ( 3 , 3 ) :: c , cdot real ( wp ), parameter :: mu = 39860 0.4418_wp ! gravitational parameter [km&#94;3/s&#94;2] write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' relative_motion_test' write ( * , * ) '---------------' write ( * , * ) '' r1_I = target_eci_state ( 1 : 3 ) v1_I = target_eci_state ( 4 : 6 ) r2_I = chaser_eci_state ( 1 : 3 ) v2_I = chaser_eci_state ( 4 : 6 ) r_12_I = r2_I - r1_I v_12_I = v2_I - v1_I call from_ijk_to_lvlh ( mu , r1_I , v1_I , c = c , cdot = cdot ) r_12_R = matmul ( c , r_12_I ) v_12_R = matmul ( cdot , r_12_I ) + matmul ( c , v_12_I ) write ( * , '(A,*(D30.16,1X))' ) 'r_12_LVLH : ' , r_12_R write ( * , '(A,*(D30.16,1X))' ) 'v_12_LVLH : ' , v_12_R write ( * , * ) '' call from_ijk_to_rsw ( mu , r1_I , v1_I , c = c , cdot = cdot ) r_12_R = matmul ( c , r_12_I ) v_12_R = matmul ( cdot , r_12_I ) + matmul ( c , v_12_I ) write ( * , '(A,*(D30.16,1X))' ) 'r_12_RSW : ' , r_12_R write ( * , '(A,*(D30.16,1X))' ) 'v_12_RSW : ' , v_12_R write ( * , * ) '' end subroutine relative_motion_test !***************************************************************************************** !***************************************************************************************** end module relative_motion_module !*****************************************************************************************","tags":"","url":"sourcefile/relative_motion_module.f90.html"},{"title":"brent_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~brent_module.f90~~EfferentGraph sourcefile~brent_module.f90 brent_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~brent_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~brent_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~brent_module.f90~~AfferentGraph sourcefile~brent_module.f90 brent_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~brent_module.f90 sourcefile~rk_module.f90 rk_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~rk_module.f90 sourcefile~rk_module_variable_step.f90 rk_module_variable_step.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~rk_module_variable_step.f90 sourcefile~halo_orbit_module.f90 halo_orbit_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~halo_orbit_module.f90 sourcefile~rk_module.f90->sourcefile~brent_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~brent_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~rk_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Brent algorithms for minimization and root solving without derivatives. ! !### See also ! !  1. R. Brent, \"Algorithms for Minimization Without Derivatives\", !     Prentice-Hall, Inc., 1973. module brent_module use kind_module , only : wp use numbers_module implicit none private type , public :: brent_class !! the main class procedure ( func ), pointer :: f => null () !! function to be minimized contains procedure :: set_function procedure :: minimize => fmin procedure :: find_zero => zeroin end type brent_class abstract interface function func ( me , x ) result ( f ) !! Interface to the function to be minimized. !! It should evaluate f(x) for any x in the interval (ax,bx) import :: wp , brent_class implicit none class ( brent_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ) :: f end function func end interface !unit test routine: public :: brent_test contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 7/19/2014 ! !  Set the function to be minimized. subroutine set_function ( me , f ) implicit none class ( brent_class ), intent ( inout ) :: me procedure ( func ) :: f me % f => f end subroutine set_function !***************************************************************************************** !***************************************************************************************** !> !  An approximation x to the point where f attains a minimum on !  the interval (ax,bx) is determined. ! !  the method used is a combination of golden section search and !  successive parabolic interpolation. convergence is never much slower !  than that for a fibonacci search. if f has a continuous second !  derivative which is positive at the minimum (which is not at ax or !  bx), then convergence is superlinear, and usually of the order of !  about 1.324. ! !  the function f is never evaluated at two points closer together !  than eps*abs(fmin) + (tol/3), where eps is approximately the square !  root of the relative machine precision. if f is a unimodal !  function and the computed values of f are always unimodal when !  separated by at least eps*abs(x) + (tol/3), then fmin approximates !  the abcissa of the global minimum of f on the interval ax,bx with !  an error less than 3*eps*abs(fmin) + tol. if f is not unimodal, !  then fmin may approximate a local, but perhaps non-global, minimum to !  the same accuracy. ! !  this function subprogram is a slightly modified version of the !  algol 60 procedure localmin given in richard brent, algorithms for !  minimization without derivatives, prentice - hall, inc. (1973). ! !### See also !  [1] http://www.netlib.org/fmm/fmin.f function fmin ( me , ax , bx , tol ) result ( xmin ) implicit none class ( brent_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( in ) :: tol !! desired length of the interval of !! uncertainty of the final result (>=0) real ( wp ) :: xmin !! abcissa approximating the point where !! f attains a minimum real ( wp ) :: a , b , d , e , xm , p , q , r , tol1 , tol2 , u , v , w real ( wp ) :: fu , fv , fw , fx , x real ( wp ) :: abs , sqrt , sign real ( wp ), parameter :: c = ( three - sqrt ( five )) / two !! squared inverse of golden ratio real ( wp ), parameter :: half = 0.5_wp real ( wp ), parameter :: eps = sqrt ( epsilon ( one )) ! initialization a = ax b = bx v = a + c * ( b - a ) w = v x = v e = zero fx = me % f ( x ) fv = fx fw = fx do !  main loop starts here xm = half * ( a + b ) tol1 = eps * abs ( x ) + tol / three tol2 = two * tol1 !  check stopping criterion if ( abs ( x - xm ) <= ( tol2 - half * ( b - a ))) exit ! is golden-section necessary if ( abs ( e ) <= tol1 ) then !  a golden-section step if ( x >= xm ) then e = a - x else e = b - x end if d = c * e else !  fit parabola r = ( x - w ) * ( fx - fv ) q = ( x - v ) * ( fx - fw ) p = ( x - v ) * q - ( x - w ) * r q = two * ( q - r ) if ( q > zero ) p = - p q = abs ( q ) r = e e = d !  is parabola acceptable if (( abs ( p ) >= abs ( half * q * r )) . or . ( p <= q * ( a - x )) . or . ( p >= q * ( b - x ))) then !  a golden-section step if ( x >= xm ) then e = a - x else e = b - x end if d = c * e else !  a parabolic interpolation step d = p / q u = x + d !  f must not be evaluated too close to ax or bx if ((( u - a ) < tol2 ) . or . (( b - u ) < tol2 )) d = sign ( tol1 , xm - x ) end if end if !  f must not be evaluated too close to x if ( abs ( d ) >= tol1 ) then u = x + d else u = x + sign ( tol1 , d ) end if fu = me % f ( u ) !  update a, b, v, w, and x if ( fu <= fx ) then if ( u >= x ) a = x if ( u < x ) b = x v = w fv = fw w = x fw = fx x = u fx = fu else if ( u < x ) a = u if ( u >= x ) b = u if ( fu <= fw . or . w == x ) then v = w fv = fw w = u fw = fu else if ( fu <= fv . or . v == x . or . v == w ) then v = u fv = fu end if end if end do !  end of main loop xmin = x end function fmin !***************************************************************************************** !***************************************************************************************** !> !  Find a zero of the function  f(x)  in the given interval !   [a_x,b_x]  to within a tolerance  4 \\epsilon |x| + tol , !  where  \\epsilon  is the relative machine precision defined as !  the smallest representable number such that  1.0 + \\epsilon > 1.0 . ! !  It is assumed that  f(a_x)  and  f(b_x)  have opposite signs. ! !### References !  * R. P. Brent, \"[An algorithm with guaranteed convergence for !    finding a zero of a function](http://maths-people.anu.edu.au/~brent/pd/rpb005.pdf)\", !    The Computer Journal, Vol 14, No. 4., 1971. !  * R. P. Brent, \"[Algorithms for minimization without derivatives](http://maths-people.anu.edu.au/~brent/pub/pub011.html)\", !    Prentice-Hall, Inc., 1973. ! !### See also !  1. [zeroin.f](http://www.netlib.org/go/zeroin.f) from Netlib subroutine zeroin ( me , ax , bx , tol , xzero , fzero , iflag , fax , fbx ) use iso_fortran_env , only : error_unit implicit none class ( brent_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: ax !! left endpoint of initial interval real ( wp ), intent ( in ) :: bx !! right endpoint of initial interval real ( wp ), intent ( in ) :: tol !! desired length of the interval of uncertainty of the final result (>=0) real ( wp ), intent ( out ) :: xzero !! abscissa approximating a zero of `f` in the interval `ax`,`bx` real ( wp ), intent ( out ) :: fzero !! value of `f` at the root (`f(xzero)`) integer , intent ( out ) :: iflag !! status flag (`-1`=error, `0`=root found) real ( wp ), intent ( in ), optional :: fax !! if `f(ax)` is already known, it can be input here real ( wp ), intent ( in ), optional :: fbx !! if `f(ax)` is already known, it can be input here real ( wp ), parameter :: eps = epsilon ( one ) !! original code had d1mach(4) real ( wp ) :: a , b , c , d , e , fa , fb , fc , tol1 , xm , p , q , r , s tol1 = eps + one a = ax b = bx if ( present ( fax )) then fa = fax else fa = me % f ( a ) end if if ( present ( fbx )) then fb = fbx else fb = me % f ( b ) end if !check trivial cases first: if ( fa == zero ) then iflag = 0 xzero = a fzero = fa elseif ( fb == zero ) then iflag = 0 xzero = b fzero = fb elseif ( fa * ( fb / abs ( fb )) < zero ) then ! check that f(ax) and f(bx) have different signs c = a fc = fa d = b - a e = d do if ( abs ( fc ) < abs ( fb )) then a = b b = c c = a fa = fb fb = fc fc = fa end if tol1 = two * eps * abs ( b ) + 0.5_wp * tol xm = 0.5_wp * ( c - b ) if (( abs ( xm ) <= tol1 ). or .( fb == zero )) exit ! see if a bisection is forced if (( abs ( e ) >= tol1 ). and .( abs ( fa ) > abs ( fb ))) then s = fb / fa if ( a /= c ) then ! inverse quadratic interpolation q = fa / fc r = fb / fc p = s * ( two * xm * q * ( q - r ) - ( b - a ) * ( r - one )) q = ( q - one ) * ( r - one ) * ( s - one ) else ! linear interpolation p = two * xm * s q = one - s end if if ( p <= zero ) then p =- p else q =- q end if s = e e = d if ((( two * p ) >= ( three * xm * q - abs ( tol1 * q ))) . or . & ( p >= abs ( 0.5_wp * s * q ))) then d = xm e = d else d = p / q end if else d = xm e = d end if a = b fa = fb if ( abs ( d ) <= tol1 ) then if ( xm <= zero ) then b = b - tol1 else b = b + tol1 end if else b = b + d end if fb = me % f ( b ) if (( fb * ( fc / abs ( fc ))) > zero ) then c = a fc = fa d = b - a e = d end if end do iflag = 0 xzero = b fzero = fb else iflag = - 1 write ( error_unit , '(A)' )& 'Error in zeroin: f(ax) and f(bx) do not have different signs.' end if end subroutine zeroin !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 7/16/2014 ! !  Test of the [[fmin]] and [[zeroin]] functions. subroutine brent_test () implicit none real ( wp ) :: r , fzero integer :: iflag real ( wp ), parameter :: ax = zero real ( wp ), parameter :: bx = two * pi real ( wp ), parameter :: tol = 1.0e-6_wp type , extends ( brent_class ) :: myfunc_type integer :: i = 0 !! function counter end type myfunc_type type ( myfunc_type ) :: myfunc write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' brent_test' write ( * , * ) '---------------' write ( * , * ) '' call myfunc % set_function ( sin_func ) !set the function !call fmin: ! [the minimum is at 270 deg] myfunc % i = 0 r = myfunc % minimize ( ax , bx , tol ) write ( * , * ) 'minimum of sin(x) at: ' , r * 18 0.0_wp / pi , ' deg' write ( * , * ) 'number of function calls: ' , myfunc % i !call zeroin: ! [the root is at pi] myfunc % i = 0 call myfunc % find_zero ( ax + 0.0001_wp , bx / two + 0.0002 , tol , r , fzero , iflag ) write ( * , * ) 'root of sin(x) at: ' , r * 18 0.0_wp / pi , ' deg' write ( * , * ) 'number of function calls: ' , myfunc % i contains function sin_func ( me , x ) result ( f ) !! Example function to minimize: sin(x) implicit none class ( brent_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ) :: f f = sin ( x ) select type ( me ) class is ( myfunc_type ) me % i = me % i + 1 !number of function calls end select end function sin_func end subroutine brent_test !***************************************************************************************** !***************************************************************************************** end module brent_module !*****************************************************************************************","tags":"","url":"sourcefile/brent_module.f90.html"},{"title":"conversion_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~conversion_module.f90~~EfferentGraph sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~conversion_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~conversion_module.f90~~AfferentGraph sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~analytical_ephemeris_module.f90 analytical_ephemeris_module.f90 sourcefile~analytical_ephemeris_module.f90->sourcefile~conversion_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~conversion_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~analytical_ephemeris_module.f90 sourcefile~geopotential_module.f90 geopotential_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geopotential_module.f90 sourcefile~iau_orientation_module.f90 iau_orientation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~iau_orientation_module.f90 sourcefile~jpl_ephemeris_module.f90 jpl_ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 sourcefile~obliquity_module.f90 obliquity_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~obliquity_module.f90 sourcefile~rk_module_variable_step.f90 rk_module_variable_step.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~rk_module_variable_step.f90 sourcefile~standish_module.f90 standish_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~standish_module.f90 sourcefile~time_module.f90 time_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~time_module.f90 sourcefile~c_interface_module.f90 c_interface_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~c_interface_module.f90 sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~transformation_module.f90 sourcefile~geopotential_module.f90->sourcefile~conversion_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~conversion_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~conversion_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~time_module.f90 sourcefile~lighting_module.f90->sourcefile~conversion_module.f90 sourcefile~lighting_module.f90->sourcefile~transformation_module.f90 sourcefile~obliquity_module.f90->sourcefile~conversion_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~conversion_module.f90 sourcefile~standish_module.f90->sourcefile~conversion_module.f90 sourcefile~standish_module.f90->sourcefile~time_module.f90 sourcefile~time_module.f90->sourcefile~conversion_module.f90 sourcefile~c_interface_module.f90->sourcefile~geopotential_module.f90 sourcefile~transformation_module.f90->sourcefile~iau_orientation_module.f90 sourcefile~transformation_module.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~obliquity_module.f90 sourcefile~transformation_module.f90->sourcefile~time_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Conversion factors. ! !# See also ! !  1. A. Thompson and B. N. Taylor, \"NIST Special Publication 811: !     Guide for the use of the International System of Units\". !     http://www.nist.gov/pml/pubs/sp811/ module conversion_module use kind_module , only : wp use numbers_module , only : one , pi implicit none public !metric/imperial: real ( wp ), parameter :: lbm2kg = 0.45359237_wp !! exact real ( wp ), parameter :: lbf2N = 4.4482216152605_wp !! exact real ( wp ), parameter :: ft2m = 0.3048_wp !! exact real ( wp ), parameter :: mile2km = 1.609344_wp !! exact real ( wp ), parameter :: nmi2km = 1.852_wp !! exact real ( wp ), parameter :: slug2kg = lbf2N / ft2m !! approximately 14.593902937206362 real ( wp ), parameter :: kg2lbm = one / lbm2kg !! approximately 2.2046226218487757 real ( wp ), parameter :: N2lbf = one / lbf2N !! approximately 0.2248089430997105 real ( wp ), parameter :: m2ft = one / ft2m !! approximately 3.280839895013123 real ( wp ), parameter :: km2mile = one / mile2km !! approximately 0.621371192237334 real ( wp ), parameter :: km2nmi = one / nmi2km !! approximately 0.5399568034557235 real ( wp ), parameter :: kg2slug = ft2m / lbf2N !! approximately 0.06852176585679176 !angles: real ( wp ), parameter :: deg2rad = pi / 18 0.0_wp real ( wp ), parameter :: rad2deg = 18 0.0_wp / pi !metric: real ( wp ), parameter :: km2m = 100 0.0_wp real ( wp ), parameter :: m2km = one / km2m real ( wp ), parameter :: au2m = 14959787070 0.0_wp !! IAU 2012 defined value !time: real ( wp ), parameter :: min2sec = 6 0.0_wp real ( wp ), parameter :: hr2min = 6 0.0_wp real ( wp ), parameter :: day2hr = 2 4.0_wp real ( wp ), parameter :: year2day = 36 5.25_wp !! julian year real ( wp ), parameter :: century2day = year2day * 10 0.0_wp !! julian century real ( wp ), parameter :: deg2arcmin = 6 0.0_wp real ( wp ), parameter :: deg2arcsec = 360 0.0_wp real ( wp ), parameter :: hr2sec = hr2min * min2sec real ( wp ), parameter :: day2min = day2hr * hr2min real ( wp ), parameter :: day2sec = day2min * min2sec real ( wp ), parameter :: century2sec = century2day * day2sec real ( wp ), parameter :: day2year = one / year2day real ( wp ), parameter :: day2century = one / century2day real ( wp ), parameter :: hr2day = one / day2hr real ( wp ), parameter :: sec2hr = one / hr2sec real ( wp ), parameter :: sec2day = one / day2sec real ( wp ), parameter :: sec2century = one / century2sec real ( wp ), parameter :: arcmin2deg = one / deg2arcmin real ( wp ), parameter :: arcsec2deg = one / deg2arcsec end module conversion_module !*****************************************************************************************","tags":"","url":"sourcefile/conversion_module.f90.html"},{"title":"celestial_body_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~celestial_body_module.f90~~EfferentGraph sourcefile~celestial_body_module.f90 celestial_body_module.f90 sourcefile~base_class_module.f90 base_class_module.f90 sourcefile~celestial_body_module.f90->sourcefile~base_class_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~celestial_body_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~celestial_body_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~celestial_body_module.f90~~AfferentGraph sourcefile~celestial_body_module.f90 celestial_body_module.f90 sourcefile~crtbp_module.f90 crtbp_module.f90 sourcefile~crtbp_module.f90->sourcefile~celestial_body_module.f90 sourcefile~ephemeris_module.f90 ephemeris_module.f90 sourcefile~ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~celestial_body_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~crtbp_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~ephemeris_module.f90 sourcefile~halo_orbit_module.f90 halo_orbit_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~halo_orbit_module.f90 sourcefile~jpl_ephemeris_module.f90 jpl_ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 sourcefile~standish_module.f90 standish_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~standish_module.f90 sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~transformation_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~celestial_body_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~crtbp_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~lighting_module.f90->sourcefile~celestial_body_module.f90 sourcefile~lighting_module.f90->sourcefile~ephemeris_module.f90 sourcefile~lighting_module.f90->sourcefile~transformation_module.f90 sourcefile~spice_ephemeris_module.f90 spice_ephemeris_module.F90 sourcefile~spice_ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~spice_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~standish_module.f90->sourcefile~celestial_body_module.f90 sourcefile~standish_module.f90->sourcefile~ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~celestial_body_module.f90 sourcefile~transformation_module.f90->sourcefile~ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~jpl_ephemeris_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Celestial body definitions module celestial_body_module use kind_module use numbers_module use base_class_module implicit none type , extends ( base_class ), public :: celestial_body !! A celestial body (Planet, moon, etc.) !! The `ID` from the [[base_class]] is the NAIF SPICE ID code for the body real ( wp ) :: mu = zero !! gravitational parameter  \\mu  [km&#94;3/s&#94;2] !note: also should add radius, etc. end type celestial_body type ( celestial_body ), parameter , public :: body_ssb = & celestial_body ( 0 , 'SSB' , 0.0_wp ) !! solar-system barycenter [note: don't have mu defined here yet] !define some bodies: ! MU values from: https://naif.jpl.nasa.gov/pub/naif/generic_kernels/pck/gm_de431.tpc type ( celestial_body ), parameter , public :: body_sun = & celestial_body ( 10 , 'Sun' , 1.3271244004193938E+11_wp ) type ( celestial_body ), parameter , public :: body_mercury = & celestial_body ( 199 , 'Mercury' , 2.2031780000000021E+04_wp ) type ( celestial_body ), parameter , public :: body_venus = & celestial_body ( 299 , 'Venus' , 3.2485859200000006E+05_wp ) type ( celestial_body ), parameter , public :: body_earth = & celestial_body ( 399 , 'Earth' , 3.9860043543609598E+05_wp ) type ( celestial_body ), parameter , public :: body_earth_moon_barycenter = & celestial_body ( 3 , 'Earth-Moon Barycenter' , 4.0350323550225981E+05_wp ) type ( celestial_body ), parameter , public :: body_moon = & celestial_body ( 301 , 'Moon' , 4.9028000661637961E+03_wp ) type ( celestial_body ), parameter , public :: body_mars = & celestial_body ( 499 , 'Mars' , 4.282837362069909E+04_wp ) type ( celestial_body ), parameter , public :: body_jupiter = & celestial_body ( 599 , 'Jupiter' , 1.266865349218008E+08_wp ) type ( celestial_body ), parameter , public :: body_saturn = & celestial_body ( 699 , 'Saturn' , 3.793120749865224E+07_wp ) type ( celestial_body ), parameter , public :: body_uranus = & celestial_body ( 799 , 'Uranus' , 5.793951322279009E+06_wp ) type ( celestial_body ), parameter , public :: body_neptune = & celestial_body ( 899 , 'Neptune' , 6.835099502439672E+06_wp ) type ( celestial_body ), parameter , public :: body_pluto = & celestial_body ( 999 , 'Pluto' , 8.696138177608748E+02_wp ) !***************************************************************************************** end module celestial_body_module !*****************************************************************************************","tags":"","url":"sourcefile/celestial_body_module.f90.html"},{"title":"base_class_module.f90 – fortran-astrodynamics-toolkit","text":"Files dependent on this one sourcefile~~base_class_module.f90~~AfferentGraph sourcefile~base_class_module.f90 base_class_module.f90 sourcefile~celestial_body_module.f90 celestial_body_module.f90 sourcefile~celestial_body_module.f90->sourcefile~base_class_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~base_class_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~celestial_body_module.f90 sourcefile~standish_module.f90 standish_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~standish_module.f90 sourcefile~crtbp_module.f90 crtbp_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~crtbp_module.f90 sourcefile~ephemeris_module.f90 ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~ephemeris_module.f90 sourcefile~halo_orbit_module.f90 halo_orbit_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~halo_orbit_module.f90 sourcefile~jpl_ephemeris_module.f90 jpl_ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~transformation_module.f90 sourcefile~standish_module.f90->sourcefile~base_class_module.f90 sourcefile~standish_module.f90->sourcefile~celestial_body_module.f90 sourcefile~standish_module.f90->sourcefile~ephemeris_module.f90 sourcefile~crtbp_module.f90->sourcefile~celestial_body_module.f90 sourcefile~ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~celestial_body_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~crtbp_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~lighting_module.f90->sourcefile~celestial_body_module.f90 sourcefile~lighting_module.f90->sourcefile~ephemeris_module.f90 sourcefile~lighting_module.f90->sourcefile~transformation_module.f90 sourcefile~spice_ephemeris_module.f90 spice_ephemeris_module.F90 sourcefile~spice_ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~spice_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~celestial_body_module.f90 sourcefile~transformation_module.f90->sourcefile~ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~jpl_ephemeris_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  A base class for defining other classes. module base_class_module implicit none integer , parameter :: name_len = 100 !! length of name strings type , abstract , public :: base_class !! A base class for defining other classes. integer :: id = 0 !! a unique ID code that distinguishes a !! variable from other variables of the same type. character ( len = name_len ) :: name = '' !! the variable name contains generic , public :: operator ( == ) => base_class_equal generic , public :: operator ( /= ) => base_class_not_equal procedure , private :: base_class_equal procedure , private :: base_class_not_equal end type base_class contains !***************************************************************************************** !***************************************************************************************** !> !  `==` operator for [[base_class]] variables. !  To be equal, they must be the same type and have the same `ID`. pure elemental function base_class_equal ( b1 , b2 ) result ( is_equal ) implicit none class ( base_class ), intent ( in ) :: b1 class ( base_class ), intent ( in ) :: b2 logical :: is_equal is_equal = same_type_as ( b1 , b2 ) . and . ( b1 % id == b2 % id ) end function base_class_equal !***************************************************************************************** !***************************************************************************************** !> !  `/=` operator for [[base_class]] variables. !  To be equal, they must be the same type and have the same `ID`. pure elemental function base_class_not_equal ( b1 , b2 ) result ( not_equal ) implicit none class ( base_class ), intent ( in ) :: b1 class ( base_class ), intent ( in ) :: b2 logical :: not_equal not_equal = . not . ( b1 % id == b2 % id ) end function base_class_not_equal !***************************************************************************************** !***************************************************************************************** end module base_class_module !*****************************************************************************************","tags":"","url":"sourcefile/base_class_module.f90.html"},{"title":"geodesy_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~geodesy_module.f90~~EfferentGraph sourcefile~geodesy_module.f90 geodesy_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~geodesy_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~geodesy_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~geodesy_module.f90~~AfferentGraph sourcefile~geodesy_module.f90 geodesy_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geodesy_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Geodesy routines. module geodesy_module use kind_module , only : wp use numbers_module implicit none private public :: heikkinen public :: olson public :: direct public :: inverse public :: cartesian_to_geodetic_triaxial public :: CartesianIntoGeodeticI , CartesianIntoGeodeticII public :: cartesian_to_geodetic_triaxial_2 public :: geodetic_to_cartesian public :: geodetic_to_cartesian_triaxial public :: geodetic_to_cartesian_triaxial_2 public :: great_circle_distance public :: geocentric_radius ! unit tests: public :: direct_inverse_test contains !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Heikkinen routine for cartesian to geodetic transformation ! !# References !  1. M. Heikkinen, \"Geschlossene formeln zur berechnung raumlicher !     geodatischer koordinaten aus rechtwinkligen Koordinaten\". !     Z. Ermess., 107 (1982), 207-211 (in German). !  2. E. D. Kaplan, \"Understanding GPS: Principles and Applications\", !     Artech House, 1996. pure subroutine heikkinen ( rvec , a , b , h , lon , lat ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: rvec !! position vector [km] real ( wp ), intent ( in ) :: a !! geoid semimajor axis [km] real ( wp ), intent ( in ) :: b !! geoid semiminor axis [km] real ( wp ), intent ( out ) :: h !! geodetic altitude [km] real ( wp ), intent ( out ) :: lon !! longitude [rad] real ( wp ), intent ( out ) :: lat !! geodetic latitude [rad] real ( wp ) :: f , e_2 , ep , r , e2 , ff , g , c , s , pp , q , r0 , u , v , z0 , x , y , z , z2 , r2 , tmp , a2 , b2 x = rvec ( 1 ) y = rvec ( 2 ) z = rvec ( 3 ) a2 = a * a b2 = b * b f = ( a - b ) / a e_2 = ( 2.0_wp * f - f * f ) ep = sqrt ( a2 / b2 - 1.0_wp ) z2 = z * z r = sqrt ( x ** 2 + y ** 2 ) r2 = r * r e2 = a2 - b2 ff = 5 4.0_wp * b2 * z2 g = r2 + ( 1.0_wp - e_2 ) * z2 - e_2 * e2 c = e_2 ** 2 * ff * r2 / g ** 3 s = ( 1.0_wp + c + sqrt ( c ** 2 + 2.0_wp * c )) ** ( 1.0_wp / 3.0_wp ) pp = ff / ( 3.0_wp * ( s + 1.0_wp / s + 1.0_wp ) ** 2 * g ** 2 ) q = sqrt ( 1.0_wp + 2.0_wp * e_2 ** 2 * pp ) r0 = - pp * e_2 * r / ( 1.0_wp + q ) + & sqrt ( max ( 0.0_wp , 1.0_wp / 2.0_wp * a2 * ( 1.0_wp + 1.0_wp / q ) - & ( pp * ( 1.0_wp - e_2 ) * z2 ) / ( q * ( 1.0_wp + q )) - & 1.0_wp / 2.0_wp * pp * r2 ) ) u = sqrt ( ( r - e_2 * r0 ) ** 2 + z2 ) v = sqrt ( ( r - e_2 * r0 ) ** 2 + ( 1.0_wp - e_2 ) * z2 ) z0 = b ** 2 * z / ( a * v ) h = u * ( 1.0_wp - b2 / ( a * v ) ) lat = atan2 ( ( z + ep ** 2 * z0 ), r ) lon = atan2 ( y , x ) end subroutine heikkinen !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Olson routine for cartesian to geodetic transformation. ! !# References !  1. Olson, D. K., Converting Earth-Centered, Earth-Fixed Coordinates to !     Geodetic Coordinates, IEEE Transactions on Aerospace and Electronic !     Systems, 32 (1996) 473-476. pure subroutine olson ( rvec , a , b , h , long , lat ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: rvec !!position vector [km] real ( wp ), intent ( in ) :: a !!geoid semimajor axis [km] real ( wp ), intent ( in ) :: b !!geoid semiminor axis [km] real ( wp ), intent ( out ) :: h !!geodetic altitude [km] real ( wp ), intent ( out ) :: long !!longitude [rad] real ( wp ), intent ( out ) :: lat !!geodetic latitude [rad] real ( wp ) :: f , x , y , z , e2 , a1 , a2 , a3 , a4 , a5 , a6 , w , zp ,& w2 , r2 , r , s2 , c2 , u , v , s , ss , c , g , rg , rf , m , p , z2 x = rvec ( 1 ) y = rvec ( 2 ) z = rvec ( 3 ) f = ( a - b ) / a e2 = f * ( 2.0_wp - f ) a1 = a * e2 a2 = a1 * a1 a3 = a1 * e2 / 2.0_wp a4 = 2.5_wp * a2 a5 = a1 + a3 a6 = 1.0_wp - e2 zp = abs ( z ) w2 = x * x + y * y w = sqrt ( w2 ) z2 = z * z r2 = z2 + w2 r = sqrt ( r2 ) if ( r < 10 0.0_wp ) then lat = 0.0_wp long = 0.0_wp h = - 1.0e7_wp else s2 = z2 / r2 c2 = w2 / r2 u = a2 / r v = a3 - a4 / r if ( c2 > 0.3_wp ) then s = ( zp / r ) * ( 1.0_wp + c2 * ( a1 + u + s2 * v ) / r ) lat = asin ( s ) ss = s * s c = sqrt ( 1.0_wp - ss ) else c = ( w / r ) * ( 1.0_wp - s2 * ( a5 - u - c2 * v ) / r ) lat = acos ( c ) ss = 1.0_wp - c * c s = sqrt ( ss ) end if g = 1.0_wp - e2 * ss rg = a / sqrt ( g ) rf = a6 * rg u = w - rg * c v = zp - rf * s f = c * u + s * v m = c * v - s * u p = m / ( rf / g + f ) lat = lat + p if ( z < 0.0_wp ) lat = - lat h = f + m * p / 2.0_wp long = atan2 ( y , x ) end if end subroutine olson !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Solve the \"direct\" geodetic problem: given the latitude and longitude of one !  point and the azimuth and distance to a second point, determine the latitude !  and longitude of that second point.  The solution is obtained using the !  algorithm by Vincenty. ! !# References !  1. T. Vincenty, \"[Direct and Inverse Solutions of Geodesics on the !     Ellipsoid with Application of Nested Equations](http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf)\", !     Survey Review XXII. 176, April 1975. !  2. [PC Software Download - INVERSE and FORWARD](http://www.ngs.noaa.gov/PC_PROD/Inv_Fwd/), !     National Geodetic Survey. Version 3.0 (November, 2012). subroutine direct ( a , f , glat1 , glon1 , faz , s , glat2 , glon2 , baz ) implicit none real ( wp ), intent ( in ) :: a !! semimajor axis of ellipsoid [m] real ( wp ), intent ( in ) :: f !! flattening of ellipsoid [-] real ( wp ), intent ( in ) :: glat1 !! latitude of 1 [rad] real ( wp ), intent ( in ) :: glon1 !! longitude of 1 [rad] real ( wp ), intent ( in ) :: faz !! forward azimuth 1->2 [rad] real ( wp ), intent ( in ) :: s !! distance from 1->2 [m] real ( wp ), intent ( out ) :: glat2 !! latitude of 2 [rad] real ( wp ), intent ( out ) :: glon2 !! longitude of 2 [rad] real ( wp ), intent ( out ) :: baz !! back azimuth 2->1 [rad] real ( wp ) :: r , tu , sf , cf , cu , su , sa , c2a , x , c , d , y , sy , cy , cz , e real ( wp ), parameter :: eps = 0.5e-13_wp r = 1.0_wp - f tu = r * sin ( glat1 ) / cos ( glat1 ) sf = sin ( faz ) cf = cos ( faz ) if ( cf /= 0.0_wp ) then baz = atan2 ( tu , cf ) * 2.0_wp else baz = 0.0_wp end if cu = 1.0_wp / sqrt ( tu * tu + 1.0_wp ) su = tu * cu sa = cu * sf c2a = - sa * sa + 1.0_wp x = sqrt (( 1.0_wp / r / r - 1.0_wp ) * c2a + 1.0_wp ) + 1.0_wp x = ( x - 2.0_wp ) / x c = 1.0_wp - x c = ( x * x / 4.0_wp + 1.0_wp ) / c d = ( 0.375_wp * x * x - 1.0_wp ) * x tu = s / r / a / c y = tu do sy = sin ( y ) cy = cos ( y ) cz = cos ( baz + y ) e = cz * cz * 2.0_wp - 1.0_wp c = y x = e * cy y = e + e - 1.0_wp y = ((( sy * sy * 4.0_wp - 3.0_wp ) * y * cz * d / 6.0_wp + x ) * d / 4.0_wp - cz ) * sy * d + tu if ( abs ( y - c ) <= eps ) exit end do baz = cu * cy * cf - su * sy c = r * sqrt ( sa * sa + baz * baz ) d = su * cy + cu * sy * cf glat2 = atan2 ( d , c ) c = cu * cy - su * sy * cf x = atan2 ( sy * sf , c ) c = (( - 3.0_wp * c2a + 4.0_wp ) * f + 4.0_wp ) * c2a * f / 1 6.0_wp d = (( e * cy * c + cz ) * sy * c + y ) * sa glon2 = glon1 + x - ( 1.0_wp - c ) * d * f baz = atan2 ( sa , baz ) + pi end subroutine direct !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams ! !  Geodetic latitude, longitude, and height to Cartesian position vector. ! !# References !  1. E. D. Kaplan, \"Understanding GPS: Principles and Applications\", !     Artech House, 1996. subroutine geodetic_to_cartesian ( a , b , glat , lon , h , r ) implicit none real ( wp ), intent ( in ) :: a !! geoid semimajor axis [km] real ( wp ), intent ( in ) :: b !! geoid semiminor axis [km] real ( wp ), intent ( in ) :: glat !! geodetic latitude [rad] real ( wp ), intent ( in ) :: lon !! longitude [rad] real ( wp ), intent ( in ) :: h !! geodetic altitude [km] real ( wp ), dimension ( 3 ), intent ( out ) :: r !! Cartesian position vector [x,y,z] real ( wp ) :: e2 , slat , clat , slon , clon , tlat , ome2 , d , q , aod slat = sin ( glat ) clat = cos ( glat ) tlat = tan ( glat ) slon = sin ( lon ) clon = cos ( lon ) e2 = 1.0_wp - ( b * b ) / ( a * a ) ome2 = 1.0_wp - e2 d = sqrt ( 1.0_wp + ome2 * tlat * tlat ) q = sqrt ( 1.0_wp - e2 * slat * slat ) aod = a / d r ( 1 ) = aod * clon + h * clon * clat r ( 2 ) = aod * slon + h * slon * clat r ( 3 ) = a * ome2 * slat / q + h * slat end subroutine geodetic_to_cartesian !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 7/13/2014 ! !  Great circle distance on a spherical body, using the Vincenty algorithm. ! !# References !  * T. Vincenty, \"[Direct and Inverse Solutions of Geodesics on the Ellipsoid !    with Application of Nested Equations](http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf)\", !    Survey Review XXII. 176, April 1975. pure function great_circle_distance ( r , long1 , lat1 , long2 , lat2 ) result ( d ) implicit none real ( wp ) :: d !! great circle distance from 1 to 2 [km] real ( wp ), intent ( in ) :: r !! radius of the body [km] real ( wp ), intent ( in ) :: long1 !! longitude of first site [rad] real ( wp ), intent ( in ) :: lat1 !! latitude of the first site [rad] real ( wp ), intent ( in ) :: long2 !! longitude of the second site [rad] real ( wp ), intent ( in ) :: lat2 !! latitude of the second site [rad] real ( wp ) :: c1 , s1 , c2 , s2 , dlon , clon , slon !Compute aux variables: c1 = cos ( lat1 ) s1 = sin ( lat1 ) c2 = cos ( lat2 ) s2 = sin ( lat2 ) dlon = long1 - long2 clon = cos ( dlon ) slon = sin ( dlon ) d = r * atan2 ( sqrt (( c2 * slon ) ** 2 + ( c1 * s2 - s1 * c2 * clon ) ** 2 ), ( s1 * s2 + c1 * c2 * clon ) ) end function great_circle_distance !***************************************************************************************** !***************************************************************************************** !> !  The distance from the center of a celestial body (e.g., the Earth) to a point !  on the spheroid surface at a specified geodetic latitude. ! !### Reference !  * [Geocentric radius](https://en.wikipedia.org/wiki/Earth_radius#Geocentric_radius) pure function geocentric_radius ( a , b , lat ) result ( r ) implicit none real ( wp ), intent ( in ) :: a !! equatorial radius (km) real ( wp ), intent ( in ) :: b !! polar radius of point (km) real ( wp ), intent ( in ) :: lat !! geodetic latitude of point (rad) real ( wp ) :: r !! distance from center of body to point (km) !local variables: real ( wp ) :: num , den , cl2 , sl2 , a2 , b2 if ( a == zero . and . b == zero ) then r = zero else cl2 = cos ( lat ) ** 2 sl2 = sin ( lat ) ** 2 a2 = a * a b2 = b * b num = cl2 * a2 ** 2 + sl2 * b2 ** 2 den = cl2 * a2 + sl2 * b2 r = sqrt ( num / den ) end if end function geocentric_radius !***************************************************************************************** !***************************************************************************************** !> !  INVERSE computes the geodetic azimuth and distance between two points, !  given their geographic positions. ! !  Version for long-line and antipodal cases. !  Latitudes may be 90 degrees exactly. ! !### Reference !  * T. Vincenty, \"[Direct and Inverse Solutions of Geodesics on the Ellipsoid !    with Application of Nested Equations](http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf)\", !    Survey Review XXII. 176, April 1975. !  * [inverse.for](http://www.ngs.noaa.gov/PC_PROD/Inv_Fwd/source/inverse.for) !    Version 3.0 (November, 2012). ! !### History !  * Original programmed by thaddeus vincenty, 1975, 1976 !  * Removed back side solution option, debugged, revised -- 2011may01 -- dgm !    this version of code is interim -- antipodal boundary needs work !  * Jacob Williams, 1/25/2016 : refactored into modern Fortran. subroutine inverse ( a , rf , b1 , l1 , b2 , l2 , faz , baz , s , it , sig , lam , kind ) implicit none real ( wp ), intent ( in ) :: a !! Equatorial semimajor axis real ( wp ), intent ( in ) :: rf !! reciprocal flattening (1/f) real ( wp ), intent ( in ) :: b1 !! latitude of point 1 (rad, positive north) real ( wp ), intent ( in ) :: l1 !! longitude of point 1 (rad, positive east) real ( wp ), intent ( in ) :: b2 !! latitude of point 2 (rad, positive north) real ( wp ), intent ( in ) :: l2 !! longitude of point 2 (rad, positive east) real ( wp ), intent ( out ) :: faz !! Forward azimuth (rad, clockwise from north) real ( wp ), intent ( out ) :: baz !! Back azimuth (rad, clockwise from north) real ( wp ), intent ( out ) :: s !! Ellipsoidal distance integer , intent ( out ) :: it !! iteration count real ( wp ), intent ( out ) :: sig !! spherical distance on auxiliary sphere real ( wp ), intent ( out ) :: lam !! longitude difference on auxiliary sphere integer , intent ( out ) :: kind !! solution flag: kind=1, long-line; kind=2, antipodal real ( wp ) :: beta1 , beta2 , biga , bigb , bige , bigf , boa , c , cosal2 , coslam ,& cossig , costm , costm2 , cosu1 , cosu2 , d , dsig , ep2 , l , prev ,& sinal , sinlam , sinsig , sinu1 , sinu2 , tem1 , tem2 , temp , test , z real ( wp ), parameter :: tol = 1.0e-14_wp !! convergence tolerance real ( wp ), parameter :: eps = 1.0e-15_wp !! tolerance for zero boa = 1.0_wp - 1.0_wp / rf ! b/a beta1 = atan ( boa * tan ( b1 )) ! better reduced latitude sinu1 = sin ( beta1 ) cosu1 = cos ( beta1 ) beta2 = atan ( boa * tan ( b2 )) ! better reduced latitude sinu2 = sin ( beta2 ) cosu2 = cos ( beta2 ) l = l2 - l1 ! longitude difference [-pi,pi] if ( l > pi ) l = l - twopi if ( l <- pi ) l = l + twopi prev = l test = l it = 0 kind = 1 lam = l longline : do ! long-line loop (kind=1) sinlam = sin ( lam ) coslam = cos ( lam ) temp = cosu1 * sinu2 - sinu1 * cosu2 * coslam sinsig = sqrt (( cosu2 * sinlam ) ** 2 + temp ** 2 ) cossig = sinu1 * sinu2 + cosu1 * cosu2 * coslam sig = atan2 ( sinsig , cossig ) if ( abs ( sinsig ) < eps ) then sinal = cosu1 * cosu2 * sinlam / sign ( eps , sinsig ) else sinal = cosu1 * cosu2 * sinlam / sinsig endif cosal2 = - sinal ** 2 + 1.0_wp if ( abs ( cosal2 ) < eps ) then costm = - 2.0_wp * ( sinu1 * sinu2 / sign ( eps , cosal2 )) + cossig else costm = - 2.0_wp * ( sinu1 * sinu2 / cosal2 ) + cossig endif costm2 = costm * costm c = (( - 3.0_wp * cosal2 + 4.0_wp ) / rf + 4.0_wp ) * cosal2 / rf / 1 6.0_wp antipodal : do ! antipodal loop (kind=2) it = it + 1 d = ((( 2.0_wp * costm2 - 1.0_wp ) * cossig * c + costm ) * sinsig * c + sig ) * ( 1.0_wp - c ) / rf if ( kind == 1 ) then lam = l + d * sinal if ( abs ( lam - test ) >= tol ) then if ( abs ( lam ) > pi ) then kind = 2 lam = pi if ( l < 0.0_wp ) lam = - lam sinal = 0.0_wp cosal2 = 1.0_wp test = 2.0_wp prev = test sig = pi - abs ( atan ( sinu1 / cosu1 ) + atan ( sinu2 / cosu2 )) sinsig = sin ( sig ) cossig = cos ( sig ) c = (( - 3.0_wp * cosal2 + 4.0_wp ) / rf + 4.0_wp ) * cosal2 / rf / 1 6.0_wp if ( abs ( sinal - prev ) < tol ) exit longline if ( abs ( cosal2 ) < eps ) then costm = - 2.0_wp * ( sinu1 * sinu2 / sign ( eps , cosal2 )) + cossig else costm = - 2.0_wp * ( sinu1 * sinu2 / cosal2 ) + cossig endif costm2 = costm * costm cycle antipodal endif if ( (( lam - test ) * ( test - prev )) < 0.0_wp . and . it > 5 ) & lam = ( 2.0_wp * lam + 3.0_wp * test + prev ) / 6.0_wp ! refined converge. prev = test test = lam cycle longline endif else sinal = ( lam - l ) / d if ( (( sinal - test ) * ( test - prev )) < 0.0_wp . and . it > 5 ) & sinal = ( 2.0_wp * sinal + 3.0_wp * test + prev ) / 6.0_wp ! refined converge. prev = test test = sinal cosal2 = - sinal ** 2 + 1.0_wp sinlam = sinal * sinsig / ( cosu1 * cosu2 ) coslam = - sqrt ( abs ( - sinlam ** 2 + 1.0_wp )) lam = atan2 ( sinlam , coslam ) temp = cosu1 * sinu2 - sinu1 * cosu2 * coslam sinsig = sqrt (( cosu2 * sinlam ) ** 2 + temp ** 2 ) cossig = sinu1 * sinu2 + cosu1 * cosu2 * coslam sig = atan2 ( sinsig , cossig ) c = (( - 3.0_wp * cosal2 + 4.0_wp ) / rf + 4.0_wp ) * cosal2 / rf / 1 6.0_wp if ( abs ( sinal - prev ) >= tol ) then if ( abs ( cosal2 ) < eps ) then costm = - 2.0_wp * ( sinu1 * sinu2 / sign ( eps , cosal2 )) + cossig else costm = - 2.0_wp * ( sinu1 * sinu2 / cosal2 ) + cossig endif costm2 = costm * costm cycle antipodal endif endif exit longline !finished end do antipodal end do longline ! convergence if ( kind == 2 ) then ! antipodal faz = sinal / cosu1 baz = sqrt ( - faz ** 2 + 1.0_wp ) if ( temp < 0.0_wp ) baz = - baz faz = atan2 ( faz , baz ) tem1 = - sinal tem2 = sinu1 * sinsig - cosu1 * cossig * baz baz = atan2 ( tem1 , tem2 ) else ! long-line tem1 = cosu2 * sinlam tem2 = cosu1 * sinu2 - sinu1 * cosu2 * coslam faz = atan2 ( tem1 , tem2 ) tem1 = - cosu1 * sinlam tem2 = sinu1 * cosu2 - cosu1 * sinu2 * coslam baz = atan2 ( tem1 , tem2 ) endif if ( faz < 0.0_wp ) faz = faz + twopi if ( baz < 0.0_wp ) baz = baz + twopi ! helmert 1880 from vincenty \"geodetic inverse solution between antipodal points\" ep2 = 1.0_wp / ( boa * boa ) - 1.0_wp bige = sqrt ( 1.0_wp + ep2 * cosal2 ) bigf = ( bige - 1.0_wp ) / ( bige + 1.0_wp ) biga = ( 1.0_wp + bigf * bigf / 4.0_wp ) / ( 1.0_wp - bigf ) bigb = bigf * ( 1.0_wp - 0.375_wp * bigf * bigf ) z = bigb / 6.0_wp * costm * ( - 3.0_wp + 4.0_wp * sinsig ** 2 ) * ( - 3.0_wp + 4.0_wp * costm2 ) dsig = bigb * sinsig * ( costm + bigb / 4.0_wp * ( cossig * ( - 1.0_wp + 2.0_wp * costm2 ) - z )) s = ( boa * a ) * biga * ( sig - dsig ) end subroutine inverse !***************************************************************************************** !***************************************************************************************** !> !  Function computes the Cartesian coordinates given the !  geodetic latitude (phi), longitude (lambda) and !  height (h) of a point related to an ellipsoid !  defined by its three semiaxes ax, ay and b ! !### History !  * Jacob Williams, 10/29/2022 : Fortran verison of this algorithm, !    based on the Matlab (v1.0 01/03/2019) code. subroutine geodetic_to_cartesian_triaxial ( ax , ay , b , phi , lambda , h , r ) real ( wp ), intent ( in ) :: ax !! semiaxes (0 < b <= ay <= ax) real ( wp ), intent ( in ) :: ay !! semiaxes (0 < b <= ay <= ax) real ( wp ), intent ( in ) :: b !! semiaxes (0 < b <= ay <= ax) real ( wp ), intent ( in ) :: phi !! geodetic latitude (radians) real ( wp ), intent ( in ) :: lambda !! geodetic longitude (radians) real ( wp ), intent ( in ) :: h !! geodetic height real ( wp ), dimension ( 3 ), intent ( out ) :: r !! Cartesian position vector [x,y,z] real ( wp ) :: ee2 , ex2 , N , cp , sp , cl , sl cp = cos ( phi ) sp = sin ( phi ) cl = cos ( lambda ) sl = sin ( lambda ) ee2 = ( ax * ax - ay * ay ) / ( ax * ax ) ex2 = ( ax * ax - b * b ) / ( ax * ax ) N = ax / sqrt ( one - ex2 * sp * sp - ee2 * cp * cp * sl * sl ) r = [( N + h ) * cp * cl , & ( N * ( one - ee2 ) + h ) * cp * sl , & ( N * ( one - ex2 ) + h ) * sp ] end subroutine geodetic_to_cartesian_triaxial !******************************************************************************** !> !  Geodetic to Cartesian for Triaxial Ellipsoid. ! !### References !  * S. Bektas, \"Geodetic Computations on Triaxial Ellipsoid\", !    International Journal of Mining Science (IJMS), !    Volume 1, Issue 1, June 2015, p 25-34 pure subroutine geodetic_to_cartesian_triaxial_2 ( a , b , c , lat , long , h , r ) implicit none real ( wp ), intent ( in ) :: a !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: b !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: c !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: lat !! latitude (rad) real ( wp ), intent ( in ) :: long !! longitude (rad) real ( wp ), intent ( in ) :: h !! altitude real ( wp ), dimension ( 3 ), intent ( out ) :: r !! Cartesian coordinates (x,y,z) real ( wp ) :: ex2 , ee2 , v , a2 , clat , slat , clon , slon , omee2 , omex2 a2 = a * a ex2 = ( a2 - c ** 2 ) / a2 ee2 = ( a2 - b ** 2 ) / a2 clat = cos ( lat ) slat = sin ( lat ) clon = cos ( long ) slon = sin ( long ) omee2 = 1.0_wp - ee2 omex2 = 1.0_wp - ex2 v = a / sqrt ( 1.0_wp - ex2 * slat ** 2 - ee2 * clat ** 2 * slon ** 2 ) r = [( v + h ) * clon * clat , & ( v * omee2 + h ) * slon * clat , & ( v * omex2 + h ) * slat ] end subroutine geodetic_to_cartesian_triaxial_2 !***************************************************************************************** !***************************************************************************************** !> !  Function computes the geodetic latitude (phi), longitude (lambda) and !  height (h) of a point related to an ellipsoid !  defined by its three semiaxes ax, ay and b (0 < b <= ay <= ax) !  given Cartesian coordinates Xi, Yi, Zi and tolerance (tol). !  Latitude and longitude are returned in radians. ! !### Reference !  * G. Panou and R. Korakitis, \"Cartesian to geodetic coordinates conversion !    on an ellipsoid using the bisection method\". !    Journal of Geodesy volume 96, Article number: 66 (2022). !    [(link)](https://link.springer.com/article/10.1007/s00190-022-01650-9) !  * [C++ code](https://www.researchgate.net/publication/353739609_PK-code) !  * [MATLAB code](https://www.researchgate.net/publication/333904614_Cartesian2Geodetic_General_Panou_Korakitis) ! !### History !  * Jacob Williams, 10/29/2022 : Fortran verison of this algorithm. subroutine cartesian_to_geodetic_triaxial ( ax , ay , b , r , tol , phi , lambda , h ) real ( wp ), intent ( in ) :: ax !! semiaxes (0 < b <= ay <= ax) real ( wp ), intent ( in ) :: ay !! semiaxes (0 < b <= ay <= ax) real ( wp ), intent ( in ) :: b !! semiaxes (0 < b <= ay <= ax) real ( wp ), dimension ( 3 ), intent ( in ) :: r !! Cartesian coordinates (x,y,z) real ( wp ), intent ( in ) :: tol !! tolerance (may be set to zero) real ( wp ), intent ( out ) :: phi !! geodetic latitude (radians) real ( wp ), intent ( out ) :: lambda !! geodetic longitude (radians) real ( wp ), intent ( out ) :: h !! geodetic height real ( wp ) :: kx , ky , cx , cy , cz , XX , YY , ZZ , x , y , z , Xo , Yo , Zo , m , Mm , axax , ayay , b2 integer :: n if ( ax < ay . or . ay < b ) error stop 'error in cartesian_to_geodetic_triaxial: invalid ax,ay,b' axax = ax * ax ayay = ay * ay b2 = b * b kx = ( axax - b2 ) / ax ky = ( ayay - b2 ) / ay cx = ( axax ) / ( b2 ) cy = ( ayay ) / ( b2 ) cz = ( axax ) / ( ayay ) XX = abs ( r ( 1 )) YY = abs ( r ( 2 )) ZZ = abs ( r ( 3 )) ! Compute geodetic latitude/longitude if ( ZZ == zero ) then if ( XX == zero . and . YY == zero ) then x = zero y = zero z = b else if ( ky * XX * ky * XX + kx * YY * kx * YY < kx * ky * kx * ky ) then x = ax * XX / kx y = ay * YY / ky z = b * sqrt ( one - (( x * x ) / ( axax )) - (( y * y ) / ( ayay ))) else if ( XX == zero ) then x = zero y = ay z = zero else if ( YY == zero ) then x = ax y = zero z = zero else Xo = XX / ax Yo = YY / ay call bisection_special_2 ( cz , Xo , Yo , tol , n , m , Mm ) x = cz * XX / ( cz + m ) y = YY / ( one + m ) z = zero end if else if ( XX == zero . and . YY == zero ) then x = zero y = zero z = b else Xo = XX / ax Yo = YY / ay Zo = ZZ / b call bisection_special_3 ( cx , cy , Xo , Yo , Zo , tol , n , m , Mm ) x = cx * XX / ( cx + m ) y = cy * YY / ( cy + m ) if ( m < zero . and . ky * XX * ky * XX + kx * YY * kx * YY < kx * ky * kx * ky ) then z = b * sqrt ( one - (( x * x ) / ( axax )) - (( y * y ) / ( ayay ))) else z = ZZ / ( one + m ) end if end if end if call xyz2fl ( ax , ay , b , x , y , z , phi , lambda ) ! analytic method used for initial guess call xyz2philambda ( ax , ay , b , x , y , z , phi , lambda ) ! iterative method call philambda_quadrant ( r ( 1 ), r ( 2 ), r ( 3 ), phi , lambda ) ! Compute geodetic height h = norm2 ([ XX - x , YY - y , ZZ - z ]) if (( XX + YY + ZZ ) < ( x + y + z )) h = - h end subroutine cartesian_to_geodetic_triaxial !***************************************************************************************** !> subroutine bisection_special_2 ( cz , Xo , Yo , tol , n , m , Gm ) real ( wp ), intent ( in ) :: cz , Xo , Yo , tol integer , intent ( out ) :: n real ( wp ), intent ( out ) :: m , Gm real ( wp ) :: d1 , Gd1 , d2 , d , MM d1 = - one + Yo Gd1 = ( cz * Xo * cz * Xo ) / (( cz + d1 ) * ( cz + d1 )) d2 = - one + sqrt ( cz * Xo * cz * Xo + Yo * Yo ) d = ( d2 - d1 ) / two n = 0 m = - two do while ( d > tol ) n = n + 1 MM = m m = d1 + d Gm = (( cz * Xo * cz * Xo ) / (( cz + m ) * ( cz + m ))) + (( Yo * Yo ) / (( one + m ) ** 2 )) - one if ( MM == m + tol . or . Gm == zero ) return if ( sign ( one , Gm ) == sign ( one , Gd1 )) then d1 = m Gd1 = Gm else d2 = m end if d = ( d2 - d1 ) / two end do n = n + 1 m = d1 + d Gm = (( cz * Xo * cz * Xo ) / (( cz + m ) * ( cz + m ))) + (( Yo * Yo ) / (( one + m ) ** 2 )) - one end subroutine bisection_special_2 !***************************************************************************************** !> subroutine bisection_special_3 ( cx , cy , Xo , Yo , Zo , tol , n , m , Hm ) real ( wp ), intent ( in ) :: cx , cy , Xo , Yo , Zo , tol integer , intent ( out ) :: n real ( wp ), intent ( out ) :: m , Hm real ( wp ) :: d1 , Hd1 , d2 , d , MM d1 = - one + Zo Hd1 = (( cx * Xo * cx * Xo ) / (( cx + d1 ) * ( cx + d1 ))) + (( cy * Yo * cy * Yo ) / (( cy + d1 ) * ( cy + d1 ))) d2 = - one + sqrt ( cx * Xo * cx * Xo + cy * Yo * cy * Yo + Zo * Zo ) d = ( d2 - d1 ) / two n = 0 m = - two do while ( d > tol ) n = n + 1 MM = m m = d1 + d Hm = (( cx * Xo * cx * Xo ) / (( cx + m ) * ( cx + m ))) + (( cy * Yo * cy * Yo ) / & (( cy + m ) * ( cy + m ))) + (( Zo * Zo ) / (( one + m ) ** 2 )) - one if ( MM == m + tol . or . Hm == zero ) return if ( sign ( one , Hm ) == sign ( one , Hd1 )) then d1 = m Hd1 = Hm else d2 = m end if d = ( d2 - d1 ) / two end do n = n + 1 m = d1 + d Hm = (( cx * Xo * cx * Xo ) / (( cx + m ) * ( cx + m ))) + (( cy * Yo * cy * Yo ) / & (( cy + m ) * ( cy + m ))) + (( Zo * Zo ) / (( one + m ) ** 2 )) - one end subroutine bisection_special_3 !***************************************************************************************** !> subroutine philambda_quadrant ( x , y , z , phi , lambda ) real ( wp ), intent ( in ) :: x , y , z real ( wp ), intent ( inout ) :: phi , lambda if ( z < zero ) then phi = - phi end if if ( x >= zero ) then if ( y >= zero ) then lambda = lambda else lambda = - lambda end if else if ( y >= zero ) then lambda = pi - lambda else lambda = lambda - pi end if end if end subroutine philambda_quadrant !****************************************************************************** !> !  Determination of the geodetic latitude and longitude ! !@note This one has a different stopping criterion than the reference. subroutine xyz2philambda ( ax , ay , b , x , y , z , phi , lambda ) real ( wp ), intent ( in ) :: ax , ay , b , x , y , z real ( wp ), intent ( inout ) :: phi , lambda !! input is initial guess, output is refined values real ( wp ) :: ee2 , ex2 , Sphi , Cphi , Slambda , Clambda ,& Den , NN , onemee2 , onemex2 , dndphi , dxdphi ,& dydphi , dzdphi , dndlam , dxdlam , dydlam , dzdlam integer :: n real ( wp ), dimension ( 3 , 2 ) :: J real ( wp ), dimension ( 2 , 3 ) :: Jt !! transpose of J real ( wp ), dimension ( 3 , 1 ) :: dl real ( wp ), dimension ( 2 , 2 ) :: Nmat , Ninv real ( wp ), dimension ( 2 , 1 ) :: dx real ( wp ), dimension ( 3 ) :: r0 ! real(wp) :: s0, SS0 ! real(wp),dimension(3,1) :: UU ! real(wp),dimension(1,1) :: tmp integer , parameter :: maxiter = 100 !! maximum number of iterations real ( wp ), parameter :: stop_tol = ten * epsilon ( one ) !! stopping tol for corrections ee2 = ( ax * ax - ay * ay ) / ( ax * ax ) ! eqn. 5 ex2 = ( ax * ax - b * b ) / ( ax * ax ) ! onemee2 = one - ee2 onemex2 = one - ex2 !s0 = zero do n = 1 , maxiter !SS0 = s0 ! Design Matrix J Sphi = sin ( phi ) Cphi = cos ( phi ) Slambda = sin ( lambda ) Clambda = cos ( lambda ) NN = ax / sqrt ( one - ex2 * Sphi * Sphi - ee2 * Cphi * Cphi * Slambda * Slambda ) ! eqn. 4 Den = two * ( one - ex2 * Sphi ** 2 - ee2 * Cphi ** 2 * Slambda ** 2 ) ** ( three / two ) dndphi = - ax * sin ( two * phi ) * ( ex2 - ee2 * Slambda ** 2 ) / Den dxdphi = ( dndphi * Cphi - NN * Sphi ) * Clambda dydphi = onemee2 * ( dndphi * Cphi - NN * Sphi ) * Slambda dzdphi = onemex2 * ( dndphi * Sphi + NN * Cphi ) dndlam = - ax * ee2 * Cphi ** 2 * sin ( two * lambda ) / Den dxdlam = ( dndlam * Clambda - NN * Slambda ) * Cphi dydlam = onemee2 * ( dndlam * Slambda + NN * Clambda ) * Cphi dzdlam = onemex2 * dndlam * Sphi J = reshape ([ dxdphi , dydphi , dzdphi , dxdlam , dydlam , dzdlam ],[ 3 , 2 ]) ! Vector dl call geodetic_to_cartesian_triaxial_2 ( ax , ay , b , phi , lambda , 0.0_wp , r0 ) ! just use the main one with alt=0 dl (:, 1 ) = [ x , y , z ] - r0 ! eqn. 51 ! Solution Jt = transpose ( J ) Nmat = matmul ( Jt , J ) ! eqn. 53 Ninv = ( one / ( Nmat ( 1 , 1 ) * Nmat ( 2 , 2 ) - Nmat ( 1 , 2 ) * Nmat ( 2 , 1 ))) * & reshape ([ Nmat ( 2 , 2 ), - Nmat ( 2 , 1 ), - Nmat ( 1 , 2 ), Nmat ( 1 , 1 )], [ 2 , 2 ]) ! eqn. 54 dx = matmul ( Ninv , matmul ( Jt , dl )) ! eqn. 52 phi = phi + dx ( 1 , 1 ) ! corrections. eqn. 55 lambda = lambda + dx ( 2 , 1 ) ! ! ! original: ! UU      = matmul(J,dx) - dl ! tmp     = sqrt(matmul(transpose(UU),UU)) ! s0      = tmp(1,1) ! if (s0 == SS0) exit ! JW: I think this is a better stopping criterion: if ( all ( abs ( dx ) <= stop_tol )) exit end do end subroutine xyz2philambda !***************************************************************************************** !***************************************************************************************** !> !  Computes the transformation of Cartesian to geodetic coordinates on the surface of the ellipsoid !  assuming x,y,z are all non-negative !  Angular coordinates in radians ! !  This is based on the [C++ version](https://www.researchgate.net/publication/353739609_PK-code) subroutine xyz2fl ( ax , ay , b , x , y , z , latitude , longitude ) real ( wp ), intent ( in ) :: ax , ay , b , x , y , z real ( wp ), intent ( out ) :: latitude , longitude real ( wp ) :: nom , den , dex , xme , rot real ( wp ) :: ax2 , ay2 , b2 , Ex2 , Ee2 , lex2 , lee2 , mex , mee ! note: these could be precomputed: ax2 = ax * ax ay2 = ay * ay b2 = b * b Ex2 = ax2 - b2 Ee2 = ax2 - ay2 lex2 = Ex2 / ax2 lee2 = Ee2 / ax2 mex = one - lex2 mee = one - lee2 nom = mee * z xme = mee * x dex = xme * xme + y * y den = mex * sqrt ( dex ) rot = sqrt ( dex ) if ( den == zero ) then latitude = halfpi longitude = zero else if ( nom <= den ) then latitude = atan ( nom / den ) else latitude = halfpi - atan ( den / nom ) end if if ( y <= xme ) then den = xme + rot longitude = two * atan ( y / den ) else den = y + rot longitude = halfpi - two * atan ( xme / den ) end if end if end subroutine xyz2fl !**************************************************************** !> !  Numerical solution to polynomial equation using Newton-Raphson method pure function solve_polynomial ( B , x0 , error ) result ( x ) real ( wp ), dimension ( 0 : 6 ), intent ( in ) :: B !! Polynomial `B = B(6) x&#94;6 + B(5) x&#94;5 + ... + B(0)` real ( wp ), intent ( in ) :: x0 !! Initial point real ( wp ), intent ( in ) :: error !! Maximum error real ( wp ) :: x !! root found after applying Newton-Raphson method to `B` !! The function returns the value when the correction !! is smaller than error. real ( wp ) :: f , fp , corr integer :: i , j !! counter integer , parameter :: maxiter = 100 !! maximum number of iterations x = x0 do i = 1 , maxiter f = B ( 6 ) do j = 5 , 0 , - 1 if ( j == 5 ) then fp = f else fp = x * fp + f end if f = x * f + B ( j ) end do if ( fp == zero ) exit ! singular point corr = f / fp x = x - corr if ( abs ( corr ) <= error ) exit end do end function solve_polynomial !**************************************************************** !> !  Horner's method to compute `B(x-c)` in terms of `B(x)`. pure subroutine horner ( B , c , BB ) real ( wp ), dimension ( 0 : 6 ), intent ( in ) :: B !! Polynomial `B = B(6) x&#94;6 + B(5) x&#94;5 + ... + B(0)` real ( wp ), intent ( in ) :: c real ( wp ), dimension ( 0 : 6 ), intent ( out ) :: BB !! Polynomial `BB` such that `B(x-c) = BB(x)` integer :: i , j !! counters BB = B do i = 0 , 6 do j = 5 , i , - 1 BB ( j ) = BB ( j ) - BB ( j + 1 ) * c end do end do end subroutine horner !****************************************************************** !> !  Cartesian to Geodetic I ! !### See also !  * [[CartesianIntoGeodeticII]] ! !### Reference !  * Gema Maria Diaz-Toca, Leandro Marin, Ioana Necula, !    \"Direct transformation from Cartesian into geodetic coordinates on a triaxial ellipsoid\" !    Computers & Geosciences, Volume 142, September 2020, 104551. !    [link](https://www.sciencedirect.com/science/article/pii/S0098300420305410?via%3Dihub), !  * [C++ code](https://data.mendeley.com/datasets/s5f6sww86x/2) [CC BY 4.0 License] subroutine CartesianIntoGeodeticI ( ax , ay , az , r , latitude , longitude , altitude , error ) real ( wp ), intent ( in ) :: ax , ay , az !! semiaxes of the celestial body: ax>ay>az real ( wp ), dimension ( 3 ), intent ( in ) :: r !! cartesian coordinates of the considered point !! in the first octant: xG, yG, zG with (xG,yG,zG)<>(0,0,0) real ( wp ), intent ( out ) :: latitude , longitude , altitude !! geodetic coordinates of the considered point real ( wp ), intent ( in ) :: error !! Values smaller than error treated as 0.0 real ( wp ) :: ax2 , ay2 , az2 , ax4 , ay4 , az4 , b5 , b4 , b3 , b3x , b3y , b3z ,& b2 , b2x , b2y , b2z , b1 , b1x , b1y , b1z , b0 , b0x , b0y , b0z , eec , exc real ( wp ) :: xg2 , yg2 , zg2 , aux , xG , yG , zG real ( wp ) :: xE , yE , zE , k , B ( 0 : 6 ), BB ( 0 : 6 ) logical :: done call special_cases ( ax , ay , az , r ( 1 ), r ( 2 ), r ( 3 ), latitude , longitude , altitude , done ) if ( done ) return ! Computations independent of xG,yG,zG. They can be precomputed, if necessary. ax2 = ax * ax ay2 = ay * ay az2 = az * az ax4 = ax2 * ax2 ay4 = ay2 * ay2 az4 = az2 * az2 b5 = 2.0_wp * ( ax2 + ay2 + az2 ) b4 = ax4 + 4.0_wp * ax2 * ay2 + ay4 + 4.0_wp * ax2 * az2 + 4.0_wp * ay2 * az2 + az4 b3 = 2.0_wp * ax4 * ay2 + 2.0_wp * ax2 * ay4 + 2.0_wp * ax4 * az2 + 8.0_wp * ax2 * ay2 * az2 + 2.0_wp * ay4 * az2 + 2.0_wp * ax2 * az4 + 2.0_wp * ay2 * az4 b3x = - 2.0_wp * ax2 * ay2 - 2.0_wp * ax2 * az2 b3y = - 2.0_wp * ax2 * ay2 - 2.0_wp * ay2 * az2 b3z = - 2.0_wp * ay2 * az2 - 2.0_wp * ax2 * az2 b2 = 4.0_wp * ax4 * ay2 * az2 + 4.0_wp * ax2 * ay4 * az2 + ax4 * az4 + 4.0_wp * ax2 * ay2 * az4 + ax4 * ay4 + ay4 * az4 b2x = - ax2 * ay4 - 4.0_wp * ax2 * ay2 * az2 - ax2 * az4 b2y = - ax4 * ay2 - 4.0_wp * ax2 * ay2 * az2 - ay2 * az4 b2z = - ax4 * az2 - 4.0_wp * ax2 * ay2 * az2 - ay4 * az2 b1 = 2.0_wp * ax4 * ay4 * az2 + 2.0_wp * ax4 * ay2 * az4 + 2.0_wp * ax2 * ay4 * az4 b1x = - 2.0_wp * ax2 * ay4 * az2 - 2.0_wp * ax2 * ay2 * az4 b1y = - 2.0_wp * ax4 * ay2 * az2 - 2.0_wp * ax2 * ay2 * az4 b1z = - 2.0_wp * ax4 * ay2 * az2 - 2.0_wp * ax2 * ay4 * az2 b0 = ax4 * ay4 * az4 b0x = - ax2 * ay4 * az4 b0y = - ax4 * ay2 * az4 b0z = - ax4 * ay4 * az2 eec = ( ax2 - ay2 ) / ax2 exc = ( ax2 - az2 ) / ax2 ! Computations dependant of xG, yG, zG xG = abs ( r ( 1 )) yG = abs ( r ( 2 )) zG = abs ( r ( 3 )) xg2 = xG * xG yg2 = yG * yG zg2 = zG * zG aux = xg2 / ax2 + yg2 / ay2 + zg2 / az2 B = [ b0 + b0x * xg2 + b0y * yg2 + b0z * zg2 , & b1 + b1x * xg2 + b1y * yg2 + b1z * zg2 , & b2 + b2x * xg2 + b2y * yg2 + b2z * zg2 , & b3 + b3x * xg2 + b3y * yg2 + b3z * zg2 , & b4 - ( ax2 * xg2 + ay2 * yg2 + az2 * zg2 ), & b5 , & 1.0_wp ] if ( abs ( aux - 1.0_wp ) < error ) then ! The point is on the ellipsoid xE = xG yE = yG zE = zG else if ( aux > 1.0_wp ) then ! The point is outside the ellipsoid k = solve_polynomial ( B ,( xg2 + yg2 + zg2 ) / 3.0_wp , error ) xE = ax2 * xG / ( ax2 + k ) yE = ay2 * yG / ( ay2 + k ) zE = az2 * zG / ( az2 + k ) else if ( zG > 0.0_wp ) then ! The point  is inside the ellipsoid and zG>0 call horner ( B , az2 , BB ) ! B(x-az2) = BB(x) k = solve_polynomial ( BB ,( xg2 + yg2 + zg2 ) / 3.0_wp + az2 , error ) - az2 xE = ax2 * xG / ( ax2 + k ) yE = ay2 * yG / ( ay2 + k ) zE = az2 * zG / ( az2 + k ) else if ( xG > 0.0_wp . and . yG > 0.0_wp ) then ! The point is inside the ellipsoid and zG=0, yG > 0, xG > 0 call horner ( B , ay2 , BB ) k = solve_polynomial ( BB ,( xg2 + yg2 + zg2 ) / 3.0_wp + ay2 , error ) - ay2 xE = ax2 * xG / ( ax2 + k ) yE = ay2 * yG / ( ay2 + k ) zE = 0.0_wp else if ( xG < error . and . yG > 0.0_wp ) then xE = 0.0_wp yE = ay zE = 0.0_wp else if ( xG > 0.0_wp . and . yG < error ) then xE = ax yE = 0.0_wp zE = 0.0_wp end if ! Computing longitude if ( xG > 0.0_wp ) then longitude = atan ( yE / (( 1.0_wp - eec ) * xE )) else if ( yG > 0.0_wp ) then longitude = halfpi else longitude = huge ( 1.0_wp ) ! undefined end if ! Computing latitude if ( xE > 0.0_wp . or . yE > 0.0_wp ) then latitude = atan (( 1.0_wp - eec ) / ( 1.0_wp - exc ) * zE / norm2 ([ xE * ( 1.0_wp - eec ), yE ])) else latitude = halfpi end if ! Computing altitude if ( aux >= 1.0_wp ) then altitude = norm2 ([ xE - xG , yE - yG , zE - zG ]) else altitude = - norm2 ([ xE - xG , yE - yG , zE - zG ]) end if call philambda_quadrant ( r ( 1 ), r ( 2 ), r ( 3 ), latitude , longitude ) end subroutine CartesianIntoGeodeticI !****************************************************************** !> !  Cartesian into Geodetic II ! !### See also !  * [[CartesianIntoGeodeticI]] subroutine CartesianIntoGeodeticII ( ax , ay , az , r , latitude , longitude , altitude , error ) real ( wp ), intent ( in ) :: ax , ay , az !! semiaxes of the celestial body: ax>ay>az real ( wp ), dimension ( 3 ), intent ( in ) :: r !! cartesian coordinates of the considered point !! in the first octant: xG, yG, zG with (xG,yG,zG)<>(0,0,0) real ( wp ), intent ( out ) :: latitude , longitude , altitude !! geodetic coordinates of the considered point real ( wp ), intent ( in ) :: error !! Values smaller than error treated as 0.0 real ( wp ) :: aymaz , aypaz , axmaz , axpaz , axpaz2 , ax2 , ay2 , az2 , ax4 , ay4 , az4 , az6 ,& az8 , temp0 , temp1 , temp2 , temp3 , temp4 , temp5 , temp6 , temp7 , temp8 ,& temp9 , tempa , az6ax2 , az6ay2 , tempb , maz10 , excc , eecc real ( wp ) :: xg2 , yg2 , zg2 , zgxg2 , zgyg2 , zg3 , zg4 , aux , xG , yG , zG real ( wp ) :: xE , yE , zE , k , B ( 0 : 6 ) logical :: done call special_cases ( ax , ay , az , r ( 1 ), r ( 2 ), r ( 3 ), latitude , longitude , altitude , done ) if ( done ) return ! Computations independent of xG,yG,zG. They can be precomputed, if necessary. aymaz = ay - az aypaz = ay + az axmaz = ax - az axpaz = ax + az axpaz2 = axpaz * axpaz ax2 = ax * ax ay2 = ay * ay az2 = az * az ax4 = ax2 * ax2 ay4 = ay2 * ay2 az4 = az2 * az2 az6 = az4 * az2 az8 = az4 * az4 temp0 = aymaz * aymaz * aypaz * aypaz * axmaz * axmaz * axpaz2 temp1 = 2 * az2 * aymaz * aypaz * axmaz * axpaz * ( ax2 + ay2 - 2 * az2 ) temp2 = - az2 * ( ax4 * ay4 - 2 * ax4 * ay2 * az2 + ax4 * az4 - 2 * ax2 * ay4 * az2 + 4 * ax2 * ay2 * az4 - 2 * ay2 * az6 + az8 - 2 * ax2 * az6 + ay4 * az4 ) temp3 = - az2 * ( - ax2 * ay4 + 2 * ax2 * ay2 * az2 - ax2 * az4 ) temp4 = - az2 * ( - ax4 * ay2 + 2 * ax2 * ay2 * az2 - ay2 * az4 ) temp5 = - az2 * ( - ax4 * az2 - 4 * ax2 * ay2 * az2 + 6 * ax2 * az4 - ay4 * az2 + 6 * ay2 * az4 - 6 * az6 ) temp6 = - 2 * az4 * ( ax4 * ay2 - ax4 * az2 + ax2 * ay4 - 4 * ax2 * ay2 * az2 + 3 * ax2 * az4 - ay4 * az2 + 3 * ay2 * az4 - 2 * az6 ) temp7 = - 2 * az4 * ( - ax2 * ay2 + ax2 * az2 ) temp8 = - 2 * az4 * ( - ax2 * ay2 + ay2 * az2 ) temp9 = - 2 * az4 * ( - ax2 * az2 - ay2 * az2 + 2 * az4 ) tempa = - az6 * ( ax4 + 4 * ax2 * ay2 - 6 * ax2 * az2 + ay4 - 6 * ay2 * az2 + 6 * az4 ) az6ax2 = az6 * ax2 az6ay2 = az6 * ay2 tempb = - 2 * az8 * ( ax2 + ay2 - 2 * az2 ) maz10 = - az6 * az4 excc = ( ax2 - az2 ) / ( ax2 ) eecc = ( ax2 - ay2 ) / ( ax2 ) xG = abs ( r ( 1 )) yG = abs ( r ( 2 )) zG = abs ( r ( 3 )) xg2 = xG * xG yg2 = yG * yG zg2 = zG * zG zgxg2 = zG * xg2 zgyg2 = zG * yg2 zg3 = zg2 * zG zg4 = zg2 * zg2 aux = xg2 / ax2 + yg2 / ay2 + zg2 / az2 if ( abs ( aux - 1.0_wp ) < error ) then ! The point is on the ellipsoid xE = xG yE = yG zE = zG else if ( zG > error ) then ! The point is inside or outside the ellipsoid with zG != 0 B ( 6 ) = temp0 B ( 5 ) = temp1 * zG B ( 4 ) = temp2 + temp3 * xg2 + temp4 * yg2 + temp5 * zg2 B ( 3 ) = zG * temp6 + temp7 * zgxg2 + temp8 * zgyg2 + temp9 * zg3 B ( 2 ) = zg2 * ( tempa + az6ax2 * xg2 + az6ay2 * yg2 + az8 * zg2 ) B ( 1 ) = tempb * zg3 B ( 0 ) = maz10 * zg4 k = solve_polynomial ( B , az * zG / norm2 ([ xG , yG , zG ]), error ) xE = ax2 * xG * k / ( ax2 * k - az2 * k + az2 * zG ) yE = ay2 * yG * k / ( ay2 * k - az2 * k + az2 * zG ) zE = k else if ( yG > error ) then B = [ - ay4 * ay2 * zg2 , & - 2 * ay4 * ( ax2 - ay2 ) * zG , & - ay2 * ( ax4 - 2 * ax2 * ay2 - ax2 * yg2 + ay4 - ay2 * zg2 ), & 2 * ay2 * ( ax2 - ay2 ) * zG , & ax4 + ay4 - 2 * ax2 * ay2 , & 0.0_wp , & 0.0_wp ] k = solve_polynomial ( B , ay * yG / norm2 ([ xG , yG , zG ]), error ) xE = k * ax2 * xG / ( ax2 * k - ay2 * k + ay2 * yG ) yE = k zE = 0.0_wp else xE = ax yE = 0.0_wp zE = 0.0_wp end if ! Computing longitude if ( xG > 0.0_wp ) then longitude = atan ( yE / (( 1.0_wp - eecc ) * xE )) else if ( yG > 0.0_wp ) then longitude = halfpi else longitude = huge ( 1.0_wp ) ! undefined end if ! Computing latitude if ( xE > 0.0_wp . or . yE > 0.0_wp ) then latitude = atan (( 1.0_wp - eecc ) / ( 1.0_wp - excc ) * zE / norm2 ([ xE * ( 1.0_wp - eecc ), yE ])) else latitude = halfpi end if ! Computing altitude if ( aux >= 1.0 ) then altitude = norm2 ([ xE - xG , yE - yG , zE - zG ]) else altitude = - norm2 ([ xE - xG , yE - yG , zE - zG ]) end if call philambda_quadrant ( r ( 1 ), r ( 2 ), r ( 3 ), latitude , longitude ) end subroutine CartesianIntoGeodeticII !******************************************************************************** !> !  Cartesian to geodetic for Triaxial Ellipsoid. ! !### References !  * S. Bektas, \"Geodetic Computations on Triaxial Ellipsoid\", !    International Journal of Mining Science (IJMS), !    Volume 1, Issue 1, June 2015, p 25-34 subroutine cartesian_to_geodetic_triaxial_2 ( a , b , c , r , eps , phi , lambda , h ) implicit none real ( wp ), intent ( in ) :: a !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: b !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: c !! ellipsoid radii `a >= b >= c` real ( wp ), dimension ( 3 ), intent ( in ) :: r !! Cartesian coordinates (x,y,z) real ( wp ), intent ( in ) :: eps !! convergence tolerance real ( wp ), intent ( out ) :: phi !! latitude (rad) real ( wp ), intent ( out ) :: lambda !! longitude (rad) real ( wp ), intent ( out ) :: h !! altitude integer , parameter :: maxiter = 20 !! maximum number of iterations integer :: i !! iteration counter real ( wp ), dimension ( 3 , 3 ) :: AA real ( wp ), dimension ( 3 ) :: bvec , xvec real ( wp ) :: a2 , b2 , c2 , x , y , z , ex2 , ee2 , e , f , g , xo , yo , zo , j11 , j12 , j21 , j23 , rmag , omee2 logical :: success x = r ( 1 ) y = r ( 2 ) z = r ( 3 ) if ( a < b . or . b < c ) error stop 'error in cartesian_to_geodetic_triaxial_2: invalid a,b,c' call special_cases ( a , b , c , x , y , z , phi , lambda , h , success ) if ( success ) return rmag = norm2 ( r ) a2 = a * a b2 = b * b c2 = c * c ex2 = ( a2 - c2 ) / a2 ee2 = ( a2 - b2 ) / a2 omee2 = one - ee2 E = one / a2 F = one / b2 G = one / c2 xo = a * x / rmag yo = b * y / rmag zo = c * z / rmag do i = 1 , maxiter j11 = F * yo - ( yo - y ) * E j12 = ( xo - x ) * F - E * xo j21 = G * zo - ( zo - z ) * E j23 = ( xo - x ) * G - E * xo ! solve the linear system: AA = reshape ( - [ j11 , j21 , two * E * xo ,& j12 , zero , two * F * yo ,& zero , j23 , two * G * zo ], [ 3 , 3 ]) bvec = [ ( xo - x ) * F * yo - ( yo - y ) * E * xo , & ( xo - x ) * G * zo - ( zo - z ) * E * xo , & E * xo ** 2 + F * yo ** 2 + G * zo ** 2 - one ] call linear_solver ( AA , bvec , xvec , success ) if (. not . success ) then write ( * , * ) 'error in cartesian_to_geodetic_triaxial_2: matrix is singular' phi = zero lambda = zero h = zero return end if xo = xo + xvec ( 1 ) yo = yo + xvec ( 2 ) zo = zo + xvec ( 3 ) if ( maxval ( abs ( xvec )) < eps ) exit end do ! outputs: phi = atan ( zo * omee2 / ( one - ex2 ) / sqrt ( omee2 ** 2 * xo ** 2 + yo ** 2 )) lambda = atan2 ( yo , omee2 * xo ) h = sign ( one , z - zo ) * sign ( one , zo ) * sqrt (( x - xo ) ** 2 + ( y - yo ) ** 2 + ( z - zo ) ** 2 ) contains subroutine linear_solver ( a , b , x , success ) !!  Solve the 3x3 system: `A * x = b` !!  Reference: https://caps.gsfc.nasa.gov/simpson/software/m33inv_f90.txt implicit none real ( wp ), dimension ( 3 , 3 ), intent ( in ) :: a real ( wp ), dimension ( 3 ), intent ( in ) :: b real ( wp ), dimension ( 3 ), intent ( out ) :: x logical , intent ( out ) :: success real ( wp ) :: det !! determinant of a real ( wp ), dimension ( 3 , 3 ) :: adj !! adjoint of a real ( wp ), dimension ( 3 , 3 ) :: ainv !! inverse of a det = a ( 1 , 1 ) * a ( 2 , 2 ) * a ( 3 , 3 ) & - a ( 1 , 1 ) * a ( 2 , 3 ) * a ( 3 , 2 ) & - a ( 1 , 2 ) * a ( 2 , 1 ) * a ( 3 , 3 ) & + a ( 1 , 2 ) * a ( 2 , 3 ) * a ( 3 , 1 ) & + a ( 1 , 3 ) * a ( 2 , 1 ) * a ( 3 , 2 ) & - a ( 1 , 3 ) * a ( 2 , 2 ) * a ( 3 , 1 ) success = abs ( det ) > tiny ( 1.0_wp ) ! check for singularity if ( success ) then adj (:, 1 ) = [ a ( 2 , 2 ) * a ( 3 , 3 ) - a ( 2 , 3 ) * a ( 3 , 2 ),& a ( 2 , 3 ) * a ( 3 , 1 ) - a ( 2 , 1 ) * a ( 3 , 3 ),& a ( 2 , 1 ) * a ( 3 , 2 ) - a ( 2 , 2 ) * a ( 3 , 1 )] adj (:, 2 ) = [ a ( 1 , 3 ) * a ( 3 , 2 ) - a ( 1 , 2 ) * a ( 3 , 3 ),& a ( 1 , 1 ) * a ( 3 , 3 ) - a ( 1 , 3 ) * a ( 3 , 1 ),& a ( 1 , 2 ) * a ( 3 , 1 ) - a ( 1 , 1 ) * a ( 3 , 2 )] adj (:, 3 ) = [ a ( 1 , 2 ) * a ( 2 , 3 ) - a ( 1 , 3 ) * a ( 2 , 2 ),& a ( 1 , 3 ) * a ( 2 , 1 ) - a ( 1 , 1 ) * a ( 2 , 3 ),& a ( 1 , 1 ) * a ( 2 , 2 ) - a ( 1 , 2 ) * a ( 2 , 1 )] ainv = adj / det x = matmul ( ainv , b ) else x = zero end if end subroutine linear_solver end subroutine cartesian_to_geodetic_triaxial_2 !******************************************************************************** !******************************************************************************** !> !  Special cases for lat/lon/altitude subroutine special_cases ( a , b , c , x , y , z , phi , lambda , h , done ) real ( wp ), intent ( in ) :: a !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: b !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: c !! ellipsoid radii `a >= b >= c` real ( wp ), intent ( in ) :: x !! Cartesian x coordinate real ( wp ), intent ( in ) :: y !! Cartesian y coordinate real ( wp ), intent ( in ) :: z !! Cartesian z coordinate real ( wp ), intent ( out ) :: phi !! latitude (rad) real ( wp ), intent ( out ) :: lambda !! longitude (rad) real ( wp ), intent ( out ) :: h !! altitude logical , intent ( out ) :: done !! true if one of the special cases was computed logical :: x0 , y0 , z0 real ( wp ), parameter :: zero_tol = 1 0.0_wp * epsilon ( 1.0_wp ) !! zero tolerance for singularities x0 = abs ( x ) <= zero_tol y0 = abs ( y ) <= zero_tol z0 = abs ( z ) <= zero_tol if ( x0 . and . y0 . and . z0 ) then ! center of the body phi = zero lambda = zero h = - c ! just pick this value done = . true . return else if ( x0 . and . y0 ) then ! (on the z-axis) if ( z >= zero ) then phi = halfpi lambda = zero h = z - c else phi = - halfpi lambda = zero h = - ( z + c ) end if done = . true . return else if ( x0 . and . z0 ) then ! on the y-axis if ( y >= zero ) then phi = zero lambda = halfpi h = y - b else phi = zero lambda = - halfpi h = - ( y + b ) end if done = . true . return else if ( y0 . and . z0 ) then ! on the x-axis if ( x >= zero ) then phi = zero lambda = zero h = x - a else phi = zero lambda = pi h = - ( x + a ) end if done = . true . return end if phi = zero lambda = zero h = zero done = . false . end subroutine special_cases !***************************************************************************************** !***************************************************************************************** !> !  Unit test for the [[direct]] and [[inverse]] geodetic routines. subroutine direct_inverse_test () implicit none !Ellipsoid : GRS80 / WGS84 (NAD83) real ( wp ), parameter :: a = 637813 7.0000_wp !! Equatorial radius real ( wp ), parameter :: rf = 29 8.25722210088_wp !! Inverse flattening real ( wp ), parameter :: f = 1.0_wp / rf !! flattening real ( wp ) :: glat1 , glon1 , glat2 , glon2 , faz , baz , s , sig , lam , glat2_ , glon2_ , baz_ integer :: it , kind write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' direct_inverse_test' write ( * , * ) '---------------' write ( * , * ) '' !specify two points: glat1 = 0.523599_wp glon1 = 1.74533_wp glat2 = 0.698132_wp glon2 = 2.0944_wp call inverse ( a , rf , glat1 , glon1 , glat2 , glon2 , faz , baz , s , it , sig , lam , kind ) call direct ( a , f , glat1 , glon1 , faz , s , glat2_ , glon2_ , baz_ ) write ( * , * ) 'lat error: ' , glat2_ - glat2 write ( * , * ) 'lon error: ' , glon2_ - glon2 write ( * , * ) 'baz error: ' , baz_ - baz end subroutine direct_inverse_test !***************************************************************************************** !***************************************************************************************** end module geodesy_module !*****************************************************************************************","tags":"","url":"sourcefile/geodesy_module.f90.html"},{"title":"rk_module_variable_step.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~rk_module_variable_step.f90~~EfferentGraph sourcefile~rk_module_variable_step.f90 rk_module_variable_step.f90 sourcefile~brent_module.f90 brent_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~brent_module.f90 sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~conversion_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~rk_module_variable_step.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~numbers_module.f90 sourcefile~orbital_mechanics_module.f90 orbital_mechanics_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~orbital_mechanics_module.f90 sourcefile~brent_module.f90->sourcefile~kind_module.f90 sourcefile~brent_module.f90->sourcefile~numbers_module.f90 sourcefile~conversion_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~kind_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~numbers_module.f90 sourcefile~math_module.f90 math_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~math_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~vector_module.f90 sourcefile~math_module.f90->sourcefile~kind_module.f90 sourcefile~math_module.f90->sourcefile~numbers_module.f90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~rk_module_variable_step.f90~~AfferentGraph sourcefile~rk_module_variable_step.f90 rk_module_variable_step.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~rk_module_variable_step.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams !  date: April 1, 2016 ! !  High-order variable step size Runge-Kutta integration methods. ! !  Currently have four methods: !   * Fehlberg 7(8) !   * Fehlberg 8(9) !   * Verner 8(9) !   * Feagin 8(10) !   * Feagin 12(10) !   * Feagin 14(12) ! !@warning This is a work in progress. module rk_module_variable_step use kind_module , only : wp use numbers_module implicit none private type , public :: stepsize_class !! Algorithms for adjusting the step size for variable-step !! Runge-Kutta integrators. private real ( wp ) :: hmax = huge ( one ) !! maximum allowed step size real ( wp ) :: hmin = two * epsilon ( one ) !! minimum allowed step size real ( wp ) :: hfactor_reject = 1.0e-3_wp !! minimum allowed factor for decreasing step size after rejected step real ( wp ) :: hfactor_accept = 10 0.0_wp !! maximum allowed factor for increasing step size after accepted step integer :: accept_mode = 1 !! method to determine if step is accepted [1,2] integer :: max_attempts = 100 !! maximum number of attempts to decrease step size before giving up ! the `hfactor` equation is: ! ! if (relative_err) then !     hfactor = safety_factor * abs(tol*h/err)**(one/real(p+p_exponent_offset,wp)) ! else !     hfactor = safety_factor * abs(tol/err)**(one/real(p+p_exponent_offset,wp)) ! end if logical :: relative_err = . false . !! to use `tol*h` in the `hfactor` equation real ( wp ) :: safety_factor = 0.9_wp !! for `hfactor` equation (>0) integer :: p_exponent_offset = 0 !! p + this value in the exponent (0 or 1) procedure ( norm_func ), nopass , pointer :: norm => maxval_func !! routine for computing the norm of the state contains private procedure , public :: initialize => stepsize_class_constructor procedure , public :: compute_stepsize procedure , public :: destroy => destroy_stepsize_class end type stepsize_class type , abstract , public :: rk_variable_step_class !! Main integration class for variable step size Runge-Kutta methods private integer :: n = 0 !! user specified number of variables procedure ( deriv_func ), pointer :: f => null () !! user-specified derivative function procedure ( report_func ), pointer :: report => null () !! user-specified report function procedure ( event_func ), pointer :: g => null () !! event function (stop when this is zero) class ( stepsize_class ), allocatable :: stepsize_method !! the method for varying the step size real ( wp ), dimension (:), allocatable :: rtol !! relative tolerance (`size(n)`) real ( wp ), dimension (:), allocatable :: atol !! absolute tolerance (`size(n)`) integer :: p = 0 !! order of the method integer :: hinit_method = 1 !! if automatically computing the inital step size, which !! method to use. 1 = `hstart`, 2 = `hinit`. integer :: num_rejected_steps = 0 !! number of rejected steps contains private procedure , public :: initialize !! initialize the class (set n,f, and report) procedure , public :: destroy !! destructor procedure , non_overridable , public :: integrate !! main integration routine procedure , non_overridable , public :: integrate_to_event !! integration with event finding procedure ( step_func ), deferred :: step !! the step routine for the rk method procedure ( order_func ), deferred :: order !! returns `p`, the order of the method procedure :: hstart !! for automatically computing the initial step size [this is from DDEABM] procedure :: hinit !! for automatically computing the initial step size [this is from DOP853] end type rk_variable_step_class type , extends ( rk_variable_step_class ), public :: rkf78_class !! Runga-Kutta Fehlberg 7(8) method. contains procedure :: step => rkf78 procedure :: order => rkf78_order end type rkf78_class type , extends ( rk_variable_step_class ), public :: rkf89_class !! Runga-Kutta Fehlberg 8(9) method. contains procedure :: step => rkf89 procedure :: order => rkf89_order end type rkf89_class type , extends ( rk_variable_step_class ), public :: rkv89_class !! Runga-Kutta Verner 8(9) method. contains procedure :: step => rkv89 procedure :: order => rkv89_order end type rkv89_class type , extends ( rk_variable_step_class ), public :: rkf108_class !! Runga-Kutta Feagin 8(10) method. contains procedure :: step => rkf108 procedure :: order => rkf108_order end type rkf108_class type , extends ( rk_variable_step_class ), public :: rkf1210_class !! Runga-Kutta Feagin 12(10) method. contains procedure :: step => rkf1210 procedure :: order => rkf1210_order end type rkf1210_class type , extends ( rk_variable_step_class ), public :: rkf1412_class !! Runga-Kutta Feagin 14(12) method. contains procedure :: step => rkf1412 procedure :: order => rkf1412_order end type rkf1412_class abstract interface pure function norm_func ( x ) result ( xmag ) !! Vector norm function. Must return a value  \\ge 0 . import :: wp implicit none real ( wp ), dimension (:), intent ( in ) :: x !! a vector real ( wp ) :: xmag !! the magnitude of the vector end function norm_func pure function order_func ( me ) result ( p ) import :: rk_variable_step_class implicit none class ( rk_variable_step_class ), intent ( in ) :: me integer :: p !! order of the method end function order_func subroutine deriv_func ( me , t , x , xdot ) !! derivative function import :: rk_variable_step_class , wp implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! time real ( wp ), dimension (:), intent ( in ) :: x !! state vector real ( wp ), dimension (:), intent ( out ) :: xdot !! derivative of state vector end subroutine deriv_func subroutine event_func ( me , t , x , g ) !! event function import :: rk_variable_step_class , wp implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! time real ( wp ), dimension (:), intent ( in ) :: x !! state vector real ( wp ), intent ( out ) :: g !! g(t,x). The goal is to stop the integration when g=0. end subroutine event_func subroutine report_func ( me , t , x ) !! report function import :: rk_variable_step_class , wp implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! time real ( wp ), dimension (:), intent ( in ) :: x !! state vector end subroutine report_func subroutine step_func ( me , t , x , h , xf , terr ) !! rk step function import :: rk_variable_step_class , wp implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state vector real ( wp ), intent ( in ) :: h !! time step  |\\Delta t|  real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! final state vector real ( wp ), dimension ( me % n ), intent ( out ) :: terr !! truncation error estimate end subroutine step_func end interface ! public routines: public :: norm2_func , maxval_func ! for testing: public :: step_size_test public :: rk_test_variable_step contains !***************************************************************************************** !***************************************************************************************** !> !  Use intrinsic `norm2(x)` for computing the vector norm. pure function norm2_func ( x ) result ( xmag ) implicit none real ( wp ), dimension (:), intent ( in ) :: x real ( wp ) :: xmag xmag = norm2 ( x ) end function norm2_func !***************************************************************************************** !***************************************************************************************** !> !  Use `maxval(abs(x))` for computing the vector norm. pure function maxval_func ( x ) result ( xmag ) implicit none real ( wp ), dimension (:), intent ( in ) :: x real ( wp ) :: xmag xmag = maxval ( abs ( x )) end function maxval_func !***************************************************************************************** !***************************************************************************************** !> !  Constructor for a [[stepsize_class]]. ! !@warning The `norm` and `compute_h_factor` options aren't public in the module. !         Need to fix this. pure subroutine stepsize_class_constructor ( me , hmin , hmax , hfactor_reject ,& hfactor_accept , norm , accept_mode , relative_err ,& safety_factor , p_exponent_offset , max_attempts ) implicit none class ( stepsize_class ), intent ( inout ) :: me real ( wp ), intent ( in ), optional :: hmin !! minimum allowed step size (>0) real ( wp ), intent ( in ), optional :: hmax !! maximum allowed step size (>0) real ( wp ), intent ( in ), optional :: hfactor_reject !! minimum allowed factor for !! decreasing step size after !! rejected step (>0) real ( wp ), intent ( in ), optional :: hfactor_accept !! maximum allowed factor for !! decreasing step size after !! accepted step (>0) procedure ( norm_func ), optional :: norm !! the user-specified  ||x||  !! function integer , intent ( in ), optional :: accept_mode !! method to determine if step !! is accepted [1,2] integer , intent ( in ), optional :: max_attempts !! max step size change attempts !! after rejected step logical , intent ( in ), optional :: relative_err !! to use `tol*h` in the `hfactor` equation real ( wp ), intent ( in ), optional :: safety_factor !! for `hfactor` equation (>0) integer , intent ( in ), optional :: p_exponent_offset !! p + this value in the exponent (0 or 1) if ( present ( hmin )) me % hmin = abs ( hmin ) if ( present ( hmax )) me % hmax = abs ( hmax ) if ( present ( hfactor_reject )) me % hfactor_reject = abs ( hfactor_reject ) if ( present ( hfactor_accept )) me % hfactor_accept = abs ( hfactor_accept ) if ( present ( norm )) me % norm => norm if ( present ( accept_mode )) me % accept_mode = accept_mode if ( present ( max_attempts )) me % max_attempts = max_attempts !if (present(compute_h_factor)) me%compute_h_factor => compute_h_factor if ( present ( relative_err )) me % relative_err = relative_err if ( present ( safety_factor )) me % safety_factor = abs ( safety_factor ) if ( present ( p_exponent_offset )) me % p_exponent_offset = abs ( p_exponent_offset ) end subroutine stepsize_class_constructor !***************************************************************************************** !***************************************************************************************** !> !  Destructor for [[stepsize_class]]. subroutine destroy_stepsize_class ( me ) implicit none class ( stepsize_class ), intent ( out ) :: me end subroutine destroy_stepsize_class !***************************************************************************************** !***************************************************************************************** pure subroutine compute_stepsize ( me , h , tol , err , p , hnew , accept ) !! Compute the new step size using the specific method. implicit none class ( stepsize_class ), intent ( in ) :: me real ( wp ), intent ( in ) :: h !! current step size (<>0) real ( wp ), intent ( in ) :: tol !! abs error tolerance (>0) real ( wp ), intent ( in ) :: err !! truncation error estimate (>0) integer , intent ( in ) :: p !! order of the method real ( wp ), intent ( out ) :: hnew !! new step size (<>0) logical , intent ( out ) :: accept !! if the step is accepted real ( wp ) :: hfactor !! step size factor (>0) real ( wp ), parameter :: small = ten * epsilon ( one ) !! small error value if ( err <= small ) then ! the error is extremely small hfactor = me % hfactor_accept accept = . true . else ! compute base factor based on the selected formula: !hfactor = abs(me%compute_h_factor(h,tol,err,p)) if ( me % relative_err ) then hfactor = abs ( me % safety_factor * abs ( tol * h / err ) ** ( one / real ( p + me % p_exponent_offset , wp )) ) else hfactor = abs ( me % safety_factor * abs ( tol / err ) ** ( one / real ( p + me % p_exponent_offset , wp )) ) end if ! if the step is to be accepted: select case ( me % accept_mode ) case ( 1 ) !algorithm 17.12 accept = ( hfactor >= one ) case ( 2 ) !algorithm 17.13 accept = ( err <= tol ) end select !...notes: ! see: L. Shampine \"Some Practical Runge-Kutta Formulas\", !      Mathematics of Computation, 46(173), Jan 1986. ! different conditions for satisfying error conditions: !  ||err|| <= tol   -- Error per step (EPS) !  ||err|| <= h*tol -- Error per unit step (EPUS) !compute the actual hfactor based on the limits: if ( accept ) then hfactor = min ( me % hfactor_accept , hfactor ) else hfactor = max ( me % hfactor_reject , hfactor ) end if end if ! compute the new step size (enforce min/max bounds & add sign): hnew = sign ( max ( me % hmin , min ( me % hmax , abs ( h ) * hfactor )), h ) end subroutine compute_stepsize !***************************************************************************************** !***************************************************************************************** !> !  Initialize the [[rk_variable_step_class]]. subroutine initialize ( me , n , f , rtol , atol , stepsize_method , hinit_method , report , g ) implicit none class ( rk_variable_step_class ), intent ( inout ) :: me integer , intent ( in ) :: n !! number of equations procedure ( deriv_func ) :: f !! derivative function real ( wp ), dimension (:), intent ( in ) :: rtol !! relative tolerance (if size=1, !! then same tol used for all !! equations) real ( wp ), dimension (:), intent ( in ) :: atol !! absolute tolerance (if size=1, !! then same tol used for all !! equations) class ( stepsize_class ), intent ( in ) :: stepsize_method !! method for varying the step size integer , intent ( in ), optional :: hinit_method !! which method to use for !! automatic initial step size !! computation. !! 1 = use `hstart`, 2 = use `hinit`. procedure ( report_func ), optional :: report !! for reporting the steps procedure ( event_func ), optional :: g !! for stopping at an event call me % destroy () me % n = n me % f => f allocate ( me % rtol ( n )) allocate ( me % atol ( n )) if ( size ( rtol ) == 1 ) then me % rtol = rtol ( 1 ) !use this for all equations else if ( size ( rtol ) == n ) then me % rtol = rtol else error stop 'invalid size for rtol array.' end if if ( size ( atol ) == 1 ) then me % atol = atol ( 1 ) !use this for all equations else if ( size ( atol ) == n ) then me % atol = atol else error stop 'invalid size for atol array.' end if if ( present ( hinit_method )) me % hinit_method = hinit_method if ( present ( report )) me % report => report if ( present ( g )) me % g => g allocate ( me % stepsize_method , source = stepsize_method ) me % num_rejected_steps = 0 end subroutine initialize !***************************************************************************************** !***************************************************************************************** !> !  Destructor for [[rk_variable_step_class]]. subroutine destroy ( me ) implicit none class ( rk_variable_step_class ), intent ( out ) :: me end subroutine destroy !***************************************************************************************** !***************************************************************************************** !> !  Main integration routine for the [[rk_variable_step_class]]. subroutine integrate ( me , t0 , x0 , h , tf , xf , ierr ) implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t0 !! initial time real ( wp ), dimension (:), intent ( in ) :: x0 !! initial state real ( wp ), intent ( in ) :: h !! initial abs(time step) real ( wp ), intent ( in ) :: tf !! final time real ( wp ), dimension (:), intent ( out ) :: xf !! final state integer , intent ( out ), optional :: ierr !! 0 = no errors, !! <0 = error. !! if not present, an error will stop program. real ( wp ) :: t , dt , t2 , err , tol , dt_new real ( wp ), dimension ( me % n ) :: x , terr , etol , xp0 logical :: last , export , accept integer :: i , p if ( present ( ierr )) ierr = 0 if (. not . associated ( me % f )) then if ( present ( ierr )) then ierr = - 1 return else error stop 'Error in integrate: f is not associated.' end if end if me % num_rejected_steps = 0 export = associated ( me % report ) if ( export ) call me % report ( t0 , x0 ) !first point if ( t0 == tf ) then xf = x0 else t = t0 x = x0 if ( h == zero ) then ! compute an appropriate initial step size: ! WARNING: this may not be working in all cases ..... etol = me % rtol * me % stepsize_method % norm ( x0 ) + me % atol call me % f ( t0 , x0 , xp0 ) ! get initial dx/dt select case ( me % hinit_method ) case ( 1 ) call me % hstart ( t0 , tf , x0 , xp0 , etol , dt ) case ( 2 ) dt = me % hinit ( t0 , x0 , sign ( one , tf - t0 ), xp0 , me % stepsize_method % hmax , me % atol , me % rtol ) case default if ( present ( ierr )) then ierr = - 2 return else error stop 'invalid hinit_method selection' end if end select !write(*,*) 'inital step size: ',dt else ! user-specified initial step size: dt = sign ( h , tf - t0 ) ! (correct sign) end if p = me % order () !order of the method do t2 = t + dt last = (( dt >= zero . and . t2 >= tf ) . or . & !adjust last time step ( dt < zero . and . t2 <= tf )) ! if ( last ) dt = tf - t ! do i = 0 , me % stepsize_method % max_attempts ! take a step: call me % step ( t , x , dt , xf , terr ) ! evaluate error and compute new step size: err = me % stepsize_method % norm ( terr ) tol = me % stepsize_method % norm ( me % rtol * xf + me % atol ) call me % stepsize_method % compute_stepsize ( dt , tol , err , p , dt_new , accept ) dt = dt_new if ( accept ) then !accept this step exit else !step is rejected, repeat step with new dt me % num_rejected_steps = me % num_rejected_steps + 1 !note: if we have reached the min step size, and the error !is still too large, we can't proceed. if ( i >= me % stepsize_method % max_attempts ) then if ( present ( ierr )) then ierr = - 3 return else error stop 'error: too many attempts to reduce step size.' end if end if if ( abs ( dt ) <= abs ( me % stepsize_method % hmin )) then if ( present ( ierr )) then ierr = - 4 return else error stop 'warning: min step size.' end if end if !...... !... if we have two rejected steps and the step size hasn't changed.. !    then we need to abort, since no progress is being made... !...... last = (( dt >= zero . and . t2 >= tf ) . or . & !adjust last time step ( dt < zero . and . t2 <= tf )) ! if ( last ) dt = tf - t ! t2 = t + dt end if end do if ( last ) exit if ( export ) call me % report ( t2 , xf ) !intermediate point x = xf t = t2 end do end if if ( export ) call me % report ( tf , xf ) !last point end subroutine integrate !***************************************************************************************** !***************************************************************************************** !> !  Event-finding integration routine for the [[rk_variable_step_class]]. !  Integrates until g(t,x)=0, or until t=tf (whichever happens first). ! !@note There are some efficiency improvements that could be made here. !      This is a work in progress. subroutine integrate_to_event ( me , t0 , x0 , h , tmax , tol , tf , xf , gf , ierr ) use brent_module implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t0 !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x0 !! initial state real ( wp ), intent ( in ) :: h !! abs(time step) real ( wp ), intent ( in ) :: tmax !! max final time if event not located real ( wp ), intent ( in ) :: tol !! function tolerance for root finding real ( wp ), intent ( out ) :: tf !! actual final time reached real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! final state (at tf) real ( wp ), intent ( out ) :: gf !! g value at tf integer , intent ( out ), optional :: ierr !! 0 = no errors, !! <0 = error. !! if not present, an error will stop program. real ( wp ), dimension ( me % n ) :: etol , xp0 real ( wp ), dimension ( me % n ) :: x , g_xf real ( wp ), dimension ( me % n ) :: terr !! truncation error estimate integer :: i , p , iflag real ( wp ) :: t , dt , t2 , ga , gb , dt_root , dum , err , dt_new , stol logical :: first , last , export , accept procedure ( report_func ), pointer :: report type ( brent_class ) :: solver if ( present ( ierr )) ierr = 0 if (. not . associated ( me % f )) then if ( present ( ierr )) then ierr = - 1 return else error stop 'Error in integrate_to_event: f is not associated.' end if end if if (. not . associated ( me % g )) then if ( present ( ierr )) then ierr = - 2 return else error stop 'Error in integrate_to_event: g is not associated.' end if end if me % num_rejected_steps = 0 export = associated ( me % report ) if ( export ) call me % report ( t0 , x0 ) !first point if ( t0 == tmax ) then xf = x0 tf = t0 call me % g ( t0 , x0 , gf ) else first = . true . t = t0 x = x0 call me % g ( t , x , ga ) !evaluate event function if ( h == zero ) then ! compute an appropriate initial step size: ! WARNING: this may not be working in all cases ..... etol = me % rtol * me % stepsize_method % norm ( x0 ) + me % atol call me % f ( t0 , x0 , xp0 ) ! get initial dx/dt select case ( me % hinit_method ) case ( 1 ) call me % hstart ( t0 , tmax , x0 , xp0 , etol , dt ) case ( 2 ) dt = me % hinit ( t0 , x0 , sign ( one , tmax - t0 ), xp0 , me % stepsize_method % hmax , me % atol , me % rtol ) case default if ( present ( ierr )) then ierr = - 3 return else error stop 'invalid hinit_method selection' end if end select else ! user-specified initial step size: dt = sign ( h , tmax - t0 ) ! (correct sign) end if p = me % order () !order of the method do t2 = t + dt last = (( dt >= zero . and . t2 >= tmax ) . or . & !adjust last time step ( dt < zero . and . t2 <= tmax )) ! if ( last ) then dt = tmax - t t2 = tmax end if do i = 0 , me % stepsize_method % max_attempts ! take a step: call me % step ( t , x , dt , xf , terr ) ! evaluate error and compute new step size: err = me % stepsize_method % norm ( terr ) stol = me % stepsize_method % norm ( me % rtol * xf + me % atol ) call me % stepsize_method % compute_stepsize ( dt , stol , err , p , dt_new , accept ) dt = dt_new if ( accept ) then !accept this step exit else !step is rejected, repeat step with new dt me % num_rejected_steps = me % num_rejected_steps + 1 !note: if we have reached the min step size, and the error !is still too large, we can't proceed. if ( i >= me % stepsize_method % max_attempts ) then if ( present ( ierr )) then ierr = - 4 return else error stop 'error: too many attempts to reduce step size.' end if end if if ( abs ( dt ) <= abs ( me % stepsize_method % hmin )) then if ( present ( ierr )) then ierr = - 5 return else error stop 'warning: min step size.' end if end if !...... !... if we have two rejected steps and the step size hasn't changed.. !    then we need to abort, since no progress is being made... !...... last = (( dt >= zero . and . t2 >= tmax ) . or . & !adjust last time step ( dt < zero . and . t2 <= tmax )) ! if ( last ) then dt = tmax - t t2 = tmax else t2 = t + dt end if end if end do call me % g ( t2 , xf , gb ) !evaluate event function if ( first . and . abs ( ga ) <= tol ) then !we ignore a root at t0 after the first step if ( abs ( gb ) <= tol ) then !check this one since it could have landed on a root gf = gb tf = t2 exit else if ( last ) then !exiting without having found a root tf = t2 gf = gb exit end if if ( export ) call me % report ( t2 , xf ) !intermediate point x = xf t = t2 ga = gb end if elseif ( ga * gb <= zero ) then !there is a root somewhere on [t,t+dt] !find the root: call solver % set_function ( solver_func ) call solver % find_zero ( zero , dt , tol , dt_root , dum , iflag , ga , gb ) t2 = t + dt_root gf = solver_func ( solver , dt_root ) tf = t2 xf = g_xf !computed in the solver function exit else !no root yet, continue if ( last ) then !exiting without having found a root tf = t2 gf = gb exit end if if ( export ) call me % report ( t2 , xf ) !intermediate point x = xf t = t2 ga = gb end if if ( first ) first = . false . if ( last ) exit x = xf t = t2 end do end if if ( export ) call me % report ( tf , xf ) !last point contains function solver_func ( this , delt ) result ( g ) !! root solver function. The input is the dt offset from time t. implicit none class ( brent_class ), intent ( inout ) :: this real ( wp ), intent ( in ) :: delt !! from [0 to dt] real ( wp ) :: g real ( wp ), dimension ( me % n ) :: terr !! truncation error estimate !take a step from t to t+delt and evaluate g function: ! [we don't check the error because we are within a !  step that was already accepted, so it should be ok] call me % step ( t , x , delt , g_xf , terr ) call me % g ( t + delt , g_xf , g ) end function solver_func end subroutine integrate_to_event !***************************************************************************************** !***************************************************************************************** !> !  Fehlberg's 7(8) algorithm. ! !### Reference !  * E. Fehlberg, \"Classical Fifth-, Sixth-, Seventh-, and Eighth-Order !    Runge-Kutta Formulas with Stepsize Control\", !   [NASA TR R-2870](http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19680027281_1968027281.pdf). subroutine rkf78 ( me , t , x , h , xf , terr ) implicit none class ( rkf78_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension ( me % n ), intent ( in ) :: x real ( wp ), intent ( in ) :: h real ( wp ), dimension ( me % n ), intent ( out ) :: xf real ( wp ), dimension ( me % n ), intent ( out ) :: terr real ( wp ), parameter :: a1 = 2.0_wp / 2 7.0_wp real ( wp ), parameter :: a2 = 1.0_wp / 9.0_wp real ( wp ), parameter :: a3 = 1.0_wp / 6.0_wp real ( wp ), parameter :: a4 = 5.0_wp / 1 2.0_wp real ( wp ), parameter :: a5 = 1.0_wp / 2.0_wp real ( wp ), parameter :: a6 = 5.0_wp / 6.0_wp real ( wp ), parameter :: a7 = 1.0_wp / 6.0_wp real ( wp ), parameter :: a8 = 2.0_wp / 3.0_wp real ( wp ), parameter :: a9 = 1.0_wp / 3.0_wp !real(wp),parameter :: a10 = 1.0_wp !real(wp),parameter :: a12 = 1.0_wp real ( wp ), parameter :: b10 = 2.0_wp / 2 7.0_wp real ( wp ), parameter :: b20 = 1.0_wp / 3 6.0_wp real ( wp ), parameter :: b21 = 1.0_wp / 1 2.0_wp real ( wp ), parameter :: b30 = 1.0_wp / 2 4.0_wp real ( wp ), parameter :: b32 = 1.0_wp / 8.0_wp real ( wp ), parameter :: b40 = 5.0_wp / 1 2.0_wp real ( wp ), parameter :: b42 = - 2 5.0_wp / 1 6.0_wp real ( wp ), parameter :: b43 = 2 5.0_wp / 1 6.0_wp real ( wp ), parameter :: b50 = 1.0_wp / 2 0.0_wp real ( wp ), parameter :: b53 = 1.0_wp / 4.0_wp real ( wp ), parameter :: b54 = 1.0_wp / 5.0_wp real ( wp ), parameter :: b60 = - 2 5.0_wp / 10 8.0_wp real ( wp ), parameter :: b63 = 12 5.0_wp / 10 8.0_wp real ( wp ), parameter :: b64 = - 6 5.0_wp / 2 7.0_wp real ( wp ), parameter :: b65 = 12 5.0_wp / 5 4.0_wp real ( wp ), parameter :: b70 = 3 1.0_wp / 30 0.0_wp real ( wp ), parameter :: b74 = 6 1.0_wp / 22 5.0_wp real ( wp ), parameter :: b75 = - 2.0_wp / 9.0_wp real ( wp ), parameter :: b76 = 1 3.0_wp / 90 0.0_wp real ( wp ), parameter :: b80 = 2.0_wp real ( wp ), parameter :: b83 = - 5 3.0_wp / 6.0_wp real ( wp ), parameter :: b84 = 70 4.0_wp / 4 5.0_wp real ( wp ), parameter :: b85 = - 10 7.0_wp / 9.0_wp real ( wp ), parameter :: b86 = 6 7.0_wp / 9 0.0_wp real ( wp ), parameter :: b87 = 3.0_wp real ( wp ), parameter :: b90 = - 9 1.0_wp / 10 8.0_wp real ( wp ), parameter :: b93 = 2 3.0_wp / 10 8.0_wp real ( wp ), parameter :: b94 = - 97 6.0_wp / 13 5.0_wp real ( wp ), parameter :: b95 = 31 1.0_wp / 5 4.0_wp real ( wp ), parameter :: b96 = - 1 9.0_wp / 6 0.0_wp real ( wp ), parameter :: b97 = 1 7.0_wp / 6.0_wp real ( wp ), parameter :: b98 = - 1.0_wp / 1 2.0_wp real ( wp ), parameter :: b100 = 238 3.0_wp / 410 0.0_wp real ( wp ), parameter :: b103 = - 34 1.0_wp / 16 4.0_wp real ( wp ), parameter :: b104 = 449 6.0_wp / 102 5.0_wp real ( wp ), parameter :: b105 = - 30 1.0_wp / 8 2.0_wp real ( wp ), parameter :: b106 = 213 3.0_wp / 410 0.0_wp real ( wp ), parameter :: b107 = 4 5.0_wp / 8 2.0_wp real ( wp ), parameter :: b108 = 4 5.0_wp / 16 4.0_wp real ( wp ), parameter :: b109 = 1 8.0_wp / 4 1.0_wp real ( wp ), parameter :: b110 = 3.0_wp / 20 5.0_wp real ( wp ), parameter :: b115 = - 6.0_wp / 4 1.0_wp real ( wp ), parameter :: b116 = - 3.0_wp / 20 5.0_wp real ( wp ), parameter :: b117 = - 3.0_wp / 4 1.0_wp real ( wp ), parameter :: b118 = 3.0_wp / 4 1.0_wp real ( wp ), parameter :: b119 = 6.0_wp / 4 1.0_wp real ( wp ), parameter :: b120 = - 177 7.0_wp / 410 0.0_wp real ( wp ), parameter :: b123 = - 34 1.0_wp / 16 4.0_wp real ( wp ), parameter :: b124 = 449 6.0_wp / 102 5.0_wp real ( wp ), parameter :: b125 = - 28 9.0_wp / 8 2.0_wp real ( wp ), parameter :: b126 = 219 3.0_wp / 410 0.0_wp real ( wp ), parameter :: b127 = 5 1.0_wp / 8 2.0_wp real ( wp ), parameter :: b128 = 3 3.0_wp / 16 4.0_wp real ( wp ), parameter :: b129 = 1 2.0_wp / 4 1.0_wp !real(wp),parameter :: b1211 = 1.0_wp real ( wp ), parameter :: c5 = 3 4.0_wp / 10 5.0_wp real ( wp ), parameter :: c6 = 9.0_wp / 3 5.0_wp real ( wp ), parameter :: c7 = 9.0_wp / 3 5.0_wp real ( wp ), parameter :: c8 = 9.0_wp / 28 0.0_wp real ( wp ), parameter :: c9 = 9.0_wp / 28 0.0_wp real ( wp ), parameter :: c11 = 4 1.0_wp / 84 0.0_wp real ( wp ), parameter :: c12 = 4 1.0_wp / 84 0.0_wp real ( wp ), dimension ( me % n ) :: f0 , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 , f10 , f11 , f12 if ( h == zero ) then xf = x terr = zero return end if call me % f ( t , x , f0 ) call me % f ( t + h * a1 , x + f0 * b10 * h , f1 ) call me % f ( t + h * a2 , x + ( f0 * b20 + f1 * b21 ) * h , f2 ) call me % f ( t + h * a3 , x + ( f0 * b30 + f2 * b32 ) * h , f3 ) call me % f ( t + h * a4 , x + ( f0 * b40 + f2 * b42 + f3 * b43 ) * h , f4 ) call me % f ( t + h * a5 , x + ( f0 * b50 + f3 * b53 + f4 * b54 ) * h , f5 ) call me % f ( t + h * a6 , x + ( f0 * b60 + f3 * b63 + f4 * b64 + f5 * b65 ) * h , f6 ) call me % f ( t + h * a7 , x + ( f0 * b70 + f4 * b74 + f5 * b75 + f6 * b76 ) * h , f7 ) call me % f ( t + h * a8 , x + ( f0 * b80 + f3 * b83 + f4 * b84 + f5 * b85 + f6 * b86 + & f7 * b87 ) * h , f8 ) call me % f ( t + h * a9 , x + ( f0 * b90 + f3 * b93 + f4 * b94 + f5 * b95 + f6 * b96 + & f7 * b97 + f8 * b98 ) * h , f9 ) call me % f ( t + h , x + ( f0 * b100 + f3 * b103 + f4 * b104 + f5 * b105 + & f6 * b106 + f7 * b107 + f8 * b108 + f9 * b109 ) * h , f10 ) call me % f ( t , x + ( f0 * b110 + f5 * b115 + f6 * b116 + f7 * b117 + f8 * b118 + & f9 * b119 ) * h , f11 ) call me % f ( t + h , x + ( f0 * b120 + f3 * b123 + f4 * b124 + f5 * b125 + f6 * b126 + & f7 * b127 + f8 * b128 + f9 * b129 + f11 ) * h , f12 ) xf = x + h * ( f5 * c5 + f6 * c6 + f7 * c7 + f8 * c8 + f9 * c9 + f11 * c11 + f12 * c12 ) terr = ( 4 1.0_wp / 84 0.0_wp ) * ( f0 + f10 - f11 - f12 ) end subroutine rkf78 !***************************************************************************************** !***************************************************************************************** !> !  Fehlberg 8(9) method. ! !### Reference !  * E. Fehlberg, \"Classical Fifth-, Sixth-, Seventh-, and Eighth-Order !    Runge-Kutta Formulas with Stepsize Control\", !   [NASA TR R-2870](http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19680027281_1968027281.pdf). subroutine rkf89 ( me , t , x , h , xf , terr ) implicit none class ( rkf89_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state real ( wp ), intent ( in ) :: h !! time step real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! state at time `t+h` real ( wp ), dimension ( me % n ), intent ( out ) :: terr !! truncation error estimate real ( wp ), parameter :: a1 = 0.44368940376498183109599404281370_wp real ( wp ), parameter :: a2 = 0.66553410564747274664399106422055_wp real ( wp ), parameter :: a3 = 0.99830115847120911996598659633083_wp real ( wp ), parameter :: a4 = 0.3155_wp real ( wp ), parameter :: a5 = 0.50544100948169068626516126737384_wp real ( wp ), parameter :: a6 = 0.17142857142857142857142857142857_wp real ( wp ), parameter :: a7 = 0.82857142857142857142857142857143_wp real ( wp ), parameter :: a8 = 0.66543966121011562534953769255586_wp real ( wp ), parameter :: a9 = 0.24878317968062652069722274560771_wp real ( wp ), parameter :: a10 = 0.1090_wp real ( wp ), parameter :: a11 = 0.8910_wp real ( wp ), parameter :: a12 = 0.3995_wp real ( wp ), parameter :: a13 = 0.6005_wp real ( wp ), parameter :: a14 = 1.0_wp real ( wp ), parameter :: a16 = 1.0_wp real ( wp ), parameter :: b1 = 0.44368940376498183109599404281370_wp real ( wp ), parameter :: b20 = 0.16638352641186818666099776605514_wp real ( wp ), parameter :: b21 = 0.49915057923560455998299329816541_wp real ( wp ), parameter :: b30 = 0.24957528961780227999149664908271_wp real ( wp ), parameter :: b32 = 0.74872586885340683997448994724812_wp real ( wp ), parameter :: b40 = 0.20661891163400602426556710393185_wp real ( wp ), parameter :: b42 = 0.17707880377986347040380997288319_wp real ( wp ), parameter :: b43 = - 0.68197715413869494669377076815048e-1_wp real ( wp ), parameter :: b50 = 0.10927823152666408227903890926157_wp real ( wp ), parameter :: b53 = 0.40215962642367995421990563690087e-2_wp real ( wp ), parameter :: b54 = 0.39214118169078980444392330174325_wp real ( wp ), parameter :: b60 = 0.98899281409164665304844765434355e-1_wp real ( wp ), parameter :: b63 = 0.35138370227963966951204487356703e-2_wp real ( wp ), parameter :: b64 = 0.12476099983160016621520625872489_wp real ( wp ), parameter :: b65 = - 0.55745546834989799643742901466348e-1_wp real ( wp ), parameter :: b70 = - 0.36806865286242203724153101080691_wp real ( wp ), parameter :: b74 = - 0.22273897469476007645024020944166e+1_wp real ( wp ), parameter :: b75 = 0.13742908256702910729565691245744e+1_wp real ( wp ), parameter :: b76 = 0.20497390027111603002159354092206e+1_wp real ( wp ), parameter :: b80 = 0.45467962641347150077351950603349e-1_wp real ( wp ), parameter :: b85 = 0.32542131701589147114677469648853_wp real ( wp ), parameter :: b86 = 0.28476660138527908888182420573687_wp real ( wp ), parameter :: b87 = 0.97837801675979152435868397271099e-2_wp real ( wp ), parameter :: b90 = 0.60842071062622057051094145205182e-1_wp real ( wp ), parameter :: b95 = - 0.21184565744037007526325275251206e-1_wp real ( wp ), parameter :: b96 = 0.19596557266170831957464490662983_wp real ( wp ), parameter :: b97 = - 0.42742640364817603675144835342899e-2_wp real ( wp ), parameter :: b98 = 0.17434365736814911965323452558189e-1_wp real ( wp ), parameter :: b100 = 0.54059783296931917365785724111182e-1_wp real ( wp ), parameter :: b106 = 0.11029825597828926530283127648228_wp real ( wp ), parameter :: b107 = - 0.12565008520072556414147763782250e-2_wp real ( wp ), parameter :: b108 = 0.36790043477581460136384043566339e-2_wp real ( wp ), parameter :: b109 = - 0.57780542770972073040840628571866e-1_wp real ( wp ), parameter :: b110 = 0.12732477068667114646645181799160_wp real ( wp ), parameter :: b117 = 0.11448805006396105323658875721817_wp real ( wp ), parameter :: b118 = 0.28773020709697992776202201849198_wp real ( wp ), parameter :: b119 = 0.50945379459611363153735885079465_wp real ( wp ), parameter :: b1110 = - 0.14799682244372575900242144449640_wp real ( wp ), parameter :: b120 = - 0.36526793876616740535848544394333e-2_wp real ( wp ), parameter :: b125 = 0.81629896012318919777819421247030e-1_wp real ( wp ), parameter :: b126 = - 0.38607735635693506490517694343215_wp real ( wp ), parameter :: b127 = 0.30862242924605106450474166025206e-1_wp real ( wp ), parameter :: b128 = - 0.58077254528320602815829374733518e-1_wp real ( wp ), parameter :: b129 = 0.33598659328884971493143451362322_wp real ( wp ), parameter :: b1210 = 0.41066880401949958613549622786417_wp real ( wp ), parameter :: b1211 = - 0.11840245972355985520633156154536e-1_wp real ( wp ), parameter :: b130 = - 0.12375357921245143254979096135669e+1_wp real ( wp ), parameter :: b135 = - 0.24430768551354785358734861366763e+2_wp real ( wp ), parameter :: b136 = 0.54779568932778656050436528991173_wp real ( wp ), parameter :: b137 = - 0.44413863533413246374959896569346e+1_wp real ( wp ), parameter :: b138 = 0.10013104813713266094792617851022e+2_wp real ( wp ), parameter :: b139 = - 0.14995773102051758447170985073142e+2_wp real ( wp ), parameter :: b1310 = 0.58946948523217013620824539651427e+1_wp real ( wp ), parameter :: b1311 = 0.17380377503428984877616857440542e+1_wp real ( wp ), parameter :: b1312 = 0.27512330693166730263758622860276e+2_wp real ( wp ), parameter :: b140 = - 0.35260859388334522700502958875588_wp real ( wp ), parameter :: b145 = - 0.18396103144848270375044198988231_wp real ( wp ), parameter :: b146 = - 0.65570189449741645138006879985251_wp real ( wp ), parameter :: b147 = - 0.39086144880439863435025520241310_wp real ( wp ), parameter :: b148 = 0.26794646712850022936584423271209_wp real ( wp ), parameter :: b149 = - 0.10383022991382490865769858507427e+1_wp real ( wp ), parameter :: b1410 = 0.16672327324258671664727346168501e+1_wp real ( wp ), parameter :: b1411 = 0.49551925855315977067732967071441_wp real ( wp ), parameter :: b1412 = 0.11394001132397063228586738141784e+1_wp real ( wp ), parameter :: b1413 = 0.51336696424658613688199097191534e-1_wp real ( wp ), parameter :: b150 = 0.10464847340614810391873002406755e-2_wp real ( wp ), parameter :: b158 = - 0.67163886844990282237778446178020e-2_wp real ( wp ), parameter :: b159 = 0.81828762189425021265330065248999e-2_wp real ( wp ), parameter :: b1510 = - 0.42640342864483347277142138087561e-2_wp real ( wp ), parameter :: b1511 = 0.28009029474168936545976331153703e-3_wp real ( wp ), parameter :: b1512 = - 0.87835333876238676639057813145633e-2_wp real ( wp ), parameter :: b1513 = 0.10254505110825558084217769664009e-1_wp real ( wp ), parameter :: b160 = - 0.13536550786174067080442168889966e+1_wp real ( wp ), parameter :: b165 = - 0.18396103144848270375044198988231_wp real ( wp ), parameter :: b166 = - 0.65570189449741645138006879985251_wp real ( wp ), parameter :: b167 = - 0.39086144880439863435025520241310_wp real ( wp ), parameter :: b168 = 0.27466285581299925758962207732989_wp real ( wp ), parameter :: b169 = - 0.10464851753571915887035188572676e+1_wp real ( wp ), parameter :: b1610 = 0.16714967667123155012004488306588e+1_wp real ( wp ), parameter :: b1611 = 0.49523916825841808131186990740287_wp real ( wp ), parameter :: b1612 = 0.11481836466273301905225795954930e+1_wp real ( wp ), parameter :: b1613 = 0.41082191313833055603981327527525e-1_wp real ( wp ), parameter :: b1615 = 1.0_wp real ( wp ), parameter :: c0 = 0.32256083500216249913612900960247e-1_wp real ( wp ), parameter :: c8 = 0.25983725283715403018887023171963_wp real ( wp ), parameter :: c9 = 0.92847805996577027788063714302190e-1_wp real ( wp ), parameter :: c10 = 0.16452339514764342891647731842800_wp real ( wp ), parameter :: c11 = 0.17665951637860074367084298397547_wp real ( wp ), parameter :: c12 = 0.23920102320352759374108933320941_wp real ( wp ), parameter :: c13 = 0.39484274604202853746752118829325e-2_wp real ( wp ), parameter :: c14 = 0.30726495475860640406368305522124e-1_wp real ( wp ), dimension ( me % n ) :: f0 , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 , f10 , f11 , f12 , f13 , f14 , f15 , f16 if ( h == zero ) then xf = x terr = zero return end if call me % f ( t , x , f0 ) call me % f ( t + h * a1 , x + f0 * b1 * h , f1 ) call me % f ( t + h * a2 , x + ( f0 * b20 + f1 * b21 ) * h , f2 ) call me % f ( t + h * a3 , x + ( f0 * b30 + f2 * b32 ) * h , f3 ) call me % f ( t + h * a4 , x + ( f0 * b40 + f2 * b42 + f3 * b43 ) * h , f4 ) call me % f ( t + h * a5 , x + ( f0 * b50 + f3 * b53 + f4 * b54 ) * h , f5 ) call me % f ( t + h * a6 , x + ( f0 * b60 + f3 * b63 + f4 * b64 + f5 * b65 ) * h , f6 ) call me % f ( t + h * a7 , x + ( f0 * b70 + f4 * b74 + f5 * b75 + f6 * b76 ) * h , f7 ) call me % f ( t + h * a8 , x + ( f0 * b80 + f5 * b85 + f6 * b86 + f7 * b87 ) * h , f8 ) call me % f ( t + h * a9 , x + ( f0 * b90 + f5 * b95 + f6 * b96 + f7 * b97 + f8 * b98 ) * h , f9 ) call me % f ( t + h * a10 , x + ( f0 * b100 + f6 * b106 + f7 * b107 + f8 * b108 + & f9 * b109 ) * h , f10 ) call me % f ( t + h * a11 , x + ( f0 * b110 + f7 * b117 + f8 * b118 + f9 * b119 + & f10 * b1110 ) * h , f11 ) call me % f ( t + h * a12 , x + ( f0 * b120 + f5 * b125 + f6 * b126 + f7 * b127 + & f8 * b128 + f9 * b129 + f10 * b1210 + f11 * b1211 ) * h , f12 ) call me % f ( t + h * a13 , x + ( f0 * b130 + f5 * b135 + f6 * b136 + f7 * b137 + & f8 * b138 + f9 * b139 + f10 * b1310 + f11 * b1311 + f12 * b1312 ) * h , f13 ) call me % f ( t + h * a14 , x + ( f0 * b140 + f5 * b145 + f6 * b146 + f7 * b147 + f8 * b148 + & f9 * b149 + f10 * b1410 + f11 * b1411 + f12 * b1412 + f13 * b1413 ) * h , f14 ) call me % f ( t , x + ( f0 * b150 + f8 * b158 + f9 * b159 + f10 * b1510 + f11 * b1511 + & f12 * b1512 + f13 * b1513 ) * h , f15 ) call me % f ( t + h * a16 , x + ( f0 * b160 + f5 * b165 + f6 * b166 + f7 * b167 + f8 * b168 + & f9 * b169 + f10 * b1610 + f11 * b1611 + f12 * b1612 + f13 * b1613 + & f15 * b1615 ) * h , f16 ) xf = x + h * ( f0 * c0 + f8 * c8 + f9 * c9 + f10 * c10 + f11 * c11 + f12 * c12 + f13 * c13 + f14 * c14 ) terr = c14 * h * ( f0 + f14 - f15 - f16 ) end subroutine rkf89 !***************************************************************************************** !***************************************************************************************** !> !  Runge Kutta Verner 8(9) ! !### Reference !  * J. H. Verner, \"Explicit Runge–Kutta Methods with Estimates of the !    Local Truncation Error\", SIAM Journal on Numerical Analysis, !   15(4), 772–790, 1978. subroutine rkv89 ( me , t , x , h , xf , terr ) implicit none class ( rkv89_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state real ( wp ), intent ( in ) :: h !! time step real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! state at time `t+h` real ( wp ), dimension ( me % n ), intent ( out ) :: terr !! truncation error estimate real ( wp ), parameter :: s6 = sqrt ( 6.0_wp ) real ( wp ), parameter :: a2 = 1.0_wp / 1 2.0_wp real ( wp ), parameter :: a3 = 1.0_wp / 9.0_wp real ( wp ), parameter :: a4 = 1.0_wp / 6.0_wp real ( wp ), parameter :: a5 = 2.0_wp * ( 1.0_wp + s6 ) / 1 5.0_wp real ( wp ), parameter :: a6 = ( 6.0_wp + s6 ) / 1 5.0_wp real ( wp ), parameter :: a7 = ( 6.0_wp - s6 ) / 1 5.0_wp real ( wp ), parameter :: a8 = 2.0_wp / 3.0_wp real ( wp ), parameter :: a9 = 1.0_wp / 2.0_wp real ( wp ), parameter :: a10 = 1.0_wp / 3.0_wp real ( wp ), parameter :: a11 = 1.0_wp / 4.0_wp real ( wp ), parameter :: a12 = 4.0_wp / 3.0_wp real ( wp ), parameter :: a13 = 5.0_wp / 6.0_wp real ( wp ), parameter :: a15 = 1.0_wp / 6.0_wp real ( wp ), parameter :: b31 = 1.0_wp / 2 7.0_wp real ( wp ), parameter :: b32 = 2.0_wp / 2 7.0_wp real ( wp ), parameter :: b41 = 1.0_wp / 2 4.0_wp real ( wp ), parameter :: b43 = 3.0_wp / 2 4.0_wp real ( wp ), parameter :: b51 = ( 4.0_wp + 9 4.0_wp * s6 ) / 37 5.0_wp real ( wp ), parameter :: b53 = - ( 28 2.0_wp + 25 2.0_wp * s6 ) / 37 5.0_wp real ( wp ), parameter :: b54 = ( 32 8.0_wp + 20 8.0_wp * s6 ) / 37 5.0_wp real ( wp ), parameter :: b61 = ( 9.0_wp - s6 ) / 15 0.0_wp real ( wp ), parameter :: b64 = ( 31 2.0_wp + 3 2.0_wp * s6 ) / 142 5.0_wp real ( wp ), parameter :: b65 = ( 6 9.0_wp + 2 9.0_wp * s6 ) / 57 0.0_wp real ( wp ), parameter :: b71 = ( 92 7.0_wp - 34 7.0_wp * s6 ) / 125 0.0_wp real ( wp ), parameter :: b74 = ( - 1624 8.0_wp + 732 8.0_wp * s6 ) / 937 5.0_wp real ( wp ), parameter :: b75 = ( - 48 9.0_wp + 17 9.0_wp * s6 ) / 375 0.0_wp real ( wp ), parameter :: b76 = ( 1426 8.0_wp - 579 8.0_wp * s6 ) / 937 5.0_wp real ( wp ), parameter :: b81 = 4.0_wp / 5 4.0_wp real ( wp ), parameter :: b86 = ( 1 6.0_wp - s6 ) / 5 4.0_wp real ( wp ), parameter :: b87 = ( 1 6.0_wp + s6 ) / 5 4.0_wp real ( wp ), parameter :: b91 = 3 8.0_wp / 51 2.0_wp real ( wp ), parameter :: b96 = ( 11 8.0_wp - 2 3.0_wp * s6 ) / 51 2.0_wp real ( wp ), parameter :: b97 = ( 11 8.0_wp + 2 3.0_wp * s6 ) / 51 2.0_wp real ( wp ), parameter :: b98 = - 1 8.0_wp / 51 2.0_wp real ( wp ), parameter :: b101 = 1 1.0_wp / 14 4.0_wp real ( wp ), parameter :: b106 = ( 26 6.0_wp - s6 ) / 86 4.0_wp real ( wp ), parameter :: b107 = ( 26 6.0_wp + s6 ) / 86 4.0_wp real ( wp ), parameter :: b108 = - 1.0_wp / 1 6.0_wp real ( wp ), parameter :: b109 = - 8.0_wp / 2 7.0_wp real ( wp ), parameter :: b111 = ( 503 4.0_wp - 27 1.0_wp * s6 ) / 6144 0.0_wp real ( wp ), parameter :: b117 = ( 785 9.0_wp - 162 6.0_wp * s6 ) / 1024 0.0_wp real ( wp ), parameter :: b118 = ( - 223 2.0_wp + 81 3.0_wp * s6 ) / 2048 0.0_wp real ( wp ), parameter :: b119 = ( - 59 4.0_wp + 27 1.0_wp * s6 ) / 96 0.0_wp real ( wp ), parameter :: b1110 = ( 65 7.0_wp - 81 3.0_wp * s6 ) / 512 0.0_wp real ( wp ), parameter :: b121 = ( 599 6.0_wp - 379 4.0_wp * s6 ) / 40 5.0_wp real ( wp ), parameter :: b126 = ( - 434 2.0_wp - 33 8.0_wp * s6 ) / 9.0_wp real ( wp ), parameter :: b127 = ( 15492 2.0_wp - 4045 8.0_wp * s6 ) / 13 5.0_wp real ( wp ), parameter :: b128 = ( - 417 6.0_wp + 379 4.0_wp * s6 ) / 4 5.0_wp real ( wp ), parameter :: b129 = ( - 34086 4.0_wp + 24281 6.0_wp * s6 ) / 40 5.0_wp real ( wp ), parameter :: b1210 = ( 2630 4.0_wp - 1517 6.0_wp * s6 ) / 4 5.0_wp real ( wp ), parameter :: b1211 = - 2662 4.0_wp / 8 1.0_wp real ( wp ), parameter :: b131 = ( 379 3.0_wp + 216 8.0_wp * s6 ) / 10368 0.0_wp real ( wp ), parameter :: b136 = ( 404 2.0_wp + 226 3.0_wp * s6 ) / 1382 4.0_wp real ( wp ), parameter :: b137 = ( - 23127 8.0_wp + 4071 7.0_wp * s6 ) / 6912 0.0_wp real ( wp ), parameter :: b138 = ( 794 7.0_wp - 216 8.0_wp * s6 ) / 1152 0.0_wp real ( wp ), parameter :: b139 = ( 104 8.0_wp - 54 2.0_wp * s6 ) / 40 5.0_wp real ( wp ), parameter :: b1310 = ( - 138 3.0_wp + 54 2.0_wp * s6 ) / 72 0.0_wp real ( wp ), parameter :: b1311 = 262 4.0_wp / 105 3.0_wp real ( wp ), parameter :: b1312 = 3.0_wp / 166 4.0_wp real ( wp ), parameter :: b141 = - 13 7.0_wp / 129 6.0_wp real ( wp ), parameter :: b146 = ( 564 2.0_wp - 33 7.0_wp * s6 ) / 86 4.0_wp real ( wp ), parameter :: b147 = ( 564 2.0_wp + 33 7.0_wp * s6 ) / 86 4.0_wp real ( wp ), parameter :: b148 = - 29 9.0_wp / 4 8.0_wp real ( wp ), parameter :: b149 = 18 4.0_wp / 8 1.0_wp real ( wp ), parameter :: b1410 = - 4 4.0_wp / 9.0_wp real ( wp ), parameter :: b1411 = - 512 0.0_wp / 105 3.0_wp real ( wp ), parameter :: b1412 = - 1 1.0_wp / 46 8.0_wp real ( wp ), parameter :: b1413 = 1 6.0_wp / 9.0_wp real ( wp ), parameter :: b151 = ( 3361 7.0_wp - 216 8.0_wp * s6 ) / 51840 0.0_wp real ( wp ), parameter :: b156 = ( - 384 6.0_wp + 3 1.0_wp * s6 ) / 1382 4.0_wp real ( wp ), parameter :: b157 = ( 15533 8.0_wp - 5280 7.0_wp * s6 ) / 34560 0.0_wp real ( wp ), parameter :: b158 = ( - 1253 7.0_wp + 216 8.0_wp * s6 ) / 5760 0.0_wp real ( wp ), parameter :: b159 = ( 9 2.0_wp + 54 2.0_wp * s6 ) / 202 5.0_wp real ( wp ), parameter :: b1510 = ( - 179 7.0_wp - 54 2.0_wp * s6 ) / 360 0.0_wp real ( wp ), parameter :: b1511 = 32 0.0_wp / 56 7.0_wp real ( wp ), parameter :: b1512 = - 1.0_wp / 192 0.0_wp real ( wp ), parameter :: b1513 = 4.0_wp / 10 5.0_wp real ( wp ), parameter :: b161 = ( - 3648 7.0_wp - 3035 2.0_wp * s6 ) / 27960 0.0_wp real ( wp ), parameter :: b166 = ( - 2966 6.0_wp - 449 9.0_wp * s6 ) / 745 6.0_wp real ( wp ), parameter :: b167 = ( 277918 2.0_wp - 61597 3.0_wp * s6 ) / 18640 0.0_wp real ( wp ), parameter :: b168 = ( - 9432 9.0_wp + 9105 6.0_wp * s6 ) / 9320 0.0_wp real ( wp ), parameter :: b169 = ( - 23219 2.0_wp + 12140 8.0_wp * s6 ) / 1747 5.0_wp real ( wp ), parameter :: b1610 = ( 10122 6.0_wp - 2276 4.0_wp * s6 ) / 582 5.0_wp real ( wp ), parameter :: b1611 = - 16998 4.0_wp / 908 7.0_wp real ( wp ), parameter :: b1612 = - 8 7.0_wp / 3029 0.0_wp real ( wp ), parameter :: b1613 = 49 2.0_wp / 116 5.0_wp real ( wp ), parameter :: b1615 = 126 0.0_wp / 23 3.0_wp real ( wp ), parameter :: c1 = 10 3.0_wp / 168 0.0_wp real ( wp ), parameter :: c8 = - 2 7.0_wp / 14 0.0_wp real ( wp ), parameter :: c9 = 7 6.0_wp / 10 5.0_wp real ( wp ), parameter :: c10 = - 20 1.0_wp / 28 0.0_wp real ( wp ), parameter :: c11 = 102 4.0_wp / 136 5.0_wp real ( wp ), parameter :: c12 = 3.0_wp / 728 0.0_wp real ( wp ), parameter :: c13 = 1 2.0_wp / 3 5.0_wp real ( wp ), parameter :: c14 = 9.0_wp / 28 0.0_wp real ( wp ), parameter :: e1 = - 191 1.0_wp / 10920 0.0_wp real ( wp ), parameter :: e8 = 3439 8.0_wp / 10920 0.0_wp real ( wp ), parameter :: e9 = - 6115 2.0_wp / 10920 0.0_wp real ( wp ), parameter :: e10 = 11466 0.0_wp / 10920 0.0_wp real ( wp ), parameter :: e11 = - 11468 8.0_wp / 10920 0.0_wp real ( wp ), parameter :: e12 = - 6 3.0_wp / 10920 0.0_wp real ( wp ), parameter :: e13 = - 1310 4.0_wp / 10920 0.0_wp real ( wp ), parameter :: e14 = - 351 0.0_wp / 10920 0.0_wp real ( wp ), parameter :: e15 = 3931 2.0_wp / 10920 0.0_wp real ( wp ), parameter :: e16 = 605 8.0_wp / 10920 0.0_wp real ( wp ), dimension ( me % n ) :: f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 ,& f10 , f11 , f12 , f13 , f14 , f15 , f16 call me % f ( t , x , f1 ) call me % f ( t + a2 * h , x + h * ( a2 * f1 ), f2 ) call me % f ( t + a3 * h , x + h * ( b31 * f1 + b32 * f2 ), f3 ) call me % f ( t + a4 * h , x + h * ( b41 * f1 + b43 * f3 ), f4 ) call me % f ( t + a5 * h , x + h * ( b51 * f1 + b53 * f3 + b54 * f4 ), f5 ) call me % f ( t + a6 * h , x + h * ( b61 * f1 + b64 * f4 + b65 * f5 ), f6 ) call me % f ( t + a7 * h , x + h * ( b71 * f1 + b74 * f4 + b75 * f5 + b76 * f6 ), f7 ) call me % f ( t + a8 * h , x + h * ( b81 * f1 + b86 * f6 + b87 * f7 ), f8 ) call me % f ( t + a9 * h , x + h * ( b91 * f1 + b96 * f6 + b97 * f7 + b98 * f8 ), f9 ) call me % f ( t + a10 * h , x + h * ( b101 * f1 + b106 * f6 + b107 * f7 + b108 * f8 + b109 * f9 ), f10 ) call me % f ( t + a11 * h , x + h * ( b111 * f1 + b117 * f7 + b118 * f8 + b119 * f9 + b1110 * f10 ), f11 ) call me % f ( t + a12 * h , x + h * ( b121 * f1 + b126 * f6 + b127 * f7 + b128 * f8 + b129 * f9 + & b1210 * f10 + b1211 * f11 ), f12 ) call me % f ( t + a13 * h , x + h * ( b131 * f1 + b136 * f6 + b137 * f7 + b138 * f8 + b139 * f9 + & b1310 * f10 + b1311 * f11 + b1312 * f12 ), f13 ) call me % f ( t + h , x + h * ( b141 * f1 + b146 * f6 + b147 * f7 + b148 * f8 + b149 * f9 + b1410 * f10 + & b1411 * f11 + b1412 * f12 + b1413 * f13 ), f14 ) call me % f ( t + a15 * h , x + h * ( b151 * f1 + b156 * f6 + b157 * f7 + b158 * f8 + b159 * f9 + b1510 * f10 + & b1511 * f11 + b1512 * f12 + b1513 * f13 ), f15 ) call me % f ( t + h , x + h * ( b161 * f1 + b166 * f6 + b167 * f7 + b168 * f8 + b169 * f9 + b1610 * f10 + & b1611 * f11 + b1612 * f12 + b1613 * f13 + b1615 * f15 ), f16 ) xf = x + h * ( c1 * f1 + c8 * f8 + c9 * f9 + c10 * f10 + c11 * f11 + c12 * f12 + c13 * f13 + c14 * f14 ) terr = e1 * f1 + e8 * f8 + e9 * f9 + e10 * f10 + e11 * f11 + e12 * f12 + e13 * f13 + e14 * f14 + e15 * f15 + e16 * f16 end subroutine rkv89 !***************************************************************************************** !***************************************************************************************** !> !  Feagin's RK8(10) method -- a 10th-order method with an embedded 8th-order method. ! !### Reference !  * T. Feagin, \"[A Tenth-Order Runge-Kutta Method with Error Estimate] !    (http://sce.uhcl.edu/feagin/courses/rk10.pdf)\", !    [coefficient file](http://sce.uhcl.edu/rungekutta/rk108.txt) subroutine rkf108 ( me , t , x , h , xf , terr ) implicit none class ( rkf108_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state real ( wp ), intent ( in ) :: h !! time step real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! state at time `t+h` real ( wp ), dimension ( me % n ), intent ( out ) :: terr !! truncation error estimate real ( wp ), parameter :: a1 = 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a2 = 0.539357840802981787532485197881302436857273449701009015505500_wp real ( wp ), parameter :: a3 = 0.809036761204472681298727796821953655285910174551513523258250_wp real ( wp ), parameter :: a4 = 0.309036761204472681298727796821953655285910174551513523258250_wp real ( wp ), parameter :: a5 = 0.981074190219795268254879548310562080489056746118724882027805_wp real ( wp ), parameter :: a6 = 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a7 = 0.354017365856802376329264185948796742115824053807373968324184_wp real ( wp ), parameter :: a8 = 0.882527661964732346425501486979669075182867844268052119663791_wp real ( wp ), parameter :: a9 = 0.642615758240322548157075497020439535959501736363212695909875_wp real ( wp ), parameter :: a10 = 0.357384241759677451842924502979560464040498263636787304090125_wp real ( wp ), parameter :: a11 = 0.117472338035267653574498513020330924817132155731947880336209_wp real ( wp ), parameter :: a12 = 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a13 = 0.309036761204472681298727796821953655285910174551513523258250_wp real ( wp ), parameter :: a14 = 0.539357840802981787532485197881302436857273449701009015505500_wp real ( wp ), parameter :: a15 = 0.100000000000000000000000000000000000000000000000000000000000_wp !real(wp),parameter :: a16 = 1.00000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c0 = 0.0333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: c1 = 0.0250000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c2 = 0.0333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: c4 = 0.0500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c6 = 0.0400000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c8 = 0.189237478148923490158306404106012326238162346948625830327194_wp real ( wp ), parameter :: c9 = 0.277429188517743176508360262560654340428504319718040836339472_wp real ( wp ), parameter :: c10 = 0.277429188517743176508360262560654340428504319718040836339472_wp real ( wp ), parameter :: c11 = 0.189237478148923490158306404106012326238162346948625830327194_wp real ( wp ), parameter :: c12 = - 0.0400000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c13 = - 0.0500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c14 = - 0.0333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: c15 = - 0.0250000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c16 = 0.0333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b10 = 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b20 = - 0.915176561375291440520015019275342154318951387664369720564660_wp real ( wp ), parameter :: b21 = 1.45453440217827322805250021715664459117622483736537873607016_wp real ( wp ), parameter :: b30 = 0.202259190301118170324681949205488413821477543637878380814562_wp real ( wp ), parameter :: b32 = 0.606777570903354510974045847616465241464432630913635142443687_wp real ( wp ), parameter :: b40 = 0.184024714708643575149100693471120664216774047979591417844635_wp real ( wp ), parameter :: b42 = 0.197966831227192369068141770510388793370637287463360401555746_wp real ( wp ), parameter :: b43 = - 0.0729547847313632629185146671595558023015011608914382961421311_wp real ( wp ), parameter :: b50 = 0.0879007340206681337319777094132125475918886824944548534041378_wp real ( wp ), parameter :: b53 = 0.410459702520260645318174895920453426088035325902848695210406_wp real ( wp ), parameter :: b54 = 0.482713753678866489204726942976896106809132737721421333413261_wp real ( wp ), parameter :: b60 = 0.0859700504902460302188480225945808401411132615636600222593880_wp real ( wp ), parameter :: b63 = 0.330885963040722183948884057658753173648240154838402033448632_wp real ( wp ), parameter :: b64 = 0.489662957309450192844507011135898201178015478433790097210790_wp real ( wp ), parameter :: b65 = - 0.0731856375070850736789057580558988816340355615025188195854775_wp real ( wp ), parameter :: b70 = 0.120930449125333720660378854927668953958938996999703678812621_wp real ( wp ), parameter :: b74 = 0.260124675758295622809007617838335174368108756484693361887839_wp real ( wp ), parameter :: b75 = 0.0325402621549091330158899334391231259332716675992700000776101_wp real ( wp ), parameter :: b76 = - 0.0595780211817361001560122202563305121444953672762930724538856_wp real ( wp ), parameter :: b80 = 0.110854379580391483508936171010218441909425780168656559807038_wp real ( wp ), parameter :: b85 = - 0.0605761488255005587620924953655516875526344415354339234619466_wp real ( wp ), parameter :: b86 = 0.321763705601778390100898799049878904081404368603077129251110_wp real ( wp ), parameter :: b87 = 0.510485725608063031577759012285123416744672137031752354067590_wp real ( wp ), parameter :: b90 = 0.112054414752879004829715002761802363003717611158172229329393_wp real ( wp ), parameter :: b95 = - 0.144942775902865915672349828340980777181668499748506838876185_wp real ( wp ), parameter :: b96 = - 0.333269719096256706589705211415746871709467423992115497968724_wp real ( wp ), parameter :: b97 = 0.499269229556880061353316843969978567860276816592673201240332_wp real ( wp ), parameter :: b98 = 0.509504608929686104236098690045386253986643232352989602185060_wp real ( wp ), parameter :: b100 = 0.113976783964185986138004186736901163890724752541486831640341_wp real ( wp ), parameter :: b105 = - 0.0768813364203356938586214289120895270821349023390922987406384_wp real ( wp ), parameter :: b106 = 0.239527360324390649107711455271882373019741311201004119339563_wp real ( wp ), parameter :: b107 = 0.397774662368094639047830462488952104564716416343454639902613_wp real ( wp ), parameter :: b108 = 0.0107558956873607455550609147441477450257136782823280838547024_wp real ( wp ), parameter :: b109 = - 0.327769124164018874147061087350233395378262992392394071906457_wp real ( wp ), parameter :: b110 = 0.0798314528280196046351426864486400322758737630423413945356284_wp real ( wp ), parameter :: b115 = - 0.0520329686800603076514949887612959068721311443881683526937298_wp real ( wp ), parameter :: b116 = - 0.0576954146168548881732784355283433509066159287152968723021864_wp real ( wp ), parameter :: b117 = 0.194781915712104164976306262147382871156142921354409364738090_wp real ( wp ), parameter :: b118 = 0.145384923188325069727524825977071194859203467568236523866582_wp real ( wp ), parameter :: b119 = - 0.0782942710351670777553986729725692447252077047239160551335016_wp real ( wp ), parameter :: b1110 = - 0.114503299361098912184303164290554670970133218405658122674674_wp real ( wp ), parameter :: b120 = 0.985115610164857280120041500306517278413646677314195559520529_wp real ( wp ), parameter :: b123 = 0.330885963040722183948884057658753173648240154838402033448632_wp real ( wp ), parameter :: b124 = 0.489662957309450192844507011135898201178015478433790097210790_wp real ( wp ), parameter :: b125 = - 1.37896486574843567582112720930751902353904327148559471526397_wp real ( wp ), parameter :: b126 = - 0.861164195027635666673916999665534573351026060987427093314412_wp real ( wp ), parameter :: b127 = 5.78428813637537220022999785486578436006872789689499172601856_wp real ( wp ), parameter :: b128 = 3.28807761985103566890460615937314805477268252903342356581925_wp real ( wp ), parameter :: b129 = - 2.38633905093136384013422325215527866148401465975954104585807_wp real ( wp ), parameter :: b1210 = - 3.25479342483643918654589367587788726747711504674780680269911_wp real ( wp ), parameter :: b1211 = - 2.16343541686422982353954211300054820889678036420109999154887_wp real ( wp ), parameter :: b130 = 0.895080295771632891049613132336585138148156279241561345991710_wp real ( wp ), parameter :: b132 = 0.197966831227192369068141770510388793370637287463360401555746_wp real ( wp ), parameter :: b133 = - 0.0729547847313632629185146671595558023015011608914382961421311_wp real ( wp ), parameter :: b135 = - 0.851236239662007619739049371445966793289359722875702227166105_wp real ( wp ), parameter :: b136 = 0.398320112318533301719718614174373643336480918103773904231856_wp real ( wp ), parameter :: b137 = 3.63937263181035606029412920047090044132027387893977804176229_wp real ( wp ), parameter :: b138 = 1.54822877039830322365301663075174564919981736348973496313065_wp real ( wp ), parameter :: b139 = - 2.12221714704053716026062427460427261025318461146260124401561_wp real ( wp ), parameter :: b1310 = - 1.58350398545326172713384349625753212757269188934434237975291_wp real ( wp ), parameter :: b1311 = - 1.71561608285936264922031819751349098912615880827551992973034_wp real ( wp ), parameter :: b1312 = - 0.0244036405750127452135415444412216875465593598370910566069132_wp real ( wp ), parameter :: b140 = - 0.915176561375291440520015019275342154318951387664369720564660_wp real ( wp ), parameter :: b141 = 1.45453440217827322805250021715664459117622483736537873607016_wp real ( wp ), parameter :: b144 = - 0.777333643644968233538931228575302137803351053629547286334469_wp real ( wp ), parameter :: b146 = - 0.0910895662155176069593203555807484200111889091770101799647985_wp real ( wp ), parameter :: b1412 = 0.0910895662155176069593203555807484200111889091770101799647985_wp real ( wp ), parameter :: b1413 = 0.777333643644968233538931228575302137803351053629547286334469_wp real ( wp ), parameter :: b150 = 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b152 = - 0.157178665799771163367058998273128921867183754126709419409654_wp real ( wp ), parameter :: b1514 = 0.157178665799771163367058998273128921867183754126709419409654_wp real ( wp ), parameter :: b160 = 0.181781300700095283888472062582262379650443831463199521664945_wp real ( wp ), parameter :: b161 = 0.675000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b162 = 0.342758159847189839942220553413850871742338734703958919937260_wp real ( wp ), parameter :: b164 = 0.259111214548322744512977076191767379267783684543182428778156_wp real ( wp ), parameter :: b165 = - 0.358278966717952089048961276721979397739750634673268802484271_wp real ( wp ), parameter :: b166 = - 1.04594895940883306095050068756409905131588123172378489286080_wp real ( wp ), parameter :: b167 = 0.930327845415626983292300564432428777137601651182965794680397_wp real ( wp ), parameter :: b168 = 1.77950959431708102446142106794824453926275743243327790536000_wp real ( wp ), parameter :: b169 = 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b1610 = - 0.282547569539044081612477785222287276408489375976211189952877_wp real ( wp ), parameter :: b1611 = - 0.159327350119972549169261984373485859278031542127551931461821_wp real ( wp ), parameter :: b1612 = - 0.145515894647001510860991961081084111308650130578626404945571_wp real ( wp ), parameter :: b1613 = - 0.259111214548322744512977076191767379267783684543182428778156_wp real ( wp ), parameter :: b1614 = - 0.342758159847189839942220553413850871742338734703958919937260_wp real ( wp ), parameter :: b1615 = - 0.675000000000000000000000000000000000000000000000000000000000_wp real ( wp ), dimension ( me % n ) :: f0 , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 , f10 , f11 , f12 , f13 , f14 , f15 , f16 if ( h == zero ) then xf = x terr = zero return end if call me % f ( t , x , f0 ) call me % f ( t + a1 * h , x + h * ( b10 * f0 ), f1 ) call me % f ( t + a2 * h , x + h * ( b20 * f0 + b21 * f1 ), f2 ) call me % f ( t + a3 * h , x + h * ( b30 * f0 + b32 * f2 ), f3 ) call me % f ( t + a4 * h , x + h * ( b40 * f0 + b42 * f2 + b43 * f3 ), f4 ) call me % f ( t + a5 * h , x + h * ( b50 * f0 + b53 * f3 + b54 * f4 ), f5 ) call me % f ( t + a6 * h , x + h * ( b60 * f0 + b63 * f3 + b64 * f4 + b65 * f5 ), f6 ) call me % f ( t + a7 * h , x + h * ( b70 * f0 + b74 * f4 + b75 * f5 + b76 * f6 ), f7 ) call me % f ( t + a8 * h , x + h * ( b80 * f0 + b85 * f5 + b86 * f6 + b87 * f7 ), f8 ) call me % f ( t + a9 * h , x + h * ( b90 * f0 + b95 * f5 + b96 * f6 + b97 * f7 + b98 * f8 ), f9 ) call me % f ( t + a10 * h , x + h * ( b100 * f0 + b105 * f5 + b106 * f6 + b107 * f7 + b108 * f8 + & b109 * f9 ), f10 ) call me % f ( t + a11 * h , x + h * ( b110 * f0 + b115 * f5 + b116 * f6 + b117 * f7 + b118 * f8 + & b119 * f9 + b1110 * f10 ), f11 ) call me % f ( t + a12 * h , x + h * ( b120 * f0 + b123 * f3 + b124 * f4 + b125 * f5 + b126 * f6 + & b127 * f7 + b128 * f8 + b129 * f9 + b1210 * f10 + b1211 * f11 ), f12 ) call me % f ( t + a13 * h , x + h * ( b130 * f0 + b132 * f2 + b133 * f3 + b135 * f5 + b136 * f6 + & b137 * f7 + b138 * f8 + b139 * f9 + b1310 * f10 + b1311 * f11 + & b1312 * f12 ), f13 ) call me % f ( t + a14 * h , x + h * ( b140 * f0 + b141 * f1 + b144 * f4 + b146 * f6 + b1412 * f12 + & b1413 * f13 ), f14 ) call me % f ( t + a15 * h , x + h * ( b150 * f0 + b152 * f2 + b1514 * f14 ), f15 ) call me % f ( t + h , x + h * ( b160 * f0 + b161 * f1 + b162 * f2 + b164 * f4 + b165 * f5 + & b166 * f6 + b167 * f7 + b168 * f8 + b169 * f9 + b1610 * f10 + b1611 * f11 + & b1612 * f12 + b1613 * f13 + b1614 * f14 + b1615 * f15 ), f16 ) xf = x + h * ( c0 * f0 + c1 * f1 + c2 * f2 + c4 * f4 + c6 * f6 + c8 * f8 + c9 * f9 + & c10 * f10 + c11 * f11 + c12 * f12 + c13 * f13 + c14 * f14 + c15 * f15 + c16 * f16 ) terr = ( 1.0_wp / 36 0.0_wp ) * h * ( f1 - f15 ) end subroutine rkf108 !***************************************************************************************** !***************************************************************************************** !> !  Feagin's RK12(10) method -- a 12th-order method with an embedded 10th-order method. ! !### Reference !  * [coefficient file](http://sce.uhcl.edu/rungekutta/rk1210.txt) subroutine rkf1210 ( me , t , x , h , xf , terr ) implicit none class ( rkf1210_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state real ( wp ), intent ( in ) :: h !! time step real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! state at time `t+h` real ( wp ), dimension ( me % n ), intent ( out ) :: terr !! truncation error estimate real ( wp ), parameter :: a0 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a1 = 0.200000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a2 = 0.555555555555555555555555555555555555555555555555555555555556_wp real ( wp ), parameter :: a3 = 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a4 = 0.333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a5 = 1.00000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a6 = 0.671835709170513812712245661002797570438953420568682550710222_wp real ( wp ), parameter :: a7 = 0.288724941110620201935458488967024976908118598341806976469674_wp real ( wp ), parameter :: a8 = 0.562500000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a9 = 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a10 = 0.947695431179199287562380162101836721649589325892740646458322_wp real ( wp ), parameter :: a11 = 0.0548112876863802643887753674810754475842153612931128785028369_wp real ( wp ), parameter :: a12 = 0.0848880518607165350639838930162674302064148175640019542045934_wp real ( wp ), parameter :: a13 = 0.265575603264642893098114059045616835297201264164077621448665_wp real ( wp ), parameter :: a14 = 0.500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a15 = 0.734424396735357106901885940954383164702798735835922378551335_wp real ( wp ), parameter :: a16 = 0.915111948139283464936016106983732569793585182435998045795407_wp real ( wp ), parameter :: a17 = 0.947695431179199287562380162101836721649589325892740646458322_wp real ( wp ), parameter :: a18 = 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a19 = 0.288724941110620201935458488967024976908118598341806976469674_wp real ( wp ), parameter :: a20 = 0.671835709170513812712245661002797570438953420568682550710222_wp real ( wp ), parameter :: a21 = 0.333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a22 = 0.555555555555555555555555555555555555555555555555555555555556_wp real ( wp ), parameter :: a23 = 0.200000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a24 = 1.00000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c0 = 0.0238095238095238095238095238095238095238095238095238095238095_wp real ( wp ), parameter :: c1 = 0.0234375000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c2 = 0.0312500000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c3 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c4 = 0.0416666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: c5 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c6 = 0.0500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c7 = 0.0500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c8 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c9 = 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c10 = 0.0714285714285714285714285714285714285714285714285714285714286_wp real ( wp ), parameter :: c11 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c12 = 0.138413023680782974005350203145033146748813640089941234591267_wp real ( wp ), parameter :: c13 = 0.215872690604931311708935511140681138965472074195773051123019_wp real ( wp ), parameter :: c14 = 0.243809523809523809523809523809523809523809523809523809523810_wp real ( wp ), parameter :: c15 = 0.215872690604931311708935511140681138965472074195773051123019_wp real ( wp ), parameter :: c16 = 0.138413023680782974005350203145033146748813640089941234591267_wp real ( wp ), parameter :: c17 = - 0.0714285714285714285714285714285714285714285714285714285714286_wp real ( wp ), parameter :: c18 = - 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c19 = - 0.0500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c20 = - 0.0500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c21 = - 0.0416666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: c22 = - 0.0312500000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c23 = - 0.0234375000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c24 = 0.0238095238095238095238095238095238095238095238095238095238095_wp real ( wp ), parameter :: b10 = 0.200000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b20 = - 0.216049382716049382716049382716049382716049382716049382716049_wp real ( wp ), parameter :: b21 = 0.771604938271604938271604938271604938271604938271604938271605_wp real ( wp ), parameter :: b30 = 0.208333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b31 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b32 = 0.625000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b40 = 0.193333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b41 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b42 = 0.220000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b43 = - 0.0800000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b50 = 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b51 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b52 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b53 = 0.400000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b54 = 0.500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b60 = 0.103364471650010477570395435690481791543342708330349879244197_wp real ( wp ), parameter :: b61 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b62 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b63 = 0.124053094528946761061581889237115328211074784955180298044074_wp real ( wp ), parameter :: b64 = 0.483171167561032899288836480451962508724109257517289177302380_wp real ( wp ), parameter :: b65 = - 0.0387530245694763252085681443767620580395733302341368038804290_wp real ( wp ), parameter :: b70 = 0.124038261431833324081904585980175168140024670698633612292480_wp real ( wp ), parameter :: b71 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b72 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b73 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b74 = 0.217050632197958486317846256953159942875916353757734167684657_wp real ( wp ), parameter :: b75 = 0.0137455792075966759812907801835048190594443990939408530842918_wp real ( wp ), parameter :: b76 = - 0.0661095317267682844455831341498149531672668252085016565917546_wp real ( wp ), parameter :: b80 = 0.0914774894856882983144991846980432197088832099976660100090486_wp real ( wp ), parameter :: b81 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b82 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b83 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b84 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b85 = - 0.00544348523717469689965754944144838611346156873847009178068318_wp real ( wp ), parameter :: b86 = 0.0680716801688453518578515120895103863112751730758794372203952_wp real ( wp ), parameter :: b87 = 0.408394315582641046727306852653894780093303185664924644551239_wp real ( wp ), parameter :: b90 = 0.0890013652502551018954509355423841780143232697403434118692699_wp real ( wp ), parameter :: b91 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b92 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b93 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b94 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b95 = 0.00499528226645532360197793408420692800405891149406814091955810_wp real ( wp ), parameter :: b96 = 0.397918238819828997341739603001347156083435060931424970826304_wp real ( wp ), parameter :: b97 = 0.427930210752576611068192608300897981558240730580396406312359_wp real ( wp ), parameter :: b98 = - 0.0865117637557827005740277475955029103267246394128995965941585_wp real ( wp ), parameter :: b100 = 0.0695087624134907543112693906409809822706021061685544615255758_wp real ( wp ), parameter :: b101 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b102 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b103 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b104 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b105 = 0.129146941900176461970759579482746551122871751501482634045487_wp real ( wp ), parameter :: b106 = 1.53073638102311295076342566143214939031177504112433874313011_wp real ( wp ), parameter :: b107 = 0.577874761129140052546751349454576715334892100418571882718036_wp real ( wp ), parameter :: b108 = - 0.951294772321088980532340837388859453930924498799228648050949_wp real ( wp ), parameter :: b109 = - 0.408276642965631951497484981519757463459627174520978426909934_wp real ( wp ), parameter :: b110 = 0.0444861403295135866269453507092463581620165501018684152933313_wp real ( wp ), parameter :: b111 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b112 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b113 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b114 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b115 = - 0.00380476867056961731984232686574547203016331563626856065717964_wp real ( wp ), parameter :: b116 = 0.0106955064029624200721262602809059154469206077644957399593972_wp real ( wp ), parameter :: b117 = 0.0209616244499904333296674205928919920806734650660039898074652_wp real ( wp ), parameter :: b118 = - 0.0233146023259321786648561431551978077665337818756053603898847_wp real ( wp ), parameter :: b119 = 0.00263265981064536974369934736325334761174975280887405725010964_wp real ( wp ), parameter :: b1110 = 0.00315472768977025060103545855572111407955208306374459723959783_wp real ( wp ), parameter :: b120 = 0.0194588815119755475588801096525317761242073762016273186231215_wp real ( wp ), parameter :: b121 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b122 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b123 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b124 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b125 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b126 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b127 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b128 = 0.0000678512949171812509306121653452367476194364781259165332321534_wp real ( wp ), parameter :: b129 = - 0.0000429795859049273623271005330230162343568863387724883603675550_wp real ( wp ), parameter :: b1210 = 0.0000176358982260285155407485928953302139937553442829975734148981_wp real ( wp ), parameter :: b1211 = 0.0653866627415027051009595231385181033549511358787382098351924_wp real ( wp ), parameter :: b130 = 0.206836835664277105916828174798272361078909196043446411598231_wp real ( wp ), parameter :: b131 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b132 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b133 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b134 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b135 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b136 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b137 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b138 = 0.0166796067104156472828045866664696450306326505094792505215514_wp real ( wp ), parameter :: b139 = - 0.00879501563200710214457024178249986591130234990219959208704979_wp real ( wp ), parameter :: b1310 = 0.00346675455362463910824462315246379209427513654098596403637231_wp real ( wp ), parameter :: b1311 = - 0.861264460105717678161432562258351242030270498966891201799225_wp real ( wp ), parameter :: b1312 = 0.908651882074050281096239478469262145034957129939256789178785_wp real ( wp ), parameter :: b140 = 0.0203926084654484010091511314676925686038504449562413004562382_wp real ( wp ), parameter :: b141 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b142 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b143 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b144 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b145 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b146 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b147 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b148 = 0.0869469392016685948675400555583947505833954460930940959577347_wp real ( wp ), parameter :: b149 = - 0.0191649630410149842286436611791405053287170076602337673587681_wp real ( wp ), parameter :: b1410 = 0.00655629159493663287364871573244244516034828755253746024098838_wp real ( wp ), parameter :: b1411 = 0.0987476128127434780903798528674033899738924968006632201445462_wp real ( wp ), parameter :: b1412 = 0.00535364695524996055083260173615567408717110247274021056118319_wp real ( wp ), parameter :: b1413 = 0.301167864010967916837091303817051676920059229784957479998077_wp real ( wp ), parameter :: b150 = 0.228410433917778099547115412893004398779136994596948545722283_wp real ( wp ), parameter :: b151 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b152 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b153 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b154 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b155 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b156 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b157 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b158 = - 0.498707400793025250635016567442511512138603770959682292383042_wp real ( wp ), parameter :: b159 = 0.134841168335724478552596703792570104791700727205981058201689_wp real ( wp ), parameter :: b1510 = - 0.0387458244055834158439904226924029230935161059142806805674360_wp real ( wp ), parameter :: b1511 = - 1.27473257473474844240388430824908952380979292713250350199641_wp real ( wp ), parameter :: b1512 = 1.43916364462877165201184452437038081875299303577911839630524_wp real ( wp ), parameter :: b1513 = - 0.214007467967990254219503540827349569639028092344812795499026_wp real ( wp ), parameter :: b1514 = 0.958202417754430239892724139109781371059908874605153648768037_wp real ( wp ), parameter :: b160 = 2.00222477655974203614249646012506747121440306225711721209798_wp real ( wp ), parameter :: b161 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b162 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b163 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b164 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b165 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b166 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b167 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b168 = 2.06701809961524912091954656438138595825411859673341600679555_wp real ( wp ), parameter :: b169 = 0.623978136086139541957471279831494466155292316167021080663140_wp real ( wp ), parameter :: b1610 = - 0.0462283685500311430283203554129062069391947101880112723185773_wp real ( wp ), parameter :: b1611 = - 8.84973288362649614860075246727118949286604835457092701094630_wp real ( wp ), parameter :: b1612 = 7.74257707850855976227437225791835589560188590785037197433615_wp real ( wp ), parameter :: b1613 = - 0.588358519250869210993353314127711745644125882130941202896436_wp real ( wp ), parameter :: b1614 = - 1.10683733362380649395704708016953056176195769617014899442903_wp real ( wp ), parameter :: b1615 = - 0.929529037579203999778397238291233214220788057511899747507074_wp real ( wp ), parameter :: b170 = 3.13789533412073442934451608989888796808161259330322100268310_wp real ( wp ), parameter :: b171 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b172 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b173 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b174 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b175 = 0.129146941900176461970759579482746551122871751501482634045487_wp real ( wp ), parameter :: b176 = 1.53073638102311295076342566143214939031177504112433874313011_wp real ( wp ), parameter :: b177 = 0.577874761129140052546751349454576715334892100418571882718036_wp real ( wp ), parameter :: b178 = 5.42088263055126683050056840891857421941300558851862156403363_wp real ( wp ), parameter :: b179 = 0.231546926034829304872663800877643660904880180835945693836936_wp real ( wp ), parameter :: b1710 = 0.0759292995578913560162301311785251873561801342333194895292058_wp real ( wp ), parameter :: b1711 = - 1 2.3729973380186513287414553402595806591349822617535905976253_wp real ( wp ), parameter :: b1712 = 9.85455883464769543935957209317369202080367765721777101906955_wp real ( wp ), parameter :: b1713 = 0.0859111431370436529579357709052367772889980495122329601159540_wp real ( wp ), parameter :: b1714 = - 5.65242752862643921117182090081762761180392602644189218673969_wp real ( wp ), parameter :: b1715 = - 1.94300935242819610883833776782364287728724899124166920477873_wp real ( wp ), parameter :: b1716 = - 0.128352601849404542018428714319344620742146491335612353559923_wp real ( wp ), parameter :: b180 = 1.38360054432196014878538118298167716825163268489922519995564_wp real ( wp ), parameter :: b181 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b182 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b183 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b184 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b185 = 0.00499528226645532360197793408420692800405891149406814091955810_wp real ( wp ), parameter :: b186 = 0.397918238819828997341739603001347156083435060931424970826304_wp real ( wp ), parameter :: b187 = 0.427930210752576611068192608300897981558240730580396406312359_wp real ( wp ), parameter :: b188 = - 1.30299107424475770916551439123047573342071475998399645982146_wp real ( wp ), parameter :: b189 = 0.661292278669377029097112528107513072734573412294008071500699_wp real ( wp ), parameter :: b1810 = - 0.144559774306954349765969393688703463900585822441545655530145_wp real ( wp ), parameter :: b1811 = - 6.96576034731798203467853867461083919356792248105919255460819_wp real ( wp ), parameter :: b1812 = 6.65808543235991748353408295542210450632193197576935120716437_wp real ( wp ), parameter :: b1813 = - 1.66997375108841486404695805725510845049807969199236227575796_wp real ( wp ), parameter :: b1814 = 2.06413702318035263832289040301832647130604651223986452170089_wp real ( wp ), parameter :: b1815 = - 0.674743962644306471862958129570837723192079875998405058648892_wp real ( wp ), parameter :: b1816 = - 0.00115618834794939500490703608435907610059605754935305582045729_wp real ( wp ), parameter :: b1817 = - 0.00544057908677007389319819914241631024660726585015012485938593_wp real ( wp ), parameter :: b190 = 0.951236297048287669474637975894973552166903378983475425758226_wp real ( wp ), parameter :: b191 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b192 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b193 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b194 = 0.217050632197958486317846256953159942875916353757734167684657_wp real ( wp ), parameter :: b195 = 0.0137455792075966759812907801835048190594443990939408530842918_wp real ( wp ), parameter :: b196 = - 0.0661095317267682844455831341498149531672668252085016565917546_wp real ( wp ), parameter :: b197 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b198 = 0.152281696736414447136604697040747131921486432699422112099617_wp real ( wp ), parameter :: b199 = - 0.337741018357599840802300793133998004354643424457539667670080_wp real ( wp ), parameter :: b1910 = - 0.0192825981633995781534949199286824400469353110630787982121133_wp real ( wp ), parameter :: b1911 = - 3.68259269696866809932409015535499603576312120746888880201882_wp real ( wp ), parameter :: b1912 = 3.16197870406982063541533528419683854018352080342887002331312_wp real ( wp ), parameter :: b1913 = - 0.370462522106885290716991856022051125477943482284080569177386_wp real ( wp ), parameter :: b1914 = - 0.0514974200365440434996434456698127984941168616474316871020314_wp real ( wp ), parameter :: b1915 = - 0.000829625532120152946787043541792848416659382675202720677536554_wp real ( wp ), parameter :: b1916 = 0.00000279801041419278598986586589070027583961355402640879503213503_wp real ( wp ), parameter :: b1917 = 0.0418603916412360287969841020776788461794119440689356178942252_wp real ( wp ), parameter :: b1918 = 0.279084255090877355915660874555379649966282167560126269290222_wp real ( wp ), parameter :: b200 = 0.103364471650010477570395435690481791543342708330349879244197_wp real ( wp ), parameter :: b201 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b202 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b203 = 0.124053094528946761061581889237115328211074784955180298044074_wp real ( wp ), parameter :: b204 = 0.483171167561032899288836480451962508724109257517289177302380_wp real ( wp ), parameter :: b205 = - 0.0387530245694763252085681443767620580395733302341368038804290_wp real ( wp ), parameter :: b206 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b207 = - 0.438313820361122420391059788940960176420682836652600698580091_wp real ( wp ), parameter :: b208 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b209 = - 0.218636633721676647685111485017151199362509373698288330593486_wp real ( wp ), parameter :: b2010 = - 0.0312334764394719229981634995206440349766174759626578122323015_wp real ( wp ), parameter :: b2011 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2012 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2013 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2014 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2015 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2016 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2017 = 0.0312334764394719229981634995206440349766174759626578122323015_wp real ( wp ), parameter :: b2018 = 0.218636633721676647685111485017151199362509373698288330593486_wp real ( wp ), parameter :: b2019 = 0.438313820361122420391059788940960176420682836652600698580091_wp real ( wp ), parameter :: b210 = 0.193333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b211 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b212 = 0.220000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b213 = - 0.0800000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b214 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b215 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b216 = 0.0984256130499315928152900286856048243348202521491288575952143_wp real ( wp ), parameter :: b217 = - 0.196410889223054653446526504390100417677539095340135532418849_wp real ( wp ), parameter :: b218 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b219 = 0.436457930493068729391826122587949137609670676712525034763317_wp real ( wp ), parameter :: b2110 = 0.0652613721675721098560370939805555698350543810708414716730270_wp real ( wp ), parameter :: b2111 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2112 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2113 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2114 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2115 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2116 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2117 = - 0.0652613721675721098560370939805555698350543810708414716730270_wp real ( wp ), parameter :: b2118 = - 0.436457930493068729391826122587949137609670676712525034763317_wp real ( wp ), parameter :: b2119 = 0.196410889223054653446526504390100417677539095340135532418849_wp real ( wp ), parameter :: b2120 = - 0.0984256130499315928152900286856048243348202521491288575952143_wp real ( wp ), parameter :: b220 = - 0.216049382716049382716049382716049382716049382716049382716049_wp real ( wp ), parameter :: b221 = 0.771604938271604938271604938271604938271604938271604938271605_wp real ( wp ), parameter :: b222 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b223 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b224 = - 0.666666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: b225 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b226 = - 0.390696469295978451446999802258495981249099665294395945559163_wp real ( wp ), parameter :: b227 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b228 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b229 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2210 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2211 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2212 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2213 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2214 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2215 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2216 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2217 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2218 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2219 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2220 = 0.390696469295978451446999802258495981249099665294395945559163_wp real ( wp ), parameter :: b2221 = 0.666666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: b230 = 0.200000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b231 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b232 = - 0.164609053497942386831275720164609053497942386831275720164609_wp real ( wp ), parameter :: b233 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b234 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b235 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b236 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b237 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b238 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b239 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2310 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2311 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2312 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2313 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2314 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2315 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2316 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2317 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2318 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2319 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2320 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2321 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b2322 = 0.164609053497942386831275720164609053497942386831275720164609_wp real ( wp ), parameter :: b240 = 1.47178724881110408452949550989023611293535315518571691939396_wp real ( wp ), parameter :: b241 = 0.787500000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b242 = 0.421296296296296296296296296296296296296296296296296296296296_wp real ( wp ), parameter :: b243 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b244 = 0.291666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: b245 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b246 = 0.348600717628329563206854421629657569274689947367847465753757_wp real ( wp ), parameter :: b247 = 0.229499544768994849582890233710555447073823569666506700662510_wp real ( wp ), parameter :: b248 = 5.79046485790481979159831978177003471098279506036722411333192_wp real ( wp ), parameter :: b249 = 0.418587511856506868874073759426596207226461447604248151080016_wp real ( wp ), parameter :: b2410 = 0.307039880222474002649653817490106690389251482313213999386651_wp real ( wp ), parameter :: b2411 = - 4.68700905350603332214256344683853248065574415794742040470287_wp real ( wp ), parameter :: b2412 = 3.13571665593802262152038152399873856554395436199962915429076_wp real ( wp ), parameter :: b2413 = 1.40134829710965720817510506275620441055845017313930508348898_wp real ( wp ), parameter :: b2414 = - 5.52931101439499023629010306005764336421276055777658156400910_wp real ( wp ), parameter :: b2415 = - 0.853138235508063349309546894974784906188927508039552519557498_wp real ( wp ), parameter :: b2416 = 0.103575780373610140411804607167772795518293914458500175573749_wp real ( wp ), parameter :: b2417 = - 0.140474416950600941142546901202132534870665923700034957196546_wp real ( wp ), parameter :: b2418 = - 0.418587511856506868874073759426596207226461447604248151080016_wp real ( wp ), parameter :: b2419 = - 0.229499544768994849582890233710555447073823569666506700662510_wp real ( wp ), parameter :: b2420 = - 0.348600717628329563206854421629657569274689947367847465753757_wp real ( wp ), parameter :: b2421 = - 0.291666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: b2422 = - 0.421296296296296296296296296296296296296296296296296296296296_wp real ( wp ), parameter :: b2423 = - 0.787500000000000000000000000000000000000000000000000000000000_wp real ( wp ), dimension ( me % n ) :: f0 , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 , f10 , f11 , f12 ,& f13 , f14 , f15 , f16 , f17 , f18 , f19 , f20 , f21 , f22 , f23 , f24 if ( h == zero ) then xf = x terr = zero return end if call me % f ( t + a0 * h , x , f0 ) call me % f ( t + a1 * h , x + h * ( b10 * f0 ), f1 ) call me % f ( t + a2 * h , x + h * ( b20 * f0 + b21 * f1 ), f2 ) call me % f ( t + a3 * h , x + h * ( b30 * f0 + b31 * f1 + b32 * f2 ), f3 ) call me % f ( t + a4 * h , x + h * ( b40 * f0 + b41 * f1 + b42 * f2 + b43 * f3 ), f4 ) call me % f ( t + a5 * h , x + h * ( b50 * f0 + b51 * f1 + b52 * f2 + b53 * f3 + & b54 * f4 ), f5 ) call me % f ( t + a6 * h , x + h * ( b60 * f0 + b61 * f1 + b62 * f2 + b63 * f3 + & b64 * f4 + b65 * f5 ), f6 ) call me % f ( t + a7 * h , x + h * ( b70 * f0 + b71 * f1 + b72 * f2 + b73 * f3 + & b74 * f4 + b75 * f5 + b76 * f6 ), f7 ) call me % f ( t + a8 * h , x + h * ( b80 * f0 + b81 * f1 + b82 * f2 + b83 * f3 + & b84 * f4 + b85 * f5 + b86 * f6 + b87 * f7 ), f8 ) call me % f ( t + a9 * h , x + h * ( b90 * f0 + b91 * f1 + b92 * f2 + b93 * f3 + & b94 * f4 + b95 * f5 + b96 * f6 + b97 * f7 + & b98 * f8 ), f9 ) call me % f ( t + a10 * h , x + h * ( b100 * f0 + b101 * f1 + b102 * f2 + b103 * f3 + & b104 * f4 + b105 * f5 + b106 * f6 + b107 * f7 + & b108 * f8 + b109 * f9 ), f10 ) call me % f ( t + a11 * h , x + h * ( b110 * f0 + b111 * f1 + b112 * f2 + b113 * f3 + & b114 * f4 + b115 * f5 + b116 * f6 + b117 * f7 + & b118 * f8 + b119 * f9 + b1110 * f10 ), f11 ) call me % f ( t + a12 * h , x + h * ( b120 * f0 + b121 * f1 + b122 * f2 + b123 * f3 + & b124 * f4 + b125 * f5 + b126 * f6 + b127 * f7 + & b128 * f8 + b129 * f9 + b1210 * f10 + b1211 * f11 ), f12 ) call me % f ( t + a13 * h , x + h * ( b130 * f0 + b131 * f1 + b132 * f2 + b133 * f3 + & b134 * f4 + b135 * f5 + b136 * f6 + b137 * f7 + & b138 * f8 + b139 * f9 + b1310 * f10 + b1311 * f11 + & b1312 * f12 ), f13 ) call me % f ( t + a14 * h , x + h * ( b140 * f0 + b141 * f1 + b142 * f2 + b143 * f3 + & b144 * f4 + b145 * f5 + b146 * f6 + b147 * f7 + & b148 * f8 + b149 * f9 + b1410 * f10 + b1411 * f11 + & b1412 * f12 + b1413 * f13 ), f14 ) call me % f ( t + a15 * h , x + h * ( b150 * f0 + b151 * f1 + b152 * f2 + b153 * f3 + & b154 * f4 + b155 * f5 + b156 * f6 + b157 * f7 + & b158 * f8 + b159 * f9 + b1510 * f10 + b1511 * f11 + & b1512 * f12 + b1513 * f13 + b1514 * f14 ), f15 ) call me % f ( t + a16 * h , x + h * ( b160 * f0 + b161 * f1 + b162 * f2 + b163 * f3 + & b164 * f4 + b165 * f5 + b166 * f6 + b167 * f7 + & b168 * f8 + b169 * f9 + b1610 * f10 + b1611 * f11 + & b1612 * f12 + b1613 * f13 + b1614 * f14 + b1615 * f15 ), f16 ) call me % f ( t + a17 * h , x + h * ( b170 * f0 + b171 * f1 + b172 * f2 + b173 * f3 + & b174 * f4 + b175 * f5 + b176 * f6 + b177 * f7 + & b178 * f8 + b179 * f9 + b1710 * f10 + b1711 * f11 + & b1712 * f12 + b1713 * f13 + b1714 * f14 + b1715 * f15 + & b1716 * f16 ), f17 ) call me % f ( t + a18 * h , x + h * ( b180 * f0 + b181 * f1 + b182 * f2 + b183 * f3 + & b184 * f4 + b185 * f5 + b186 * f6 + b187 * f7 + & b188 * f8 + b189 * f9 + b1810 * f10 + b1811 * f11 + & b1812 * f12 + b1813 * f13 + b1814 * f14 + b1815 * f15 + & b1816 * f16 + b1817 * f17 ), f18 ) call me % f ( t + a19 * h , x + h * ( b190 * f0 + b191 * f1 + b192 * f2 + b193 * f3 + & b194 * f4 + b195 * f5 + b196 * f6 + b197 * f7 + & b198 * f8 + b199 * f9 + b1910 * f10 + b1911 * f11 + & b1912 * f12 + b1913 * f13 + b1914 * f14 + b1915 * f15 + & b1916 * f16 + b1917 * f17 + b1918 * f18 ), f19 ) call me % f ( t + a20 * h , x + h * ( b200 * f0 + b201 * f1 + b202 * f2 + b203 * f3 + & b204 * f4 + b205 * f5 + b206 * f6 + b207 * f7 + & b208 * f8 + b209 * f9 + b2010 * f10 + b2011 * f11 + & b2012 * f12 + b2013 * f13 + b2014 * f14 + b2015 * f15 + & b2016 * f16 + b2017 * f17 + b2018 * f18 + b2019 * f19 ), f20 ) call me % f ( t + a21 * h , x + h * ( b210 * f0 + b211 * f1 + b212 * f2 + b213 * f3 + & b214 * f4 + b215 * f5 + b216 * f6 + b217 * f7 + & b218 * f8 + b219 * f9 + b2110 * f10 + b2111 * f11 + & b2112 * f12 + b2113 * f13 + b2114 * f14 + b2115 * f15 + & b2116 * f16 + b2117 * f17 + b2118 * f18 + b2119 * f19 + & b2120 * f20 ), f21 ) call me % f ( t + a22 * h , x + h * ( b220 * f0 + b221 * f1 + b222 * f2 + b223 * f3 + & b224 * f4 + b225 * f5 + b226 * f6 + b227 * f7 + & b228 * f8 + b229 * f9 + b2210 * f10 + b2211 * f11 + & b2212 * f12 + b2213 * f13 + b2214 * f14 + b2215 * f15 + & b2216 * f16 + b2217 * f17 + b2218 * f18 + b2219 * f19 + & b2220 * f20 + b2221 * f21 ), f22 ) call me % f ( t + a23 * h , x + h * ( b230 * f0 + b231 * f1 + b232 * f2 + b233 * f3 + & b234 * f4 + b235 * f5 + b236 * f6 + b237 * f7 + & b238 * f8 + b239 * f9 + b2310 * f10 + b2311 * f11 + & b2312 * f12 + b2313 * f13 + b2314 * f14 + b2315 * f15 + & b2316 * f16 + b2317 * f17 + b2318 * f18 + b2319 * f19 + & b2320 * f20 + b2321 * f21 + b2322 * f22 ), f23 ) call me % f ( t + a24 * h , x + h * ( b240 * f0 + b241 * f1 + b242 * f2 + b243 * f3 + & b244 * f4 + b245 * f5 + b246 * f6 + b247 * f7 + & b248 * f8 + b249 * f9 + b2410 * f10 + b2411 * f11 + & b2412 * f12 + b2413 * f13 + b2414 * f14 + b2415 * f15 + & b2416 * f16 + b2417 * f17 + b2418 * f18 + b2419 * f19 + & b2420 * f20 + b2421 * f21 + b2422 * f22 + b2423 * f23 ), f24 ) xf = x + h * ( c0 * f0 + & c1 * f1 + & c2 * f2 + & c3 * f3 + & c4 * f4 + & c5 * f5 + & c6 * f6 + & c7 * f7 + & c8 * f8 + & c9 * f9 + & c10 * f10 + & c11 * f11 + & c12 * f12 + & c13 * f13 + & c14 * f14 + & c15 * f15 + & c16 * f16 + & c17 * f17 + & c18 * f18 + & c19 * f19 + & c20 * f20 + & c21 * f21 + & c22 * f22 + & c23 * f23 + & c24 * f24 ) terr = ( 4 9.0_wp / 64 0.0_wp ) * h * ( f1 - f23 ) end subroutine rkf1210 !***************************************************************************************** !***************************************************************************************** !> !  Feagin's RK14(12) - a 14th-order method with an embedded 12th-order method. ! !### Reference !  * [coefficient file](http://sce.uhcl.edu/rungekutta/rk1412.txt) subroutine rkf1412 ( me , t , x , h , xf , terr ) implicit none class ( rkf1412_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t !! initial time real ( wp ), dimension ( me % n ), intent ( in ) :: x !! initial state real ( wp ), intent ( in ) :: h !! time step real ( wp ), dimension ( me % n ), intent ( out ) :: xf !! state at time `t+h` real ( wp ), dimension ( me % n ), intent ( out ) :: terr !! truncation error estimate real ( wp ), parameter :: a0 = 0.000000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a1 = 0.111111111111111111111111111111111111111111111111111111111111_wp real ( wp ), parameter :: a2 = 0.555555555555555555555555555555555555555555555555555555555556_wp real ( wp ), parameter :: a3 = 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a4 = 0.333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a5 = 1.00000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a6 = 0.669986979272772921764683785505998513938845229638460353285142_wp real ( wp ), parameter :: a7 = 0.297068384213818357389584716808219413223332094698915687379168_wp real ( wp ), parameter :: a8 = 0.727272727272727272727272727272727272727272727272727272727273_wp real ( wp ), parameter :: a9 = 0.140152799042188765276187487966946717629806463082532936287323_wp real ( wp ), parameter :: a10 = 0.700701039770150737151099854830749337941407049265546408969222_wp real ( wp ), parameter :: a11 = 0.363636363636363636363636363636363636363636363636363636363636_wp real ( wp ), parameter :: a12 = 0.263157894736842105263157894736842105263157894736842105263158_wp real ( wp ), parameter :: a13 = 0.0392172246650270859125196642501208648863714315266128052078483_wp real ( wp ), parameter :: a14 = 0.812917502928376762983393159278036506189612372617238550774312_wp real ( wp ), parameter :: a15 = 0.166666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: a16 = 0.900000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: a17 = 0.0641299257451966923312771193896682809481096651615083225402924_wp real ( wp ), parameter :: a18 = 0.204149909283428848927744634301023405027149505241333751628870_wp real ( wp ), parameter :: a19 = 0.395350391048760565615671369827324372352227297456659450554577_wp real ( wp ), parameter :: a20 = 0.604649608951239434384328630172675627647772702543340549445423_wp real ( wp ), parameter :: a21 = 0.795850090716571151072255365698976594972850494758666248371130_wp real ( wp ), parameter :: a22 = 0.935870074254803307668722880610331719051890334838491677459708_wp real ( wp ), parameter :: a23 = 0.166666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: a24 = 0.812917502928376762983393159278036506189612372617238550774312_wp real ( wp ), parameter :: a25 = 0.0392172246650270859125196642501208648863714315266128052078483_wp real ( wp ), parameter :: a26 = 0.363636363636363636363636363636363636363636363636363636363636_wp real ( wp ), parameter :: a27 = 0.700701039770150737151099854830749337941407049265546408969222_wp real ( wp ), parameter :: a28 = 0.140152799042188765276187487966946717629806463082532936287323_wp real ( wp ), parameter :: a29 = 0.297068384213818357389584716808219413223332094698915687379168_wp real ( wp ), parameter :: a30 = 0.669986979272772921764683785505998513938845229638460353285142_wp real ( wp ), parameter :: a31 = 0.333333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: a32 = 0.555555555555555555555555555555555555555555555555555555555556_wp real ( wp ), parameter :: a33 = 0.111111111111111111111111111111111111111111111111111111111111_wp real ( wp ), parameter :: a34 = 1.00000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c0 = 0.0178571428571428571428571428571428571428571428571428571428571_wp real ( wp ), parameter :: c1 = 0.00585937500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c2 = 0.0117187500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c3 = 0.0_wp real ( wp ), parameter :: c4 = 0.0175781250000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c5 = 0.0_wp real ( wp ), parameter :: c6 = 0.0234375000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c7 = 0.0292968750000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c8 = 0.0_wp real ( wp ), parameter :: c9 = 0.0351562500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c10 = 0.0410156250000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c11 = 0.0468750000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c12 = 0.0_wp real ( wp ), parameter :: c13 = 0.0527343750000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c14 = 0.0585937500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c15 = 0.0644531250000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c16 = 0.0_wp real ( wp ), parameter :: c17 = 0.105352113571753019691496032887878162227673083080523884041670_wp real ( wp ), parameter :: c18 = 0.170561346241752182382120338553874085887555487802790804737501_wp real ( wp ), parameter :: c19 = 0.206229397329351940783526485701104894741914286259542454077972_wp real ( wp ), parameter :: c20 = 0.206229397329351940783526485701104894741914286259542454077972_wp real ( wp ), parameter :: c21 = 0.170561346241752182382120338553874085887555487802790804737501_wp real ( wp ), parameter :: c22 = 0.105352113571753019691496032887878162227673083080523884041670_wp real ( wp ), parameter :: c23 = - 0.0644531250000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c24 = - 0.0585937500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c25 = - 0.0527343750000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c26 = - 0.0468750000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c27 = - 0.0410156250000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c28 = - 0.0351562500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c29 = - 0.0292968750000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c30 = - 0.0234375000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c31 = - 0.0175781250000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c32 = - 0.0117187500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c33 = - 0.00585937500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: c34 = 0.0178571428571428571428571428571428571428571428571428571428571_wp real ( wp ), parameter :: b10 = 0.111111111111111111111111111111111111111111111111111111111111_wp real ( wp ), parameter :: b20 = - 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b21 = 1.38888888888888888888888888888888888888888888888888888888889_wp real ( wp ), parameter :: b30 = 0.208333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b31 = 0.0_wp real ( wp ), parameter :: b32 = 0.625000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b40 = 0.193333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b41 = 0.0_wp real ( wp ), parameter :: b42 = 0.220000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b43 = - 0.0800000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b50 = 0.100000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b51 = 0.0_wp real ( wp ), parameter :: b52 = 0.0_wp real ( wp ), parameter :: b53 = 0.400000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b54 = 0.500000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b60 = 0.103484561636679776672993546511910344499744798201971316606663_wp real ( wp ), parameter :: b61 = 0.0_wp real ( wp ), parameter :: b62 = 0.0_wp real ( wp ), parameter :: b63 = 0.122068887306407222589644082868962077139592714834162134741275_wp real ( wp ), parameter :: b64 = 0.482574490331246622475134780125688112865919023850168049679402_wp real ( wp ), parameter :: b65 = - 0.0381409600015606999730886240005620205664113072478411477421970_wp real ( wp ), parameter :: b70 = 0.124380526654094412881516420868799316268491466359671423163289_wp real ( wp ), parameter :: b71 = 0.0_wp real ( wp ), parameter :: b72 = 0.0_wp real ( wp ), parameter :: b73 = 0.0_wp real ( wp ), parameter :: b74 = 0.226120282197584301422238662979202901196752320742633143965145_wp real ( wp ), parameter :: b75 = 0.0137885887618080880607695837016477814530969417491493385363543_wp real ( wp ), parameter :: b76 = - 0.0672210133996684449749399507414305856950086341525382182856200_wp real ( wp ), parameter :: b80 = 0.0936919065659673815530885456083005933866349695217750085655603_wp real ( wp ), parameter :: b81 = 0.0_wp real ( wp ), parameter :: b82 = 0.0_wp real ( wp ), parameter :: b83 = 0.0_wp real ( wp ), parameter :: b84 = 0.0_wp real ( wp ), parameter :: b85 = - 0.00613406843450510987229498995641664735620914507128858871007099_wp real ( wp ), parameter :: b86 = 0.216019825625503063708860097659866573490979433278117320188668_wp real ( wp ), parameter :: b87 = 0.423695063515761937337619073960976753205867469544123532683116_wp real ( wp ), parameter :: b90 = 0.0838479812409052664616968791372814085980533139224911131069335_wp real ( wp ), parameter :: b91 = 0.0_wp real ( wp ), parameter :: b92 = 0.0_wp real ( wp ), parameter :: b93 = 0.0_wp real ( wp ), parameter :: b94 = 0.0_wp real ( wp ), parameter :: b95 = - 0.0117949367100973814319755056031295775367961960590736150777613_wp real ( wp ), parameter :: b96 = - 0.247299020568812652339473838743194598325992840353340132697498_wp real ( wp ), parameter :: b97 = 0.0978080858367729012259313014081291665503740655476733940756599_wp real ( wp ), parameter :: b98 = 0.217590689243420631360008651767860318344168120024782176879989_wp real ( wp ), parameter :: b100 = 0.0615255359769428227954562389614314714333423969064821107453940_wp real ( wp ), parameter :: b101 = 0.0_wp real ( wp ), parameter :: b102 = 0.0_wp real ( wp ), parameter :: b103 = 0.0_wp real ( wp ), parameter :: b104 = 0.0_wp real ( wp ), parameter :: b105 = 0.00592232780324503308042990005798046524738389560444257136834990_wp real ( wp ), parameter :: b106 = 0.470326159963841112217224303205894113455362530746108825010848_wp real ( wp ), parameter :: b107 = 0.299688863848679000853981837096192399136831121671781279184194_wp real ( wp ), parameter :: b108 = - 0.247656877593994914689992276329810825853958069263947095548189_wp real ( wp ), parameter :: b109 = 0.110895029771437682893999851839061714522445173600678718208625_wp real ( wp ), parameter :: b110 = 0.0419700073362782579861792864787277787213483656543104611245994_wp real ( wp ), parameter :: b111 = 0.0_wp real ( wp ), parameter :: b112 = 0.0_wp real ( wp ), parameter :: b113 = 0.0_wp real ( wp ), parameter :: b114 = 0.0_wp real ( wp ), parameter :: b115 = - 0.00317987696266205093901912847692712407988609169703103952205634_wp real ( wp ), parameter :: b116 = 0.806397714906192077260821711520379506393543111567419750119748_wp real ( wp ), parameter :: b117 = 0.0975983126412388979093522850684288851314672048003054550357187_wp real ( wp ), parameter :: b118 = 0.778575578158398909027512446452927238999763460594181964958853_wp real ( wp ), parameter :: b119 = 0.204890423831599428189499202098105603312029235081420653574829_wp real ( wp ), parameter :: b1110 = - 1.56261579627468188307070943950527825211462892236424360892806_wp real ( wp ), parameter :: b120 = 0.0437726782233730163574465242495339811688214967071614123256973_wp real ( wp ), parameter :: b121 = 0.0_wp real ( wp ), parameter :: b122 = 0.0_wp real ( wp ), parameter :: b123 = 0.0_wp real ( wp ), parameter :: b124 = 0.0_wp real ( wp ), parameter :: b125 = 0.0_wp real ( wp ), parameter :: b126 = 0.0_wp real ( wp ), parameter :: b127 = 0.0_wp real ( wp ), parameter :: b128 = 0.00624365027520195208794358628580933625281631216903095917201250_wp real ( wp ), parameter :: b129 = 0.200043097109577314994435165469647856829066232218264969608768_wp real ( wp ), parameter :: b1210 = - 0.00805328367804983036823857162048902911923392887337029314844206_wp real ( wp ), parameter :: b1211 = 0.0211517528067396521915711903523399601316877825157550573051221_wp real ( wp ), parameter :: b130 = 0.0283499250363514563095023591920717312247137654896477097768495_wp real ( wp ), parameter :: b131 = 0.0_wp real ( wp ), parameter :: b132 = 0.0_wp real ( wp ), parameter :: b133 = 0.0_wp real ( wp ), parameter :: b134 = 0.0_wp real ( wp ), parameter :: b135 = 0.0_wp real ( wp ), parameter :: b136 = 0.0_wp real ( wp ), parameter :: b137 = 0.0_wp real ( wp ), parameter :: b138 = 0.00249163204855817407538949148805995149459884653585417680098222_wp real ( wp ), parameter :: b139 = 0.0230138787854593149638399846373742768772087122638142234223658_wp real ( wp ), parameter :: b1310 = - 0.00322155956692977098724476092467120878189463604760620461043308_wp real ( wp ), parameter :: b1311 = 0.00988442549447664668946335414487885256040819982786014648129297_wp real ( wp ), parameter :: b1312 = - 0.0213010771328887351384307642875927384886634565429572466632092_wp real ( wp ), parameter :: b140 = 0.343511894290243001049432234735147943083353174980701426268122_wp real ( wp ), parameter :: b141 = 0.0_wp real ( wp ), parameter :: b142 = 0.0_wp real ( wp ), parameter :: b143 = 0.0_wp real ( wp ), parameter :: b144 = 0.0_wp real ( wp ), parameter :: b145 = 0.0_wp real ( wp ), parameter :: b146 = 0.0_wp real ( wp ), parameter :: b147 = 0.0_wp real ( wp ), parameter :: b148 = 0.210451912023627385609097011999010655788807405225626700040882_wp real ( wp ), parameter :: b149 = 1.03427452057230411936482926828825709938667999698324740166559_wp real ( wp ), parameter :: b1410 = 0.00600303645864422487051240448206640574939078092406156945568306_wp real ( wp ), parameter :: b1411 = 0.855938125099619537578012106002407728915062652616416005816477_wp real ( wp ), parameter :: b1412 = - 0.977235005036766810872264852372525633013107656892839677696022_wp real ( wp ), parameter :: b1413 = - 0.660026980479294694616225013856327693720573981219974874776419_wp real ( wp ), parameter :: b150 = - 0.0143574001672168069538206399935076366657755954378399880691949_wp real ( wp ), parameter :: b151 = 0.0_wp real ( wp ), parameter :: b152 = 0.0_wp real ( wp ), parameter :: b153 = 0.0_wp real ( wp ), parameter :: b154 = 0.0_wp real ( wp ), parameter :: b155 = 0.0_wp real ( wp ), parameter :: b156 = 0.0_wp real ( wp ), parameter :: b157 = 0.0_wp real ( wp ), parameter :: b158 = - 0.0366253270049039970293685796848974791733119081733552207318285_wp real ( wp ), parameter :: b159 = 0.0350254975636213681976849406979846524346789082471103574920148_wp real ( wp ), parameter :: b1510 = 0.0360946016362113508931786658758335239823689929864237671348749_wp real ( wp ), parameter :: b1511 = - 0.0265219967553681106351595946834601923649627012457464284442911_wp real ( wp ), parameter :: b1512 = 0.0445699011305698119638911537508839908104336323082226770910408_wp real ( wp ), parameter :: b1513 = 0.124343093331358243286225595741786448038973408895106741855721_wp real ( wp ), parameter :: b1514 = 0.00413829693239480694403512496204335960426192908674476033832967_wp real ( wp ), parameter :: b160 = 0.356032404425120290975609116398089176264106222379748802654822_wp real ( wp ), parameter :: b161 = 0.0_wp real ( wp ), parameter :: b162 = 0.0_wp real ( wp ), parameter :: b163 = 0.0_wp real ( wp ), parameter :: b164 = 0.0_wp real ( wp ), parameter :: b165 = 0.0_wp real ( wp ), parameter :: b166 = 0.0_wp real ( wp ), parameter :: b167 = 0.0_wp real ( wp ), parameter :: b168 = - 0.450192758947562595966821779075956175110645100214763601190349_wp real ( wp ), parameter :: b169 = 0.430527907083710898626656292808782917793030154094709462877146_wp real ( wp ), parameter :: b1610 = 0.511973029011022237668556960394071692077125787030651386389972_wp real ( wp ), parameter :: b1611 = 0.908303638886404260390159124638110213997496214819904630546596_wp real ( wp ), parameter :: b1612 = - 1.23921093371933931757372469151534028854413889248605726186520_wp real ( wp ), parameter :: b1613 = - 0.649048661671761465141672348879062553905402831967191097656668_wp real ( wp ), parameter :: b1614 = 0.251708904586819292210480529948970541404887852931447491219418_wp real ( wp ), parameter :: b1615 = 0.779906470345586398810756795282334476023540593411550187024263_wp real ( wp ), parameter :: b170 = 0.0130935687406513066406881206418834980127470438213192487844956_wp real ( wp ), parameter :: b171 = 0.0_wp real ( wp ), parameter :: b172 = 0.0_wp real ( wp ), parameter :: b173 = 0.0_wp real ( wp ), parameter :: b174 = 0.0_wp real ( wp ), parameter :: b175 = 0.0_wp real ( wp ), parameter :: b176 = 0.0_wp real ( wp ), parameter :: b177 = 0.0_wp real ( wp ), parameter :: b178 = 0.0_wp real ( wp ), parameter :: b179 = 0.0_wp real ( wp ), parameter :: b1710 = 0.0_wp real ( wp ), parameter :: b1711 = 0.0_wp real ( wp ), parameter :: b1712 = - 0.0000932053067985113945908461962767108237858631509684667142124826_wp real ( wp ), parameter :: b1713 = 0.0505374334262299359640090443138590726770942344716122381702746_wp real ( wp ), parameter :: b1714 = 8.04470341944487979109579109610197797641311868930865361048975e-7_wp real ( wp ), parameter :: b1715 = 0.000591726029494171190528755742777717259844340971924321528178248_wp real ( wp ), parameter :: b1716 = - 4.01614722154557337064691684906375587732264247950093804676867e-7_wp real ( wp ), parameter :: b180 = 0.0207926484466053012541944544000765652167255206144373407979758_wp real ( wp ), parameter :: b181 = 0.0_wp real ( wp ), parameter :: b182 = 0.0_wp real ( wp ), parameter :: b183 = 0.0_wp real ( wp ), parameter :: b184 = 0.0_wp real ( wp ), parameter :: b185 = 0.0_wp real ( wp ), parameter :: b186 = 0.0_wp real ( wp ), parameter :: b187 = 0.0_wp real ( wp ), parameter :: b188 = 0.0_wp real ( wp ), parameter :: b189 = 0.0_wp real ( wp ), parameter :: b1810 = 0.0_wp real ( wp ), parameter :: b1811 = 0.0_wp real ( wp ), parameter :: b1812 = 0.000582695918800085915101902697837284108951406103029871570103075_wp real ( wp ), parameter :: b1813 = - 0.00801700732358815939083342186525852746640558465919633524655451_wp real ( wp ), parameter :: b1814 = 4.03847643847136940375170821743560570484117290330895506618968e-6_wp real ( wp ), parameter :: b1815 = 0.0854609998055506144225056114567535602510114622033622491802597_wp real ( wp ), parameter :: b1816 = - 2.04486480935804242706707569691004307904442837552677456232848e-6_wp real ( wp ), parameter :: b1817 = 0.105328578824431893399799402979093997354240904235172843146582_wp real ( wp ), parameter :: b190 = 1.40153449795736021415446247355771306718486452917597731683689_wp real ( wp ), parameter :: b191 = 0.0_wp real ( wp ), parameter :: b192 = 0.0_wp real ( wp ), parameter :: b193 = 0.0_wp real ( wp ), parameter :: b194 = 0.0_wp real ( wp ), parameter :: b195 = 0.0_wp real ( wp ), parameter :: b196 = 0.0_wp real ( wp ), parameter :: b197 = 0.0_wp real ( wp ), parameter :: b198 = 0.0_wp real ( wp ), parameter :: b199 = 0.0_wp real ( wp ), parameter :: b1910 = 0.0_wp real ( wp ), parameter :: b1911 = 0.0_wp real ( wp ), parameter :: b1912 = - 0.230252000984221261616272410367415621261130298274455611733277_wp real ( wp ), parameter :: b1913 = - 7.21106840466912905659582237106874247165856493509961561958267_wp real ( wp ), parameter :: b1914 = 0.00372901560694836335236995327852132340217759566678662385552634_wp real ( wp ), parameter :: b1915 = - 4.71415495727125020678778179392224757011323373221820091641216_wp real ( wp ), parameter :: b1916 = - 0.00176367657545349242053841995032797673574903886695600132759652_wp real ( wp ), parameter :: b1917 = 7.64130548038698765563029310880237651185173367813936997648198_wp real ( wp ), parameter :: b1918 = 3.50602043659751834989896082949744710968212949893375368243588_wp real ( wp ), parameter :: b200 = 1 1.9514650694120686799372385830716401674473610826553517297976_wp real ( wp ), parameter :: b201 = 0.0_wp real ( wp ), parameter :: b202 = 0.0_wp real ( wp ), parameter :: b203 = 0.0_wp real ( wp ), parameter :: b204 = 0.0_wp real ( wp ), parameter :: b205 = 0.0_wp real ( wp ), parameter :: b206 = 0.0_wp real ( wp ), parameter :: b207 = 0.0_wp real ( wp ), parameter :: b208 = 0.0_wp real ( wp ), parameter :: b209 = 0.0_wp real ( wp ), parameter :: b2010 = 0.0_wp real ( wp ), parameter :: b2011 = 0.0_wp real ( wp ), parameter :: b2012 = 7.79480932108175968783516700231764388220284279598980948538579_wp real ( wp ), parameter :: b2013 = - 5 6.4501393867325792523560991120904281440468100061340556540132_wp real ( wp ), parameter :: b2014 = 0.0912376306930644901344530449290276645709607450403673704844997_wp real ( wp ), parameter :: b2015 = - 1 2.7336279925434886201945524309199275038162717529918963305155_wp real ( wp ), parameter :: b2016 = - 0.0396895921904719712313542810939736674712383070433147873009352_wp real ( wp ), parameter :: b2017 = 5 4.4392141883570886996225765155307791861438378423305337073797_wp real ( wp ), parameter :: b2018 = - 3.64411637921569236846406990361350645806721478409266709351203_wp real ( wp ), parameter :: b2019 = - 0.804503249910509910899030787958579499315694913210787878260459_wp real ( wp ), parameter :: b210 = - 14 8.809426507100488427838868268647625561930612082148597076690_wp real ( wp ), parameter :: b211 = 0.0_wp real ( wp ), parameter :: b212 = 0.0_wp real ( wp ), parameter :: b213 = 0.0_wp real ( wp ), parameter :: b214 = 0.0_wp real ( wp ), parameter :: b215 = 0.0_wp real ( wp ), parameter :: b216 = 0.0_wp real ( wp ), parameter :: b217 = 0.0_wp real ( wp ), parameter :: b218 = 0.0_wp real ( wp ), parameter :: b219 = 0.0_wp real ( wp ), parameter :: b2110 = 0.0_wp real ( wp ), parameter :: b2111 = 0.0_wp real ( wp ), parameter :: b2112 = - 9 1.7295278291256484357935662402321623495228729036354276506427_wp real ( wp ), parameter :: b2113 = 70 7.656144971598359834575719286335716154821128966649565194286_wp real ( wp ), parameter :: b2114 = - 1.10563611857482440905296961311590930801338308942637769555540_wp real ( wp ), parameter :: b2115 = 17 6.134591883811372587859898076055660406999516762301689616841_wp real ( wp ), parameter :: b2116 = 0.491384824214880662268898345164454557416884631402764792538746_wp real ( wp ), parameter :: b2117 = - 68 4.278000449814944358237535610895081956077167893600278300805_wp real ( wp ), parameter :: b2118 = 2 7.9910604998398258984224332124380407446002518400668657974589_wp real ( wp ), parameter :: b2119 = 1 3.1939710030282333443670964371153238435064159623744975073252_wp real ( wp ), parameter :: b2120 = 1.25128781283980445450114974148056006317268830077396406361417_wp real ( wp ), parameter :: b220 = - 9.67307946948196763644126118433219395839951408571877262880482_wp real ( wp ), parameter :: b221 = 0.0_wp real ( wp ), parameter :: b222 = 0.0_wp real ( wp ), parameter :: b223 = 0.0_wp real ( wp ), parameter :: b224 = 0.0_wp real ( wp ), parameter :: b225 = 0.0_wp real ( wp ), parameter :: b226 = 0.0_wp real ( wp ), parameter :: b227 = 0.0_wp real ( wp ), parameter :: b228 = 0.0_wp real ( wp ), parameter :: b229 = 0.0_wp real ( wp ), parameter :: b2210 = 0.0_wp real ( wp ), parameter :: b2211 = 0.0_wp real ( wp ), parameter :: b2212 = - 4.46990150858505531443846227701960360497830681408751431146712_wp real ( wp ), parameter :: b2213 = 4 5.5127128690952681968241950400052751178905907817398483534845_wp real ( wp ), parameter :: b2214 = - 0.0713085086183826912791492024438246129930559805352394367050813_wp real ( wp ), parameter :: b2215 = 1 1.2273614068412741582590624479939384207826800776794485051540_wp real ( wp ), parameter :: b2216 = 0.126244376717622724516237912909138809361786889819105426371393_wp real ( wp ), parameter :: b2217 = - 4 3.5439339549483313605810624907242107623814304467621407753424_wp real ( wp ), parameter :: b2218 = 0.787174307543058978398792994996550902064546091443233850464377_wp real ( wp ), parameter :: b2219 = 0.532264696744684215669300708603886690785395776821503851830821_wp real ( wp ), parameter :: b2220 = 0.422422733996325326010225127471388772575086538809603346825334_wp real ( wp ), parameter :: b2221 = 0.0859131249503067107308438031499859443441115056294154956487671_wp real ( wp ), parameter :: b230 = - 1 0.0664032447054702403396606900426891472202824757968765569183_wp real ( wp ), parameter :: b231 = 0.0_wp real ( wp ), parameter :: b232 = 0.0_wp real ( wp ), parameter :: b233 = 0.0_wp real ( wp ), parameter :: b234 = 0.0_wp real ( wp ), parameter :: b235 = 0.0_wp real ( wp ), parameter :: b236 = 0.0_wp real ( wp ), parameter :: b237 = 0.0_wp real ( wp ), parameter :: b238 = - 0.0366253270049039970293685796848974791733119081733552207318285_wp real ( wp ), parameter :: b239 = 0.0350254975636213681976849406979846524346789082471103574920148_wp real ( wp ), parameter :: b2310 = 0.0360946016362113508931786658758335239823689929864237671348749_wp real ( wp ), parameter :: b2311 = - 0.0265219967553681106351595946834601923649627012457464284442911_wp real ( wp ), parameter :: b2312 = - 6.27088972181464143590553149478871603839356122957396018530209_wp real ( wp ), parameter :: b2313 = 4 8.2079237442562989090702103008195063923492593141636117832993_wp real ( wp ), parameter :: b2314 = - 0.0694471689136165640882395180583732834557754169149088630301342_wp real ( wp ), parameter :: b2315 = 1 2.6810690204850295698341370913609807066108483811412127009785_wp real ( wp ), parameter :: b2316 = 0.0119671168968323754838161435501011294100927813964199613229864_wp real ( wp ), parameter :: b2317 = - 4 6.7249764992482408003358268242662695593201321659795608950429_wp real ( wp ), parameter :: b2318 = 1.33029613326626711314710039298216591399033511191227101321435_wp real ( wp ), parameter :: b2319 = 1.00766787503398298353438903619926657771162717793661719708370_wp real ( wp ), parameter :: b2320 = 0.0209512051933665091664122388475480702892770753864487241177616_wp real ( wp ), parameter :: b2321 = 0.0210134706331264177317735424331396407424412188443757490871603_wp real ( wp ), parameter :: b2322 = 0.00952196014417121794175101542454575907376360233658356240547761_wp real ( wp ), parameter :: b240 = - 40 9.478081677743708772589097409370357624424341606752069725341_wp real ( wp ), parameter :: b241 = 0.0_wp real ( wp ), parameter :: b242 = 0.0_wp real ( wp ), parameter :: b243 = 0.0_wp real ( wp ), parameter :: b244 = 0.0_wp real ( wp ), parameter :: b245 = 0.0_wp real ( wp ), parameter :: b246 = 0.0_wp real ( wp ), parameter :: b247 = 0.0_wp real ( wp ), parameter :: b248 = 0.210451912023627385609097011999010655788807405225626700040882_wp real ( wp ), parameter :: b249 = 1.03427452057230411936482926828825709938667999698324740166559_wp real ( wp ), parameter :: b2410 = 0.00600303645864422487051240448206640574939078092406156945568306_wp real ( wp ), parameter :: b2411 = 0.855938125099619537578012106002407728915062652616416005816477_wp real ( wp ), parameter :: b2412 = - 25 0.516998547447860492777657729316130386584050420782075966990_wp real ( wp ), parameter :: b2413 = 194 6.42466652388427766053750328264758595829850895761428240231_wp real ( wp ), parameter :: b2414 = - 3.04503882102310365506105809086860882786950544097602101685174_wp real ( wp ), parameter :: b2415 = 49 0.626379528281713521208265299168083841598542274061671576230_wp real ( wp ), parameter :: b2416 = 1.56647589531270907115484067013597445739595615245966775329993_wp real ( wp ), parameter :: b2417 = - 188 1.97428994011173362217267377035870619215906638453056643641_wp real ( wp ), parameter :: b2418 = 7 5.2592224724847175278837713643303149821620618914245864351135_wp real ( wp ), parameter :: b2419 = 3 4.5734356980331067622434344736554689696728644793551014989002_wp real ( wp ), parameter :: b2420 = 3.21147679440968961435417361847073755169022966748891627882572_wp real ( wp ), parameter :: b2421 = - 0.460408041738414391307201404237058848867245095265382820823055_wp real ( wp ), parameter :: b2422 = - 0.0870718339841810522431884137957986245724252047388936572215438_wp real ( wp ), parameter :: b2423 = - 7.39351814158303067567016952195521063999185773249132944724553_wp real ( wp ), parameter :: b250 = 3.43347475853550878921093496257596781120623891072008459930197_wp real ( wp ), parameter :: b251 = 0.0_wp real ( wp ), parameter :: b252 = 0.0_wp real ( wp ), parameter :: b253 = 0.0_wp real ( wp ), parameter :: b254 = 0.0_wp real ( wp ), parameter :: b255 = 0.0_wp real ( wp ), parameter :: b256 = 0.0_wp real ( wp ), parameter :: b257 = 0.0_wp real ( wp ), parameter :: b258 = 0.00249163204855817407538949148805995149459884653585417680098222_wp real ( wp ), parameter :: b259 = 0.0230138787854593149638399846373742768772087122638142234223658_wp real ( wp ), parameter :: b2510 = - 0.00322155956692977098724476092467120878189463604760620461043308_wp real ( wp ), parameter :: b2511 = 0.00988442549447664668946335414487885256040819982786014648129297_wp real ( wp ), parameter :: b2512 = 2.16252799377922507788307841904757354045759225335732707916530_wp real ( wp ), parameter :: b2513 = - 1 6.2699864546457421328065640660139489006987552040228852402716_wp real ( wp ), parameter :: b2514 = - 0.128534502120524552843583417470935010538029037542654506231743_wp real ( wp ), parameter :: b2515 = - 8.98915042666504253089307820833379330486511746063552853023189_wp real ( wp ), parameter :: b2516 = - 0.00348595363232025333387080201851013650192401767250513765000963_wp real ( wp ), parameter :: b2517 = 1 5.7936194113339807536235187388695574135853387025139738341334_wp real ( wp ), parameter :: b2518 = - 0.574403330914095065628165482017335820148383663195675408024658_wp real ( wp ), parameter :: b2519 = - 0.345602039021393296692722496608124982535237228827655306030152_wp real ( wp ), parameter :: b2520 = - 0.00662241490206585091731619991383757781133067992707418687587487_wp real ( wp ), parameter :: b2521 = - 0.00777788129242204164032546458607364309759347209626759111946150_wp real ( wp ), parameter :: b2522 = - 0.00356084192402274913338827232697437364675240818791706587952939_wp real ( wp ), parameter :: b2523 = 4.79282506449930799649797749629840189457296934139359048988332_wp real ( wp ), parameter :: b2524 = 0.153725464873068577844576387402512082757034273069877432944621_wp real ( wp ), parameter :: b260 = 3 2.3038520871985442326994734440031535091364975047784630088983_wp real ( wp ), parameter :: b261 = 0.0_wp real ( wp ), parameter :: b262 = 0.0_wp real ( wp ), parameter :: b263 = 0.0_wp real ( wp ), parameter :: b264 = 0.0_wp real ( wp ), parameter :: b265 = - 0.00317987696266205093901912847692712407988609169703103952205634_wp real ( wp ), parameter :: b266 = 0.806397714906192077260821711520379506393543111567419750119748_wp real ( wp ), parameter :: b267 = 0.0975983126412388979093522850684288851314672048003054550357187_wp real ( wp ), parameter :: b268 = 0.778575578158398909027512446452927238999763460594181964958853_wp real ( wp ), parameter :: b269 = 0.204890423831599428189499202098105603312029235081420653574829_wp real ( wp ), parameter :: b2610 = - 1.56261579627468188307070943950527825211462892236424360892806_wp real ( wp ), parameter :: b2611 = 0.0_wp real ( wp ), parameter :: b2612 = 1 6.3429891882310570648504243973927174708753353504154550405647_wp real ( wp ), parameter :: b2613 = - 15 4.544555293543621230730189631471036399316683669609116705323_wp real ( wp ), parameter :: b2614 = 1.56971088703334872692034283417621761466263593582497085955201_wp real ( wp ), parameter :: b2615 = 3.27685545087248131321429817269900731165522404974733504794135_wp real ( wp ), parameter :: b2616 = - 0.0503489245193653176348040727199783626534081095691632396802451_wp real ( wp ), parameter :: b2617 = 15 3.321151858041665070593767885914694011224363102594556731397_wp real ( wp ), parameter :: b2618 = 7.17568186327720495846766484814784143567826308034865369443637_wp real ( wp ), parameter :: b2619 = - 2.94036748675300481945917659896930989215320594380777597403592_wp real ( wp ), parameter :: b2620 = - 0.0665845946076803144470749676022628870281920493197256887985612_wp real ( wp ), parameter :: b2621 = - 0.0462346054990843661229248668562217261176966514016859284197145_wp real ( wp ), parameter :: b2622 = - 0.0204198733585679401539388228617269778848579774821581777675337_wp real ( wp ), parameter :: b2623 = - 5 3.3523106438735850515953441165998107974045090495791591218714_wp real ( wp ), parameter :: b2624 = - 1.35548714715078654978732186705996404017554501614191325114947_wp real ( wp ), parameter :: b2625 = - 1.57196275801232751882901735171459249177687219114442583461866_wp real ( wp ), parameter :: b270 = - 1 6.6451467486341512872031294403931758764560371130818978459405_wp real ( wp ), parameter :: b271 = 0.0_wp real ( wp ), parameter :: b272 = 0.0_wp real ( wp ), parameter :: b273 = 0.0_wp real ( wp ), parameter :: b274 = 0.0_wp real ( wp ), parameter :: b275 = 0.00592232780324503308042990005798046524738389560444257136834990_wp real ( wp ), parameter :: b276 = 0.470326159963841112217224303205894113455362530746108825010848_wp real ( wp ), parameter :: b277 = 0.299688863848679000853981837096192399136831121671781279184194_wp real ( wp ), parameter :: b278 = - 0.247656877593994914689992276329810825853958069263947095548189_wp real ( wp ), parameter :: b279 = 0.110895029771437682893999851839061714522445173600678718208625_wp real ( wp ), parameter :: b2710 = 0.0_wp real ( wp ), parameter :: b2711 = - 0.491719043846229147070666628704194097678081907210673044988866_wp real ( wp ), parameter :: b2712 = - 1 1.4743154427289496968389492564352536350842454130853175250727_wp real ( wp ), parameter :: b2713 = 8 0.2593166576230272541702485886484400152793366623589989106256_wp real ( wp ), parameter :: b2714 = - 0.384132303980042847625312526759029103746926841342088219165648_wp real ( wp ), parameter :: b2715 = 7.28147667468107583471326950926136115767612581862877764249646_wp real ( wp ), parameter :: b2716 = - 0.132699384612248379510571708176035274836827341616751884314074_wp real ( wp ), parameter :: b2717 = - 8 1.0799832525730726674679289752255240006070716633632990308935_wp real ( wp ), parameter :: b2718 = - 1.25037492835620639521768185656179119962253747492403205797494_wp real ( wp ), parameter :: b2719 = 2.59263594969543681023776379504377324994226447359296887778718_wp real ( wp ), parameter :: b2720 = - 0.301440298346404539830163997260526875264431537275641495291993_wp real ( wp ), parameter :: b2721 = 0.221384460789832337451706451572773791695246839057318414301020_wp real ( wp ), parameter :: b2722 = 0.0827577274771892931955989870974693152996276435429809890551210_wp real ( wp ), parameter :: b2723 = 1 8.9960662040611520464672450037243263998175161412237156872211_wp real ( wp ), parameter :: b2724 = 0.269231946409639685623468015128334167460051910348912845121977_wp real ( wp ), parameter :: b2725 = 1.62674827447066537462989364929628933988125029284183680279020_wp real ( wp ), parameter :: b2726 = 0.491719043846229147070666628704194097678081907210673044988866_wp real ( wp ), parameter :: b280 = 0.0838479812409052664616968791372814085980533139224911131069335_wp real ( wp ), parameter :: b281 = 0.0_wp real ( wp ), parameter :: b282 = 0.0_wp real ( wp ), parameter :: b283 = 0.0_wp real ( wp ), parameter :: b284 = 0.0_wp real ( wp ), parameter :: b285 = - 0.0117949367100973814319755056031295775367961960590736150777613_wp real ( wp ), parameter :: b286 = - 0.247299020568812652339473838743194598325992840353340132697498_wp real ( wp ), parameter :: b287 = 0.0978080858367729012259313014081291665503740655476733940756599_wp real ( wp ), parameter :: b288 = 0.217590689243420631360008651767860318344168120024782176879989_wp real ( wp ), parameter :: b289 = 0.0_wp real ( wp ), parameter :: b2810 = 0.137585606763325224865659632196787746647447222975084865975440_wp real ( wp ), parameter :: b2811 = 0.0439870229715046685058790092341545026046103890294261359042581_wp real ( wp ), parameter :: b2812 = 0.0_wp real ( wp ), parameter :: b2813 = - 0.513700813768193341957004456618630303738757363641964030086972_wp real ( wp ), parameter :: b2814 = 0.826355691151315508644211308399153458701423158616168576922372_wp real ( wp ), parameter :: b2815 = 2 5.7018139719811832625873882972519939511136556341960074626615_wp real ( wp ), parameter :: b2816 = 0.0_wp real ( wp ), parameter :: b2817 = 0.0_wp real ( wp ), parameter :: b2818 = 0.0_wp real ( wp ), parameter :: b2819 = 0.0_wp real ( wp ), parameter :: b2820 = 0.0_wp real ( wp ), parameter :: b2821 = 0.0_wp real ( wp ), parameter :: b2822 = 0.0_wp real ( wp ), parameter :: b2823 = - 2 5.7018139719811832625873882972519939511136556341960074626615_wp real ( wp ), parameter :: b2824 = - 0.826355691151315508644211308399153458701423158616168576922372_wp real ( wp ), parameter :: b2825 = 0.513700813768193341957004456618630303738757363641964030086972_wp real ( wp ), parameter :: b2826 = - 0.0439870229715046685058790092341545026046103890294261359042581_wp real ( wp ), parameter :: b2827 = - 0.137585606763325224865659632196787746647447222975084865975440_wp real ( wp ), parameter :: b290 = 0.124380526654094412881516420868799316268491466359671423163289_wp real ( wp ), parameter :: b291 = 0.0_wp real ( wp ), parameter :: b292 = 0.0_wp real ( wp ), parameter :: b293 = 0.0_wp real ( wp ), parameter :: b294 = 0.226120282197584301422238662979202901196752320742633143965145_wp real ( wp ), parameter :: b295 = 0.0137885887618080880607695837016477814530969417491493385363543_wp real ( wp ), parameter :: b296 = - 0.0672210133996684449749399507414305856950086341525382182856200_wp real ( wp ), parameter :: b297 = 0.0_wp real ( wp ), parameter :: b298 = 0.0_wp real ( wp ), parameter :: b299 = - 0.856238975085428354755349769879501772112121597411563802855067_wp real ( wp ), parameter :: b2910 = - 1.96337522866858908928262850028093813988180440518267404553576_wp real ( wp ), parameter :: b2911 = - 0.232332822724119401237246257308921847250108199230419994978218_wp real ( wp ), parameter :: b2912 = 0.0_wp real ( wp ), parameter :: b2913 = 4.30660719086453349461668936876562947772432562053478092626764_wp real ( wp ), parameter :: b2914 = - 2.92722963249465482659787911202390446687687394950633612630592_wp real ( wp ), parameter :: b2915 = - 8 2.3131666397858944454492334105458707735761966428138676971041_wp real ( wp ), parameter :: b2916 = 0.0_wp real ( wp ), parameter :: b2917 = 0.0_wp real ( wp ), parameter :: b2918 = 0.0_wp real ( wp ), parameter :: b2919 = 0.0_wp real ( wp ), parameter :: b2920 = 0.0_wp real ( wp ), parameter :: b2921 = 0.0_wp real ( wp ), parameter :: b2922 = 0.0_wp real ( wp ), parameter :: b2923 = 8 2.3131666397858944454492334105458707735761966428138676971041_wp real ( wp ), parameter :: b2924 = 2.92722963249465482659787911202390446687687394950633612630592_wp real ( wp ), parameter :: b2925 = - 4.30660719086453349461668936876562947772432562053478092626764_wp real ( wp ), parameter :: b2926 = 0.232332822724119401237246257308921847250108199230419994978218_wp real ( wp ), parameter :: b2927 = 1.96337522866858908928262850028093813988180440518267404553576_wp real ( wp ), parameter :: b2928 = 0.856238975085428354755349769879501772112121597411563802855067_wp real ( wp ), parameter :: b300 = 0.103484561636679776672993546511910344499744798201971316606663_wp real ( wp ), parameter :: b301 = 0.0_wp real ( wp ), parameter :: b302 = 0.0_wp real ( wp ), parameter :: b303 = 0.122068887306407222589644082868962077139592714834162134741275_wp real ( wp ), parameter :: b304 = 0.482574490331246622475134780125688112865919023850168049679402_wp real ( wp ), parameter :: b305 = - 0.0381409600015606999730886240005620205664113072478411477421970_wp real ( wp ), parameter :: b306 = 0.0_wp real ( wp ), parameter :: b307 = - 0.550499525310802324138388507020508177411414311000037561712836_wp real ( wp ), parameter :: b308 = 0.0_wp real ( wp ), parameter :: b309 = - 0.711915811585189227887648262043794387578291882406745570495765_wp real ( wp ), parameter :: b3010 = - 0.584129605671551340432988730158480872095335329645227595707052_wp real ( wp ), parameter :: b3011 = 0.0_wp real ( wp ), parameter :: b3012 = 0.0_wp real ( wp ), parameter :: b3013 = 2.11046308125864932128717300046622750300375054278936987850718_wp real ( wp ), parameter :: b3014 = - 0.0837494736739572135525742023001037992695260175335123517729291_wp real ( wp ), parameter :: b3015 = 5.10021499072320914075295969043344113107545060862804249161191_wp real ( wp ), parameter :: b3016 = 0.0_wp real ( wp ), parameter :: b3017 = 0.0_wp real ( wp ), parameter :: b3018 = 0.0_wp real ( wp ), parameter :: b3019 = 0.0_wp real ( wp ), parameter :: b3020 = 0.0_wp real ( wp ), parameter :: b3021 = 0.0_wp real ( wp ), parameter :: b3022 = 0.0_wp real ( wp ), parameter :: b3023 = - 5.10021499072320914075295969043344113107545060862804249161191_wp real ( wp ), parameter :: b3024 = 0.0837494736739572135525742023001037992695260175335123517729291_wp real ( wp ), parameter :: b3025 = - 2.11046308125864932128717300046622750300375054278936987850718_wp real ( wp ), parameter :: b3026 = 0.0_wp real ( wp ), parameter :: b3027 = 0.584129605671551340432988730158480872095335329645227595707052_wp real ( wp ), parameter :: b3028 = 0.711915811585189227887648262043794387578291882406745570495765_wp real ( wp ), parameter :: b3029 = 0.550499525310802324138388507020508177411414311000037561712836_wp real ( wp ), parameter :: b310 = 0.193333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b311 = 0.0_wp real ( wp ), parameter :: b312 = 0.220000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b313 = - 0.0800000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b314 = 0.0_wp real ( wp ), parameter :: b315 = 0.0_wp real ( wp ), parameter :: b316 = 0.109993425580724703919462404865068340845119058295846426463652_wp real ( wp ), parameter :: b317 = - 0.254297048076270161384068506997153122141835626976703920846242_wp real ( wp ), parameter :: b318 = 0.0_wp real ( wp ), parameter :: b319 = 0.865570777116694254343770343821098281832847401233011859346737_wp real ( wp ), parameter :: b3110 = 3.32416449114093083106799552786572018336860092936986407160200_wp real ( wp ), parameter :: b3111 = 0.0_wp real ( wp ), parameter :: b3112 = 0.0_wp real ( wp ), parameter :: b3113 = - 1 2.0102223315977933882352385148661841260301942633996815127277_wp real ( wp ), parameter :: b3114 = 0.476601466242493239430442776862061899602963782003580209476163_wp real ( wp ), parameter :: b3115 = - 2 9.0243011221036390525802623213654099596251221332470910692353_wp real ( wp ), parameter :: b3116 = 0.0_wp real ( wp ), parameter :: b3117 = 0.0_wp real ( wp ), parameter :: b3118 = 0.0_wp real ( wp ), parameter :: b3119 = 0.0_wp real ( wp ), parameter :: b3120 = 0.0_wp real ( wp ), parameter :: b3121 = 0.0_wp real ( wp ), parameter :: b3122 = 0.0_wp real ( wp ), parameter :: b3123 = 2 9.0243011221036390525802623213654099596251221332470910692353_wp real ( wp ), parameter :: b3124 = - 0.476601466242493239430442776862061899602963782003580209476163_wp real ( wp ), parameter :: b3125 = 1 2.0102223315977933882352385148661841260301942633996815127277_wp real ( wp ), parameter :: b3126 = 0.0_wp real ( wp ), parameter :: b3127 = - 3.32416449114093083106799552786572018336860092936986407160200_wp real ( wp ), parameter :: b3128 = - 0.865570777116694254343770343821098281832847401233011859346737_wp real ( wp ), parameter :: b3129 = 0.254297048076270161384068506997153122141835626976703920846242_wp real ( wp ), parameter :: b3130 = - 0.109993425580724703919462404865068340845119058295846426463652_wp real ( wp ), parameter :: b320 = - 0.833333333333333333333333333333333333333333333333333333333333_wp real ( wp ), parameter :: b321 = 1.38888888888888888888888888888888888888888888888888888888889_wp real ( wp ), parameter :: b322 = 0.0_wp real ( wp ), parameter :: b323 = 0.0_wp real ( wp ), parameter :: b324 = - 0.750000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b325 = 0.0_wp real ( wp ), parameter :: b326 = - 0.492529543718026304422682049114021320200214681580657784719074_wp real ( wp ), parameter :: b327 = 0.0_wp real ( wp ), parameter :: b328 = 0.0_wp real ( wp ), parameter :: b329 = 0.0_wp real ( wp ), parameter :: b3210 = 0.0_wp real ( wp ), parameter :: b3211 = 0.0_wp real ( wp ), parameter :: b3212 = 0.0_wp real ( wp ), parameter :: b3213 = 0.0_wp real ( wp ), parameter :: b3214 = 0.0_wp real ( wp ), parameter :: b3215 = 0.0_wp real ( wp ), parameter :: b3216 = 0.0_wp real ( wp ), parameter :: b3217 = 0.0_wp real ( wp ), parameter :: b3218 = 0.0_wp real ( wp ), parameter :: b3219 = 0.0_wp real ( wp ), parameter :: b3220 = 0.0_wp real ( wp ), parameter :: b3221 = 0.0_wp real ( wp ), parameter :: b3222 = 0.0_wp real ( wp ), parameter :: b3223 = 0.0_wp real ( wp ), parameter :: b3224 = 0.0_wp real ( wp ), parameter :: b3225 = 0.0_wp real ( wp ), parameter :: b3226 = 0.0_wp real ( wp ), parameter :: b3227 = 0.0_wp real ( wp ), parameter :: b3228 = 0.0_wp real ( wp ), parameter :: b3229 = 0.0_wp real ( wp ), parameter :: b3230 = 0.492529543718026304422682049114021320200214681580657784719074_wp real ( wp ), parameter :: b3231 = 0.750000000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b330 = 0.111111111111111111111111111111111111111111111111111111111111_wp real ( wp ), parameter :: b331 = 0.0_wp real ( wp ), parameter :: b332 = - 0.222222222222222222222222222222222222222222222222222222222222_wp real ( wp ), parameter :: b333 = 0.0_wp real ( wp ), parameter :: b334 = 0.0_wp real ( wp ), parameter :: b335 = 0.0_wp real ( wp ), parameter :: b336 = 0.0_wp real ( wp ), parameter :: b337 = 0.0_wp real ( wp ), parameter :: b338 = 0.0_wp real ( wp ), parameter :: b339 = 0.0_wp real ( wp ), parameter :: b3310 = 0.0_wp real ( wp ), parameter :: b3311 = 0.0_wp real ( wp ), parameter :: b3312 = 0.0_wp real ( wp ), parameter :: b3313 = 0.0_wp real ( wp ), parameter :: b3314 = 0.0_wp real ( wp ), parameter :: b3315 = 0.0_wp real ( wp ), parameter :: b3316 = 0.0_wp real ( wp ), parameter :: b3317 = 0.0_wp real ( wp ), parameter :: b3318 = 0.0_wp real ( wp ), parameter :: b3319 = 0.0_wp real ( wp ), parameter :: b3320 = 0.0_wp real ( wp ), parameter :: b3321 = 0.0_wp real ( wp ), parameter :: b3322 = 0.0_wp real ( wp ), parameter :: b3323 = 0.0_wp real ( wp ), parameter :: b3324 = 0.0_wp real ( wp ), parameter :: b3325 = 0.0_wp real ( wp ), parameter :: b3326 = 0.0_wp real ( wp ), parameter :: b3327 = 0.0_wp real ( wp ), parameter :: b3328 = 0.0_wp real ( wp ), parameter :: b3329 = 0.0_wp real ( wp ), parameter :: b3330 = 0.0_wp real ( wp ), parameter :: b3331 = 0.0_wp real ( wp ), parameter :: b3332 = 0.222222222222222222222222222222222222222222222222222222222222_wp real ( wp ), parameter :: b340 = 0.285835140388971558796088842163836414852927537894596466840753_wp real ( wp ), parameter :: b341 = 0.291666666666666666666666666666666666666666666666666666666667_wp real ( wp ), parameter :: b342 = 0.218750000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b343 = 0.0_wp real ( wp ), parameter :: b344 = 0.164062500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b345 = 0.0_wp real ( wp ), parameter :: b346 = 0.218194354945556658327188241581352107093288824322187941141516_wp real ( wp ), parameter :: b347 = 0.180392898478697766863635221946775437719620053641849228562435_wp real ( wp ), parameter :: b348 = 0.0_wp real ( wp ), parameter :: b349 = 0.205713839404845018859120755122929542277570094982808905393991_wp real ( wp ), parameter :: b3410 = 0.242715791581770239970282927959446515762745971386670541948576_wp real ( wp ), parameter :: b3411 = 0.246465780813629305833609291181891407799228103869305705137021_wp real ( wp ), parameter :: b3412 = - 3.44991940790890824979834154601622662060370460614931644223924_wp real ( wp ), parameter :: b3413 = 0.228875562160036081760729060738458584294220372552740218459295_wp real ( wp ), parameter :: b3414 = 0.283290599702151415321527419056733335978436595493855789831434_wp real ( wp ), parameter :: b3415 = 3.21085125837766640960131490544236787005557320332238705967955_wp real ( wp ), parameter :: b3416 = - 0.223538777364845699920233756214162507964125230083674032084065_wp real ( wp ), parameter :: b3417 = - 0.707121157204419073518727286207487212130091231955206160635271_wp real ( wp ), parameter :: b3418 = 3.21123345150287080408174729202856500893260034443022374267639_wp real ( wp ), parameter :: b3419 = 1.40954348309669766030414474301123175769045945573548986335553_wp real ( wp ), parameter :: b3420 = - 0.151362053443742613121602276742518111090963026203676055891793_wp real ( wp ), parameter :: b3421 = 0.372350574527014276454724080214619984397121028202148298716575_wp real ( wp ), parameter :: b3422 = 0.252978746406361336722199907762141285915775728129414319261111_wp real ( wp ), parameter :: b3423 = - 3.21085125837766640960131490544236787005557320332238705967955_wp real ( wp ), parameter :: b3424 = - 0.283290599702151415321527419056733335978436595493855789831434_wp real ( wp ), parameter :: b3425 = - 0.228875562160036081760729060738458584294220372552740218459295_wp real ( wp ), parameter :: b3426 = - 0.246465780813629305833609291181891407799228103869305705137021_wp real ( wp ), parameter :: b3427 = - 0.242715791581770239970282927959446515762745971386670541948576_wp real ( wp ), parameter :: b3428 = - 0.205713839404845018859120755122929542277570094982808905393991_wp real ( wp ), parameter :: b3429 = - 0.180392898478697766863635221946775437719620053641849228562435_wp real ( wp ), parameter :: b3430 = - 0.218194354945556658327188241581352107093288824322187941141516_wp real ( wp ), parameter :: b3431 = - 0.164062500000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b3432 = - 0.218750000000000000000000000000000000000000000000000000000000_wp real ( wp ), parameter :: b3433 = - 0.291666666666666666666666666666666666666666666666666666666667_wp real ( wp ), dimension ( me % n ) :: f0 , f1 , f2 , f3 , f4 , f5 , f6 , f7 , f8 , f9 , f10 , f11 , f12 ,& f13 , f14 , f15 , f16 , f17 , f18 , f19 , f20 , f21 , f22 , f23 , f24 ,& f25 , f26 , f27 , f28 , f29 , f30 , f31 , f32 , f33 , f34 if ( h == zero ) then xf = x terr = zero return end if call me % f ( t + a0 * h , x , f0 ) call me % f ( t + a1 * h , x + h * ( b10 * f0 ), f1 ) call me % f ( t + a2 * h , x + h * ( b20 * f0 + b21 * f1 ), f2 ) call me % f ( t + a3 * h , x + h * ( b30 * f0 + b31 * f1 + b32 * f2 ), f3 ) call me % f ( t + a4 * h , x + h * ( b40 * f0 + b41 * f1 + b42 * f2 + b43 * f3 ), f4 ) call me % f ( t + a5 * h , x + h * ( b50 * f0 + b51 * f1 + b52 * f2 + b53 * f3 + & b54 * f4 ), f5 ) call me % f ( t + a6 * h , x + h * ( b60 * f0 + b61 * f1 + b62 * f2 + b63 * f3 + & b64 * f4 + b65 * f5 ), f6 ) call me % f ( t + a7 * h , x + h * ( b70 * f0 + b71 * f1 + b72 * f2 + b73 * f3 + & b74 * f4 + b75 * f5 + b76 * f6 ), f7 ) call me % f ( t + a8 * h , x + h * ( b80 * f0 + b81 * f1 + b82 * f2 + b83 * f3 + & b84 * f4 + b85 * f5 + b86 * f6 + b87 * f7 ), f8 ) call me % f ( t + a9 * h , x + h * ( b90 * f0 + b91 * f1 + b92 * f2 + b93 * f3 + & b94 * f4 + b95 * f5 + b96 * f6 + b97 * f7 + & b98 * f8 ), f9 ) call me % f ( t + a10 * h , x + h * ( b100 * f0 + b101 * f1 + b102 * f2 + b103 * f3 + & b104 * f4 + b105 * f5 + b106 * f6 + b107 * f7 + & b108 * f8 + b109 * f9 ), f10 ) call me % f ( t + a11 * h , x + h * ( b110 * f0 + b111 * f1 + b112 * f2 + b113 * f3 + & b114 * f4 + b115 * f5 + b116 * f6 + b117 * f7 + & b118 * f8 + b119 * f9 + b1110 * f10 ), f11 ) call me % f ( t + a12 * h , x + h * ( b120 * f0 + b121 * f1 + b122 * f2 + b123 * f3 + & b124 * f4 + b125 * f5 + b126 * f6 + b127 * f7 + & b128 * f8 + b129 * f9 + b1210 * f10 + b1211 * f11 ), f12 ) call me % f ( t + a13 * h , x + h * ( b130 * f0 + b131 * f1 + b132 * f2 + b133 * f3 + & b134 * f4 + b135 * f5 + b136 * f6 + b137 * f7 + & b138 * f8 + b139 * f9 + b1310 * f10 + b1311 * f11 + & b1312 * f12 ), f13 ) call me % f ( t + a14 * h , x + h * ( b140 * f0 + b141 * f1 + b142 * f2 + b143 * f3 + & b144 * f4 + b145 * f5 + b146 * f6 + b147 * f7 + & b148 * f8 + b149 * f9 + b1410 * f10 + b1411 * f11 + & b1412 * f12 + b1413 * f13 ), f14 ) call me % f ( t + a15 * h , x + h * ( b150 * f0 + b151 * f1 + b152 * f2 + b153 * f3 + & b154 * f4 + b155 * f5 + b156 * f6 + b157 * f7 + & b158 * f8 + b159 * f9 + b1510 * f10 + b1511 * f11 + & b1512 * f12 + b1513 * f13 + b1514 * f14 ), f15 ) call me % f ( t + a16 * h , x + h * ( b160 * f0 + b161 * f1 + b162 * f2 + b163 * f3 + & b164 * f4 + b165 * f5 + b166 * f6 + b167 * f7 + & b168 * f8 + b169 * f9 + b1610 * f10 + b1611 * f11 + & b1612 * f12 + b1613 * f13 + b1614 * f14 + b1615 * f15 ), f16 ) call me % f ( t + a17 * h , x + h * ( b170 * f0 + b171 * f1 + b172 * f2 + b173 * f3 + & b174 * f4 + b175 * f5 + b176 * f6 + b177 * f7 + & b178 * f8 + b179 * f9 + b1710 * f10 + b1711 * f11 + & b1712 * f12 + b1713 * f13 + b1714 * f14 + b1715 * f15 + & b1716 * f16 ), f17 ) call me % f ( t + a18 * h , x + h * ( b180 * f0 + b181 * f1 + b182 * f2 + b183 * f3 + & b184 * f4 + b185 * f5 + b186 * f6 + b187 * f7 + & b188 * f8 + b189 * f9 + b1810 * f10 + b1811 * f11 + & b1812 * f12 + b1813 * f13 + b1814 * f14 + b1815 * f15 + & b1816 * f16 + b1817 * f17 ), f18 ) call me % f ( t + a19 * h , x + h * ( b190 * f0 + b191 * f1 + b192 * f2 + b193 * f3 + & b194 * f4 + b195 * f5 + b196 * f6 + b197 * f7 + & b198 * f8 + b199 * f9 + b1910 * f10 + b1911 * f11 + & b1912 * f12 + b1913 * f13 + b1914 * f14 + b1915 * f15 + & b1916 * f16 + b1917 * f17 + b1918 * f18 ), f19 ) call me % f ( t + a20 * h , x + h * ( b200 * f0 + b201 * f1 + b202 * f2 + b203 * f3 + & b204 * f4 + b205 * f5 + b206 * f6 + b207 * f7 + & b208 * f8 + b209 * f9 + b2010 * f10 + b2011 * f11 + & b2012 * f12 + b2013 * f13 + b2014 * f14 + b2015 * f15 + & b2016 * f16 + b2017 * f17 + b2018 * f18 + b2019 * f19 ), f20 ) call me % f ( t + a21 * h , x + h * ( b210 * f0 + b211 * f1 + b212 * f2 + b213 * f3 + & b214 * f4 + b215 * f5 + b216 * f6 + b217 * f7 + & b218 * f8 + b219 * f9 + b2110 * f10 + b2111 * f11 + & b2112 * f12 + b2113 * f13 + b2114 * f14 + b2115 * f15 + & b2116 * f16 + b2117 * f17 + b2118 * f18 + b2119 * f19 + & b2120 * f20 ), f21 ) call me % f ( t + a22 * h , x + h * ( b220 * f0 + b221 * f1 + b222 * f2 + b223 * f3 + & b224 * f4 + b225 * f5 + b226 * f6 + b227 * f7 + & b228 * f8 + b229 * f9 + b2210 * f10 + b2211 * f11 + & b2212 * f12 + b2213 * f13 + b2214 * f14 + b2215 * f15 + & b2216 * f16 + b2217 * f17 + b2218 * f18 + b2219 * f19 + & b2220 * f20 + b2221 * f21 ), f22 ) call me % f ( t + a23 * h , x + h * ( b230 * f0 + b231 * f1 + b232 * f2 + b233 * f3 + & b234 * f4 + b235 * f5 + b236 * f6 + b237 * f7 + & b238 * f8 + b239 * f9 + b2310 * f10 + b2311 * f11 + & b2312 * f12 + b2313 * f13 + b2314 * f14 + b2315 * f15 + & b2316 * f16 + b2317 * f17 + b2318 * f18 + b2319 * f19 + & b2320 * f20 + b2321 * f21 + b2322 * f22 ), f23 ) call me % f ( t + a24 * h , x + h * ( b240 * f0 + b241 * f1 + b242 * f2 + b243 * f3 + & b244 * f4 + b245 * f5 + b246 * f6 + b247 * f7 + & b248 * f8 + b249 * f9 + b2410 * f10 + b2411 * f11 + & b2412 * f12 + b2413 * f13 + b2414 * f14 + b2415 * f15 + & b2416 * f16 + b2417 * f17 + b2418 * f18 + b2419 * f19 + & b2420 * f20 + b2421 * f21 + b2422 * f22 + b2423 * f23 ), f24 ) call me % f ( t + a25 * h , x + h * ( b250 * f0 + b251 * f1 + b252 * f2 + b253 * f3 + & b254 * f4 + b255 * f5 + b256 * f6 + b257 * f7 + & b258 * f8 + b259 * f9 + b2510 * f10 + b2511 * f11 + & b2512 * f12 + b2513 * f13 + b2514 * f14 + b2515 * f15 + & b2516 * f16 + b2517 * f17 + b2518 * f18 + b2519 * f19 + & b2520 * f20 + b2521 * f21 + b2522 * f22 + b2523 * f23 + & b2524 * f24 ), f25 ) call me % f ( t + a26 * h , x + h * ( b260 * f0 + b261 * f1 + b262 * f2 + b263 * f3 + & b264 * f4 + b265 * f5 + b266 * f6 + b267 * f7 + & b268 * f8 + b269 * f9 + b2610 * f10 + b2611 * f11 + & b2612 * f12 + b2613 * f13 + b2614 * f14 + b2615 * f15 + & b2616 * f16 + b2617 * f17 + b2618 * f18 + b2619 * f19 + & b2620 * f20 + b2621 * f21 + b2622 * f22 + b2623 * f23 + & b2624 * f24 + b2625 * f25 ), f26 ) call me % f ( t + a27 * h , x + h * ( b270 * f0 + b271 * f1 + b272 * f2 + b273 * f3 + & b274 * f4 + b275 * f5 + b276 * f6 + b277 * f7 + & b278 * f8 + b279 * f9 + b2710 * f10 + b2711 * f11 + & b2712 * f12 + b2713 * f13 + b2714 * f14 + b2715 * f15 + & b2716 * f16 + b2717 * f17 + b2718 * f18 + b2719 * f19 + & b2720 * f20 + b2721 * f21 + b2722 * f22 + b2723 * f23 + & b2724 * f24 + b2725 * f25 + b2726 * f26 ), f27 ) call me % f ( t + a28 * h , x + h * ( b280 * f0 + b281 * f1 + b282 * f2 + b283 * f3 + & b284 * f4 + b285 * f5 + b286 * f6 + b287 * f7 + & b288 * f8 + b289 * f9 + b2810 * f10 + b2811 * f11 + & b2812 * f12 + b2813 * f13 + b2814 * f14 + b2815 * f15 + & b2816 * f16 + b2817 * f17 + b2818 * f18 + b2819 * f19 + & b2820 * f20 + b2821 * f21 + b2822 * f22 + b2823 * f23 + & b2824 * f24 + b2825 * f25 + b2826 * f26 + b2827 * f27 ), f28 ) call me % f ( t + a29 * h , x + h * ( b290 * f0 + b291 * f1 + b292 * f2 + b293 * f3 + & b294 * f4 + b295 * f5 + b296 * f6 + b297 * f7 + & b298 * f8 + b299 * f9 + b2910 * f10 + b2911 * f11 + & b2912 * f12 + b2913 * f13 + b2914 * f14 + b2915 * f15 + & b2916 * f16 + b2917 * f17 + b2918 * f18 + b2919 * f19 + & b2920 * f20 + b2921 * f21 + b2922 * f22 + b2923 * f23 + & b2924 * f24 + b2925 * f25 + b2926 * f26 + b2927 * f27 + & b2928 * f28 ), f29 ) call me % f ( t + a30 * h , x + h * ( b300 * f0 + b301 * f1 + b302 * f2 + b303 * f3 + & b304 * f4 + b305 * f5 + b306 * f6 + b307 * f7 + & b308 * f8 + b309 * f9 + b3010 * f10 + b3011 * f11 + & b3012 * f12 + b3013 * f13 + b3014 * f14 + b3015 * f15 + & b3016 * f16 + b3017 * f17 + b3018 * f18 + b3019 * f19 + & b3020 * f20 + b3021 * f21 + b3022 * f22 + b3023 * f23 + & b3024 * f24 + b3025 * f25 + b3026 * f26 + b3027 * f27 + & b3028 * f28 + b3029 * f29 ), f30 ) call me % f ( t + a31 * h , x + h * ( b310 * f0 + b311 * f1 + b312 * f2 + b313 * f3 + & b314 * f4 + b315 * f5 + b316 * f6 + b317 * f7 + & b318 * f8 + b319 * f9 + b3110 * f10 + b3111 * f11 + & b3112 * f12 + b3113 * f13 + b3114 * f14 + b3115 * f15 + & b3116 * f16 + b3117 * f17 + b3118 * f18 + b3119 * f19 + & b3120 * f20 + b3121 * f21 + b3122 * f22 + b3123 * f23 + & b3124 * f24 + b3125 * f25 + b3126 * f26 + b3127 * f27 + & b3128 * f28 + b3129 * f29 + b3130 * f30 ), f31 ) call me % f ( t + a32 * h , x + h * ( b320 * f0 + b321 * f1 + b322 * f2 + b323 * f3 + & b324 * f4 + b325 * f5 + b326 * f6 + b327 * f7 + & b328 * f8 + b329 * f9 + b3210 * f10 + b3211 * f11 + & b3212 * f12 + b3213 * f13 + b3214 * f14 + b3215 * f15 + & b3216 * f16 + b3217 * f17 + b3218 * f18 + b3219 * f19 + & b3220 * f20 + b3221 * f21 + b3222 * f22 + b3223 * f23 + & b3224 * f24 + b3225 * f25 + b3226 * f26 + b3227 * f27 + & b3228 * f28 + b3229 * f29 + b3230 * f30 + b3231 * f31 ), f32 ) call me % f ( t + a33 * h , x + h * ( b330 * f0 + b331 * f1 + b332 * f2 + b333 * f3 + & b334 * f4 + b335 * f5 + b336 * f6 + b337 * f7 + & b338 * f8 + b339 * f9 + b3310 * f10 + b3311 * f11 + & b3312 * f12 + b3313 * f13 + b3314 * f14 + b3315 * f15 + & b3316 * f16 + b3317 * f17 + b3318 * f18 + b3319 * f19 + & b3320 * f20 + b3321 * f21 + b3322 * f22 + b3323 * f23 + & b3324 * f24 + b3325 * f25 + b3326 * f26 + b3327 * f27 + & b3328 * f28 + b3329 * f29 + b3330 * f30 + b3331 * f31 + & b3332 * f32 ), f33 ) call me % f ( t + a34 * h , x + h * ( b340 * f0 + b341 * f1 + b342 * f2 + b343 * f3 + & b344 * f4 + b345 * f5 + b346 * f6 + b347 * f7 + & b348 * f8 + b349 * f9 + b3410 * f10 + b3411 * f11 + & b3412 * f12 + b3413 * f13 + b3414 * f14 + b3415 * f15 + & b3416 * f16 + b3417 * f17 + b3418 * f18 + b3419 * f19 + & b3420 * f20 + b3421 * f21 + b3422 * f22 + b3423 * f23 + & b3424 * f24 + b3425 * f25 + b3426 * f26 + b3427 * f27 + & b3428 * f28 + b3429 * f29 + b3430 * f30 + b3431 * f31 + & b3432 * f32 + b3433 * f33 ), f34 ) xf = x + h * ( c0 * f0 + & c1 * f1 + & c2 * f2 + & c3 * f3 + & c4 * f4 + & c5 * f5 + & c6 * f6 + & c7 * f7 + & c8 * f8 + & c9 * f9 + & c10 * f10 + & c11 * f11 + & c12 * f12 + & c13 * f13 + & c14 * f14 + & c15 * f15 + & c16 * f16 + & c17 * f17 + & c18 * f18 + & c19 * f19 + & c20 * f20 + & c21 * f21 + & c22 * f22 + & c23 * f23 + & c24 * f24 + & c25 * f25 + & c26 * f26 + & c27 * f27 + & c28 * f28 + & c29 * f29 + & c30 * f30 + & c31 * f31 + & c32 * f32 + & c33 * f33 + & c34 * f34 ) terr = ( 1.0_wp / 100 0.0_wp ) * h * ( f1 - f33 ) end subroutine rkf1412 !***************************************************************************************** !***************************************************************************************** !> !  Returns the order of the rkf78 method. pure function rkf78_order ( me ) result ( p ) implicit none class ( rkf78_class ), intent ( in ) :: me integer :: p !! order of the method p = 7 end function rkf78_order !***************************************************************************************** !***************************************************************************************** !> !  Returns the order of the rkf89 method. pure function rkf89_order ( me ) result ( p ) implicit none class ( rkf89_class ), intent ( in ) :: me integer :: p !! order of the method p = 8 end function rkf89_order !***************************************************************************************** !***************************************************************************************** !> !  Returns the order of the rkv89 method. pure function rkv89_order ( me ) result ( p ) implicit none class ( rkv89_class ), intent ( in ) :: me integer :: p !! order of the method p = 8 end function rkv89_order !***************************************************************************************** !***************************************************************************************** !> !  Returns the order of the [[rkf108]] method. pure function rkf108_order ( me ) result ( p ) implicit none class ( rkf108_class ), intent ( in ) :: me integer :: p !! order of the method p = 10 end function rkf108_order !***************************************************************************************** !***************************************************************************************** !> !  Returns the order of the [[rkf1210]] method. pure function rkf1210_order ( me ) result ( p ) implicit none class ( rkf1210_class ), intent ( in ) :: me integer :: p !! order of the method p = 12 end function rkf1210_order !***************************************************************************************** !***************************************************************************************** !> !  Returns the order of the [[rkf1412]] method. pure function rkf1412_order ( me ) result ( p ) implicit none class ( rkf1412_class ), intent ( in ) :: me integer :: p !! order of the method p = 14 end function rkf1412_order !***************************************************************************************** !***************************************************************************************** !> !  Computes a starting step size to be used in solving initial !  value problems in ordinary differential equations. ! !  It is based on an estimate of the local lipschitz constant for the !  differential equation (lower bound on a norm of the jacobian) , !  a bound on the differential equation (first derivative), and !  a bound on the partial derivative of the equation with respect to !  the independent variable. (all approximated near the initial point a) ! !@note Subroutine hstart also uses the `me%stepsize_method%norm` !      function for computing vector norms ! !@note This routine is from [DDEABM](https://github.com/jacobwilliams/ddeabm). ! !# History !   * 820301  date written -- watts, h. a., (snla) !   * 890531  changed all specific intrinsics to generic.  (wrb) !   * 890831  modified array declarations.  (wrb) !   * 890911  removed unnecessary intrinsics.  (wrb) !   * 891024  changed references from dvnorm to dhvnrm.  (wrb) !   * 891214  prologue converted to version 4.0 format.  (bab) !   * 900328  added type section.  (wrb) !   * 910722  updated author section.  (als) !   * December, 2015 : Refactored this routine (jw) !   * April 2016 : Some modifications for the variable-step RK module (jw) subroutine hstart ( me , a , b , y , yprime , etol , h ) implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: a !! the initial point of integration. real ( wp ), intent ( in ) :: b !! a value of the independent variable used to define !! the direction of integration. a reasonable choice is to !! set `b` to the first point at which a solution is desired. !! you can also use `b`, if necessary, to restrict the length !! of the first integration step because the algorithm will !! not compute a starting step length which is bigger than !! `abs(b-a)`, unless `b` has been chosen too close to `a`. !! (it is presumed that hstart has been called with `b` !! different from `a` on the machine being used. also see the !! discussion about the parameter `small`.) real ( wp ), dimension ( me % n ), intent ( in ) :: y !! the vector of initial values of the `neq` solution !! components at the initial point `a`. real ( wp ), dimension ( me % n ), intent ( in ) :: yprime !! the vector of derivatives of the `neq` !! solution components at the initial point `a`. !! (defined by the differential equations in subroutine `me%f`) real ( wp ), dimension ( me % n ), intent ( in ) :: etol !! the vector of error tolerances corresponding to !! the `neq` solution components. it is assumed that all !! elements are positive. following the first integration !! step, the tolerances are expected to be used by the !! integrator in an error test which roughly requires that !! `abs(local error) <= etol` for each vector component. real ( wp ), intent ( out ) :: h !! appropriate starting step size to be attempted by the !! differential equation method. real ( wp ), dimension ( me % n ) :: spy !! work array which provide the routine with needed storage space. real ( wp ), dimension ( me % n ) :: pv !! work array which provide the routine with needed storage space. real ( wp ), dimension ( me % n ) :: yp !! work array which provide the routine with needed storage space. real ( wp ), dimension ( me % n ) :: sf !! work array which provide the routine with needed storage space. real ( wp ), parameter :: small = epsilon ( one ) real ( wp ), parameter :: big = huge ( one ) real ( wp ), parameter :: relper = small ** 0.375_wp integer :: j , k , lk real ( wp ) :: absdx , da , delf , dely ,& dfdub , dfdxb ,& dx , dy , fbnd ,& srydpb , tolexp , tolmin , tolp , tolsum , ydpb integer :: morder !! the order of the formula which will be used by !! the initial value method for taking the first integration !! step. morder = me % p dx = b - a absdx = abs ( dx ) ! compute an approximate bound (dfdxb) on the partial ! derivative of the equation with respect to the ! independent variable. protect against an overflow. ! also compute a bound (fbnd) on the first derivative ! locally. da = sign ( max ( min ( relper * abs ( a ), absdx ), 10 0.0_wp * small * abs ( a )), dx ) if ( da == zero ) da = relper * dx call me % f ( a + da , y , sf ) yp = sf - yprime delf = me % stepsize_method % norm ( yp ) dfdxb = big if ( delf < big * abs ( da )) dfdxb = delf / abs ( da ) fbnd = me % stepsize_method % norm ( sf ) ! compute an estimate (dfdub) of the local lipschitz ! constant for the system of differential equations. this ! also represents an estimate of the norm of the jacobian ! locally.  three iterations (two when neq=1) are used to ! estimate the lipschitz constant by numerical differences. ! the first perturbation vector is based on the initial ! derivatives and direction of integration. the second ! perturbation vector is formed using another evaluation of ! the differential equation.  the third perturbation vector ! is formed using perturbations based only on the initial ! values. components that are zero are always changed to ! non-zero values (except on the first iteration). when ! information is available, care is taken to ensure that ! components of the perturbation vector have signs which are ! consistent with the slopes of local solution curves. ! also choose the largest bound (fbnd) for the first ! derivative. ! ! perturbation vector size is held ! constant for all iterations. compute ! this change from the ! size of the vector of initial ! values. dely = relper * me % stepsize_method % norm ( y ) if ( dely == zero ) dely = relper dely = sign ( dely , dx ) delf = me % stepsize_method % norm ( yprime ) fbnd = max ( fbnd , delf ) if ( delf == zero ) then ! cannot have a null perturbation vector spy = zero yp = one delf = me % stepsize_method % norm ( yp ) else ! use initial derivatives for first perturbation spy = yprime yp = yprime end if dfdub = zero lk = min ( me % n + 1 , 3 ) do k = 1 , lk ! define perturbed vector of initial values pv = y + yp * ( dely / delf ) if ( k == 2 ) then ! use a shifted value of the independent variable ! in computing one estimate call me % f ( a + da , pv , yp ) pv = yp - sf else ! evaluate derivatives associated with perturbed ! vector and compute corresponding differences call me % f ( a , pv , yp ) pv = yp - yprime end if ! choose largest bounds on the first derivative ! and a local lipschitz constant fbnd = max ( fbnd , me % stepsize_method % norm ( yp )) delf = me % stepsize_method % norm ( pv ) if ( delf >= big * abs ( dely )) then ! protect against an overflow dfdub = big exit end if dfdub = max ( dfdub , delf / abs ( dely )) if ( k == lk ) exit ! choose next perturbation vector if ( delf == zero ) delf = one do j = 1 , me % n if ( k == 2 ) then dy = y ( j ) if ( dy == zero ) dy = dely / relper else dy = abs ( pv ( j )) if ( dy == zero ) dy = delf end if if ( spy ( j ) == zero ) spy ( j ) = yp ( j ) if ( spy ( j ) /= zero ) dy = sign ( dy , spy ( j )) yp ( j ) = dy end do delf = me % stepsize_method % norm ( yp ) end do ! compute a bound (ydpb) on the norm of the second derivative ydpb = dfdxb + dfdub * fbnd ! define the tolerance parameter upon which the starting step ! size is to be based.  a value in the middle of the error ! tolerance range is selected. tolmin = big tolsum = zero do k = 1 , me % n tolexp = log10 ( etol ( k )) tolmin = min ( tolmin , tolexp ) tolsum = tolsum + tolexp end do tolp = 1 0.0_wp ** ( 0.5_wp * ( tolsum / me % n + tolmin ) / ( morder + 1 )) ! compute a starting step size based on the above first and ! second derivative information ! ! restrict the step length to be not bigger ! than abs(b-a). (unless b is too close to a) h = absdx if ( ydpb == zero . and . fbnd == zero ) then ! both first derivative term (fbnd) and second ! derivative term (ydpb) are zero if ( tolp < one ) h = absdx * tolp elseif ( ydpb == zero ) then ! only second derivative term (ydpb) is zero if ( tolp < fbnd * absdx ) h = tolp / fbnd else ! second derivative term (ydpb) is non-zero srydpb = sqrt ( 0.5_wp * ydpb ) if ( tolp < srydpb * absdx ) h = tolp / srydpb end if ! further restrict the step length to be not bigger than  1/dfdub if ( h * dfdub > one ) h = one / dfdub ! finally, restrict the step length to be not ! smaller than 100*small*abs(a). however, if ! a=0. and the computed h underflowed to zero, ! the algorithm returns small*abs(b) for the step length. h = max ( h , 10 0.0_wp * small * abs ( a )) if ( h == zero ) h = small * abs ( b ) ! now set direction of integration h = sign ( h , dx ) end subroutine hstart !***************************************************************************************** !***************************************************************************************** !> !  computation of an initial step size guess ! !@note This routine is from dop853. It was modified for this module. function hinit ( me , x , y , posneg , f0 , hmax , atol , rtol ) implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: x real ( wp ), dimension (:), intent ( in ) :: y !! dimension(n) real ( wp ), intent ( in ) :: posneg !! posneg = sign(1.0_wp,xend-x) real ( wp ), dimension (:), intent ( in ) :: f0 !! dimension(n) real ( wp ), intent ( in ) :: hmax real ( wp ), dimension (:), intent ( in ) :: atol real ( wp ), dimension (:), intent ( in ) :: rtol real ( wp ) :: der12 , der2 , dnf , dny , h , h1 , hinit , sk integer :: i integer :: iord !! order of the method real ( wp ), dimension ( me % n ) :: f1 , y1 iord = me % p ! compute a first guess for explicit euler as !   h = 0.01 * norm (y0) / norm (f0) ! the increment for explicit euler is small ! compared to the solution dnf = zero dny = zero do i = 1 , me % n sk = atol ( i ) + rtol ( i ) * abs ( y ( i )) dnf = dnf + ( f0 ( i ) / sk ) ** 2 dny = dny + ( y ( i ) / sk ) ** 2 end do if ( dnf <= 1.0e-10_wp . or . dny <= 1.0e-10_wp ) then h = 1.0e-6_wp else h = sqrt ( dny / dnf ) * 0.01_wp end if h = min ( h , hmax ) h = sign ( h , posneg ) ! perform an explicit euler step do i = 1 , me % n y1 ( i ) = y ( i ) + h * f0 ( i ) end do call me % f ( x + h , y1 , f1 ) ! estimate the second derivative of the solution der2 = zero do i = 1 , me % n sk = atol ( i ) + rtol ( i ) * abs ( y ( i )) der2 = der2 + (( f1 ( i ) - f0 ( i )) / sk ) ** 2 end do der2 = sqrt ( der2 ) / h ! step size is computed such that !  h**iord * max ( norm (f0), norm (der2)) = 0.01 der12 = max ( abs ( der2 ), sqrt ( dnf )) if ( der12 <= 1.0e-15_wp ) then h1 = max ( 1.0e-6_wp , abs ( h ) * 1.0e-3_wp ) else h1 = ( 0.01_wp / der12 ) ** ( 1.0_wp / iord ) end if h = min ( 10 0.0_wp * abs ( h ), h1 , hmax ) hinit = sign ( h , posneg ) end function hinit !***************************************************************************************** !***************************************************************************************** !> !  Unit tests for step size adjustment routines. subroutine step_size_test () implicit none type ( stepsize_class ) :: s1 !! for testing the different methods type ( stepsize_class ) :: s2 !! for testing the different methods type ( stepsize_class ) :: s3 !! for testing the different methods real ( wp ) :: h !! current step size real ( wp ) :: tol !! abs error tolerance real ( wp ) :: err !! truncation error estimate integer :: p !! order of the method real ( wp ) :: hnew !! new step size logical :: accept !! if the step is accepted write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' step_size_test' write ( * , * ) '---------------' write ( * , * ) '' h = 1 0.0_wp tol = 1.0e-9_wp err = 1.0e-7_wp p = 4 call s1 % initialize () call s1 % compute_stepsize ( h , tol , err , p , hnew , accept ) write ( * , * ) 'stepsize_hull    : hnew = ' , hnew call s2 % initialize () call s2 % compute_stepsize ( h , tol , err , p , hnew , accept ) write ( * , * ) 'stepsize_stoer_1 : hnew = ' , hnew call s3 % initialize () call s3 % compute_stepsize ( h , tol , err , p , hnew , accept ) write ( * , * ) 'stepsize_stoer_2 : hnew = ' , hnew end subroutine step_size_test !***************************************************************************************** !***************************************************************************************** !> !  Unit test of the [[rk_module]]. !  Integrate a two-body orbit around the Earth. subroutine rk_test_variable_step () use orbital_mechanics_module , only : orbital_elements_to_rv use conversion_module , only : deg2rad implicit none !type,extends(rkf78_class) :: spacecraft !type,extends(rkf89_class) :: spacecraft !type,extends(rkv89_class) :: spacecraft !type,extends(rkf108_class) :: spacecraft !type,extends(rkf1210_class) :: spacecraft type , extends ( rkf1412_class ) :: spacecraft !! spacecraft propagation type. real ( wp ) :: mu = zero !! central body gravitational parameter (km3/s2) integer :: fevals = 0 !! number of function evaluations logical :: first = . true . !! first point is being exported end type spacecraft integer , parameter :: n = 6 !! number of state variables real ( wp ), parameter :: tol = 1.0e-12_wp !! event location tolerance type ( spacecraft ) :: s , s2 real ( wp ) :: t0 , tf , x0 ( n ), dt , xf ( n ), x02 ( n ), gf , tf_actual , rtol , atol integer :: ierr !! error flag type ( stepsize_class ) :: sz integer :: icase logical :: relative_err real ( wp ) :: safety_factor , hfactor_accept integer :: p_exponent_offset real ( wp ) :: mu real ( wp ) :: a , p , ecc , inc , raan , aop , tru real ( wp ), dimension ( 3 ) :: r , v write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' rk_variable_step_test' write ( * , * ) '---------------' write ( * , * ) '' !*************************************************************************** do icase = 1 , 4 write ( * , * ) '' write ( * , * ) '***************' write ( * , * ) ' case' , icase write ( * , * ) '***************' write ( * , * ) '' ! ... relative_err,safety_factor,p_exponent_offset don't !     seem to change the results at all .... select case ( icase ) case ( 1 ) ! defaults relative_err = . false . safety_factor = 0.8_wp p_exponent_offset = 1 hfactor_accept = 2.0_wp ! changing this does change result case ( 2 ) relative_err = . false . safety_factor = 0.9_wp p_exponent_offset = 1 hfactor_accept = 5.0_wp case ( 3 ) relative_err = . false . safety_factor = 0.95_wp p_exponent_offset = 1 hfactor_accept = 1 0.0_wp case ( 4 ) relative_err = . false . safety_factor = 0.9_wp p_exponent_offset = 0 hfactor_accept = 2.0_wp end select !step size constructor: !call sz%initialize(hmin=1.0e-6_wp,hmax=1.0e6_wp) call sz % initialize ( hmin = 1.0e-6_wp , & hmax = 1.0e+6_wp , & hfactor_reject = 0.5_wp , & hfactor_accept = hfactor_accept , & max_attempts = 1000 , & accept_mode = 2 , & norm = maxval_func , & relative_err = relative_err , & safety_factor = safety_factor , & p_exponent_offset = p_exponent_offset ) !integrator constructor: call s % initialize ( n = n , f = twobody , rtol = [ 1.0e-15_wp ], atol = [ 1.0e-12_wp ],& stepsize_method = sz , report = twobody_report ) !initial conditions: !write(*,*) 'general elliptical:' mu = 3.9860043543609593E+05_wp ! for earth a = 800 0.0_wp ! km ecc = 0.1_wp inc = 4 5.0_wp * deg2rad raan = 4 5.0_wp * deg2rad aop = 4 5.0_wp * deg2rad tru = 4 5.0_wp * deg2rad p = a * ( one - ecc ** 2 ) call orbital_elements_to_rv ( mu , p , ecc , inc , raan , aop , tru , r , v ) x0 = [ r , v ] !x0   = [10000.0_wp,10000.0_wp,10000.0_wp,&   ! initial state [r,v] (km,km/s) !        1.0_wp,2.0_wp,3.0_wp] t0 = zero ! initial time (sec) !dt   = 0.0_wp           ! automatically compute an initial time step (sec) dt = 1 0.0_wp ! initial time step (sec) tf = 1000 0.0_wp ! final time (sec) s % mu = 39860 0.436233_wp ! main body is Earth s % num_rejected_steps = 0 s % fevals = 0 s % first = . true . call s % integrate ( t0 , x0 , dt , tf , xf , ierr ) !forward write ( * , * ) '' write ( * , * ) 'ierr = ' , ierr write ( * , '(A/,*(F15.6/))' ) 'Final state:' , xf write ( * , '(A,I5)' ) 'Function evaluations:' , s % fevals write ( * , '(A,I5)' ) 'Number of rejected steps:' , s % num_rejected_steps ! why is this 0 when ierr = -3 ??? s % num_rejected_steps = 0 s % fevals = 0 s % report => null () !disable reporting call s % integrate ( tf , xf , - dt , t0 , x02 , ierr ) !backwards write ( * , * ) 'ierr = ' , ierr write ( * , '(A/,*(E20.12/))' ) 'Error:' , x02 - x0 write ( * , '(A,I5)' ) 'Function evaluations:' , s % fevals write ( * , '(A,I5)' ) 'Number of rejected steps:' , s % num_rejected_steps write ( * , * ) '' end do !*************************************************************************** !event finding test: write ( * , * ) ' Event test - integrate until z = 12,000' ! NOTE: the following causes an ICE in gfortran 7.1, but works with ifort: ! s2 = spacecraft(n=n,f=twobody,g=twobody_event,mu=398600.436233_wp,& !                  rtol=[1.0e-12_wp],atol=[1.0e-12_wp],& !                  stepsize_method=sz,report=twobody_report) ! do it this way instead: call s2 % initialize ( n = n , f = twobody , g = twobody_event ,& rtol = [ 1.0e-12_wp ], atol = [ 1.0e-12_wp ],& stepsize_method = sz ,& report = twobody_report ) s2 % mu = 39860 0.436233_wp s2 % fevals = 0 s2 % first = . true . x0 = [ 1000 0.0_wp , 1000 0.0_wp , 1000 0.0_wp ,& !initial state [r,v] (km,km/s) 1.0_wp , 2.0_wp , 3.0_wp ] t0 = zero !initial time (sec) dt = 1 0.0_wp !time step (sec) tf = 100 0.0_wp !final time (sec) call s2 % integrate_to_event ( t0 , x0 , dt , tf , tol , tf_actual , xf , gf , ierr ) write ( * , * ) '' write ( * , '(A,I5)' ) 'ierr:       ' , ierr write ( * , '(A/,*(F15.6/))' ) 'Final time: ' , tf_actual write ( * , '(A/,*(F15.6/))' ) 'Final state:' , xf write ( * , '(A/,*(F15.6/))' ) 'Event func :' , gf write ( * , '(A,I5)' ) 'Function evaluations:' , s2 % fevals write ( * , '(A,I5)' ) 'Number of rejected steps:' , s2 % num_rejected_steps contains !***************************************************************************************** !********************************************************* subroutine twobody ( me , t , x , xdot ) !! derivative routine for two-body orbit propagation implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), dimension (:), intent ( out ) :: xdot real ( wp ), dimension ( 3 ) :: r , v , a_grav real ( wp ) :: rmag select type ( me ) class is ( spacecraft ) r = x ( 1 : 3 ) v = x ( 4 : 6 ) rmag = norm2 ( r ) a_grav = - me % mu / rmag ** 3 * r !acceleration due to gravity xdot ( 1 : 3 ) = v xdot ( 4 : 6 ) = a_grav me % fevals = me % fevals + 1 end select end subroutine twobody !********************************************************* !********************************************************* subroutine twobody_report ( me , t , x ) !! report function - write time,state to console implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension (:), intent ( in ) :: x select type ( me ) class is ( spacecraft ) if ( me % first ) then !print header write ( * , * ) '' write ( * , '(*(A15,1X))' ) 'time (sec)' , 'x (km)' , 'y (km)' , 'z (km)' ,& 'vx (km/s)' , 'vy (km/s)' , 'vz (km/s)' me % first = . false . end if end select write ( * , '(*(F15.6,1X))' ) t , x end subroutine twobody_report !********************************************************* !********************************************************* subroutine twobody_event ( me , t , x , g ) !! event function (z = 12,000) implicit none class ( rk_variable_step_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: t real ( wp ), dimension (:), intent ( in ) :: x real ( wp ), intent ( out ) :: g g = x ( 3 ) - 1200 0.0_wp end subroutine twobody_event !********************************************************* end subroutine rk_test_variable_step !***************************************************************************************** !***************************************************************************************** end module rk_module_variable_step !*****************************************************************************************","tags":"","url":"sourcefile/rk_module_variable_step.f90.html"},{"title":"kind_module.F90 – fortran-astrodynamics-toolkit","text":"Files dependent on this one sourcefile~~kind_module.f90~~AfferentGraph sourcefile~kind_module.f90 kind_module.F90 sourcefile~analytical_ephemeris_module.f90 analytical_ephemeris_module.f90 sourcefile~analytical_ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90 conversion_module.f90 sourcefile~analytical_ephemeris_module.f90->sourcefile~conversion_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~analytical_ephemeris_module.f90->sourcefile~numbers_module.f90 sourcefile~bplane_module.f90 bplane_module.f90 sourcefile~bplane_module.f90->sourcefile~kind_module.f90 sourcefile~bplane_module.f90->sourcefile~numbers_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~bplane_module.f90->sourcefile~vector_module.f90 sourcefile~brent_module.f90 brent_module.f90 sourcefile~brent_module.f90->sourcefile~kind_module.f90 sourcefile~brent_module.f90->sourcefile~numbers_module.f90 sourcefile~c_interface_module.f90 c_interface_module.f90 sourcefile~c_interface_module.f90->sourcefile~kind_module.f90 sourcefile~geopotential_module.f90 geopotential_module.f90 sourcefile~c_interface_module.f90->sourcefile~geopotential_module.f90 sourcefile~celestial_body_module.f90 celestial_body_module.f90 sourcefile~celestial_body_module.f90->sourcefile~kind_module.f90 sourcefile~celestial_body_module.f90->sourcefile~numbers_module.f90 sourcefile~complex_step.f90 complex_step.f90 sourcefile~complex_step.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~kind_module.f90 sourcefile~conversion_module.f90->sourcefile~numbers_module.f90 sourcefile~crtbp_module.f90 crtbp_module.f90 sourcefile~crtbp_module.f90->sourcefile~kind_module.f90 sourcefile~crtbp_module.f90->sourcefile~celestial_body_module.f90 sourcefile~math_module.f90 math_module.f90 sourcefile~crtbp_module.f90->sourcefile~math_module.f90 sourcefile~crtbp_module.f90->sourcefile~numbers_module.f90 sourcefile~drag_module.f90 drag_module.f90 sourcefile~drag_module.f90->sourcefile~kind_module.f90 sourcefile~eispack_module.f90 eispack_module.f90 sourcefile~eispack_module.f90->sourcefile~kind_module.f90 sourcefile~eispack_module.f90->sourcefile~numbers_module.f90 sourcefile~ephemeris_module.f90 ephemeris_module.f90 sourcefile~ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~kind_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~analytical_ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~bplane_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~brent_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~c_interface_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~celestial_body_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~complex_step.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~conversion_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~crtbp_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~drag_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~eispack_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~ephemeris_module.f90 sourcefile~geodesy_module.f90 geodesy_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geodesy_module.f90 sourcefile~geometry_module.f90 geometry_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geometry_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geopotential_module.f90 sourcefile~gooding_module.f90 gooding_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~gooding_module.f90 sourcefile~gravity_module.f90 gravity_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~gravity_module.f90 sourcefile~halo_orbit_module.f90 halo_orbit_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~halo_orbit_module.f90 sourcefile~iau_orientation_module.f90 iau_orientation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~iau_orientation_module.f90 sourcefile~jpl_ephemeris_module.f90 jpl_ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~kepler_module.f90 kepler_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~kepler_module.f90 sourcefile~lambert_module.f90 lambert_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lambert_module.f90 sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~math_module.f90 sourcefile~matrix_module.f90 matrix_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~matrix_module.f90 sourcefile~minpack_module.f90 minpack_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~minpack_module.f90 sourcefile~modified_equinoctial_module.f90 modified_equinoctial_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~modified_equinoctial_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~numbers_module.f90 sourcefile~obliquity_module.f90 obliquity_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~obliquity_module.f90 sourcefile~orbital_mechanics_module.f90 orbital_mechanics_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~orbital_mechanics_module.f90 sourcefile~random_module.f90 random_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~random_module.f90 sourcefile~relative_motion_module.f90 relative_motion_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~relative_motion_module.f90 sourcefile~rk_module.f90 rk_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~rk_module.f90 sourcefile~rk_module_variable_step.f90 rk_module_variable_step.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~rk_module_variable_step.f90 sourcefile~standish_module.f90 standish_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~standish_module.f90 sourcefile~time_module.f90 time_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~time_module.f90 sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~vector_module.f90 sourcefile~geodesy_module.f90->sourcefile~kind_module.f90 sourcefile~geodesy_module.f90->sourcefile~numbers_module.f90 sourcefile~geometry_module.f90->sourcefile~kind_module.f90 sourcefile~geometry_module.f90->sourcefile~vector_module.f90 sourcefile~geopotential_module.f90->sourcefile~kind_module.f90 sourcefile~geopotential_module.f90->sourcefile~conversion_module.f90 sourcefile~geopotential_module.f90->sourcefile~numbers_module.f90 sourcefile~geopotential_module.f90->sourcefile~random_module.f90 sourcefile~geopotential_module.f90->sourcefile~vector_module.f90 sourcefile~gooding_module.f90->sourcefile~kind_module.f90 sourcefile~gooding_module.f90->sourcefile~numbers_module.f90 sourcefile~gravity_module.f90->sourcefile~kind_module.f90 sourcefile~gravity_module.f90->sourcefile~numbers_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~kind_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~celestial_body_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~crtbp_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~math_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~matrix_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~minpack_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~numbers_module.f90 sourcefile~halo_orbit_module.f90->sourcefile~rk_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~kind_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~conversion_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~numbers_module.f90 sourcefile~iau_orientation_module.f90->sourcefile~vector_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~conversion_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~numbers_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~time_module.f90 sourcefile~kepler_module.f90->sourcefile~kind_module.f90 sourcefile~newton_module.f90 newton_module.f90 sourcefile~kepler_module.f90->sourcefile~newton_module.f90 sourcefile~kepler_module.f90->sourcefile~numbers_module.f90 sourcefile~lambert_module.f90->sourcefile~kind_module.f90 sourcefile~lambert_module.f90->sourcefile~gooding_module.f90 sourcefile~lambert_module.f90->sourcefile~numbers_module.f90 sourcefile~lambert_module.f90->sourcefile~random_module.f90 sourcefile~lambert_module.f90->sourcefile~vector_module.f90 sourcefile~lighting_module.f90->sourcefile~kind_module.f90 sourcefile~lighting_module.f90->sourcefile~celestial_body_module.f90 sourcefile~lighting_module.f90->sourcefile~conversion_module.f90 sourcefile~lighting_module.f90->sourcefile~ephemeris_module.f90 sourcefile~lighting_module.f90->sourcefile~math_module.f90 sourcefile~lighting_module.f90->sourcefile~numbers_module.f90 sourcefile~lighting_module.f90->sourcefile~transformation_module.f90 sourcefile~lighting_module.f90->sourcefile~vector_module.f90 sourcefile~math_module.f90->sourcefile~kind_module.f90 sourcefile~math_module.f90->sourcefile~numbers_module.f90 sourcefile~matrix_module.f90->sourcefile~kind_module.f90 sourcefile~matrix_module.f90->sourcefile~numbers_module.f90 sourcefile~minpack_module.f90->sourcefile~kind_module.f90 sourcefile~minpack_module.f90->sourcefile~numbers_module.f90 sourcefile~modified_equinoctial_module.f90->sourcefile~kind_module.f90 sourcefile~modified_equinoctial_module.f90->sourcefile~numbers_module.f90 sourcefile~modified_equinoctial_module.f90->sourcefile~vector_module.f90 sourcefile~newton_module.f90->sourcefile~kind_module.f90 sourcefile~newton_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~obliquity_module.f90->sourcefile~kind_module.f90 sourcefile~obliquity_module.f90->sourcefile~conversion_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~kind_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~math_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~numbers_module.f90 sourcefile~orbital_mechanics_module.f90->sourcefile~vector_module.f90 sourcefile~random_module.f90->sourcefile~kind_module.f90 sourcefile~relative_motion_module.f90->sourcefile~kind_module.f90 sourcefile~relative_motion_module.f90->sourcefile~numbers_module.f90 sourcefile~relative_motion_module.f90->sourcefile~vector_module.f90 sourcefile~rk_module.f90->sourcefile~kind_module.f90 sourcefile~rk_module.f90->sourcefile~brent_module.f90 sourcefile~rk_module.f90->sourcefile~numbers_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~kind_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~brent_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~conversion_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~numbers_module.f90 sourcefile~rk_module_variable_step.f90->sourcefile~orbital_mechanics_module.f90 sourcefile~spice_ephemeris_module.f90 spice_ephemeris_module.F90 sourcefile~spice_ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~spice_ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~spice_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~spice_ephemeris_module.f90->sourcefile~numbers_module.f90 sourcefile~standish_module.f90->sourcefile~kind_module.f90 sourcefile~standish_module.f90->sourcefile~celestial_body_module.f90 sourcefile~standish_module.f90->sourcefile~conversion_module.f90 sourcefile~standish_module.f90->sourcefile~ephemeris_module.f90 sourcefile~standish_module.f90->sourcefile~numbers_module.f90 sourcefile~standish_module.f90->sourcefile~time_module.f90 sourcefile~time_module.f90->sourcefile~kind_module.f90 sourcefile~time_module.f90->sourcefile~conversion_module.f90 sourcefile~transformation_module.f90->sourcefile~kind_module.f90 sourcefile~transformation_module.f90->sourcefile~celestial_body_module.f90 sourcefile~transformation_module.f90->sourcefile~ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~iau_orientation_module.f90 sourcefile~transformation_module.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~numbers_module.f90 sourcefile~transformation_module.f90->sourcefile~obliquity_module.f90 sourcefile~transformation_module.f90->sourcefile~time_module.f90 sourcefile~transformation_module.f90->sourcefile~vector_module.f90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  Define the numeric kinds. module kind_module use , intrinsic :: iso_fortran_env , only : real32 , real64 , real128 implicit none private #ifdef REAL32 integer , parameter , public :: wp = real32 !! real kind used by this module [4 bytes] #elif REAL64 integer , parameter , public :: wp = real64 !! real kind used by this module [8 bytes] #elif REAL128 integer , parameter , public :: wp = real128 !! real kind used by this module [16 bytes] #else integer , parameter , public :: wp = real64 !! real kind used by this module [8 bytes] #endif end module kind_module !*****************************************************************************************","tags":"","url":"sourcefile/kind_module.f90.html"},{"title":"geometry_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~geometry_module.f90~~EfferentGraph sourcefile~geometry_module.f90 geometry_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~geometry_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~geometry_module.f90->sourcefile~vector_module.f90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~geometry_module.f90~~AfferentGraph sourcefile~geometry_module.f90 geometry_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~geometry_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams !  date: 2012 ! !  Geometry routines. module geometry_module use kind_module , only : wp use vector_module , only : cross implicit none private !public routines: public :: locpt public :: distance_from_point_to_line public :: distance_from_point_to_line_segment public :: distance_from_point_to_path !unit test routine: public :: geometry_unit_test contains !***************************************************************************************** !***************************************************************************************** !> !  given a polygonal line connecting the vertices (x(i),y(i)) !  (i = 1,...,n) taken in this order. it is assumed that the !  polygonal path is a loop, where (x(n),y(n)) = (x(1),y(1)) !  or there is an arc from (x(n),y(n)) to (x(1),y(1)). ! !  (x0,y0) is an arbitrary point and l and m are variables. !  l and m are assigned the following values: ! !     l = -1   if (x0,y0) is outside the polygonal path !     l =  0   if (x0,y0) lies on the polygonal path !     l =  1   if (x0,y0) is inside the polygonal path ! !  m = 0 if (x0,y0) is on or outside the path. if (x0,y0) !  is inside the path then m is the winding number of the !  path around the point (x0,y0). ! !# History !  * Original version from the NSWC Library !  * Modified by J. Williams : 08/04/2012 : refactored to modern Fortran pure subroutine locpt ( x0 , y0 , x , y , n , l , m ) implicit none !arguments: integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: y0 real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension ( n ), intent ( in ) :: y integer , intent ( out ) :: l integer , intent ( out ) :: m !constants: real ( wp ), parameter :: eps = epsilon ( 1.0_wp ) real ( wp ), parameter :: pi = atan2 ( 0.0_wp , - 1.0_wp ) real ( wp ), parameter :: pi2 = 2.0_wp * pi real ( wp ), parameter :: tol = 4.0_wp * eps * pi !local variables: integer :: i , n0 real ( wp ) :: u , v , theta1 , sum , theta , angle , thetai n0 = n if ( x ( 1 ) == x ( n ) . and . y ( 1 ) == y ( n )) n0 = n - 1 l = - 1 m = 0 u = x ( 1 ) - x0 v = y ( 1 ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path else if ( n0 >= 2 ) then theta1 = atan2 ( v , u ) sum = 0.0_wp theta = theta1 do i = 2 , n0 u = x ( i ) - x0 v = y ( i ) - y0 if ( u == 0.0_wp . and . v == 0.0_wp ) then l = 0 !(x0, y0) is on the boundary of the path exit end if thetai = atan2 ( v , u ) angle = abs ( thetai - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path exit end if if ( angle > pi ) angle = angle - pi2 if ( theta > thetai ) angle = - angle sum = sum + angle theta = thetai end do if ( l /= 0 ) then angle = abs ( theta1 - theta ) if ( abs ( angle - pi ) < tol ) then l = 0 !(x0, y0) is on the boundary of the path else if ( angle > pi ) angle = angle - pi2 if ( theta > theta1 ) angle = - angle sum = sum + angle !sum = 2*pi*m where m is the winding number m = abs ( sum ) / pi2 + 0.2_wp if ( m /= 0 ) then l = 1 if ( sum < 0.0_wp ) m = - m end if end if end if end if end if end subroutine locpt !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date:8/2012 ! !  Compute the distance between the point X and the line defined !  by the two points X1 and X2. ! !# References !  1. http://mathworld.wolfram.com/Point-LineDistance2-Dimensional.html pure function distance_from_point_to_line ( x1 , x2 , x ) result ( d ) implicit none real ( wp ), dimension ( 3 ), intent ( in ) :: x1 real ( wp ), dimension ( 3 ), intent ( in ) :: x2 real ( wp ), dimension ( 3 ), intent ( in ) :: x real ( wp ) :: d real ( wp ), dimension ( 3 ) :: x21 real ( wp ) :: x21_mag x21 = x2 - x1 x21_mag = norm2 ( x21 ) if ( x21_mag /= 0.0_wp ) then d = norm2 ( cross ( x21 , x1 - x ) ) / x21_mag else d = norm2 ( x1 - x ) end if end function distance_from_point_to_line !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date:8/2012 ! !  Compute the distance between a line segment and a point. ! !# References !  1. http://forums.codeguru.com/showthread.php?194400-Distance-between-point-and-line-segment ! !@note x,x1,x2 should all be the same length pure function distance_from_point_to_line_segment ( x1 , x2 , x ) result ( d ) implicit none real ( wp ), dimension (:), intent ( in ) :: x1 real ( wp ), dimension (:), intent ( in ) :: x2 real ( wp ), dimension (:), intent ( in ) :: x real ( wp ) :: d real ( wp ), dimension ( size ( x1 )) :: x12 real ( wp ) :: s real ( wp ) :: x12_mag x12 = x1 - x2 x12_mag = norm2 ( x12 ) if ( x12_mag == 0.0_wp ) then d = norm2 ( x1 - x ) else s = dot_product ( x1 - x , x12 ) / dot_product ( x12 , x12 ) !if the projection is not on the segment, ! then use the closest end point: if ( s < 0.0_wp ) then s = 0.0_wp else if ( s > 1.0_wp ) then s = 1.0_wp end if d = norm2 ( x - x1 + s * x12 ) end if end function distance_from_point_to_line_segment !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date:8/2012 ! !  Compute the distance between a point and a polygonal path. !  Given a point (x0,y0), and a path (x(n),y(n)), the distance !  to the path is the distance to the closest line segment (x(i),y(i)). function distance_from_point_to_path ( x0 , y0 , x , y , n ) result ( d ) implicit none !arguments: integer , intent ( in ) :: n real ( wp ), intent ( in ) :: x0 real ( wp ), intent ( in ) :: y0 real ( wp ), dimension ( n ), intent ( in ) :: x real ( wp ), dimension ( n ), intent ( in ) :: y real ( wp ) :: d integer :: l , m , i real ( wp ) :: dmin !is the point inside, outside, or on the path: call locpt ( x0 , y0 , x , y , n , l , m ) select case ( l ) case ( 1 , - 1 ) !point is not on the path if ( n == 1 ) then !only one point in the path: d = norm2 ([ x0 - x ( 1 ), y0 - y ( 1 )]) else do i = 1 , n !loop through all line segments in the path !the distance to the path is the distance from the closest line segment if ( i < n ) then d = distance_from_point_to_line_segment ( & [ x ( i ), y ( i )], [ x ( i + 1 ), y ( i + 1 )], [ x0 , y0 ]) else !note: if 1st /= nth point, then have to check that line segment also. if ( x ( 1 ) /= x ( n ) . or . y ( 1 ) /= y ( n )) then d = distance_from_point_to_line_segment ( & [ x ( n ), y ( n )], [ x ( 1 ), y ( 1 )], [ x0 , y0 ]) end if end if !get lowest value: if ( d < dmin . or . i == 1 ) dmin = d end do end if !set sign of d: d = dmin * l ! <0 if outside the path ! >0 if inside the path case default !point is on the path d = 0.0_wp end select end function distance_from_point_to_path !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date:8/2012 ! !  Unit test routine ! !# Output ! !    x0,y0=  0.59999999999999998       0.59999999999999998 !    l=           1 !    m=          -1 !    dist to path=  0.40000000000000002 ! !    x0,y0=   1.5000000000000000       0.50000000000000000 !    l=          -1 !    m=           0 !    dist to path= -0.50000000000000000 ! !    x0,y0=   1.0000000000000000        0.0000000000000000 !    l=           0 !    m=           0 !    dist to path=   0.0000000000000000 subroutine geometry_unit_test () implicit none integer :: l , m real ( wp ) :: x0 , y0 !a 1x1 square: integer , parameter :: n = 4 real ( wp ), dimension ( n ), parameter :: x = [ 0.0_wp , 0.0_wp , 1.0_wp , 1.0_wp ] real ( wp ), dimension ( n ), parameter :: y = [ 0.0_wp , 1.0_wp , 1.0_wp , 0.0_wp ] x0 = 0.6_wp !inside the path y0 = 0.6_wp call go () x0 = 1.5_wp !outside the path y0 = 0.5_wp call go () x0 = 1 0.0_wp !outside the path y0 = 0.0_wp call go () x0 = 1.0_wp !on the path y0 = 0.0_wp call go () contains subroutine go () !call locpt for the x0,y0 point, and print results implicit none real ( wp ) :: d call locpt ( x0 , y0 , x , y , n , l , m ) write ( * , * ) '' write ( * , * ) 'x0,y0=' , x0 , y0 write ( * , * ) 'l=' , l write ( * , * ) 'm=' , m d = distance_from_point_to_path ( x0 , y0 , x , y , n ) write ( * , * ) 'dist to path=' , d end subroutine go end subroutine geometry_unit_test !***************************************************************************************** !***************************************************************************************** end module geometry_module !*****************************************************************************************","tags":"","url":"sourcefile/geometry_module.f90.html"},{"title":"ephemeris_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~ephemeris_module.f90~~EfferentGraph sourcefile~ephemeris_module.f90 ephemeris_module.f90 sourcefile~celestial_body_module.f90 celestial_body_module.f90 sourcefile~ephemeris_module.f90->sourcefile~celestial_body_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~ephemeris_module.f90->sourcefile~kind_module.f90 sourcefile~celestial_body_module.f90->sourcefile~kind_module.f90 sourcefile~base_class_module.f90 base_class_module.f90 sourcefile~celestial_body_module.f90->sourcefile~base_class_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~celestial_body_module.f90->sourcefile~numbers_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~ephemeris_module.f90~~AfferentGraph sourcefile~ephemeris_module.f90 ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~ephemeris_module.f90 sourcefile~jpl_ephemeris_module.f90 jpl_ephemeris_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~jpl_ephemeris_module.f90 sourcefile~lighting_module.f90 lighting_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~lighting_module.f90 sourcefile~standish_module.f90 standish_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~standish_module.f90 sourcefile~transformation_module.f90 transformation_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~transformation_module.f90 sourcefile~jpl_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~lighting_module.f90->sourcefile~ephemeris_module.f90 sourcefile~lighting_module.f90->sourcefile~transformation_module.f90 sourcefile~spice_ephemeris_module.f90 spice_ephemeris_module.F90 sourcefile~spice_ephemeris_module.f90->sourcefile~ephemeris_module.f90 sourcefile~standish_module.f90->sourcefile~ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~ephemeris_module.f90 sourcefile~transformation_module.f90->sourcefile~jpl_ephemeris_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> !  Abstract class for celestial body ephemerides. module ephemeris_module use kind_module use celestial_body_module implicit none private type , abstract , public :: ephemeris_class !! abstract class for interfacing with ephemeris systems. private contains private procedure ( rv_func ), deferred , public :: get_rv !! get the state of one body w.r.t. another body. procedure ( r_func ), deferred , public :: get_r !! get the position of one body w.r.t. another body. end type ephemeris_class abstract interface subroutine rv_func ( me , et , targ , obs , rv , status_ok ) !! function to return the state of the `targ` body relative to !! the `obs` body, in the inertial frame [ICRF]. import :: wp , ephemeris_class , celestial_body implicit none class ( ephemeris_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: et !! ephemeris time [sec] type ( celestial_body ), intent ( in ) :: targ !! target body type ( celestial_body ), intent ( in ) :: obs !! observer body real ( wp ), dimension ( 6 ), intent ( out ) :: rv !! state of targ w.r.t. obs logical , intent ( out ) :: status_ok !! true if there were no problems end subroutine rv_func subroutine r_func ( me , et , targ , obs , r , status_ok ) !! function to return the position of the `targ` body relative to !! the `obs` body, in the inertial frame [ICRF]. import :: wp , ephemeris_class , celestial_body implicit none class ( ephemeris_class ), intent ( inout ) :: me real ( wp ), intent ( in ) :: et !! ephemeris time [sec] type ( celestial_body ), intent ( in ) :: targ !! target body type ( celestial_body ), intent ( in ) :: obs !! observer body real ( wp ), dimension ( 3 ), intent ( out ) :: r !! position vector of targ w.r.t. obs logical , intent ( out ) :: status_ok !! true if there were no problems end subroutine r_func end interface !***************************************************************************************** end module ephemeris_module !*****************************************************************************************","tags":"","url":"sourcefile/ephemeris_module.f90.html"},{"title":"bplane_module.f90 – fortran-astrodynamics-toolkit","text":"This file depends on sourcefile~~bplane_module.f90~~EfferentGraph sourcefile~bplane_module.f90 bplane_module.f90 sourcefile~kind_module.f90 kind_module.F90 sourcefile~bplane_module.f90->sourcefile~kind_module.f90 sourcefile~numbers_module.f90 numbers_module.f90 sourcefile~bplane_module.f90->sourcefile~numbers_module.f90 sourcefile~vector_module.f90 vector_module.f90 sourcefile~bplane_module.f90->sourcefile~vector_module.f90 sourcefile~numbers_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~kind_module.f90 sourcefile~vector_module.f90->sourcefile~numbers_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Files dependent on this one sourcefile~~bplane_module.f90~~AfferentGraph sourcefile~bplane_module.f90 bplane_module.f90 sourcefile~fortran_astrodynamics_toolkit.f90 fortran_astrodynamics_toolkit.f90 sourcefile~fortran_astrodynamics_toolkit.f90->sourcefile~bplane_module.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Source Code !***************************************************************************************** !> author: Jacob Williams ! !  B-plane and hyperbolic routines. module bplane_module use kind_module , only : wp use numbers_module use vector_module implicit none private public :: bplane public :: calculate_bplane_data public :: hyperbolic_turning_angle public :: vinf_to_energy !unit tests: public :: bplane_test contains !***************************************************************************************** !***************************************************************************************** !> !  Compute B-plane parameters from position and velocity. ! !# References !  1. W. Kizner, \"A method of describing miss distances for lunar and interplanetary trajectories\", !     Planetary and Space Science, Volume 7, July 1961. !  2. W. Kizner, \"[Some orbital elements useful in space trajectory calculations](http://www.dtic.mil/dtic/tr/fulltext/u2/263968.pdf)\", !     JPL Technical Release No. 34-84, July 25, 1960. !  3. A. B. Sergeyevsky, G. C. Snyder, R. A. Cunniff, !     \"[Interplanetary Mission Design Handbook, Volume I, Part 2](http://ntrs.nasa.gov/archive/nasa/casi.ntrs.nasa.gov/19840010158.pdf)\", !     JPL Publication 82-43, September 15, 1983. !  4. [B-Plane Targeting](http://www.agi.com/resources/help/online/stk/10.1/index.html?page=source%2Fextfile%2Fgator%2Feq-bplane.htm) subroutine bplane ( mu , rv , vinfvec , bmag , theta , BdotT , BdotR , status_ok ) implicit none real ( wp ), intent ( in ) :: mu !! central body grav parameter  (km&#94;3/s&#94;2)  real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! state vector (km,km/s) real ( wp ), dimension ( 3 ), intent ( out ) :: vinfvec !! incoming V-infinity vector (km/s) real ( wp ), intent ( out ) :: bmag !! magnitude of B vector (km) real ( wp ), intent ( out ) :: theta !! aim point orientation [rad] real ( wp ), intent ( out ) :: BdotT !!  \\mathbf{B} \\cdot \\mathbf{T}  (km) real ( wp ), intent ( out ) :: BdotR !!  \\mathbf{B} \\cdot \\mathbf{R}  (km) logical , intent ( out ) :: status_ok !! false if there were errors (non-hyperbolic or degenerate state) !local variables: real ( wp ), dimension ( 3 ) :: r , v , h , evec , bvec , tvec , ehat , hhat , hehat , Shat , That , Rhat , Bhat real ( wp ) :: rmag , vmag , vinf2 , rdv , vmag2 , a , alpha , sd2 , cd2 , ct , st , vinf , e status_ok = . true . r = rv ( 1 : 3 ) v = rv ( 4 : 6 ) h = cross ( r , v ) hhat = unit ( h ) if ( all ( hhat == zero )) then write ( * , * ) 'error: degenerate state.' status_ok = . false . return end if rdv = dot_product ( r , v ) rmag = norm2 ( r ) vmag = norm2 ( v ) vmag2 = vmag * vmag vinf2 = vmag2 - two * mu / rmag vinf = sqrt ( vinf2 ) ! magnitude of v-infinity vector evec = cross ( v , h ) / mu - r / rmag ! eccentricity vector e = norm2 ( evec ) ! eccentricity if ( e <= one ) then write ( * , * ) 'error: state is not hyperbolic.' status_ok = . false . return end if ehat = evec / e ! eccentricity unit vector a = one / ( two / rmag - vmag2 / mu ) ! semi-major axis hehat = cross ( hhat , ehat ) ! h x e unit vector sd2 = one / e ! sin(delta/2) cd2 = sqrt ( one - sd2 * sd2 ) ! cos(delta/2) Shat = cd2 * hehat + sd2 * ehat ! incoming vinf unit vector !Shat     = cd2*hehat - sd2*ehat            ! outgoing vinf unit vector That = ucross ( Shat ,[ zero , zero , one ]) ! here we define Tvec relative to the Z-axis of ! the frame in which the state is defined if ( all ( That == zero )) then write ( * , * ) 'error: vinf vector is parallel to z-axis.' status_ok = . false . return end if Rhat = cross ( Shat , That ) ! Eqn 1 in [1] Bhat = ucross ( Shat , h ) ct = dot_product ( Bhat , That ) ! cos(theta) st = dot_product ( Bhat , Rhat ) ! sin(theta) !outputs: Bmag = abs ( a ) * sqrt ( e * e - one ) ! magnitude of B vector theta = atan2 ( st , ct ) ! aim point orientation vinfvec = vinf * Shat ! incoming vinf vector BdotT = bmag * ct ! B dot T BdotR = bmag * st ! B dot R end subroutine bplane !***************************************************************************************** !***************************************************************************************** !> !  Compute B-plane parameters from position and velocity -- alternate version. ! !### See also !  * [[bplane]] ! !### Reference !  * This one is based on the algorithm in GMAT: GmatCalcUtil::CalculateBPlaneData subroutine calculate_bplane_data ( mu , state , bdotr , bdott , bmag , theta , istat ) implicit none real ( wp ), intent ( in ) :: mu !! central body grav parameter  (km&#94;3/s&#94;2)  real ( wp ), dimension ( 6 ), intent ( in ) :: state !! state vector (km,km/s) real ( wp ), intent ( out ) :: bdotr !!  \\mathbf{B} \\cdot \\mathbf{R}  (km) real ( wp ), intent ( out ) :: bdott !!  \\mathbf{B} \\cdot \\mathbf{T}  (km) real ( wp ), intent ( out ) :: bmag !! magnitude of B vector (km) real ( wp ), intent ( out ) :: theta !! aim point orientation [rad] integer , intent ( out ) :: istat !! status flag: !! !! * 0 if no errors. !! * -1 if state is not hyperbolic real ( wp ), dimension ( 3 ) :: r !! position vector real ( wp ), dimension ( 3 ) :: v !! velocity vector real ( wp ), dimension ( 3 ) :: evec !! eccentricity vector real ( wp ), dimension ( 3 ) :: hvec !! angular momentum vector real ( wp ), dimension ( 3 ) :: nvec !! orbit normal vector real ( wp ), dimension ( 3 ) :: svec !! incoming asymptote real ( wp ), dimension ( 3 ) :: bvec !! B vector real ( wp ), dimension ( 3 ) :: tvec !! T vector real ( wp ), dimension ( 3 ) :: rvec !! R vector real ( wp ) :: rmag !! magnitude of `r` real ( wp ) :: vmag !! magnitude of `v` real ( wp ) :: e !! eccentricity real ( wp ) :: hmag !! magnitude of `hvec` vector real ( wp ) :: b !! semiminor axis real ( wp ) :: oneovere !! 1/e real ( wp ) :: temp r = state ( 1 : 3 ) v = state ( 4 : 6 ) hvec = cross ( r , v ) rmag = norm2 ( r ) vmag = norm2 ( v ) evec = cross ( v , hvec ) / mu - r / rmag e = norm2 ( evec ) if ( e <= 1.0 ) then ! not hyperbolic write ( * , * ) 'error: state is not hyperbolic.' istat = - 1 bdotr = 0.0_wp bdott = 0.0_wp bmag = 0.0_wp theta = 0.0_wp else istat = 0 evec = unit ( evec ) hmag = norm2 ( hvec ) hvec = unit ( hvec ) nvec = cross ( hvec , evec ) b = ( hmag * hmag ) / ( mu * sqrt ( e * e - 1.0_wp )) oneovere = 1.0_wp / e temp = sqrt ( 1.0_wp - oneovere * oneovere ) svec = ( evec / e ) + ( temp * nvec ) bvec = b * ( temp * evec - oneovere * nvec ) tvec = [ svec ( 2 ), - svec ( 1 ), 0.0_wp ] / sqrt ( svec ( 1 ) * svec ( 1 ) + svec ( 2 ) * svec ( 2 )) rvec = cross ( svec , tvec ) bdott = dot_product ( bvec , tvec ) bdotr = dot_product ( bvec , rvec ) bmag = sqrt ( bdott * bdott + bdotr * bdotr ) theta = atan ( bdotr , bdott ) end if end subroutine calculate_bplane_data !***************************************************************************************** !***************************************************************************************** !> !  Compute the incoming and/or outgoing v-infinity vectors, given !  the position and velocity of a hyperbola. ! !@note This is for testing the other routines. subroutine compute_vinf_vectors ( mu , rv , vinfin , vinfout ) implicit none real ( wp ), intent ( in ) :: mu !! central body gravitational parameter real ( wp ), dimension ( 6 ), intent ( in ) :: rv !! position,velocity vector real ( wp ), dimension ( 3 ), intent ( out ), optional :: vinfin !! incoming v-infinity vector real ( wp ), dimension ( 3 ), intent ( out ), optional :: vinfout !! outgoing v-infinity vector real ( wp ), dimension ( 3 ) :: h , e , p , q , r , v real ( wp ) :: rmag , vmag , vinfmag , emag , qmag , cbeta , sbeta if ( present ( vinfin ) . or . present ( vinfout )) then r = rv ( 1 : 3 ) v = rv ( 4 : 6 ) rmag = norm2 ( r ) vmag = norm2 ( v ) h = cross ( r , v ) q = cross ( v , h ) vinfmag = sqrt ( vmag * vmag - two * mu / rmag ) e = q / mu - r / rmag emag = norm2 ( e ) q = cross ( h , e ) qmag = norm2 ( q ) cbeta = one / emag sbeta = sqrt ( one - cbeta * cbeta ) p = e / emag q = q / qmag if ( present ( vinfin )) vinfin = vinfmag * ( cbeta * p + sbeta * q ) if ( present ( vinfout )) vinfout = vinfmag * ( - cbeta * p + sbeta * q ) end if end subroutine compute_vinf_vectors !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 3/6/2016 ! !  Compute the hyperbolic turning angle from the eccentricity. pure function hyperbolic_turning_angle ( e ) result ( delta ) implicit none real ( wp ), intent ( in ) :: e !! eccentricity [--] real ( wp ) :: delta !! turning angle [rad] delta = two * asin ( one / e ) end function hyperbolic_turning_angle !***************************************************************************************** !***************************************************************************************** !> author: Jacob Williams !  date: 3/6/2016 ! !  Convert V-infinity magnitude to energy. pure function vinf_to_energy ( vinfmag ) result ( energy ) implicit none real ( wp ), intent ( in ) :: vinfmag !! v&#94;{\\infty}  vector magnitude [km/s] real ( wp ) :: energy !! two-body orbital energy [km&#94;2/s&#94;2] energy = ( vinfmag ** 2 ) / two end function vinf_to_energy !***************************************************************************************** !***************************************************************************************** !> !  Unit test for [[bplane_module]]. subroutine bplane_test () implicit none real ( wp ), dimension ( 3 ) :: vinfvec real ( wp ) :: bmag , theta , BdotT , BdotR , bmag2 , theta2 , BdotT2 , BdotR2 logical :: status_ok integer :: istat real ( wp ), parameter :: mu = 0.398600436233000e+06_wp !! grav. param. for earth  (km&#94;2/s&#94;2)  real ( wp ), dimension ( 6 ), parameter :: rv = [ - 1.518170076605391E+04_wp , & 1.518170076605392E+04_wp , & 2.147016712324346E+04_wp , & - 4.613927243557805E+00_wp , & - 2.352686048227026E+00_wp , & 1.598938983116768E+00_wp ] !! example hyperbolic state write ( * , * ) '' write ( * , * ) '---------------' write ( * , * ) ' bplane_test' write ( * , * ) '---------------' write ( * , * ) '' call compute_vinf_vectors ( mu , rv , vinfin = vinfvec ) write ( * , * ) 'vinfvec(1) =' , vinfvec ( 1 ) write ( * , * ) 'vinfvec(2) =' , vinfvec ( 2 ) write ( * , * ) 'vinfvec(3) =' , vinfvec ( 3 ) call bplane ( mu , rv , vinfvec , bmag , theta , BdotT , BdotR , status_ok ) write ( * , * ) '' write ( * , * ) 'vinfvec(1) =' , vinfvec ( 1 ) write ( * , * ) 'vinfvec(2) =' , vinfvec ( 2 ) write ( * , * ) 'vinfvec(3) =' , vinfvec ( 3 ) write ( * , * ) 'bmag       =' , bmag write ( * , * ) 'theta      =' , theta write ( * , * ) 'BdotT      =' , BdotT write ( * , * ) 'BdotR      =' , BdotR call calculate_bplane_data ( mu , rv , BdotR2 , BdotT2 , bmag2 , theta2 , istat ) write ( * , * ) '' write ( * , * ) 'Alternate version:' write ( * , * ) '' write ( * , * ) 'bmag       =' , bmag2 write ( * , * ) 'theta      =' , theta2 write ( * , * ) 'BdotT      =' , BdotT2 write ( * , * ) 'BdotR      =' , BdotR2 write ( * , * ) '' write ( * , * ) 'Difference:' write ( * , * ) '' write ( * , * ) 'bmag       =' , bmag2 - bmag write ( * , * ) 'theta      =' , theta2 - theta write ( * , * ) 'BdotT      =' , BdotT2 - BdotT write ( * , * ) 'BdotR      =' , BdotR2 - BdotR end subroutine bplane_test !***************************************************************************************** !***************************************************************************************** end module bplane_module !*****************************************************************************************","tags":"","url":"sourcefile/bplane_module.f90.html"}]}